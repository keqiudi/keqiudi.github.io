<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>CMake学习笔记 | THEDI的仓库</title><meta name="keywords" content="构建工具"><meta name="author" content="THEDI"><meta name="copyright" content="THEDI"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="CMake学习笔记"><meta name="application-name" content="CMake学习笔记"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="CMake学习笔记"><meta property="og:url" content="https://www.thekqd.top/2025/06/03/CMake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><meta property="og:site_name" content="THEDI的仓库"><meta property="og:description" content="学CMake时记录的笔记"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://www.thekqd.top/assets/30.webp"><meta property="article:author" content="THEDI"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.thekqd.top/assets/30.webp"><meta name="description" content="学CMake时记录的笔记"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://www.thekqd.top/2025/06/03/CMake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="manifest" href="/manifest.json"/><meta name="msapplication-TileColor" content="var(--anzhiyu-main)"/><link rel="mask-icon" href="/img/siteicon/apple-icon-180.png" color="#5bbad5"/><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/apple-icon-180.png"/><link rel="apple-touch-icon-precomposed" sizes="180x180" href="/img/siteicon/apple-icon-180.png"/><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/16.png"/><link rel="bookmark" href="/img/siteicon/apple-icon-180.png"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2048-2732.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2732-2048.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1668-2388.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2388-1668.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1536-2048.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2048-1536.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1668-2224.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2224-1668.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1620-2160.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2160-1620.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1290-2796.jpg" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2796-1290.jpg" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1179-2556.jpg" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2556-1179.jpg" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1284-2778.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2778-1284.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1170-2532.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2532-1170.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1125-2436.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2436-1125.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1242-2688.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2688-1242.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-828-1792.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1792-828.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1242-2208.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2208-1242.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-750-1334.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1334-750.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-640-1136.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1136-640.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css#fontawesome_animation 如果有就会加载，示例值：https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: {"enable":true,"title":"与大家一起进步","addFriendPlaceholder":"昵称（请勿包含博客等字样）：\n网站地址（要求博客地址，请勿提交个人主页）：\n头像图片url（请提供尽可能清晰的图片，我会上传到我自己的图床）：\n描述：\n站点截图（可选）：\n"},
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"该回来学习啦！","backTitle":"w(ﾟДﾟ)w快认真学习！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🏠 智能家居小能手"]},
  algolia: {"appId":"PW49GHYJ6T","apiKey":"42b04be58e36cfebeb6ac1989c6e8009","indexName":"hexo","hits":{"per_page":6},"languages":{"input_placeholder":"输入关键词后按下回车查找","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: THEDI","link":"链接: ","source":"来源: THEDI的仓库","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'THEDI的仓库',
  title: 'CMake学习笔记',
  postAI: '',
  pageFillDescription: 'CMake概述, CMake的基本使用, 注释, 注释行, 注释块, 只有源文件, 全在一个目录下, build目录, 私人订制, 定义变量, 指定使用的C++标准, 指定输出路径, 示例使用, 搜索文件, 方式1, 方式2, 示例使用, 包含头文件, 添加方法, 示例使用, 制作动态库和静态库, 制作静态库, 制作静态链接库示例, 制作动态库, 创建动态链接库示例, 指定库文件输出的路径, 方式1- 适用于动态库, 方式2-都适用(推荐使用这种), 示例使用, 使用链接库(包含库文件), 链接静态库, 使用静态链接库示例, 链接动态库, 链接系统动态库, 链接第三方动态库, 使用动态库链接示例, target_link_libraries和link_libraries区别, 日志(调试), 命令, 示例, 变量操作, 追加, 使用set拼接, 示例-使用set拼接, 使用list拼接, 示例-使用list拼接, 字符串移除(list), 示例-字符串移除, list其他功能, 宏定义, 示例, 嵌套CMake, 准备工作, 节点关系, 添加子目录, 解决问题, 根目录, calc目录, sort目录, test1目录, test2目录, 构建项目, 实践练习, 总结, 在静态库中链接静态库, 在静态库中链接动态库, CMake流程控制, 条件判断, 基本表达式, 逻辑判断, 比较, 文件操作, 其他, 循环, foreach, 方法1, 方法2, 方法3, 方法4, while, 预定义宏, 基于多目录的CMake编写摘自来源爱编程的大丙视频教程哔哩哔哩官方文档概述是一个跨平台的项目构建工具关于项目构建还有通过命令进行项目的构建大多是软件都集成了比如的下的的等如果自己动手写就会发现通常依赖于当前的编译平台而且编写的工作量比较大解决依赖关系时也容易出错而恰好能解决上述问题其允许开发者指定整个工程的编译流程再根据编译平台自动生成本地化的和工程文件最后用户只需编译即可所以可以把看成一款自动生成的工具其编译流程如下图蓝色虚线为构建项目的过程红色实线为构建项目的过程命令会读取并分析你的源码依赖编译规则等然后会自动生成平台和工具链相关的构建文件在下通常是也可以生成文件工程等是工具使用的构建说明文件包含了所有编译链接目标的依赖和命令命令会根据自动调用等编译器把源代码编译为目标文件静态动态库可执行文件等和区别主要是构建系统生成器不直接参与编译只是根据你的生成适合你平台的或其他构建系统文件里写明了实际编译与链接的步骤命令才会真正调用编译器执行编译动作所以的作用是生成构建规则的作用是执行这些规则完成编译总结优点跨平台能够管理大型项目流水线管理简化编译构建过程和编译过程可扩展可以为编写特定功能的模块扩充功能的基本使用注释支持大写小写混合大小写的命令如果在编写文件时使用的工具有对应的命令提示那么大小写随缘即可不要太过在意注释行使用进行行注释可以放在任何位置这是一个文件注释块使用形式进行块注释这是一个文件这是一个文件这是一个文件只有源文件全在一个目录下准备了以下几个测试文件加法除法上述文件的目录结构如下添加文件在上述源文件所在目录下添加一个新文件完整文件内容如下接下来依次介绍一下在文件中添加的三个命令指定使用的的最低版本可选非必须不加可能会有警告定义工程名称并可指定工程的版本工程描述主页地址支持的语言默认情况支持所有语言如果不需要这些都是可以忽略的只需要指定出工程名字即可指令的语法是一般只指定名字定义工程会生成一个可执行程序可执行文件名源文件源文件可执行文件名你想要生成的可执行程序的名字不需要加扩展名源文件列表组成该程序的所有源文件等这里的可执行程序名和中的项目名没有任何关系源文件名可以是一个也可以是多个如有多个可用空格或间隔样式样式执行命令将文件编辑好之后就可以执行命令了命令作用根据配置文件自动生成适合当前平台的构建系统文件等命令原型文件所在路径当前目录查找文件并在这个目录下生成对应的构建文件比如上一级目录查找当执行命令之后中的命令就会被执行所以一定要注意给命令指定路径的时候一定不能出错执行命令之后看一下源文件所在目录中是否多了一些文件我们可以看到在对应的目录下生成了一个文件此时再执行命令就可以对项目进行构建得到所需的可执行程序了最终可执行程序就被编译出来了这个名字是在中指定的目录通过上面的例子可以看出如果在文件所在目录执行了命令之后就会生成一些目录和文件包括文件如果再基于文件执行命令程序在编译过程中还会生成一些中间文件和一个可执行文件这样会导致整个项目目录看起来很混乱不太容易管理和维护此时我们就可以把生成的这些与项目源码无关的文件统一放到一个对应的目录里边比如将这个目录命名为现在命令是在目录中执行的但是文件是目录的上一级目录中所以命令后指定的路径为即当前目录的上一级目录当命令执行完毕之后在目录中会生成文件和其他文件这样就可以在目录中执行命令编译项目生成的相关文件自然也就被存储到目录中了这样通过和生成的所有文件就全部和项目源文件隔离开了便于管理和维护回到目录执行命令生成可执行文件运行成功私人订制定义变量在上面的例子中一共提供了个源文件假设这五个源文件需要反复被使用每次都直接将它们的名字写出来确实是很麻烦此时我们就需要定义一个变量将文件名对应的字符串中默认的都是字符串形式存储起来在里定义变量需要使用指令的语法是中的参数为可选项如不需要可以不写变量名变量值取值方法变量名方式各个源文件之间使用空格间隔方式各个源文件之间使用分号间隔指定使用的标准在编写程序的时候可能会用到等新特性那么就需要在编译的时候在编译命令中制定出要使用哪个标准不指定的话默认使用的标准上面的例子中通过参数指定出要使用标准编译程序标准对应有一宏叫做在中想要指定标准有两种方式在中通过命令指定设置宏的值增加增加增加在执行命令的时候指定出这个宏的值增加文件路径增加文件路径增加文件路径在上面例子中后的路径需要根据实际情况酌情修改指定输出路径在中指定可执行程序输出的路径不指定默认当前目录下输出也对应一个宏叫做它的值还是通过命令进行设置定义变量指定生成的可执行程序保存的路径第一行定义一个变量用于存储一个绝对路径第二行将拼接好的路径值设置给宏如果这个路径中的子目录不存在会自动生成无需自己手动创建由于可执行程序是基于命令生成的文件然后再执行命令得到的所以如果此处指定可执行程序生成路径的时候使用的是相对路径那么这个路径中的对应的就是文件所在的那个目录示例使用可以看到生成的可执行文件出现在了我们指定的下搜索文件如果一个项目里边的源文件很多在编写文件的时候不可能将项目目录的各个文件一一罗列出来这样太麻烦也不现实所以在中为我们提供了搜索文件的命令可以使用命令或者命令其中的涉及到存放源文件的变量不需要使用定义直接使用即可就是自动将指定目录的源文件定义为一个变量供使用的过程可以看作的升级版方式在中使用命令可以查找某个路径下的所有源文件命令格式为要搜索的目录将从目录下搜索到的源文件列表存储到该变量中搜索目录下的源文件自带宏定义即文件路径自带宏定义也是文件路径与完全相同随便使用一个即可方式第二种方式是使用当然除了搜索以外通过还可以做其他事情进行搜索与方式的区别呢使用需要执行文件的类型后缀变量名要搜索的文件路径和文件类型将指定目录下搜索到的满足条件的所有文件名生成一个列表并将其存储到变量中递归搜索指定目录将搜索到的满足条件的文件名生成一个列表并将其存储到变量中搜索当前目录的目录下所有的源文件并存储到变量中关于要搜索的文件路径和类型可加双引号也可不加示例使用方式方式包含头文件添加方法在编译项目源文件的时候很多时候都需要将源文件对应的头文件路径指定出来这样才能保证在编译过程中编译器能够找到这些头文件并顺利通过编译在中设置要包含的目录也很简单通过一个命令就可以搞定了他就是举例说明有源文件若干其目录结构如下文件内容如下其中第六行指定就是头文件的路径宏对应的值就是我们在使用命令时后面紧跟的目录一般是工程的根目录示例使用我们将原本头文件和源文件混合的情况下创建和的文件夹分别存放源文件和头文件我们将原本的头文件和源文件移动到和文件夹修改中的搜索文件添加以下路径执行和命令我们可以发现报错说找不到头文件此时由两种处理方式修改头文件路径将原来的改为修改后通过编译这种方法如果头文件很多的话就会很麻烦所以推荐下面再中添加包含头文件在中添加包含头文件推荐使用在行中我们添加对头文件路径的搜索中是我们的所有头文件的文件夹所在目录然后进行我们的命令成功找到头文件成功运行可执行文件制作动态库和静态库有些时候我们编写的源代码并不需要将他们编译生成可执行程序而是生成一些静态库或动态库提供给第三方使用提供时需要将动态静态库源代码的二进制文件或和头文件提供给使用者才能使用其实就是相当于把很多相关的源文件合起来打包变成了二进制文件使用者看不到文件内容隐藏实现只能通过头文件来看有哪些函数如何使用再调用函数否则用户看不懂下面来讲解在中生成这两类库文件的方法制作静态库在中如果要制作静态库需要使用的命令如下库名称源文件源文件在中静态库名字分为三部分库名字此处只需要指定出库的名字就可以了另外两部分在生成该文件的时候会自动填充在中静态库名字是库名字下面有一个目录需要将目录中的源文件编译成静态库然后再使用头文件目录用于测试的源文件源文件目录根据上面的目录结构可以这样编写文件生成静态库文件这样最终就会生成对应的静态库文件制作静态链接库示例现在我们是创建链接库将原来的生成可执行文件注释掉田间使用执行和后我们可以看到在当前目录下生成了静态库可以看到图中是白色的是因为静态库没有可执行权限的而我们的动态链接库是绿色的具有执行权限制作动态库在中如果要制作动态库需要使用的命令如下库名称源文件源文件在中动态库名字分为三部分库名字此处只需要指定出库的名字就可以了另外两部分在生成该文件的时候会自动填充在中动态库的名字叫库名字根据上面的目录结构可以这样编写文件生成动态库文件这样最终就会生成对应的动态库文件创建动态链接库示例现在我们是创建链接库将原来的生成可执行文件注释掉田间使用执行和后我们可以看到在当前目录下生成了动态链接库可以看到图中是绿色的是因为动态链接库是有可执行权限的而我们的静态库没有执行权限指定库文件输出的路径方式适用于动态库对于生成的库文件来说和可执行程序一样都可以指定输出路径由于在下生成的动态库默认是有执行权限的所以可以按照生成可执行程序的方式去指定它生成的目录设置动态库生成路径按照生成可执行程序的方式指定生成目录对于这种方式来说其实就是通过命令给宏设置了一个路径这个路径就是可执行文件生成的路径方式都适用推荐使用这种由于在下生成的静态库默认不具有可执行权限所以在指定静态库生成的路径的时候就不能使用宏了而应该使用这个宏对应静态库文件和动态库文件都适用设置动态库静态库生成路径生成动态库生成静态库示例使用使用宏指定库文件输出路径到静态链接库动态链接库我们可以看到切换为动态链接库后也在下生成了对应的库文件使用链接库包含库文件在编写程序的过程中可能会用到一些系统提供的动态库或者自己制作出的动态库或者静态库文件中也为我们提供了相关的加载动态库的命令链接静态库在编写程序的过程中可能会用到一些系统提供的动态库或者自己制作出的动态库或者静态库文件中也为我们提供了相关的加载动态库的命令现在我们把上面目录中的编译成一个静态库文件通过命令制作并使用静态链接库测试目录结构如下制作出的静态库的名字在中链接静态库的命令如下用于设置全局链接库这些库会链接到之后定义的所有目标上参数指定出要链接的静态库的名字可以是全名也可以是掐头去尾之后的名字参数可以链接一个或多个静态库这里依次填写要链接的其它静态库的名字即可如果该静态库不是系统提供的自己制作或者使用第三方提供的静态库可能出现静态库找不到的情况此时需要将静态库的路径也指定出来如果是系统提供的静态库不需要指定路径只需要使用上面的就可以找到这样修改之后的文件内容如下搜索指定目录下源文件包含头文件路径包含静态库路径在生成可执行文件前链接静态库这样编译之后就会将源文件和库文件放到一起最终生成我们的可执行文件静态库使用会被打包到可执行文件中使用静态链接库示例目前把动态链接库和静态链接库分别创建了和在我们的中使用他们文件夹的内容是库文件的文件实现这里我们制作成了动态库和静态库所以该文件夹可以直接删去只需要使用链接库文件即可修改我们先不指出库文件的路径注释掉我们执行和报错发现找不到库文件我们将注释的静态库路径重新启用修改后编译就可以找到库文件的了编译通过链接动态库在程序编写过程中除了在项目中引入静态库好多时候也会使用一些标准的或者第三方提供的一些动态库关于动态库的制作使用以及在内存中的加载方式和静态库都是不同的在此不再过多赘述如有疑惑请参考静态库和动态库在中链接动态库的命令如下用于指定一个目标如可执行文件或库在编译时需要链接哪些库它支持指定库的名称路径以及链接库的顺序指定要加载的库的文件的名字该文件可能是一个源文件该文件可能是一个动态库静态库文件该文件可能是一个可执行文件动态库的访问权限默认为如果各个动态库之间没有依赖关系无需做任何设置三者没有没有区别一般无需指定使用默认的即可动态库的链接具有传递性仅权限如果动态库链接了动态库动态库链接了动态库此时动态库相当于也链接了动态库并可以使用动态库中定义的方法链接链接传递多次在后面的库会被到前面的所有中并且里面的符号函数也会被导出提供给第三方使用具有传递性仅传递一次在后面的库仅被到前面的中并且终结掉第三方不能感知你调了啥库不具有传递性在后面引入的库不会被链接到前面的中只会导出符号不具有传递性链接系统动态库动态库的链接和静态库是完全不同的静态库会在生成可执行程序的链接阶段被打包到可执行程序中所以可执行程序启动静态库就被加载到内存中了动态库在生成可执行程序的链接阶段不会被打包到可执行程序中当可执行程序被启动并且调用了动态库中的函数的时候动态库才会被加载到内存因此在中指定要链接的动态库的时候应该将命令写到生成了可执行文件之后添加并指定最终生成的可执行程序名写到可执行文件之后指定可执行程序要链接的动态库名字在中对应的是最终生成的可执行程序的名字这是可执行程序要加载的动态库这个库是系统提供的线程库全名为在指定的时候一般会掐头去尾链接第三方动态库现在自己编写并生成了一个动态库对应的目录结构如下动态库对应的头文件自己制作的动态库文件测试用的源文件假设在测试文件中既使用了自己制作的动态库又使用了系统提供的线程库此时文件可以这样写链接动态库在第六行中都是可执行程序要链接的动态库的名字当可执行程序生成之后并执行该文件会提示有如下错误信息这是因为可执行程序启动之后去加载这个动态库但是不知道这个动态库被放到了什么位置解决动态库无法加载的问题所以就加载失败了在中可以在生成可执行程序之前通过命令指定出要链接的动态库的位置在动态库使用的是这个命令这里也可以使用之前静态库中一个是全局一个是指定所以修改之后的文件应该是这样的指定要链接的动态库的路径法全局添加动态库搜索路径添加并生成一个可执行程序指定要链接的动态库的路径法指定添加链接目录在生成可执行文件后才指定要链接的动态库要不然不知道可执行文件通过指定了动态库的路径之后在执行生成的可执行程序的时候就不会出现找不到动态库的问题了使用动态库链接示例法或法有一点区别但都能使用随便使用一种即可建议使用法图中的权限可以省略因为默认就是使用其他权限时就需要明确指出同时图中只链接了一个库如果要链接多个库之间使用空格分开即可一定要保证在生成可执行文件之后和区别温馨提示和是中用于链接库的两个命令其实都可以用于链接动态库和静态库但它们的使用场景和功能有所不同下面是关于二者的总结功能用于指定一个目标如可执行文件或库在编译时需要链接哪些库它支持指定库的名称路径以及链接库的顺序语法优点更精确地控制目标的链接库可以指定库的不同链接条件如调试版本发布版本支持多个目标和多个库之间的复杂关系更加灵活和易于维护特别是在大型项目中示例功能用于设置全局链接库这些库会链接到之后定义的所有目标上它会影响所有的目标适用于全局设置但不如精确语法缺点缺乏针对具体目标的控制不适合复杂的项目结构容易导致意外的依赖关系因为它对所有目标都生效一旦设置全局影响可能导致难以追踪的链接问题示例总结只影响指定是推荐的方式因为它允许更精确的控制和管理链接库的依赖特别是在大型项目中它能够避免全局设置可能带来的问题全局影响虽然简单但在复杂的项目中可能会导致意外的问题通常适用于简单的项目或临时设置静态库和动态库链接方法几乎一样可以混用但建议用现代写法建议在项目中优先使用日志调试在编写的过程中如果我们想要输出一些调试信息就可以使用命令命令在中可以用用户显示一条消息该命令的名字为无不指定默认是重要消息非重要消息警告会继续执行警告会继续执行错误继续执行但是会跳过生成的步骤错误终止所有处理过程的命令行工具会在上显示消息在上显示其他所有消息的会在它的区域显示所有消息警告和错误消息的文本显示使用的是一种简单的标记语言文本没有缩进超过长度的行会回卷段落之间以新行做为分隔符输出一般日志信息输出警告信息输出错误信息示例中添加四条日志默认执行到日志处发生中断日志不执行注释掉的日志部分正常运行到日志变量操作追加有时候项目中的源文件并不一定都在同一个目录中但是这些源文件最终却需要一起进行编译来生成最终的可执行文件或者库文件如果我们通过命令对各个目录下的源文件进行搜索最后还需要做一个字符串拼接的操作关于字符串拼接可以使用命令也可以使用命令使用拼接如果使用进行字符串拼接对应的命令格式如下变量名变量名变量名关于上面的命令其实就是将从第二个参数开始往后所有的字符串进行拼接最后将结果存储到第一个参数中如果第一个参数中原来有数据会对原数据就行覆盖追加拼接示例使用拼接定义变量为将值拼接到后方输出和的值使用拼接如果使用进行字符串拼接对应的命令格式如下命令的功能比要强大字符串拼接只是它的其中一个功能所以需要在它第一个参数的位置指定出我们要做的操作表示进行数据追加后边的参数和就一样了追加拼接在中使用命令可以创建一个一个在内部是一个由分号分割的一组字符串例如命令将会创建一个底层通过分号管理但是最终打印变量值的时候会去掉分号将所有字符串拼接起来得到的是输出的结果示例使用拼接使用命令追加等字符串字符串移除我们在通过搜索某个目录就得到了该目录下所有的源文件但是其中有些源文件并不是我们所需要的比如在当前这么目录有五个源文件其中是一个测试文件如果我们想要把计算器相关的源文件生成一个动态库给别人使用那么只需要这四个源文件就可以了此时就需要将从搜索到的数据中剔除出去但实际我们并不想删除想要实现这个功能也可以使用通过上面的命令原型可以看到删除和追加数据类似只不过是第一个参数变成了移除前日志移除移除后日志可以看到在第行把将要移除的文件的名字指定给就可以了但是一定要注意通过命令搜索源文件的时候得到的是文件的绝对路径在中每个文件对应的路径都是一个并且都是绝对路径那么在移除的时候也要将该文件的绝对路径指定出来才可以否是移除操作不会成功示例字符串移除我们需要的就是去掉的路径让其不包含在内使用命令指定的绝对路径可以看到两次输出的路径中第二次的输出已经删除了的路径其他功能关于命令还有其它功能但是并不常用在此就不一一进行举例介绍了获取的长度子命令用于读取列表长度底层分号分隔当前操作的列表新创建的变量字符串用于存储列表的长度读取列表中指定索引的的元素可以指定多个索引当前操作的列表列表元素的索引从开始编号索引的元素为列表中的第一个元素索引也可以是负数表示列表的最后一个元素表示列表倒数第二个元素以此类推当索引不管是正还是负超过列表的长度运行会报错新创建的变量存储指定索引元素的返回结果也是一个列表将列表中的元素用连接符字符串连接起来组成一个字符串当前操作的列表指定的连接符字符串新创建的变量存储返回的字符串查找列表是否存在指定的元素若果未找到返回当前操作的列表需要再列表中搜索的元素新创建的变量如果列表中存在那么返回在列表中的索引如果未找到则返回将元素追加到列表中在中指定的位置插入若干元素将元素插入到列表的索引位置将列表中最后元素移除将列表中第一个元素移除将指定的元素从列表中移除将指定索引的元素从列表中移除移除列表中的重复元素列表翻转列表排序指定排序方法有如下几种值可选按照字母顺序进行排序为默认的排序方法如果是一系列路径名会使用进行排序使用自然数顺序排序指明是否大小写敏感有如下几种值可选按照大小写敏感的方式进行排序为默认值按照大小写不敏感方式进行排序指明排序的顺序有如下几种值可选按照升序排列为默认值按照降序排列宏定义在进行程序测试的时候我们可以在代码中添加一些宏定义通过这些宏来控制这些代码是否生效在大型项目中这样可以方便对与所有日志输出的启用和关闭如下所示我是一个程序猿我不会爬树在程序的第七行对宏进行了判断如果该宏被定义了那么第八行就会进行日志输出如果没有定义这个宏第八行就相当于被注释掉了因此最终无法看到日志输入出上述代码中并没有定义这个宏为了让测试更灵活我们可以不在代码中定义这个宏而是在测试的时候去把它定义出来其中一种方式就是在命令中去指定如下在命令中通过参数指定出要定义的宏的名字这样就相当于在代码中定义了一个宏其名字为在中我们也可以做类似的事情宏定义对应的命令叫做宏名称宏名称宏名称针对于上面的源文件编写一个内容如下自定义宏通过这种方式上述代码中的第八行日志就能够被输出出来了示例两个分别是添加宏定义和未添加宏定义的输出确实在的控制下日志才会输出嵌套如果项目很大或者项目中有很多的源码目录在通过管理项目的时候如果只使用一个那么这个文件相对会比较复杂有一种化繁为简的方式就是给每个源码目录都添加一个文件头文件目录不需要这样每个文件都不会太复杂而且更灵活更容易维护先来看一下下面的这个的目录结构目录头文件目录目录目录中的四个源文件对应的加减乘除算法对应的头文件是中的目录目录中的两个源文件对应的是插入排序和选择排序算法对应的头文件是中的目录测试目录对加减乘除算法进行测试目录测试目录对排序算法进行测试可以看到各个源文件目录所需要的文件现在已经添加完毕了接下来庖丁解牛我们依次分析一下各个文件中需要添加的内容准备工作节点关系众所周知的目录是树状结构所以嵌套的也是一个树状结构最顶层的是根节点其次都是子节点因此我们需要了解一些关于文件变量作用域的一些信息根节点中的变量全局有效父节点中的变量可以在子节点中使用子节点中的变量只能在当前节点中使用根节点的中定义的变量可以在任意子节点中直接使用添加子目录接下来我们还需要知道在中父子节点之间的关系是如何建立的这里需要用到一个命令指定了源文件和代码文件的位置其实就是指定子目录指定了输出文件的路径一般不需要指定忽略即可在子路径下的目标默认不会被包含到父路径的目标里并且也会被排除在工程文件之外用户必须显式构建在子路径下的目标通过这种方式文件之间的父子关系就被构建出来了解决问题在上面的目录中我们要做如下事情通过目录中的测试文件进行计算器相关的测试通过目录中的测试文件进行排序相关的测试现在相当于是要进行模块化测试对于和目录中的源文件来说可以将它们先编译成库文件可以是静态库也可以是动态库然后在提供给测试文件使用即可库文件的本质其实还是代码只不过是从文本格式变成了二进制格式根目录根目录中的文件内容如下定义变量静态库生成的路径测试程序生成的路径头文件目录静态库的名字可执行程序的名字添加子目录在根节点对应的文件中主要做了两件事情定义全局变量和添加子目录定义的全局变量主要是给子节点使用目的是为了提高子节点中的文件的可读性和可维护性避免冗余并降低出差的概率一共添加了四个子目录每个子目录中都有一个文件这样它们的父子关系就被确定下来了目录目录中的文件内容如下第行搜索当前目录目录下的所有源文件第行包含头文件路径是在根节点文件中定义的第行设置库的生成的路径是在根节点文件中定义的第行生成静态库静态库名字是在根节点文件中定义的目录目录中的文件内容如下第行生成动态库动态库名字是在根节点文件中定义的这个文件中的内容和节点文件中的内容类似只不过这次生成的是动态库在生成库文件的时候这个库可以是静态库也可以是动态库一般需要根据实际情况来确定如果生成的库比较大建议将其制作成动态库目录目录中的文件内容如下第行指定头文件路径变量是在根节点文件中定义的第行指定可执行程序要链接的静态库变量是在根节点文件中定义的第行指定可执行程序生成的路径变量是在根节点文件中定义的第行生成可执行程序变量是在根节点文件中定义的此处的可执行程序链接的是静态库最终静态库会被打包到可执行程序中可执行程序启动之后静态库也就随之被加载到内存中了目录目录中的文件内容如下第四行包含头文件路径变量是在根节点文件中定义的第五行指定可执行程序生成的路径变量是在根节点文件中定义的第六行指定可执行程序要链接的动态库的路径变量是在根节点文件中定义的第七行生成可执行程序变量是在根节点文件中定义的第八行指定可执行程序要链接的动态库的名字在生成可执行程序的时候动态库不会被打包到可执行程序内部当可执行程序启动之后动态库也不会被加载到内存只有可执行程序调用了动态库中的函数的时候动态库才会被加载到内存中且多个进程可以共用内存中的同一个动态库所以动态库又叫共享库构建项目一切准备就绪之后开始构建项目进入到根节点目录的目录中执行命令如下可以看到在目录中生成了一些文件等和目录如下所示目录文件目录文件文件目录目录目录然后在目录下再执行命令通过上图可以得到如下信息在项目根目录的目录中生成了静态库在项目根目录的目录中生成了动态库在项目根目录的目录中生成了可执行程序在项目根目录的目录中生成了可执行程序最后再来看一下上面提到的这些文件是否真的被生成到对应的目录中了确实生成了项目构建完毕注意在项目中如果将程序中的某个模块制作成了动态库或者静态库并且在中指定了库的输出目录而后其它模块又需要加载这个生成的库文件此时直接使用就可以了如果没有指定库的输出路径或者需要直接加载外部提供的库文件此时就需要使用将库文件路径指定出来实践练习准备好对应的文件目录目录目录目录目录思路目录和目录生成对应的库文件和目录调用库生成可执行程序和根下的子下的子下的子下的子回到根目录的目录下执行和命令可以看到生成了对应的库文件和可执行文件执行和文件执行成功说明没有问题同时对应和中的文件也是正确的总结通过父和多个子的使用我们更方便对项目的管理每个子做的事情都单一化了推荐在大型项目中使用多个的形式管理还有我们上面在根中定义变量然后再去子中使用的方法看起来会比较工整简洁但是在单独看子时对于变量值我们还需要到根中去寻找这样的话可读性较低不利于我们直观的理解上方因为需要演示根变量可以在子中使用所以这样写实际上我们直接将对应的路径写出来即可不需要这样传递变量使用在静态库中链接静态库现在去掉文件夹将原有的的操作添加到库中的之中去根去掉子节点中添加加法操作修改下的链接我们自定义的库执行和命令生成对应的执行发现确实出现了加法操作故在静态库中链接静态库成功对应下的只链接了静态库因为本来就链接了这里相当于也链接了就不需要再链接了相当于生成的静态库中包含了静态库在静态库中链接动态库将中的中的生成静态库改成动态库将中的中改为链接动态库到我们的静态库库中执行和命令这里我们可以看到生成了动态库静态库可执行文件并且可以成功运行说明静态库链接动态库成功静态库被打包到了中动态库没有被打包流程控制在的中也可以进行流程控制也就是说可以像写脚本那样进行条件判断和循环条件判断关于条件判断其语法格式如下可选快可以重复可选快在进行条件判断的时候如果有多个条件那么可以写多个最后一个条件可以使用但是开始和结束是必须要成对出现的分别为和基本表达式如果是基本表达式有以下三种情况常量变量字符串如果是非零值非空字符串时条件判断返回如果是空字符串时条件判断返回逻辑判断其实这就是一个取反操作如果条件为将返回如果条件为将返回如果和同时为返回否则返回如果和两个条件中至少有一个为返回如果两个条件都为则返回比较基于数值的比较如果左侧数值小于右侧返回如果左侧数值大于右侧返回如果左侧数值等于右侧返回如果左侧数值小于等于右侧返回如果左侧数值大于等于右侧返回基于字符串的比较如果左侧字符串小于右侧返回如果左侧字符串大于右侧返回如果左侧字符串等于右侧返回如果左侧字符串小于等于右侧返回如果左侧字符串大于等于右侧返回文件操作判断文件或者目录是否存在如果文件或者目录存在返回否则返回判断是不是目录此处目录的必须是绝对路径如果目录存在返回目录不存在返回判断是不是软链接此处的对应的路径必须是绝对路径如果软链接存在返回软链接不存在返回软链接相当于里的快捷方式判断是不是绝对路径关于绝对路径如果是该路径需要从根目录开始描述如果是该路径需要从盘符开始描述如果是绝对路径返回如果不是绝对路径返回其他判断某个元素是否在列表中版本要求大于等于如果这个元素在列表中返回否则返回比较两个路径是否相等版本要求大于等于如果这个元素在列表中返回否则返回关于路径的比较其实就是另个字符串的比较如果路径格式书写没有问题也可以通过下面这种方式进行比较我们在书写某个路径的时候可能由于误操作会多写几个分隔符比如把写成此时通过对这两个字符串进行比较肯定是不相等的但是通过去比较两个路径得到的结果确实相等的可以看下面的例子路径相等路径不相等路径相等路径不相等输出的日志信息如下路径相等路径不相等通过得到的结果我们可以得到一个结论在进行路径比较的时候如果使用可以自动剔除路径中多余的分割线然后再进行路径的对比使用则只能进行字符串比较更多条件判断请参考官方文档循环在中循环有两种方式分别是和使用进行循环语法格式如下通过我们就可以对中的数据进行遍历然后通过将遍历到的当前的值取出在取值的时候有以下几种用法方法关键字表示要遍历范围这是一个正整数表示范围的结束值在遍历的时候从开始最大值为存储每次循环取出的值举例说明循环当前遍历的值为输出的日志信息是这样的当前遍历的值为当前遍历的值为当前遍历的值为当前遍历的值为当前遍历的值为当前遍历的值为当前遍历的值为当前遍历的值为当前遍历的值为当前遍历的值为当前遍历的值为再次强调在对一个整数区间进行遍历的时候得到的范围是这样的右侧是闭区间包含这个值方法这是上面方法的加强版我们在遍历一个整数区间的时候除了可以指定起始范围还可以指定步长关键字表示要遍历范围这是一个正整数表示范围的起始值也就是说最小值为这是一个正整数表示范围的结束值也就是说最大值为控制每次遍历的时候以怎样的步长增长默认为可以不设置存储每次循环取出的值举例说明当前遍历的值为输出的结果如下当前遍历的值为当前遍历的值为当前遍历的值为当前遍历的值为当前遍历的值为当前遍历的值为当前遍历的值为当前遍历的值为当前遍历的值为当前遍历的值为当前遍历的值为再次强调在使用上面的方式对一个整数区间进行遍历的时候得到的范围是这样的左右两侧都是闭区间包含和这两个值步长默认为可以不设置方法这是的另一个变体通过这种方式我们可以对更加复杂的数据进行遍历前两种方式只适用于对某个正整数范围内的遍历关键字表示在里边关键字对应的是列表通过可以获得关键字对应的也是列表存储每次循环取出的值创建遍历当前遍历的值为在上面的例子中创建了两个列表在遍历的时候对它们两个都进行了遍历可以根据实际需求选择同时遍历多个或者只遍历一个输出的日志信息如下当前遍历的值为当前遍历的值为当前遍历的值为当前遍历的值为当前遍历的值为当前遍历的值为当前遍历的值为一共输出了个字符串说明遍历是没有问题的接下来看另外一种方式当前遍历的值为在上面的例子中遍历过程中将关键字改成了后边跟的还是一个或者多个列表只不过此时需要通过将列表中的值取出其输出的信息和上一个例子是一样的当前遍历的值为当前遍历的值为当前遍历的值为当前遍历的值为当前遍历的值为当前遍历的值为当前遍历的值为小细节在通过组织列表的时候如果某个字符串中有空格可以通过双引号将其包裹起来具体的操作方法可以参考上面的例子方法注意事项这种循环方式要求的版本大于等于通过这种方式遍历的还是一个或多个列表可以理解为是方式的加强版因为通过上面的方式遍历多个列表但是又想把指定列表中的元素取出来使用是做不到的在这个加强版中就可以轻松实现存储每次循环取出的值可以根据要遍历的列表的数量指定多个变量用于存储对应的列表当前取出的那个值如果指定了多个变量名它们的数量应该和列表的数量相等如果只给出了一个那么它将一系列的变量来存储对应列表中的当前项也就是说对应第一个列表对应第二个列表以此类推如果遍历的多个列表中一个列表较短当它遍历完成之后将不会再参与后续的遍历因为其它列表还没有遍历完关键字表示在里边关键字对应的是列表通过可以获得通过给列表添加数据遍历列表当前遍历的值为遍历列表当前遍历的值为在这个例子中关于列表数据的添加是通过来实现的在遍历列表的时候一共使用了两种方式一种提供了多个变量来存储当前列表中的值另一种只有一个变量但是实际取值的时候需要通过变量名变量名变量名的方式来操作注意事项第一个列表对应的编号是第一个列表对应的编号是第一个列表对应的编号是上面的例子输出的结果如下当前遍历的值为当前遍历的值为当前遍历的值为当前遍历的值为当前遍历的值为当前遍历的值为当前遍历的值为当前遍历的值为当前遍历的值为当前遍历的值为除了使用也可以使用进行循环关于循环结束对应的条件判断的书写格式和是一样的的语法格式如下循环比较简单只需要指定出循环结束的条件即可创建一个列表得到列表长度循环弹出列表头部元素更新列表长度输出的结果如下可以看到当列表中的元素全部被弹出之后列表的长度变成了此时循环也就退出了预定义宏下面的列表是一些中已经预定义的常用的宏宏功能说明使用命令后紧跟的目录一般是工程的根目录执行命令的目录当前处理的所在的路径编译目录重新定义目标二进制可执行文件的存放位置重新定义目标链接库文件的存放位置返回通过指令定义的项目名称项目实际构建路径假设在目录进行的构建那么得到的就是这个目录的路径基于多目录的编写看这个就可以了爱编程的大丙哔哩哔哩',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-06-04 10:48:41',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://i.postimg.cc/fbN6bFqP/20220206101541-14a48.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="安知鱼的博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="安知鱼的博客"/><span class="back-menu-item-text">安知鱼的博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/keqiudi/keqiudi.github.io" title="我的博客仓库"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="我的博客仓库"/><span class="back-menu-item-text">我的博客仓库</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">THEDI的仓库</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/null"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/null"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>2</sup></a><a href="/tags/CLion/" style="font-size: 1.05rem;">CLion<sup>1</sup></a><a href="/tags/Git/" style="font-size: 1.05rem;">Git<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem;">Linux<sup>8</sup></a><a href="/tags/MySQL/" style="font-size: 1.05rem;">MySQL<sup>2</sup></a><a href="/tags/QT/" style="font-size: 1.05rem;">QT<sup>1</sup></a><a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/" style="font-size: 1.05rem;">嵌入式<sup>7</sup></a><a href="/tags/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/" style="font-size: 1.05rem;">构建工具<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>3</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/06/"><span class="card-archive-list-date">六月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/05/"><span class="card-archive-list-date">五月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/01/"><span class="card-archive-list-date">一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/02/"><span class="card-archive-list-date">二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">九月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/07/"><span class="card-archive-list-date">七月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/" itemprop="url">构建工具</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>构建工具</span></a></span></div></div><h1 class="post-title" itemprop="name headline">CMake学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-06-03T06:15:03.000Z" title="发表于 2025-06-03 14:15:03">2025-06-03</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-06-04T02:48:41.146Z" title="更新于 2025-06-04 10:48:41">2025-06-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">16.8k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>59分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="CMake学习笔记"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为成都"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>成都</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="/assets/30.webp"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://www.thekqd.top/2025/06/03/CMake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><header><a class="post-meta-categories" href="/categories/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/" itemprop="url">构建工具</a><a href="/tags/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/" tabindex="-1" itemprop="url">构建工具</a><h1 id="CrawlerTitle" itemprop="name headline">CMake学习笔记</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">THEDI</span><time itemprop="dateCreated datePublished" datetime="2025-06-03T06:15:03.000Z" title="发表于 2025-06-03 14:15:03">2025-06-03</time><time itemprop="dateCreated datePublished" datetime="2025-06-04T02:48:41.146Z" title="更新于 2025-06-04 10:48:41">2025-06-04</time></header><p><strong>摘自</strong>： <a target="_blank" rel="noopener" href="https://subingwen.cn/cmake/CMake-primer/#2-6-3-%E6%80%BB%E7%BB%93">https://subingwen.cn/cmake/CMake-primer/#2-6-3-%E6%80%BB%E7%BB%93</a><br><strong>来源</strong>:  爱编程的大丙</p>
<p><strong>视频教程</strong>：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV14s4y1g7Zj?spm_id_from=333.788.player.switch&vd_source=830e63bd86bd9268c1b7cd9ff383f386&p=13">哔哩哔哩_bilibili</a></p>
<p><strong>官方文档</strong>：<a target="_blank" rel="noopener" href="https://cmake.org/cmake/help/latest/manual/cmake-commands.7.html">cmake-commands(7) — CMake 4.0.2 Documentation</a></p>
<h1 id="CMake概述"><a href="#CMake概述" class="headerlink" title="CMake概述"></a>CMake概述</h1><p>CMake 是一个<code>跨平台</code>的项目构建工具。关于项目构建还有Makefile（通过 make 命令进行项目的构建），大多是IDE软件都集成了make，比如：VS 的 nmake、linux 下的 GNU make、Qt 的 qmake等，如果自己动手写makefile，就会发现，<code>makefile</code> <strong>通常依赖于当前的编译平台，而且编写makefile 的工作量比较大，解决依赖关系时也容易出错</strong>。</p>
<p>而 <code>CMake </code>恰好能解决上述问题， 其允许开发者指定整个工程的编译流程，再根据编译平台，<code>自动生成本地化的Makefile和工程文件</code>，最后用户只需<code>make</code>编译即可，<strong>所以可以把CMake看成一款自动生成 Makefile的工具</strong>，其编译流程如下图：</p>
<ul>
<li><p>蓝色虚线为<code>makefile</code>构建项目的过程</p>
</li>
<li><p>红色实线为<code>cmake</code>构建项目的过程</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250530154111909-1748931689530-2.png" alt="image-20250530154111909"></p>
<blockquote>
<p><code>cmake</code> 命令会读取<code>CMakeLists.txt</code>，并分析你的源码依赖、编译规则等，然后会自动生成平台和工具链相关的构建文件（在 Linux 下通常是 Makefile，也可以生成 ninja 文件、VS 工程等）。</p>
<p><code>Makefile</code>是 make 工具使用的构建说明文件，包含了所有编译、链接目标的依赖和命令。<code>make</code> 命令会根据 Makefile，自动调用 gcc&#x2F;g++ 等编译器，把源代码编译为目标文件（.o）、静态&#x2F;动态库、可执行文件等。</p>
<p><strong>CMake和Makefile区别</strong>：</p>
<ul>
<li><p><strong>CMake</strong> 主要是“构建系统生成器”，不直接参与编译，只是根据你的 CMakeLists.txt 生成适合你平台的 Makefile（或其他构建系统文件）。</p>
</li>
<li><p><strong>Makefile</strong> 里写明了实际编译与链接的步骤，<strong>make</strong>命令才会真正调用编译器执行编译动作。</p>
<p><strong>所以：CMake 的作用是生成构建规则（Makefile），make 的作用是执行这些规则完成编译。</strong></p>
</li>
</ul>
</blockquote>
<p><strong>总结CMake优点</strong>：</p>
<ul>
<li>跨平台</li>
<li>能够管理大型项目(流水线管理)</li>
<li>简化编译构建过程和编译过程</li>
<li>可扩展：可以为 cmake 编写特定功能的模块，扩充 cmake 功能</li>
</ul>
<h1 id="CMake的基本使用"><a href="#CMake的基本使用" class="headerlink" title="CMake的基本使用"></a>CMake的基本使用</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>CMake支持大写、小写、混合大小写的命令。如果在编写CMakeLists.txt文件时使用的工具有对应的命令提示，那么大小写随缘即可，不要太过在意。</p>
<h3 id="注释行"><a href="#注释行" class="headerlink" title="注释行"></a>注释行</h3><p>CMake 使用 # 进行行注释，可以放在任何位置。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是一个 CMakeLists.txt 文件</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.22</span>.<span class="number">4</span>)</span><br></pre></td></tr></table></figure>



<h3 id="注释块"><a href="#注释块" class="headerlink" title="注释块"></a>注释块</h3><p><code>CMake</code> 使用 <code> #[[ ]]</code>形式进行<code>块注释</code>。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#[[ 这是一个 CMakeLists.txt 文件</span></span><br><span class="line"><span class="comment">这是一个 CMakeLists.txt 文件</span></span><br><span class="line"><span class="comment">这是一个 CMakeLists.txt 文件]]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.22</span>.<span class="number">4</span>)</span><br></pre></td></tr></table></figure>





<h2 id="只有源文件"><a href="#只有源文件" class="headerlink" title="只有源文件"></a>只有源文件</h2><h3 id="全在一个目录下"><a href="#全在一个目录下" class="headerlink" title="全在一个目录下"></a>全在一个目录下</h3><ol>
<li><strong>准备了以下几个测试文件</strong></li>
</ol>
<ul>
<li>add.c</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>div.c</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)a/b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>head.h</li>
</ul>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _HEAD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _HEAD_H</span></span><br><span class="line"><span class="comment">// 加法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="comment">// 除法</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>main.c</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a + b = %d\n&quot;</span>, add(a, b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a / b = %f\n&quot;</span>, divide(a, b));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li><strong>上述文件的目录结构如下</strong>：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── add.c</span><br><span class="line">├── div.c</span><br><span class="line">├── head.h</span><br><span class="line">├── main.c</span><br></pre></td></tr></table></figure>



<ol start="3">
<li><strong>添加<code>CMakeLists.txt</code>文件</strong></li>
</ol>
<p>在上述源文件所在目录下添加一个新文件<code>CMakeLists.txt</code>，完整文件内容如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">add_executable</span>(app add.c div.c main.c)</span><br></pre></td></tr></table></figure>



<p>接下来依次介绍一下在<code>CMakeLists.txt </code>文件中添加的三个命令：</p>
<ul>
<li><p><code>cmake_minimum_required</code>：指定使用的 cmake 的最低版本</p>
<ul>
<li>可选，非必须，不加可能会有警告</li>
</ul>
</li>
<li><p><code>project</code>: 定义工程名称，并可指定工程的版本、工程描述、web主页地址、支持的语言（默认情况支持所有语言），如果不需要这些都是<code>可以忽略</code>的，只需要指定出<code>工程名字</code>即可。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PROJECT 指令的语法是：</span></span><br><span class="line"><span class="keyword">project</span>(&lt;<span class="keyword">PROJECT</span>-NAME&gt; [&lt;language-name&gt;...])</span><br><span class="line"><span class="keyword">project</span>(&lt;<span class="keyword">PROJECT</span>-NAME&gt;</span><br><span class="line">       [VERSION &lt;major&gt;[.&lt;minor&gt;[.&lt;patch&gt;[.&lt;tweak&gt;]]]]</span><br><span class="line">       [DESCRIPTION &lt;<span class="keyword">project</span>-description-<span class="keyword">string</span>&gt;]</span><br><span class="line">       [HOMEPAGE_URL &lt;url-<span class="keyword">string</span>&gt;]</span><br><span class="line">       [LANGUAGES &lt;language-name&gt;...])</span><br><span class="line">       </span><br><span class="line"><span class="comment"># 一般只指定名字</span></span><br><span class="line"><span class="keyword">project</span>(my_project_name)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>add_executable</code>: 定义工程会生成一个可执行程序</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(可执行文件名 源文件<span class="number">1</span> 源文件<span class="number">2</span> ...)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可执行文件名：你想要生成的可执行程序的名字（不需要加扩展名）。</span></span><br><span class="line"><span class="comment"># 源文件列表：组成该程序的所有源文件（.cpp、.c、.cc等）</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>这里的可执行程序名和<code>project</code>中的项目名没有任何关系</p>
</li>
<li><p>源文件名可以是<strong>一个</strong>也可以是<strong>多个</strong>，如有多个可用<strong>空格</strong>或**;**间隔</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 样式1</span></span><br><span class="line"><span class="keyword">add_executable</span>(app add.c div.c main.c)</span><br><span class="line"><span class="comment"># 样式2</span></span><br><span class="line"><span class="keyword">add_executable</span>(app add.c;div.c;main.c)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>执行<code>CMake</code>命令</strong></li>
</ol>
<p>​	将<code>CMakeLists.txt</code>文件编辑好之后，就可以执行 <code>cmake</code>命令了</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cmake命令作用：根据 CMakeLists.txt 配置文件，自动生成适合当前平台的构建系统文件(Makefile等)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cmake 命令原型</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake CMakeLists.txt文件所在路径</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake . <span class="comment">#当前目录查找CMakeLists.txt 文件，并在这个目录下生成对应的构建文件（比如 Makefile)</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake .. <span class="comment"># 上一级目录查找</span></span></span><br></pre></td></tr></table></figure>



<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250530172633352-1748931689528-1.png" alt="image-20250530172633352"></p>
<p>当执行<code>cmake</code>命令之后，<code>CMakeLists.txt </code>中的命令就会被执行，所以一定要注意给cmake 命令指定路径的时候一定不能出错。</p>
<p>执行命令之后，看一下源文件所在目录中是否多了一些文件：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250530173001617-1748931689531-23.png" alt="image-20250530173001617"></p>
<p>我们可以看到在对应的目录下生成了一个<code>makefile</code>文件，此时再执行<code>make</code>命令，就可以对项目进行构建得到所需的可执行程序了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250530173256867-1748931689531-3.png" alt="image-20250530173256867"></p>
<p>最终可执行程序<code>app</code>就被编译出来了（这个名字是在<code>CMakeLists.txt</code>中指定的）。</p>
<h3 id="build目录"><a href="#build目录" class="headerlink" title="build目录"></a>build目录</h3><p>通过上面的例子可以看出，如果在<code>CMakeLists.txt文件</code>所在目录执行了<code>cmake命令</code>之后就会生成一些目录和文件（<code>包括 makefile 文件</code>），如果再基于<code>makefile</code>文件执行<code>make</code>命令，程序在编译过程中还会生成一些中间文件和一个可执行文件，这样会导致整个项目目录看起来很混乱，不太容易管理和维护，此时我们就可以把生成的这些与项目源码无关的文件统一放到一个对应的目录里边，比如将这个目录命名为<code>build</code>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250530180208981-1748931689531-5.png" alt="image-20250530180208981"></p>
<p>现在<code>cmake</code>命令是在<code>build</code>目录中执行的，但是<code>CMakeLists.txt</code>文件是<code>build</code>目录的上一级目录中，所以<code>cmake </code>命令后指定的路径为<code>..</code>，即当前目录的上一级目录。</p>
<p>当命令执行完毕之后，在<code>build</code>目录中会生成<code>makefile</code>文件，和其他文件</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250530180313054-1748931689531-4.png" alt="image-20250530180313054"></p>
<p>这样就可以在<code>build</code>目录中执行<code>make</code>命令编译项目，生成的相关文件自然也就被存储到build目录中了。这样通过<code>cmake</code>和<code>make</code>生成的所有文件就全部和项目源文件隔离开了，便于管理和维护</p>
<p>回到<code>build</code>目录，执行<code>make</code>命令，生成可执行文件<code>app</code>，运行app成功</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250530180812459-1748931689531-6.png" alt="image-20250530180812459"></p>
<h2 id="私人订制"><a href="#私人订制" class="headerlink" title="私人订制"></a>私人订制</h2><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>在上面的例子中一共提供了5个源文件，假设这五个源文件需要反复被使用，每次都直接将它们的名字写出来确实是很麻烦，此时我们就需要<strong>定义一个变量</strong>，将文件名对应的字符串(<code>cmake中默认的都是字符串形式</code>)存储起来，在cmake里定义变量需要使用<code>set</code>。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SET 指令的语法是：</span></span><br><span class="line"><span class="comment"># [] 中的参数为可选项, 如不需要可以不写</span></span><br><span class="line"><span class="keyword">SET</span>(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>VAR</strong>：变量名</li>
<li><strong>VALUE</strong>：变量值，取值方法：<code>$&#123;变量名&#125;</code></li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式1: 各个源文件之间使用空格间隔</span></span><br><span class="line"><span class="comment"># set(SRC_LIST add.c  div.c   main.c  mult.c  sub.c)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式2: 各个源文件之间使用分号 ; 间隔</span></span><br><span class="line"><span class="keyword">set</span>(SRC_LIST add.c;div.c;main.c;mult.c;sub.c)</span><br><span class="line"><span class="keyword">add_executable</span>(app  <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="指定使用的C-标准"><a href="#指定使用的C-标准" class="headerlink" title="指定使用的C++标准"></a>指定使用的C++标准</h3><p>在编写C++程序的时候，可能会用到C++11、C++14、C++17、C++20等新特性，那么就需要在编译的时候在编译命令中制定出要使用哪个标准，不指定的话默认使用C++98的标准</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ *.cpp -std=c++11 -o app</span></span><br></pre></td></tr></table></figure>

<p>上面的例子中通过参数-std&#x3D;c++11指定出要使用c++11标准编译程序，C++标准对应有一宏叫做DCMAKE_CXX_STANDARD。在CMake中想要指定C++标准有两种方式：</p>
<ol>
<li><strong>在 CMakeLists.txt 中通过 set 命令指定</strong>：设置CMAKE_CXX_STANDARD宏的值</li>
</ol>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#增加-std=c++11</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="comment">#增加-std=c++14</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"><span class="comment">#增加-std=c++17</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>在执行 cmake 命令的时候指定出这个宏的值</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">增加-std=c++11</span></span><br><span class="line">cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=11</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">增加-std=c++14</span></span><br><span class="line">cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=14</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">增加-std=c++17</span></span><br><span class="line">cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=17</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>在上面例子中 CMake 后的路径需要根据实际情况酌情修改。</strong></p>
</blockquote>
<h3 id="指定输出路径"><a href="#指定输出路径" class="headerlink" title="指定输出路径"></a>指定输出路径</h3><p>在CMake中指定可执行程序输出的路径(不指定默认当前目录下输出)，也对应一个宏，叫做<code>EXECUTABLE_OUTPUT_PATH</code>，它的值还是通过<code>set</code>命令进行设置:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义变量</span></span><br><span class="line"><span class="keyword">set</span>(HOME /home/robin/Linux/Sort)</span><br><span class="line"><span class="comment"># 指定生成的可执行程序保存的路径</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;HOME&#125;</span>/bin)</span><br></pre></td></tr></table></figure>

<ul>
<li>第一行：定义一个变量用于存储一个绝对路径</li>
<li>第二行：将拼接好的路径值设置给<code>EXECUTABLE_OUTPUT_PATH</code>宏<ul>
<li><strong>如果这个路径中的子目录不存在，会自动生成，无需自己手动创建</strong></li>
</ul>
</li>
</ul>
<p><strong>由于可执行程序是基于 cmake 命令生成的 makefile 文件然后再执行 make 命令得到的，所以如果此处指定可执行程序生成路径的时候使用的是相对路径 .&#x2F;xxx&#x2F;xxx，那么这个路径中的 .&#x2F; 对应的就是 makefile 文件所在的那个目录。</strong></p>
<h3 id="示例使用"><a href="#示例使用" class="headerlink" title="示例使用"></a>示例使用</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250602142809198-1748931689531-7.png" alt="image-20250602142809198"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250602142852977-1748931689531-8.png" alt="image-20250602142852977"></p>
<p>可以看到生成的可执行文件app出现在了我们指定的&#x2F;home&#x2F;keqiudi&#x2F;aa&#x2F;bb&#x2F;cc下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250602142937310-1748931689531-9.png" alt="image-20250602142937310"></p>
<h2 id="搜索文件"><a href="#搜索文件" class="headerlink" title="搜索文件"></a>搜索文件</h2><p>如果一个项目里边的源文件很多，在编写<code>CMakeLists.txt</code>文件的时候不可能将项目目录的各个文件一一罗列出来，这样太麻烦也不现实。所以，在CMake中为我们提供了搜索文件的命令，可以使用<code>aux_source_directory</code>命令或者<code>file</code>命令。</p>
<p><strong>其中的涉及到存放源文件的变量不需要使用set定义，直接使用即可(就是自动将指定目录的源文件定义为一个变量供add_executable使用的过程，可以看作set的升级版)</strong></p>
<h3 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h3><p>在 CMake 中使用<code>aux_source_directory</code>命令可以查找某个路径下的所有<code>源文件</code>，命令格式为：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span>(&lt; dir &gt; &lt; variable &gt;)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>dir</code>：要搜索的目录</li>
<li><code>variable</code>：将从<code>dir</code>目录下搜索到的源文件列表存储到该变量中</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># 搜索 src 目录下的源文件</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src SRC_LIST)</span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>PROJECT_SOURCE_DIR</code>: 自带宏定义，即CMakeLists.txt文件路径</li>
<li><code>CMAKE_CURRENT_SOURCE_DIR</code>: 自带宏定义，也是CMakeLists.txt文件路径。与<strong>PROJECT_SOURCE_DIR</strong>完全相同，随便使用一个即可</li>
</ul>
<h3 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h3><p>第二种方式是使用<code>file</code>（当然，除了搜索以外通过 file 还可以做其他事情）进行搜索，与方式1的区别呢，使用file，需要执行文件的类型(后缀)</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB/GLOB_RECURSE 变量名 要搜索的文件路径和文件类型)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>GLOB</strong>: 将指定目录下搜索到的满足条件的所有文件名生成一个列表，并将其存储到变量中。</li>
<li><strong>GLOB_RECURSE</strong>：递归搜索指定目录，将搜索到的满足条件的文件名生成一个列表，并将其存储到变量中。</li>
</ul>
<p><strong>搜索当前目录的src目录下所有的源文件，并存储到变量中</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB MAIN_SRC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"><span class="keyword">file</span>(GLOB MAIN_HEAD <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>/*.h)</span><br></pre></td></tr></table></figure>

<ul>
<li>关于要搜索的文件路径和类型可加双引号，也可不加:</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB MAIN_HEAD <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.h&quot;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="示例使用-1"><a href="#示例使用-1" class="headerlink" title="示例使用"></a>示例使用</h3><p><strong>方式1：aux_source_directory</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250602150725291-1748931689531-10.png" alt="image-20250602150725291"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250602150757897-1748931689531-11.png" alt="image-20250602150757897"></p>
<p><strong>方式2：file</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250602151021746-1748931689531-12.png" alt="image-20250602151021746"></p>
<h2 id="包含头文件"><a href="#包含头文件" class="headerlink" title="包含头文件"></a>包含头文件</h2><h3 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h3><p>在编译项目源文件的时候，很多时候都需要将源文件对应的头文件路径指定出来，这样才能保证在编译过程中编译器能够找到这些头文件，并顺利通过编译。在CMake中设置要包含的目录也很简单，通过一个命令就可以搞定了，他就是<code>include_directories</code>:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(headfile_path)</span><br></pre></td></tr></table></figure>

<p>举例说明，有源文件若干，其目录结构如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">└── src</span><br><span class="line">    ├── add.cpp</span><br><span class="line">    ├── div.cpp</span><br><span class="line">    ├── main.cpp</span><br><span class="line">    ├── mult.cpp</span><br><span class="line">    └── sub.cpp</span><br><span class="line"></span><br><span class="line">3 directories, 7 files</span><br></pre></td></tr></table></figure>

<p><code>CMakeLists.txt</code>文件内容如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(HOME /home/robin/Linux/calc)</span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;HOME&#125;</span>/bin/)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(app  <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>其中，第六行指定就是头文件的路径，<code>PROJECT_SOURCE_DIR</code>宏对应的值就是我们在使用cmake命令时，后面紧跟的目录，一般是工程的根目录。</p>
<h3 id="示例使用-2"><a href="#示例使用-2" class="headerlink" title="示例使用"></a>示例使用</h3><p>我们将原本头文件和源文件混合的情况下，创建<code>src</code>和<code>include</code>的文件夹，分别存放源文件和头文件。我们将原本的头文件和源文件移动到<code>include</code>和<code>src</code>文件夹</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250602152538002-1748931689531-13.png" alt="image-20250602152538002"></p>
<p>修改CMakeLists.txt 中的搜索文件添加以下src路径：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250602153250865-1748931689531-14.png" alt="image-20250602153250865"></p>
<p>执行cmake和make命令：我们可以发现报错说找不到头文件</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250602153452264-1748931689531-15.png" alt="image-20250602153452264"></p>
<p>此时由两种处理方式：</p>
<ul>
<li><p><strong>修改头文件路径</strong>：将原来的head.h改为..&#x2F;include&#x2F;head.h</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250602153752343-1748931689531-16.png" alt="image-20250602153752343"></p>
<p>修改后通过编译：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250602153955649-1748931689531-17.png" alt="image-20250602153955649"></p>
<blockquote>
<p>这种方法如果头文件很多的话就会很麻烦，所以推荐下面再CMakeLists中添加包含头文件</p>
</blockquote>
</li>
<li><p><strong>在CMakeLists.txt中添加包含头文件</strong>(推荐使用)：</p>
</li>
</ul>
<p>在10行中我们添加对头文件路径的搜索，include中是我们的所有头文件的文件夹所在目录</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250602154125377-1748931689531-18.png" alt="image-20250602154125377"></p>
<p>然后进行我们的make命令，成功找到头文件，成功运行可执行文件app</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250602154502901-1748931689531-20.png" alt="image-20250602154502901"></p>
<h2 id="制作动态库和静态库"><a href="#制作动态库和静态库" class="headerlink" title="制作动态库和静态库"></a>制作动态库和静态库</h2><p>有些时候我们编写的源代码并不需要将他们编译生成可执行程序，而是生成一些静态库或动态库<strong>提供给第三方使用</strong>，提供时需要将<code>动态/静态库(源代码的二进制文件libxxx.a/.lib或libxxx.so/.dll)</code>和<code>头文件</code>提供给使用者才能使用</p>
<blockquote>
<p>其实就是相当于把很多相关的<code>.c源文件</code>合起来打包变成了<code>二进制文件</code>。</p>
<p>使用者看不到<code>.c</code>文件内容(隐藏实现)，只能通过<code>头文件</code>来看有哪些函数，如何使用，再调用函数，否则用户看不懂。</p>
</blockquote>
<p>下面来讲解在cmake中生成这两类库文件的方法。</p>
<h3 id="制作静态库"><a href="#制作静态库" class="headerlink" title="制作静态库"></a>制作静态库</h3><p>在cmake中，如果要制作静态库，需要使用的命令如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(库名称 STATIC 源文件<span class="number">1</span> [源文件<span class="number">2</span>] ...) </span><br></pre></td></tr></table></figure>

<p>在Linux中，静态库名字分为三部分：<code>lib</code>+<code>库名字</code>+<code>.a</code>，此处只需要指定出库的名字就可以了，另外两部分在生成该文件的时候会自动填充。</p>
<p>在Windows中静态库名字是：<code>lib</code>+<code>库名字</code>+<code>.lib</code>，</p>
<p>下面有一个目录，需要将<code>src</code>目录中的源文件编译成静态库，然后再使用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include           # 头文件目录</span><br><span class="line">│   └── head.h</span><br><span class="line">├── main.cpp          # 用于测试的源文件</span><br><span class="line">└── src               # 源文件目录</span><br><span class="line">    ├── add.cpp</span><br><span class="line">    ├── div.cpp</span><br><span class="line">    ├── mult.cpp</span><br><span class="line">    └── sub.cpp</span><br></pre></td></tr></table></figure>

<p>根据上面的目录结构，可以这样编写<code>CMakeLists.txt</code>文件：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成静态库文件</span></span><br><span class="line"><span class="keyword">add_library</span>(calc STATIC <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>这样最终就会生成对应的静态库文件<code>libcalc.a</code>。</p>
<h3 id="制作静态链接库示例"><a href="#制作静态链接库示例" class="headerlink" title="制作静态链接库示例"></a>制作静态链接库示例</h3><p>现在我们是创建链接库，将原来的生成可执行文件<code>add_executable</code>注释掉，田间<code>add_library()</code>，使用<code>STATIC</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250602194632666-1748931689531-19.png" alt="image-20250602194632666"></p>
<p>执行<code>cmake</code>和<code>make</code>后，我们可以看到在当前目录下生成了libcalc.a(静态库)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250602194554742-1748931689531-22.png" alt="image-20250602194554742"></p>
<blockquote>
<p>可以看到图中<code>libcalc.a</code>是白色的，是因为<code>静态库没有可执行权限的</code>，而我们的<code>动态链接库是绿色的，具有执行权限</code></p>
</blockquote>
<h3 id="制作动态库"><a href="#制作动态库" class="headerlink" title="制作动态库"></a>制作动态库</h3><p>在<code>cmake</code>中，如果要制作动态库，需要使用的命令如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(库名称 SHARED 源文件<span class="number">1</span> [源文件<span class="number">2</span>] ...) </span><br></pre></td></tr></table></figure>

<p>在<strong>Linux</strong>中，动态库名字分为三部分：<code>lib</code>+<code>库名字</code>+<code>.so</code>，此处只需要指定出库的名字就可以了，另外两部分在生成该文件的时候会自动填充。</p>
<p>在<strong>Windows</strong>中动态库的名字叫<code>lib</code>+<code>库名字</code>+<code>.dll</code></p>
<p>根据上面的目录结构，可以这样编写<code>CMakeLists.txt</code>文件:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成动态库文件</span></span><br><span class="line"><span class="keyword">add_library</span>(calc SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>这样最终就会生成对应的动态库文件<code>libcalc.so</code>。</p>
<h3 id="创建动态链接库示例"><a href="#创建动态链接库示例" class="headerlink" title="创建动态链接库示例"></a>创建动态链接库示例</h3><p>现在我们是创建链接库，将原来的生成可执行文件<code>add_executable</code>注释掉，田间<code>add_library()</code>，使用<code>SHARED</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250602193743030-1748931689531-21.png" alt="image-20250602193743030"></p>
<p>执行<code>cmake</code>和<code>make</code>后，我们可以看到在当前目录下生成了libcalc.so(动态链接库)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250602194059434-1748931689531-24.png" alt="image-20250602194059434"></p>
<blockquote>
<p>可以看到图中<code>libcalc.so</code>是绿色的，是因为<code>动态链接库是有可执行权限的</code>，而我们的<code>静态库没有执行权限</code></p>
</blockquote>
<h3 id="指定库文件输出的路径"><a href="#指定库文件输出的路径" class="headerlink" title="指定库文件输出的路径"></a>指定库文件输出的路径</h3><h4 id="方式1-适用于动态库"><a href="#方式1-适用于动态库" class="headerlink" title="方式1- 适用于动态库"></a>方式1- 适用于动态库</h4><p>对于生成的库文件来说和可执行程序一样都可以指定输出路径。<code>由于在Linux下生成的动态库默认是有执行权限的</code>，所以可以按照生成可执行程序的方式去指定它生成的目录：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br><span class="line"><span class="comment"># 设置动态库生成路径</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)<span class="comment">#按照生成可执行程序的方式指定生成目录</span></span><br><span class="line"><span class="keyword">add_library</span>(calc SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于这种方式来说，其实就是通过<code>set</code>命令给<code>EXECUTABLE_OUTPUT_PATH</code>宏设置了一个路径，这个路径就是可执行文件生成的路径。</p>
<h4 id="方式2-都适用-推荐使用这种"><a href="#方式2-都适用-推荐使用这种" class="headerlink" title="方式2-都适用(推荐使用这种)"></a>方式2-都适用(推荐使用这种)</h4><p>由于在Linux下生成的静态库默认不具有可执行权限，所以在指定静态库生成的路径的时候就不能使用<code>EXECUTABLE_OUTPUT_PATH</code>宏了，而应该使用<code>LIBRARY_OUTPUT_PATH</code>，<strong>这个宏对应静态库文件和动态库文件都适用</strong>。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br><span class="line"><span class="comment"># 设置动态库/静态库生成路径</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># 生成动态库</span></span><br><span class="line"><span class="comment"># add_library(calc SHARED $&#123;SRC_LIST&#125;)</span></span><br><span class="line"><span class="comment"># 生成静态库</span></span><br><span class="line"><span class="keyword">add_library</span>(calc STATIC <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="示例使用-3"><a href="#示例使用-3" class="headerlink" title="示例使用"></a>示例使用</h4><p>使用<code>set()</code>，宏<code>LIBRARY_OUTPUT_PATH</code> ，指定库文件输出路径到<strong>lib</strong></p>
<p><strong>静态链接库</strong>：STATIC</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250602201936010-1748931689531-26.png" alt="image-20250602201936010"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250602202407734-1748931689531-25.png" alt="image-20250602202407734"></p>
<p><strong>动态链接库</strong>：SHARED</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250602202520033-1748931689531-27.png" alt="image-20250602202520033"></p>
<p>我们可以看到切换为动态链接库后，也在lib下生成了对应的<code>libcalc.so</code>库文件</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250602202804739-1748931689531-28.png" alt="image-20250602202804739"></p>
<h2 id="使用链接库-包含库文件"><a href="#使用链接库-包含库文件" class="headerlink" title="使用链接库(包含库文件)"></a>使用链接库(包含库文件)</h2><p>在编写程序的过程中，可能会用到一些系统提供的动态库或者自己制作出的动态库或者静态库文件，cmake中也为我们提供了相关的加载动态库的命令。</p>
<h3 id="链接静态库"><a href="#链接静态库" class="headerlink" title="链接静态库"></a>链接静态库</h3><p>在编写程序的过程中，可能会用到一些系统提供的动态库或者自己制作出的动态库或者静态库文件，cmake中也为我们提供了相关的加载动态库的命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">├── add.cpp</span><br><span class="line">├── div.cpp</span><br><span class="line">├── main.cpp</span><br><span class="line">├── mult.cpp</span><br><span class="line">└── sub.cpp</span><br></pre></td></tr></table></figure>

<p>现在我们把上面<code>src</code>目录中的<code>add.cpp</code>、<code>div.cpp</code>、<code>mult.cpp</code>、<code>sub.cpp</code>编译成一个静态库文件<code>libcalc.a</code>。</p>
<a class="btn-anzhiyu larger" target="_blank" rel="noopener" href="https://subingwen.cn/linux/library/" 
  title="通过命令制作并使用静态链接库"><i class="anzhiyufont anzhiyu-icon-circle-arrow-right"></i><span>通过命令制作并使用静态链接库</span></a>

<p>测试目录结构如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span> </span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">├── lib</span><br><span class="line">│   └── libcalc.a     # 制作出的静态库的名字</span><br><span class="line">└── src</span><br><span class="line">    └── main.cpp</span><br><span class="line"></span><br><span class="line">4 directories, 4 files</span><br></pre></td></tr></table></figure>

<p><strong>在cmake中，链接静态库的命令如下</strong>：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">link_libraries</span>(&lt;static lib&gt; [&lt;static lib&gt;...])</span><br></pre></td></tr></table></figure>

<p>用于设置全局链接库，这些库会链接到之后定义的所有目标上</p>
<ul>
<li><strong>参数1</strong>：指定出要链接的静态库的名字<ul>
<li>可以是全名 <code>libxxx.a</code></li>
<li>也可以是掐头（<code>lib</code>）去尾（<code>.a</code>）之后的名字 xxx</li>
</ul>
</li>
<li><strong>参数2-N</strong>：可以链接一个或多个静态库，这里依次填写要链接的其它静态库的名字即可</li>
</ul>
<p>如果该静态库不是系统提供的（自己制作或者使用第三方提供的静态库）可能出现静态库找不到的情况，此时需要将静态库的路径也指定出来：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#如果是系统提供的静态库不需要指定路径，只需要使用上面的link_libraries就可以找到</span></span><br><span class="line"><span class="keyword">link_directories</span>(&lt;lib path&gt;)</span><br></pre></td></tr></table></figure>

<p>这样，修改之后的<code>CMakeLists.txt</code>文件内容如下:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)<span class="comment"># 搜索指定目录下源文件</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)<span class="comment"># 包含头文件路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.包含静态库路径</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># 2.在生成可执行文件前,链接静态库</span></span><br><span class="line"><span class="keyword">link_libraries</span>(calc)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样编译之后就会将 源文件(SRC_LIST) 和 库文件(link_libraries(calc))放到一起，最终生成我们的可执行文件app</p>
<p>静态库使用会被打包到可执行文件中</p>
</blockquote>
<h3 id="使用静态链接库示例"><a href="#使用静态链接库示例" class="headerlink" title="使用静态链接库示例"></a>使用静态链接库示例</h3><p>目前把动态链接库和静态链接库分别创建了<code>lib_shared</code>和<code>lib_static</code>，在我们的<code>main.cpp</code>中使用他们</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250602210016066-1748931689531-29.png" alt="image-20250602210016066"></p>
<blockquote>
<p><strong>src</strong>文件夹的内容是<strong>库文件的.c文件实现</strong>，这里我们制作成了动态库和静态库，所以该文件夹可以直接删去，只需要使用链接库文件(libcalc.a&#x2F;so)即可</p>
</blockquote>
<ol>
<li><p><strong>修改CMakeLists.txt：我们先不指出库文件的路径，注释掉link_directories</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250602211358021-1748931689531-30.png" alt="image-20250602211358021"></p>
</li>
<li><p><strong>我们执行cmake和make，报错发现找不到calc库文件</strong></p>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250602211336966-1748931689531-31.png" alt="image-20250602211336966"></p>
<ol start="3">
<li><p><strong>我们将注释的静态库路径重新启用：link_directories</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250602211535279-1748931689531-32.png" alt="image-20250602211535279"></p>
</li>
<li><p><strong>修改后编译就可以找到库文件的了，编译通过</strong></p>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250602211638378-1748931689531-34.png" alt="image-20250602211638378"></p>
<h3 id="链接动态库"><a href="#链接动态库" class="headerlink" title="链接动态库"></a>链接动态库</h3><p>在程序编写过程中，除了在项目中引入静态库，好多时候也会使用一些标准的或者第三方提供的一些动态库，关于动态库的制作、使用以及在内存中的加载方式和静态库都是不同的，在此不再过多赘述，如有疑惑请参考<a class="btn-anzhiyu larger" target="_blank" rel="noopener" href="https://subingwen.cn/linux/library/" 
  title="Linux静态库和动态库"><i class="anzhiyufont anzhiyu-icon-circle-arrow-right"></i><span>Linux静态库和动态库</span></a></p>
<p>在<code>cmake</code>中<strong>链接动态库的命令</strong>如下:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">    &lt;<span class="keyword">target</span>&gt; </span><br><span class="line">    &lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;... </span><br><span class="line">    [&lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...]...)</span><br></pre></td></tr></table></figure>

<p>用于指定一个目标（如可执行文件或库）在编译时需要链接哪些库。它支持指定库的名称、路径以及链接库的顺序。</p>
<ul>
<li><p><strong>target</strong>：指定要加载的库的文件的名字</p>
<ul>
<li>该文件可能是一个<strong>源文件</strong></li>
<li>该文件可能是一个<strong>动态库&#x2F;静态库文件</strong></li>
<li>该文件可能是一个<strong>可执行文件</strong></li>
</ul>
</li>
<li><p><strong>PRIVATE|PUBLIC|INTERFACE</strong>：动态库的访问权限，默认为<code>PUBLIC</code></p>
<ul>
<li><p>如果各个动态库之间没有依赖关系，无需做任何设置，三者没有没有区别，<code>一般无需指定，使用默认的 PUBLIC 即可</code>。</p>
</li>
<li><p><code>动态库的链接具有传递性(仅PUBLIC权限)</code>，如果动态库 A 链接了动态库B、C，动态库D链接了动态库A，此时动态库D相当于也链接了动态库B、C，并可以使用动态库B、C中定义的方法。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(A B C) <span class="comment"># A 链接B、C</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(D A)<span class="comment"># D 链接 A</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>PUBLIC(传递多次)</strong>：在public后面的库会被Link到前面的所有target中，并且里面的符号(函数)也会被导出，提供给第三方使用(<strong>具有传递性</strong>)。</p>
</li>
<li><p><strong>PRIVATE(仅传递一次)</strong>：在private后面的库仅被link到前面的target中，并且终结掉，第三方不能感知你调了啥库(<strong>不具有传递性</strong>)。</p>
</li>
<li><p><strong>INTERFACE</strong>：在interface后面引入的库不会被链接到前面的target中，只会导出符号(<strong>不具有传递性</strong>)。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="链接系统动态库"><a href="#链接系统动态库" class="headerlink" title="链接系统动态库"></a>链接系统动态库</h4><p>动态库的链接和静态库是完全不同的：</p>
<ul>
<li><p>静态库会在生成可执行程序的链接阶段被打包到可执行程序中，所以可执行程序启动，静态库就被加载到内存中了。</p>
</li>
<li><p>动态库在生成可执行程序的链接阶段<code>不会</code>被打包到可执行程序中，<strong>当可执行程序被启动并且调用了动态库中的函数的时候，动态库才会被加载到内存</strong></p>
</li>
</ul>
<p>因此，在<code>cmake</code>中指定要链接的动态库的时候，<code>应该将命令写到生成了可执行文件之后</code>：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/*.cpp)</span><br><span class="line"><span class="comment"># 添加并指定最终生成的可执行程序名</span></span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="comment"># 写到可执行文件之后：指定可执行程序要链接的动态库名字</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(app pthread)</span><br></pre></td></tr></table></figure>

<p>在<code>target_link_libraries(app pthread)中</code>：</p>
<ul>
<li><code>app</code>: 对应的是最终生成的可执行程序的名字</li>
<li><code>pthread</code>：这是可执行程序要加载的动态库，这个库是系统提供的线程库，全名为libpthread.so，在指定的时候一般会掐头（lib）去尾（.so）。</li>
</ul>
<h4 id="链接第三方动态库"><a href="#链接第三方动态库" class="headerlink" title="链接第三方动态库"></a>链接第三方动态库</h4><p>现在，自己编写并生成了一个动态库，对应的目录结构如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span> </span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h            # 动态库对应的头文件</span><br><span class="line">├── lib</span><br><span class="line">│   └── libcalc.so        # 自己制作的动态库文件</span><br><span class="line">└── main.cpp              # 测试用的源文件</span><br><span class="line"></span><br><span class="line">3 directories, 4 files</span><br></pre></td></tr></table></figure>

<p>假设在测试文件main.cpp中既使用了自己制作的动态库libcalc.so又使用了系统提供的线程库，此时CMakeLists.txt文件可以这样写：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/*.cpp)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="comment"># 链接动态库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(app pthread calc)</span><br></pre></td></tr></table></figure>

<p>在<strong>第六行</strong>中，<code>pthread</code>、<code>calc</code>都是可执行程序<code>app</code>要链接的动态库的名字。当可执行程序<code>app</code>生成之后并执行该文件，会提示有如下错误信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./app</span> </span><br><span class="line">./app: error while loading shared libraries: libcalc.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>

<p>这是因为可执行程序启动之后，去加载<code>calc</code>这个动态库，但是不知道这个动态库被放到了什么位置<a class="btn-anzhiyu larger" target="_blank" rel="noopener" href="https://subingwen.cn/linux/library/" 
  title="解决动态库无法加载的问题"><i class="anzhiyufont anzhiyu-icon-circle-arrow-right"></i><span>解决动态库无法加载的问题</span></a>，所以就加载失败了。</p>
<p><strong>在 CMake 中可以在生成可执行程序之前，通过命令指定出要链接的动态库的位置，在动态库使用的是这个命令</strong>：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_directories</span>(</span><br><span class="line">    &lt;<span class="keyword">target</span>&gt; </span><br><span class="line">    &lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;... </span><br><span class="line">    [&lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...]...)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里也可以使用之前静态库中<code>link_directories</code>，一个是全局，一个是指定</p>
</blockquote>
<p>所以修改之后的<code>CMakeLists.txt</code>文件应该是这样的：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/*.cpp)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.指定要链接的动态库的路径</span></span><br><span class="line"><span class="comment"># link_directories($&#123;PROJECT_SOURCE_DIR&#125;/lib)法1：全局添加动态库搜索路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加并生成一个可执行程序</span></span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.指定要链接的动态库的路径</span></span><br><span class="line"><span class="keyword">target_link_directories</span>(app PUBLIC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/lib_shared) <span class="comment"># 法2: 指定添加链接目录</span></span><br><span class="line"><span class="comment"># 2.在生成可执行文件后才指定要链接的动态库，要不然不知道可执行文件</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(app pthread calc)</span><br></pre></td></tr></table></figure>

<p>通过<code>link_directories</code>&#x2F;<code>target_link_directories</code>指定了动态库的路径之后，在执行生成的可执行程序的时候，就不会出现找不到动态库的问题了。</p>
<h3 id="使用动态库链接示例"><a href="#使用动态库链接示例" class="headerlink" title="使用动态库链接示例"></a>使用动态库链接示例</h3><p>法1或法2有一点区别但都能使用，随便使用一种即可，<strong>建议使用法2</strong></p>
<p>图中的PUBLIC权限可以省略，因为默认就是PUBLIC，使用其他权限时就需要明确指出</p>
<p>同时图中只链接了一个库<code>cal </code>，如果要链接多个库之间使用空格分开即可</p>
<p>一定要保证<code>target_link_libraries</code>在生成可执行文件(<code>add_excutable</code>)之后</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250603103740999-1748931689531-33.png" alt="image-20250603103740999"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250603103752510-1748931689531-35.png" alt="image-20250603103752510"></p>
<h3 id="target-link-libraries和link-libraries区别"><a href="#target-link-libraries和link-libraries区别" class="headerlink" title="target_link_libraries和link_libraries区别"></a>target_link_libraries和link_libraries区别</h3><blockquote>
<p>温馨提示：<code>target_link_libraries</code> 和  <code>link_libraries </code>是 CMake 中用于链接库的两个命令，其实都可以用于<strong>链接动态库和静态库</strong>，但它们的使用场景和功能有所不同。下面是关于二者的总结：</p>
</blockquote>
<p><strong>target_link_libraries&#x2F;target_link_directories</strong></p>
<ul>
<li><p>功能: <code>target_link_libraries </code>用于<strong>指定一个目标</strong>（如可执行文件或库）在编译时需要链接哪些库。它支持指定库的名称、路径以及链接库的顺序。</p>
</li>
<li><p>语法:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(target_name [item1 [item2 [...]]]</span><br><span class="line">                      [&lt;debug|optimized|general&gt; &lt;lib1&gt; [&lt;lib2&gt; [...]]])</span><br></pre></td></tr></table></figure>
</li>
<li><p>优点:</p>
<ul>
<li>更精确地控制目标的链接库。</li>
<li>可以指定库的不同链接条件（如调试版本、发布版本）。</li>
<li>支持多个目标和多个库之间的复杂关系。</li>
<li>更加灵活和易于维护，特别是在大型项目中。</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(my_executable main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(my_executable PRIVATE my_dynamic_library)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>link_libraries&#x2F;link_directories</strong></p>
<ul>
<li><p>功能: <code>link_libraries</code> 用于<strong>设置全局链接库</strong>，这些库会链接到之后定义的所有目标上。它会影响所有的目标，适用于全局设置，但不如 <code>target_link_libraries</code> 精确。</p>
</li>
<li><p>语法：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">link_libraries</span>(lib1 lib2 [...])</span><br></pre></td></tr></table></figure>
</li>
<li><p>缺点：</p>
<ul>
<li>缺乏针对具体目标的控制，不适合复杂的项目结构。</li>
<li>容易导致意外的依赖关系，因为它对所有目标都生效。</li>
<li>一旦设置，全局影响可能导致难以追踪的链接问题。</li>
</ul>
</li>
<li><p>示例:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">link_libraries</span>(my_static_library)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(my_executable main.cpp)</span><br></pre></td></tr></table></figure>



<p>总结：</p>
</li>
<li><p><strong>target_link_libraries&#x2F;target_link_directories</strong> 只影响指定target，是<code>推荐</code>的方式，因为它允许更精确的控制和管理链接库的依赖，特别是在大型项目中，它能够避免全局设置可能带来的问题。</p>
</li>
<li><p><strong>link_libraries&#x2F;link_directories</strong> 全局影响，虽然简单，但在复杂的项目中可能会导致意外的问题，通常适用于简单的项目或临时设置。</p>
</li>
</ul>
<p>静态库和动态库链接方法几乎一样，可以混用，但建议用现代CMake写法。</p>
<p>建议在 CMake 项目中优先使用 <code>target_link_libraries</code>&#x2F;<code>target_link_directories</code>。</p>
<h2 id="日志-调试"><a href="#日志-调试" class="headerlink" title="日志(调试)"></a>日志(调试)</h2><p>在编写CMakeLists的过程中，如果我们想要输出一些调试信息，就可以使用message命令</p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>在CMake中可以用用户显示一条消息，该命令的名字为<code>message</code>：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR] <span class="string">&quot;message to display&quot;</span> ...)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>(无)</code> ：不指定，默认是重要消息</p>
</li>
<li><p><code>STATUS</code> ：非重要消息</p>
</li>
<li><p><code>WARNING</code>：CMake 警告, 会继续执行</p>
</li>
<li><p><code>AUTHOR_WARNING</code>：CMake 警告 (dev), 会继续执行</p>
</li>
<li><p><code>SEND_ERROR</code>：CMake 错误, 继续执行，但是会跳过生成的步骤</p>
</li>
<li><p><code>FATAL_ERROR</code>：CMake 错误, 终止所有处理过程</p>
</li>
</ul>
<p>CMake的命令行工具会在stdout上显示<code>STATUS</code>消息，在stderr上显示其他所有消息。CMake的GUI会在它的log区域显示所有消息。</p>
<p>CMake警告和错误消息的文本显示使用的是一种简单的标记语言。文本没有缩进，超过长度的行会回卷，段落之间以新行做为分隔符。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出一般日志信息</span></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="comment"># 输出警告信息</span></span><br><span class="line"><span class="keyword">message</span>(WARNING <span class="string">&quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="comment"># 输出错误信息</span></span><br><span class="line"><span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>CMakeLists中添加四条日志:  <strong>默认</strong>、<strong>STATUS</strong>、<strong>FATAL_ERROR</strong>、<strong>STATUS</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250603111206825-1748931689531-36.png" alt="image-20250603111206825"></p>
<p>执行到FATAL_ERROR，<code>日志3处发生中断</code>，日志4不执行</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250603111242791-1748931689531-38.png" alt="image-20250603111242791"></p>
<hr>
<p>注释掉FATAL_ERROR的日志部分</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250603111434163-1748931689531-37.png" alt="image-20250603111434163"></p>
<p>正常运行到日志4</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250603111516345-1748931689532-39.png" alt="image-20250603111516345"></p>
<h2 id="变量操作"><a href="#变量操作" class="headerlink" title="变量操作"></a>变量操作</h2><h3 id="追加"><a href="#追加" class="headerlink" title="追加"></a>追加</h3><p>有时候项目中的源文件并不一定都在同一个目录中，但是这些源文件最终却需要一起进行编译来生成最终的可执行文件或者库文件。如果我们通过<code>file</code>命令对各个目录下的源文件进行搜索，最后还需要做一个字符串拼接的操作，关于字符串拼接可以使用<code>set</code>命令也可以使用<code>list</code>命令。</p>
<h4 id="使用set拼接"><a href="#使用set拼接" class="headerlink" title="使用set拼接"></a>使用set拼接</h4><p>如果使用set进行字符串拼接，对应的命令格式如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(变量名<span class="number">1</span> <span class="variable">$&#123;变量名1&#125;</span> <span class="variable">$&#123;变量名2&#125;</span> ...)</span><br></pre></td></tr></table></figure>

<p>关于上面的命令其实就是将从第二个参数开始往后所有的字符串进行拼接，最后将结果存储到第一个参数中，如果第一个参数中原来有数据会对原数据就行覆盖。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="keyword">set</span>(TEMP <span class="string">&quot;hello,world&quot;</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_1 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src1/*.cpp)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_2 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src2/*.cpp)</span><br><span class="line"><span class="comment"># 追加(拼接)</span></span><br><span class="line"><span class="keyword">set</span>(SRC_1 <span class="variable">$&#123;SRC_1&#125;</span> <span class="variable">$&#123;SRC_2&#125;</span> <span class="variable">$&#123;TEMP&#125;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;message: $&#123;SRC_1&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="示例-使用set拼接"><a href="#示例-使用set拼接" class="headerlink" title="示例-使用set拼接"></a>示例-使用set拼接</h4><p>定义变量tmp1为helloworld，将SRC值拼接到tmp1后方</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250603133056804-1748931689532-40.png" alt="image-20250603133056804"></p>
<p>输出tmp 和tmp1的值</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250603133009406-1748931689532-41.png" alt="image-20250603133009406"></p>
<h4 id="使用list拼接"><a href="#使用list拼接" class="headerlink" title="使用list拼接"></a>使用list拼接</h4><p>如果使用list进行字符串拼接，对应的命令格式如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(APPEND &lt;<span class="keyword">list</span>&gt; [&lt;element&gt; ...])</span><br></pre></td></tr></table></figure>

<p><code>list</code>命令的功能比<code>set</code>要强大，字符串拼接只是它的其中一个功能，所以需要在它第一个参数的位置指定出我们要做的操作，<code>APPEND</code>表示进行数据追加，后边的参数和<code>set </code>就一样了。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="keyword">set</span>(TEMP <span class="string">&quot;hello,world&quot;</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_1 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src1/*.cpp)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_2 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src2/*.cpp)</span><br><span class="line"><span class="comment"># 追加(拼接)</span></span><br><span class="line"><span class="keyword">list</span>(APPEND SRC_1 <span class="variable">$&#123;SRC_1&#125;</span> <span class="variable">$&#123;SRC_2&#125;</span> <span class="variable">$&#123;TEMP&#125;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;message: $&#123;SRC_1&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>



<p>在CMake中，使用<code>set</code>命令可以创建一个<code>list</code>。一个在<code>list</code>内部是一个由<code>分号;</code>分割的一组字符串。例如，<code>set(var a b c d e)</code>命令将会创建一个<code>list:a;b;c;d;e</code>，<strong>底层通过分号管理，但是最终打印变量值的时候会去掉分号将所有字符串拼接起来</strong>，得到的是<code>abcde</code>。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(tmp1 a;b;c;d;e)</span><br><span class="line"><span class="keyword">set</span>(tmp2 a b c d e)</span><br><span class="line"><span class="keyword">message</span>(<span class="variable">$&#123;tmp1&#125;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="variable">$&#123;tmp2&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>输出的结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abcde</span><br><span class="line">abcde</span><br></pre></td></tr></table></figure>

<h3 id="示例-使用list拼接"><a href="#示例-使用list拼接" class="headerlink" title="示例-使用list拼接"></a>示例-使用list拼接</h3><p>使用list append命令追加xxx1、sss2等字符串</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250603133549405-1748931689532-42.png" alt="image-20250603133549405"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250603133523735-1748931689532-43.png" alt="image-20250603133523735"></p>
<h3 id="字符串移除-list"><a href="#字符串移除-list" class="headerlink" title="字符串移除(list)"></a>字符串移除(list)</h3><p>我们在通过<code>file</code>搜索某个目录就得到了该目录下所有的源文件，但是其中有些源文件并不是我们所需要的，比如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── add.cpp</span><br><span class="line">├── div.cpp</span><br><span class="line">├── main.cpp</span><br><span class="line">├── mult.cpp</span><br><span class="line">└── sub.cpp</span><br><span class="line"></span><br><span class="line">0 directories, 5 files</span><br></pre></td></tr></table></figure>

<p>在当前这么目录有五个源文件，其中<code>main.cpp</code>是一个测试文件。如果我们想要把计算器相关的源文件生成一个动态库给别人使用，那么只需要<code>add.cpp</code>、<code>div.cpp</code>、<code>mult.cpp</code>、<code>sub.cpp</code>这四个源文件就可以了。此时，就需要将<code>main.cpp</code>从搜索到的数据中剔除出去(但实际我们并不想删除<code>main.cpp</code>)，想要实现这个功能，也可以使用<code>list</code></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(REMOVE_ITEM &lt;<span class="keyword">list</span>&gt; &lt;value&gt; [&lt;value&gt; ...])</span><br></pre></td></tr></table></figure>



<p>通过上面的命令原型可以看到删除和追加数据(<code>APPEND</code>)类似，只不过是第一个参数变成了<code>REMOVE_ITEM</code>。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="keyword">set</span>(TEMP <span class="string">&quot;hello,world&quot;</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_1 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/*.cpp)</span><br><span class="line"><span class="comment"># 移除前日志</span></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;message: $&#123;SRC_1&#125;&quot;</span>)</span><br><span class="line"><span class="comment"># 移除 main.cpp</span></span><br><span class="line"><span class="keyword">list</span>(REMOVE_ITEM SRC_1 <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/main.cpp)</span><br><span class="line"><span class="comment"># 移除后日志</span></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;message: $&#123;SRC_1&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到，在<code>第8行</code>把将要移除的文件的名字指定给<code>list</code>就可以了。但是一定要注意<strong>通过 file 命令搜索源文件的时候得到的是文件的绝对路径（在list中每个文件对应的路径都是一个item，并且都是绝对路径），那么在移除的时候也要将该文件的绝对路径指定出来才可以，否是移除操作不会成功</strong>。</p>
<h3 id="示例-字符串移除"><a href="#示例-字符串移除" class="headerlink" title="示例-字符串移除"></a>示例-字符串移除</h3><p>我们需要的就是去掉mian.cpp的路径，让其不包含在内</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250603113941908-1748931689532-44.png" alt="image-20250603113941908"></p>
<p>使用list remove命令，指定main.cpp的绝对路径</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250603134233856-1748931689532-46.png" alt="image-20250603134233856"></p>
<p>可以看到两次输出的路径中，第二次的输出已经删除了main.cpp的路径</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250603134219038-1748931689532-45.png" alt="image-20250603134219038"></p>
<h3 id="list其他功能"><a href="#list其他功能" class="headerlink" title="list其他功能"></a>list其他功能</h3><p>关于<code>list</code>命令还有其它功能，但是并不常用，在此就不一一进行举例介绍了。</p>
<ol>
<li><p><strong>获取list的长度</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(LENGTH &lt;<span class="keyword">list</span>&gt; &lt;output variable&gt;)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>LENGTH</code>：子命令LENGTH用于读取列表长度(底层分号分隔)</li>
<li><code>&lt;list&gt;</code>：当前操作的列表</li>
<li><code>&lt;output variable&gt;</code>：新创建的变量(字符串)，用于存储列表的长度。</li>
</ul>
</li>
<li><p><strong>读取列表中指定索引的的元素，可以指定多个索引</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(GET &lt;<span class="keyword">list</span>&gt; &lt;element index&gt; [&lt;element index&gt; ...] &lt;output variable&gt;)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;list&gt;</code>：当前操作的列表</li>
<li><code>&lt;element index&gt;</code>：列表元素的索引<ul>
<li>从0开始编号，索引0的元素为列表中的第一个元素；</li>
<li>索引也可以是负数，-1表示列表的最后一个元素，-2表示列表倒数第二个元素，以此类推</li>
<li>当索引（不管是正还是负）超过列表的长度，运行会报错</li>
</ul>
</li>
<li><code>&lt;output variable&gt;</code>：新创建的变量，存储指定索引元素的返回结果，也是一个列表。</li>
</ul>
</li>
<li><p><strong>将列表中的元素用连接符（字符串）连接起来组成一个字符串</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span> (JOIN &lt;<span class="keyword">list</span>&gt; &lt;glue&gt; &lt;output variable&gt;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>&lt;list&gt;</code>：当前操作的列表</p>
</li>
<li><p><code>&lt;glue&gt;</code>：指定的连接符（字符串）</p>
</li>
<li><p><code>&lt;output variable&gt;</code>：新创建的变量，存储返回的字符串</p>
</li>
</ul>
</li>
</ol>
<p>​     </p>
<ol start="4">
<li><p><strong>查找列表是否存在指定的元素，若果未找到，返回-1</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(FIND &lt;<span class="keyword">list</span>&gt; &lt;value&gt; &lt;output variable&gt;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>&lt;list&gt;</code>：当前操作的列表</p>
</li>
<li><p><code>&lt;value&gt;</code>：需要再列表中搜索的元素</p>
</li>
<li><p><code>&lt;output variable&gt;</code>：新创建的变量</p>
<ul>
<li>如果列表<code>&lt;list&gt;</code>中存在<code>&lt;value&gt;</code>，那么返回<code>&lt;value&gt;</code>在列表中的索引</li>
<li>如果未找到则返回-1。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>​     </p>
<ol start="5">
<li><p><strong>将元素追加到列表中</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span> (APPEND &lt;<span class="keyword">list</span>&gt; [&lt;element&gt; ...])</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>在list中指定的位置插入若干元素</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(INSERT &lt;<span class="keyword">list</span>&gt; &lt;element_index&gt; &lt;element&gt; [&lt;element&gt; ...])</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>将元素插入到列表的0索引位置</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span> (PREPEND &lt;<span class="keyword">list</span>&gt; [&lt;element&gt; ...])</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>将列表中最后元素移除</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span> (POP_BACK &lt;<span class="keyword">list</span>&gt; [&lt;out-var&gt;...])</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>将列表中第一个元素移除</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span> (POP_FRONT &lt;<span class="keyword">list</span>&gt; [&lt;out-var&gt;...])</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>将指定的元素从列表中移除</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span> (REMOVE_ITEM &lt;<span class="keyword">list</span>&gt; &lt;value&gt; [&lt;value&gt; ...])</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>将指定索引的元素从列表中移除</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span> (REMOVE_AT &lt;<span class="keyword">list</span>&gt; &lt;index&gt; [&lt;index&gt; ...])</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>移除列表中的重复元素</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span> (REMOVE_DUPLICATES &lt;<span class="keyword">list</span>&gt;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>列表翻转</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(REVERSE &lt;<span class="keyword">list</span>&gt;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>列表排序</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span> (SORT &lt;<span class="keyword">list</span>&gt; [COMPARE &lt;compare&gt;] [CASE &lt;case&gt;] [ORDER &lt;order&gt;])</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><code>COMPARE</code>：指定排序方法。有如下几种值可选：<ul>
<li><code>STRING</code>: 按照字母顺序进行排序，为默认的排序方法</li>
<li><code>FILE_BASENAME</code>：如果是一系列路径名，会使用basename进行排序</li>
<li><code>NATURAL</code>：使用自然数顺序排序</li>
</ul>
</li>
<li><code>CASE</code>：指明是否大小写敏感。有如下几种值可选：<ul>
<li><code>SENSITIVE</code>:  按照大小写敏感的方式进行排序，为默认值</li>
<li><code>INSENSITIVE</code>：按照大小写不敏感方式进行排序</li>
</ul>
</li>
<li><code>ORDER</code>：指明排序的顺序。有如下几种值可选：<ul>
<li><code>ASCENDING</code>: 按照升序排列，为默认值</li>
<li><code>DESCENDING</code>：按照降序排列</li>
</ul>
</li>
</ul>
<h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><p>在进行程序测试的时候，我们可以在代码中添加一些宏定义，通过这些宏来控制这些代码是否生效，在大型项目中，这样可以方便对与所有日志输出的启用和关闭如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUMBER  3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是一个程序猿, 我不会爬树...\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;NUMBER; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello, GCC!!!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在程序的第七行对<code>DEBUG</code>宏进行了判断，如果该宏被定义了，那么第八行就会进行日志输出，如果没有定义这个宏，第八行就相当于被注释掉了，因此最终无法看到日志输入出（<strong>上述代码中并没有定义这个宏</strong>）。</p>
<p>为了让测试更灵活，我们可以不在代码中定义这个宏，而是在测试的时候去把它定义出来，其中一种方式就是在<code>gcc/g++</code>命令中去指定，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc test.c -DDEBUG -o app</span></span><br></pre></td></tr></table></figure>

<p>在<code>gcc/g++</code>命令中通过参数<code> -D</code>指定出要定义的宏的名字，这样就相当于在代码中定义了一个宏，其名字为<code>DEBUG</code>。</p>
<p>在<code>CMake</code>中我们也可以做类似的事情，宏定义对应的命令叫做<code>add_definitions</code>:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_definitions</span>(-D宏名称 -D宏名称 -D宏名称 ...)</span><br></pre></td></tr></table></figure>

<p>针对于上面的源文件编写一个<code>CMakeLists.txt</code>，内容如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">TEST</span>)</span><br><span class="line"><span class="comment"># 自定义 DEBUG 宏</span></span><br><span class="line"><span class="keyword">add_definitions</span>(-DDEBUG)</span><br><span class="line"><span class="keyword">add_executable</span>(app ./<span class="keyword">test</span>.c)</span><br></pre></td></tr></table></figure>

<p>通过这种方式，上述代码中的第八行日志就能够被输出出来了。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250603135528745-1748931689532-47.png" alt="image-20250603135528745"></p>
<p>两个分别是添加宏定义和未添加宏定义的输出，确实在DEBUG的控制下日志才会输出</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250603135506514-1748931689532-48.png" alt="image-20250603135506514"></p>
<h1 id="嵌套CMake"><a href="#嵌套CMake" class="headerlink" title="嵌套CMake"></a>嵌套CMake</h1><p>如果项目很大，或者项目中有很多的源码目录，在通过CMake管理项目的时候如果只使用一个<code>CMakeLists.txt</code>，那么这个文件相对会比较复杂，有一种化繁为简的方式就是给每个源码目录都添加一个<code>CMakeLists.txt</code>文件（头文件目录不需要），这样每个文件都不会太复杂，而且更灵活，更容易维护。</p>
<p>先来看一下下面的这个的目录结构：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── calc</span><br><span class="line">│   ├── add.cpp</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── div.cpp</span><br><span class="line">│   ├── mult.cpp</span><br><span class="line">│   └── sub.cpp</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   ├── calc.h</span><br><span class="line">│   └── sort.h</span><br><span class="line">├── sort</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── insert.cpp</span><br><span class="line">│   └── select.cpp</span><br><span class="line">├── test1</span><br><span class="line">│   ├── calc.cpp</span><br><span class="line">│   └── CMakeLists.txt</span><br><span class="line">└── test2</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── sort.cpp</span><br><span class="line"></span><br><span class="line">6 directories, 15 files</span><br></pre></td></tr></table></figure>



<ul>
<li><p><code>include 目录</code>：头文件目录</p>
</li>
<li><p><code>calc 目录</code>：目录中的四个源文件对应的加、减、乘、除算法</p>
<ul>
<li>对应的头文件是<code>include</code>中的<code>calc.h</code></li>
</ul>
</li>
<li><p><code>sort 目录</code> ：目录中的两个源文件对应的是插入排序和选择排序算法</p>
<ul>
<li>对应的头文件是<code>include</code>中的<code>sort.h</code></li>
</ul>
</li>
<li><p><code>test1 目录</code>：测试目录，对加、减、乘、除算法进行测试</p>
</li>
<li><p><code>test2 目录</code>：测试目录，对排序算法进行测试</p>
</li>
</ul>
<p>可以看到各个源文件目录所需要的CMakeLists.txt文件现在已经添加完毕了。接下来庖丁解牛，我们依次分析一下各个文件中需要添加的内容。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h3><p>众所周知，Linux的目录是树状结构，<code>所以嵌套的 CMake 也是一个树状结构，最顶层的 CMakeLists.txt 是根节点，其次都是子节点</code>。因此，我们需要了解一些关于 <code>CMakeLists.txt</code> 文件变量作用域的一些信息：</p>
<ul>
<li>根节点<code>CMakeLists.txt</code>中的<code>变量全局有效</code></li>
<li>父节点<code>CMakeLists.txt</code>中的变量可以在子节点中使用</li>
<li>子节点<code>CMakeLists.txt</code>中的变量只能在当前节点中使用</li>
</ul>
<blockquote>
<p><strong>根节点的CMakeLists中定义的变量可以在任意子节点中直接使用!</strong></p>
</blockquote>
<h3 id="添加子目录"><a href="#添加子目录" class="headerlink" title="添加子目录"></a>添加子目录</h3><p>接下来我们还需要知道在 CMake 中父子节点之间的关系是如何建立的，这里需要用到一个 CMake 命令：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</span><br></pre></td></tr></table></figure>

<ul>
<li><code>source_dir</code>：指定了<code>CMakeLists.txt</code>源文件和代码文件的位置，其实就是指定子目录</li>
<li><code>binary_dir</code>：指定了输出文件的路径，一般不需要指定，忽略即可。</li>
<li><code>EXCLUDE_FROM_ALL</code>：在子路径下的目标默认不会被包含到父路径的ALL目标里，并且也会被排除在IDE工程文件之外。用户必须显式构建在子路径下的目标。</li>
</ul>
<p>通过这种方式<code>CMakeLists.txt</code>文件之间的父子关系就被构建出来了。</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>在上面的目录中我们要做如下事情：</p>
<ol>
<li>通过<code> test1 目录中</code>的测试文件进行计算器相关的测试</li>
<li>通过<code> test2 目录中</code>的测试文件进行排序相关的测试</li>
</ol>
<p>现在相当于是要进行模块化测试，对于<code>calc</code>和<code>sort</code>目录中的源文件来说，可以将它们先编译成库文件（可以是静态库也可以是动态库）然后在提供给测试文件使用即可。库文件的本质其实还是代码，只不过是从文本格式变成了二进制格式。</p>
<h3 id="根目录"><a href="#根目录" class="headerlink" title="根目录"></a>根目录</h3><p>根目录中的 <code>CMakeLists.txt</code>文件内容如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"><span class="comment"># 定义变量</span></span><br><span class="line"><span class="comment"># 静态库生成的路径</span></span><br><span class="line"><span class="keyword">set</span>(LIB_PATH <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># 测试程序生成的路径</span></span><br><span class="line"><span class="keyword">set</span>(EXEC_PATH <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"><span class="comment"># 头文件目录</span></span><br><span class="line"><span class="keyword">set</span>(HEAD_PATH <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># 静态库的名字</span></span><br><span class="line"><span class="keyword">set</span>(CALC_LIB calc)</span><br><span class="line"><span class="keyword">set</span>(SORT_LIB sort)</span><br><span class="line"><span class="comment"># 可执行程序的名字</span></span><br><span class="line"><span class="keyword">set</span>(APP_NAME_1 test1)</span><br><span class="line"><span class="keyword">set</span>(APP_NAME_2 test2)</span><br><span class="line"><span class="comment"># 添加子目录</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(calc)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(sort)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(test1)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(test2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在根节点对应的文件中主要做了两件事情：<code>定义全局变量</code>和<code>添加子目录</code>。</p>
<ul>
<li>定义的全局变量主要是给子节点使用，目的是为了提高子节点中的<code>CMakeLists.txt</code>文件的可读性和可维护性，避免冗余并降低出差的概率。</li>
<li>一共添加了四个子目录，每个子目录中都有一个<code>CMakeLists.txt</code>文件，这样它们的父子关系就被确定下来了。</li>
</ul>
<h3 id="calc目录"><a href="#calc目录" class="headerlink" title="calc目录"></a>calc目录</h3><p>calc 目录中的 <code>CMakeLists.txt</code>文件内容如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALCLIB)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(./ SRC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;HEAD_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;LIB_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;CALC_LIB&#125;</span> STATIC <span class="variable">$&#123;SRC&#125;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>第3行<code>aux_source_directory</code>：搜索当前目录（calc目录）下的所有源文件</li>
<li>第4行<code>include_directories</code>：包含头文件路径，<code>HEAD_PATH</code>是在根节点文件中定义的</li>
<li>第5行<code>set</code>：设置库的生成的路径，<code>LIB_PATH</code>是在根节点文件中定义的</li>
<li>第6行<code>add_library</code>：生成静态库，静态库名字<code>CALC_LIB</code>是在根节点文件中定义的</li>
</ul>
<h3 id="sort目录"><a href="#sort目录" class="headerlink" title="sort目录"></a>sort目录</h3><p>sort 目录中的 <code>CMakeLists.txt</code>文件内容如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(SORTLIB)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(./ SRC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;HEAD_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;LIB_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;SORT_LIB&#125;</span> SHARED <span class="variable">$&#123;SRC&#125;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>第6行<code>add_library</code>：<strong>生成动态库</strong>，动态库名字<code>SORT_LIB</code>是在根节点文件中定义的</li>
</ul>
<p>这个文件中的内容和<code>calc</code>节点文件中的内容类似，只不过这次生成的是动态库。</p>
<blockquote>
<p><strong>在生成库文件的时候，这个库可以是静态库也可以是动态库，一般需要根据实际情况来确定。如果生成的库比较大，建议将其制作成动态库。</strong></p>
</blockquote>
<h3 id="test1目录"><a href="#test1目录" class="headerlink" title="test1目录"></a>test1目录</h3><p>test1 目录中的<code> CMakeLists.txt</code>文件内容如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALCTEST)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(./ SRC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;HEAD_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;LIB_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">link_libraries</span>(<span class="variable">$&#123;CALC_LIB&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;EXEC_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;APP_NAME_1&#125;</span> <span class="variable">$&#123;SRC&#125;</span>)</span><br></pre></td></tr></table></figure>



<ul>
<li><p>第4行<code>include_directories</code>：指定头文件路径，<code>HEAD_PATH</code>变量是在根节点文件中定义的</p>
</li>
<li><p>第6行<code>link_libraries</code>：指定可执行程序要链接的<code>静态库</code>，<code>CALC_LIB</code>变量是在根节点文件中定义的</p>
</li>
<li><p>第7行<code>set</code>：指定可执行程序生成的路径，<code>EXEC_PATH</code>变量是在根节点文件中定义的</p>
</li>
<li><p>第8行<code>add_executable</code>：生成可执行程序，<code>APP_NAME_1</code>变量是在根节点文件中定义的</p>
</li>
</ul>
<p><strong>此处的可执行程序链接的是静态库，最终静态库会被打包到可执行程序中，可执行程序启动之后，静态库也就随之被加载到内存中了。</strong></p>
<h3 id="test2目录"><a href="#test2目录" class="headerlink" title="test2目录"></a>test2目录</h3><p>test2目录中的CMakeLists.txt文件内容如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(SORTTEST)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(./ SRC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;HEAD_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;EXEC_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;LIB_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;APP_NAME_2&#125;</span> <span class="variable">$&#123;SRC&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;APP_NAME_2&#125;</span> <span class="variable">$&#123;SORT_LIB&#125;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>第四行<code>include_directories</code>：包含头文件路径，<code>HEAD_PATH</code>变量是在根节点文件中定义的</li>
<li>第五行<code>set</code>：指定可执行程序生成的路径，<code>EXEC_PATH</code>变量是在根节点文件中定义的</li>
<li>第六行<code>link_directories</code>：指定可执行程序要链接的动态库的路径，<code>LIB_PATH</code>变量是在根节点文件中定义的</li>
<li>第七行<code>add_executable</code>：生成可执行程序，<code>APP_NAME_2</code>变量是在根节点文件中定义的</li>
<li>第八行<code>target_link_libraries</code>：指定可执行程序要链接的动态库的名字</li>
</ul>
<p><strong>在生成可执行程序的时候，动态库不会被打包到可执行程序内部。当可执行程序启动之后动态库也不会被加载到内存，只有可执行程序调用了动态库中的函数的时候，动态库才会被加载到内存中，且多个进程可以共用内存中的同一个动态库，所以动态库又叫共享库</strong>。</p>
<h3 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h3><p>一切准备就绪之后，开始构建项目，进入到根节点目录的<code>build </code>目录中，执行<code>cmake </code>命令，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake ..</span></span><br><span class="line">-- The C compiler identification is GNU 5.4.0</span><br><span class="line">-- The CXX compiler identification is GNU 5.4.0</span><br><span class="line">-- Check for working C compiler: /usr/bin/cc</span><br><span class="line">-- Check for working C compiler: /usr/bin/cc -- works</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - done</span><br><span class="line">-- Detecting C compile features</span><br><span class="line">-- Detecting C compile features - done</span><br><span class="line">-- Check for working CXX compiler: /usr/bin/c++</span><br><span class="line">-- Check for working CXX compiler: /usr/bin/c++ -- works</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - done</span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - done</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/keqiudi/test</span><br></pre></td></tr></table></figure>

<p>可以看到在<code>build</code>目录中生成了一些文件(Makefile等)和目录，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree build -L 1</span>     </span><br><span class="line">build</span><br><span class="line">├── calc                  # 目录</span><br><span class="line">├── CMakeCache.txt        # 文件</span><br><span class="line">├── CMakeFiles            # 目录</span><br><span class="line">├── cmake_install.cmake   # 文件</span><br><span class="line">├── Makefile              # 文件</span><br><span class="line">├── sort                  # 目录</span><br><span class="line">├── test1                 # 目录</span><br><span class="line">└── test2                 # 目录</span><br></pre></td></tr></table></figure>

<p>然后在<code>build </code>目录下再执行<code>make </code>命令:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250603202655725-1749004783841-35.png" alt="image-20250603202655725"></p>
<p>通过上图可以得到如下信息：</p>
<ol>
<li>在项目根目录的<code>lib</code>目录中生成了静态库<code>libcalc.a</code></li>
<li>在项目根目录的<code>lib</code>目录中生成了动态库<code>libsort.so</code></li>
<li>在项目根目录的<code>bin</code>目录中生成了可执行程序<code>test1</code></li>
<li>在项目根目录的<code>bin</code>目录中生成了可执行程序<code>test2</code></li>
</ol>
<p>最后再来看一下上面提到的这些文件是否真的被生成到对应的目录中了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree bin/ lib/</span></span><br><span class="line">bin/</span><br><span class="line">├── test1</span><br><span class="line">└── test2</span><br><span class="line">lib/</span><br><span class="line">├── libcalc.a</span><br><span class="line">└── libsort.so</span><br></pre></td></tr></table></figure>

<p>确实生成了，项目构建完毕。</p>
<blockquote>
<p><strong>注意</strong></p>
<p>在项目中，如果将程序中的某个模块制作成了动态库或者静态库<code>并且在CMakeLists.txt 中指定了库的输出目录</code>，而后其它模块又需要加载这个生成的库文件，此时直接使用就可以了，<code>如果没有指定库的输出路径或者需要直接加载外部提供的库文件，此时就需要使用 link_directories 将库文件路径指定出来</code>。</p>
</blockquote>
<h2 id="实践练习"><a href="#实践练习" class="headerlink" title="实践练习"></a>实践练习</h2><p>准备好对应的文件，calc目录、sort目录、test1目录、test2目录、include目录</p>
<p><strong>思路</strong>：<code>calc</code>目录和<code>sort</code>目录生成对应的库文件，<code>test1</code>和<code>test2</code>目录调用库生成可执行程序<code>app_calc</code>和<code>app_sort</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250603204037310-1749004783842-38.png" alt="image-20250603204037310"></p>
<p><strong>根CMakeLists.txt</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250603212614351-1749004783841-37.png" alt="image-20250603212614351"></p>
<p><strong><code>calc</code>下的子CMakeLists.txt</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250603212639535-1749004783842-39.png" alt="image-20250603212639535"></p>
<p><strong><code>sort</code>下的子CMakeLists.txt</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250603213239189-1749004783841-36.png" alt="image-20250603213239189"></p>
<p><strong><code>test1</code>下的子CMakeLists.txt</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250603213314125-1749004783842-40.png" alt="image-20250603213314125"></p>
<p><strong><code>test2</code>下的子CMakeLists.txt</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250603213327464-1749004783842-44.png" alt="image-20250603213327464"></p>
<p>回到根目录的<code>build</code>目录下，执行<code>cmake</code>和<code>make</code>命令</p>
<p>可以看到，生成了对应的<strong>库文件</strong>和<strong>可执行文件</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250603213457229-1749004783842-43.png" alt="image-20250603213457229"></p>
<p>执行<code>app_calc</code>和<code>app_sort</code>文件，执行成功，说明没有问题。同时对应<code>lib</code>和<code>bin</code>中的文件也是正确的</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250603213636333-1749004783842-41.png" alt="image-20250603213636333"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过父CMakeLists.txt和多个子CMakeLists.txt的使用，我们更方便对项目的管理，每个<code>子CMakeLists.txt</code>做的事情都<code>单一化了</code>。</p>
<p><strong>推荐在大型项目中使用多个CMakeLists.txt的形式管理</strong></p>
<p>还有我们上面在<code>根CMakeLists.txt</code>中定义变量然后再去<code>子CMakeLists.txt</code>中使用的方法，看起来会比较工整、简洁。</p>
<p>但是在单独看子CMakeLists.txt时，对于变量值我们还需要到<code>根CMakeLists.txt</code>中去寻找，这样的话可读性较低，不利于我们直观的理解，上方因为需要演示<code>根CMakeLists.txt</code>变量可以在<code>子CMakeLists.txt</code>中使用，所以这样写。</p>
<p><strong>实际上：我们直接将对应的路径写出来即可，不需要这样传递变量使用</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250603212056942-1749004783842-42.png" alt="image-20250603212056942"></p>
<h2 id="在静态库中链接静态库"><a href="#在静态库中链接静态库" class="headerlink" title="在静态库中链接静态库"></a>在静态库中链接静态库</h2><p>现在去掉<code>test1</code>文件夹,将原有的<code>calc</code>的操作添加到<code>sort</code>库中的<code>insert.cpp</code>之中去</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250604094338096-1749004783842-45.png" alt="image-20250604094338096"></p>
<p><code>根CMakeLists</code>：去掉子节点test1</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250604094550651-1749004783842-46.png" alt="image-20250604094550651"></p>
<p><code>insert.cpp</code>中添加加法操作</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250604094648540-1749004783842-47.png" alt="image-20250604094648540"></p>
<p>修改<code>sort</code>下的<code>CMakeLists.txt</code>：链接我们自定义的calc库</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250604094730776-1749004783842-49.png" alt="image-20250604094730776"></p>
<p>执行<code>cmake</code>和<code>make</code>命令，生成对应的<code>app_sort</code>，执行发现确实出现了加法操作，故<strong>在静态库sort中链接静态库calc成功</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250604094853289-1749004783842-48.png" alt="image-20250604094853289"></p>
<p>对应<code>test2</code>下的<code>CMakeLists.txt</code>：只链接了静态库sort，因为sort本来就链接了calc，这里相当于也链接了calc，就不需要再链接calc了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250604095053774-1749004783842-50.png" alt="image-20250604095053774"></p>
<blockquote>
<p><strong>相当于生成的sort静态库中包含了calc静态库</strong></p>
</blockquote>
<h2 id="在静态库中链接动态库"><a href="#在静态库中链接动态库" class="headerlink" title="在静态库中链接动态库"></a>在静态库中链接动态库</h2><ol>
<li>将<code>calc</code>中的<code>CMakeLists.txt</code>中的生成静态库(STATIC)改成动态库(SHARED)</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250604100150207-1749004783842-52.png" alt="image-20250604100150207"></p>
<ol start="2">
<li>将<code>sort</code>中的<code>CMakeLists.txt</code>中改为链接动态库calc到我们的静态库sort库中</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250604102207995-1749004783842-51.png" alt="image-20250604102207995"></p>
<ol start="3">
<li>执行<code>cmake</code>和<code>make</code>命令</li>
</ol>
<p>这里我们可以看到生成了<strong>动态库libcalc.so</strong>、<strong>静态库libsort.a</strong>、<strong>可执行文件app_sort</strong>，并且可以成功运行，说明<code>静态库链接动态库成功</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250604102440768-1749004783842-53.png" alt="image-20250604102440768"></p>
<blockquote>
<p><strong>静态库被打包到了app_sort中，动态库没有被打包</strong></p>
</blockquote>
<h1 id="CMake流程控制"><a href="#CMake流程控制" class="headerlink" title="CMake流程控制"></a>CMake流程控制</h1><p>在 CMake 的 CMakeLists.txt 中也可以进行流程控制，也就是说可以像写 shell 脚本那样进行<code>条件判断</code>和<code>循环</code>。</p>
<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p>关于条件判断其语法格式如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(&lt;condition&gt;)</span><br><span class="line">  &lt;commands&gt;</span><br><span class="line"><span class="keyword">elseif</span>(&lt;condition&gt;) <span class="comment"># 可选快, 可以重复</span></span><br><span class="line">  &lt;commands&gt;</span><br><span class="line"><span class="keyword">else</span>()              <span class="comment"># 可选快</span></span><br><span class="line">  &lt;commands&gt;</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>



<p>在进行条件判断的时候，如果有多个条件，那么可以写多个<code>elseif</code>，最后一个条件可以使用<code>else</code>，但是<strong>开始和结束是必须要成对出现的</strong>，分别为：<code>if</code>和<code>endif</code>。</p>
<h3 id="基本表达式"><a href="#基本表达式" class="headerlink" title="基本表达式"></a>基本表达式</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(&lt;expression&gt;)</span><br></pre></td></tr></table></figure>

<p>如果是基本表达式，<code>expression </code>有以下三种情况：<code>常量</code>、<code>变量</code>、<code>字符串</code>。</p>
<ul>
<li>如果是<code>1</code>,<code> ON</code>,<code> YES</code>, <code>TRUE</code>, <code>Y</code>, <code>非零值</code>，<code>非空字符串</code>时，条件判断返回<code>True</code></li>
<li>如果是<code> 0</code>, <code>OFF</code>,<code> NO</code>,<code> FALSE</code>,<code> N</code>,<code> IGNORE</code>, <code>NOTFOUND</code>，<code>空字符串</code>时，条件判断返回<code>False</code></li>
</ul>
<h3 id="逻辑判断"><a href="#逻辑判断" class="headerlink" title="逻辑判断"></a>逻辑判断</h3><ul>
<li><strong>NOT</strong></li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> &lt;condition&gt;)</span><br></pre></td></tr></table></figure>


<p>其实这就是一个取反操作，如果条件<code>condition</code>为<code>True</code>将返回<code>False</code>，如果条件<code>condition</code>为<code>False</code>将返回<code>True</code>。</p>
<ul>
<li><strong>AND</strong></li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(&lt;cond1&gt; <span class="keyword">AND</span> &lt;cond2&gt;)</span><br></pre></td></tr></table></figure>


<p>如果<code>cond1</code>和<code>cond2</code>同时为<code>True</code>，返回<code>True</code>否则返回<code>False</code>。</p>
<ul>
<li><strong>OR</strong></li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(&lt;cond1&gt; <span class="keyword">OR</span> &lt;cond2&gt;)</span><br></pre></td></tr></table></figure>

<p>如果<code>cond1</code>和<code>cond2</code>两个条件中至少有一个为<code>True</code>，返回<code>True</code>，如果两个条件都为<code>False</code>则返回<code>False</code>。</p>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><ul>
<li><strong>基于数值的比较</strong></li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(&lt;variable|<span class="keyword">string</span>&gt; <span class="keyword">LESS</span> &lt;variable|<span class="keyword">string</span>&gt;)</span><br><span class="line"><span class="keyword">if</span>(&lt;variable|<span class="keyword">string</span>&gt; <span class="keyword">GREATER</span> &lt;variable|<span class="keyword">string</span>&gt;)</span><br><span class="line"><span class="keyword">if</span>(&lt;variable|<span class="keyword">string</span>&gt; <span class="keyword">EQUAL</span> &lt;variable|<span class="keyword">string</span>&gt;)</span><br><span class="line"><span class="keyword">if</span>(&lt;variable|<span class="keyword">string</span>&gt; <span class="keyword">LESS_EQUAL</span> &lt;variable|<span class="keyword">string</span>&gt;)</span><br><span class="line"><span class="keyword">if</span>(&lt;variable|<span class="keyword">string</span>&gt; <span class="keyword">GREATER_EQUAL</span> &lt;variable|<span class="keyword">string</span>&gt;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>LESS</code>：如果左侧数值<code>小于</code>右侧，返回<code>True</code></p>
</li>
<li><p><code>GREATER</code>：如果左侧数值<code>大于</code>右侧，返回<code>True</code></p>
</li>
<li><p><code>EQUAL</code>：如果左侧数值<code>等于</code>右侧，返回<code>True</code></p>
</li>
<li><p><code>LESS_EQUAL</code>：如果左侧数值<code>小于等于</code>右侧，返回<code>True</code></p>
</li>
<li><p><code>GREATER_EQUAL</code>：如果左侧数值<code>大于等于</code>右侧，返回<code>True</code></p>
</li>
<li><p><strong>基于字符串的比较</strong></p>
</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(&lt;variable|<span class="keyword">string</span>&gt; <span class="keyword">STRLESS</span> &lt;variable|<span class="keyword">string</span>&gt;)</span><br><span class="line"><span class="keyword">if</span>(&lt;variable|<span class="keyword">string</span>&gt; <span class="keyword">STRGREATER</span> &lt;variable|<span class="keyword">string</span>&gt;)</span><br><span class="line"><span class="keyword">if</span>(&lt;variable|<span class="keyword">string</span>&gt; <span class="keyword">STREQUAL</span> &lt;variable|<span class="keyword">string</span>&gt;)</span><br><span class="line"><span class="keyword">if</span>(&lt;variable|<span class="keyword">string</span>&gt; <span class="keyword">STRLESS_EQUAL</span> &lt;variable|<span class="keyword">string</span>&gt;)</span><br><span class="line"><span class="keyword">if</span>(&lt;variable|<span class="keyword">string</span>&gt; <span class="keyword">STRGREATER_EQUAL</span> &lt;variable|<span class="keyword">string</span>&gt;)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>STRLESS</code>：如果左侧字符串<code>小于</code>右侧，返回<code>True</code></li>
<li><code>STRGREATER</code>：如果左侧字符串<code>大于</code>右侧，返回<code>True</code></li>
<li><code>STREQUAL</code>：如果左侧字符串<code>等于</code>右侧，返回<code>True</code></li>
<li><code>STRLESS_EQUAL</code>：如果左侧字符串<code>小于等于</code>右侧，返回<code>True</code></li>
<li><code>STRGREATER_EQUAL</code>：如果左侧字符串<code>大于等于</code>右侧，返回<code>True</code></li>
</ul>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ol>
<li><p><strong>判断文件或者目录是否存在</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">EXISTS</span> path-to-<span class="keyword">file</span>-<span class="keyword">or</span>-directory)</span><br></pre></td></tr></table></figure>

<p>如果文件或者目录存在返回<code>True</code>，否则返回<code>False</code>。</p>
</li>
<li><p><strong>判断是不是目录</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">IS_DIRECTORY</span> path)</span><br></pre></td></tr></table></figure>

<p><strong>此处目录的 <code>path </code>必须是绝对路径</strong><br>如果目录存在返回<code>True</code>，目录不存在返回<code>False</code>。</p>
</li>
<li><p><strong>判断是不是软链接</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">IS_SYMLINK</span> <span class="keyword">file</span>-name)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>此处的 file-name 对应的路径必须是绝对路径</strong></li>
<li>如果软链接存在返回<code>True</code>，软链接不存在返回<code>False</code>。</li>
<li>软链接相当于 Windows 里的快捷方式。</li>
</ul>
</li>
<li><p><strong>判断是不是绝对路径</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">IS_ABSOLUTE</span> path)</span><br></pre></td></tr></table></figure>

<ul>
<li>关于绝对路径：<ul>
<li>如果是<code>Linux</code>，该路径需要从根目录开始描述</li>
<li>如果是<code>Windows</code>，该路径需要从盘符开始描述</li>
</ul>
</li>
<li>如果是绝对路径返回<code>True</code>，如果不是绝对路径返回<code>False</code>。</li>
</ul>
</li>
</ol>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p><strong>判断某个元素是否在列表中</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(&lt;variable|<span class="keyword">string</span>&gt; <span class="keyword">IN_LIST</span> &lt;variable&gt;)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>CMake 版本要求：大于等于3.3</strong></li>
<li>如果这个元素在列表中返回<code>True</code>，否则返回<code>False</code>。</li>
</ul>
</li>
<li><p><strong>比较两个路径是否相等</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(&lt;variable|<span class="keyword">string</span>&gt; PATH_EQUAL &lt;variable|<span class="keyword">string</span>&gt;)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>CMake 版本要求：大于等于3.24</strong></li>
<li>如果这个元素在列表中返回<code>True</code>，否则返回<code>False</code>。</li>
</ul>
<p>关于路径的比较其实就是另个字符串的比较，如果路径格式书写没有问题也可以通过下面这种方式进行比较：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(&lt;variable|<span class="keyword">string</span>&gt; <span class="keyword">STREQUAL</span> &lt;variable|<span class="keyword">string</span>&gt;)</span><br></pre></td></tr></table></figure>



<p>我们在书写某个路径的时候，可能由于误操作会多写几个分隔符，比如把<code>/a/b/c</code>写成<code>/a//b///c</code>，此时通过<code>STREQUAL</code>对这两个字符串进行比较肯定是不相等的，但是通过<code>PATH_EQUAL</code>去比较两个路径，得到的结果确实相等的，可以看下面的例子：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.26</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;/home//robin///Linux&quot;</span> PATH_EQUAL <span class="string">&quot;/home/robin/Linux&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;路径相等&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;路径不相等&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;/home//robin///Linux&quot;</span> <span class="keyword">STREQUAL</span> <span class="string">&quot;/home/robin/Linux&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;路径相等&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;路径不相等&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>输出的日志信息如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">路径相等</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">路径不相等</span><br></pre></td></tr></table></figure>

<p>通过得到的结果我们可以得到一个结论：<strong>在进行路径比较的时候，如果使用 PATH_EQUAL 可以自动剔除路径中多余的分割线然后再进行路径的对比，使用 STREQUAL 则只能进行字符串比较。</strong></p>
<p>更多if条件判断，请参考官方文档：</p>
<p><a target="_blank" rel="noopener" href="https://cmake.org/cmake/help/latest/command/if.html">if — CMake 4.0.2 Documentation</a></p>
</li>
</ul>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>在 CMake 中循环有两种方式，分别是：<code>foreach</code>和<code>while</code>。</p>
<h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p>使用 foreach 进行循环，语法格式如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(&lt;loop_var&gt; &lt;items&gt;)</span><br><span class="line">    &lt;commands&gt;</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure>

<p>通过<code>foreach</code>我们就可以对<code>items</code>中的数据进行遍历，然后通过<code>loop_var</code>将遍历到的当前的值取出，在取值的时候有以下几种用法：</p>
<h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(&lt;loop_var&gt; RANGE &lt;stop&gt;)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>RANGE</code>：关键字，表示要遍历范围</li>
<li><code>stop</code>：这是一个<code>正整数，表示范围的结束值</code>，在遍历的时候<code>从 0 开始，最大值为 stop</code>。</li>
<li><code>loop_var</code>：存储每次循环取出的值</li>
</ul>
<p>举例说明：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.2</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"><span class="comment"># 循环</span></span><br><span class="line"><span class="keyword">foreach</span>(item RANGE <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;当前遍历的值为: $&#123;item&#125;&quot;</span> )</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure>

<p>输出的日志信息是这样的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake ..</span></span><br><span class="line">-- 当前遍历的值为: 0</span><br><span class="line">-- 当前遍历的值为: 1</span><br><span class="line">-- 当前遍历的值为: 2</span><br><span class="line">-- 当前遍历的值为: 3</span><br><span class="line">-- 当前遍历的值为: 4</span><br><span class="line">-- 当前遍历的值为: 5</span><br><span class="line">-- 当前遍历的值为: 6</span><br><span class="line">-- 当前遍历的值为: 7</span><br><span class="line">-- 当前遍历的值为: 8</span><br><span class="line">-- 当前遍历的值为: 9</span><br><span class="line">-- 当前遍历的值为: 10</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/keqiudi/abc/a/build。</span><br></pre></td></tr></table></figure>

<p><strong>再次强调：在对一个整数区间进行遍历的时候，得到的范围是这样的 【0，stop】，右侧是闭区间包含 stop 这个值。</strong></p>
<h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(&lt;loop_var&gt; RANGE &lt;start&gt; &lt;stop&gt; [&lt;step&gt;])</span><br></pre></td></tr></table></figure>

<p>这是上面<code>方法1</code>的加强版，我们在遍历一个整数区间的时候，除了可以指定起始范围，还可以指定步长。</p>
<ul>
<li><code>RANGE</code>：关键字，表示要遍历范围</li>
<li><code>start</code>：这是一个正整数，表示范围的起始值，也就是说最小值为 start</li>
<li><code>stop</code>：这是一个正整数，表示范围的结束值，也就是说最大值为 stop</li>
<li><code>step</code>：控制每次遍历的时候以怎样的步长增长，默认为1，可以不设置</li>
<li><code>loop_var</code>：存储每次循环取出的值</li>
</ul>
<p>举例说明：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.2</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(item RANGE <span class="number">10</span> <span class="number">30</span> <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;当前遍历的值为: $&#123;item&#125;&quot;</span> )</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure>

<p>输出的结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake ..</span></span><br><span class="line">-- 当前遍历的值为: 10</span><br><span class="line">-- 当前遍历的值为: 12</span><br><span class="line">-- 当前遍历的值为: 14</span><br><span class="line">-- 当前遍历的值为: 16</span><br><span class="line">-- 当前遍历的值为: 18</span><br><span class="line">-- 当前遍历的值为: 20</span><br><span class="line">-- 当前遍历的值为: 22</span><br><span class="line">-- 当前遍历的值为: 24</span><br><span class="line">-- 当前遍历的值为: 26</span><br><span class="line">-- 当前遍历的值为: 28</span><br><span class="line">-- 当前遍历的值为: 30</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/keqiudi/abc/a/build</span><br></pre></td></tr></table></figure>

<p><strong>再次强调：在使用上面的方式对一个整数区间进行遍历的时候，得到的范围是这样的 【start，stop】，左右两侧都是闭区间，包含 start 和 stop 这两个值，步长 step 默认为1，可以不设置。</strong></p>
<h4 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(&lt;loop_var&gt; IN [LISTS [&lt;lists&gt;]] [ITEMS [&lt;items&gt;]])</span><br></pre></td></tr></table></figure>

<p>这是<code>foreach</code>的另一个变体，通过这种方式我们可以对更加复杂的数据进行遍历，前两种方式只适用于对某个正整数范围内的遍历。</p>
<p><code>IN</code>：关键字，表示在 xxx 里边</p>
<p><code>LISTS</code>：关键字，对应的是列表<code>list</code>，通过<code>set</code>、<code>list</code>可以获得</p>
<p><code>ITEMS</code>：关键字，对应的也是列表</p>
<p><code>loop_var</code>：存储每次循环取出的值</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.2</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"><span class="comment"># 创建 list</span></span><br><span class="line"><span class="keyword">set</span>(WORD a b c d)</span><br><span class="line"><span class="keyword">set</span>(NAME ace sabo luffy)</span><br><span class="line"><span class="comment"># 遍历 list</span></span><br><span class="line"><span class="keyword">foreach</span>(item IN LISTS WORD NAME)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;当前遍历的值为: $&#123;item&#125;&quot;</span> )</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，创建了两个 <code>list</code> 列表，在遍历的时候对它们两个都进行了遍历（<code>可以根据实际需求选择同时遍历多个或者只遍历一个</code>）。输出的日志信息如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> build/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake ..</span></span><br><span class="line">-- 当前遍历的值为: a</span><br><span class="line">-- 当前遍历的值为: b</span><br><span class="line">-- 当前遍历的值为: c</span><br><span class="line">-- 当前遍历的值为: d</span><br><span class="line">-- 当前遍历的值为: ace</span><br><span class="line">-- 当前遍历的值为: sabo</span><br><span class="line">-- 当前遍历的值为: luffy</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/keqiudi/abc/a/build</span><br></pre></td></tr></table></figure>

<p>一共输出了7个字符串，说明遍历是没有问题的。接下来看另外一种方式：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.2</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(WORD a b c <span class="string">&quot;d e f&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(NAME ace sabo luffy)</span><br><span class="line"><span class="keyword">foreach</span>(item IN ITEMS <span class="variable">$&#123;WORD&#125;</span> <span class="variable">$&#123;NAME&#125;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;当前遍历的值为: $&#123;item&#125;&quot;</span> )</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，遍历过程中将关键字<code>LISTS</code>改成了<code>ITEMS</code>，后边跟的还是一个或者多个列表，只不过此时需要通过<code>$&#123;&#125;</code>将列表中的值取出。其输出的信息和上一个例子是一样的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> build/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake ..</span></span><br><span class="line">-- 当前遍历的值为: a</span><br><span class="line">-- 当前遍历的值为: b</span><br><span class="line">-- 当前遍历的值为: c</span><br><span class="line">-- 当前遍历的值为: d e f</span><br><span class="line">-- 当前遍历的值为: ace</span><br><span class="line">-- 当前遍历的值为: sabo</span><br><span class="line">-- 当前遍历的值为: luffy</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/keqiudi/abc/a/build</span><br></pre></td></tr></table></figure>

<p><strong>小细节：在通过 set 组织列表的时候，如果某个字符串中有空格，可以通过双引号将其包裹起来，具体的操作方法可以参考上面的例子</strong>。</p>
<h4 id="方法4"><a href="#方法4" class="headerlink" title="方法4"></a>方法4</h4><p>注意事项：这种循环方式要求CMake的版本大于等于 3.17。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(&lt;loop_var&gt;... IN ZIP_LISTS &lt;lists&gt;)</span><br></pre></td></tr></table></figure>

<p>通过这种方式，遍历的还是一个或多个列表，可以理解为是<code>方式3</code>的加强版。因为通过上面的方式遍历多个列表，但是又想把指定列表中的元素取出来使用是做不到的，在这个加强版中就可以轻松实现。</p>
<ul>
<li><code>loop_var</code>：存储每次循环取出的值，可以根据要遍历的列表的数量指定多个变量，用于存储对应的列表当前取出的那个值。<ul>
<li><strong>如果指定了多个变量名，它们的数量应该和列表的数量相等</strong></li>
<li><strong>如果只给出了一个 loop_var，那么它将一系列的 loop_var_N 变量来存储对应列表中的当前项，也就是说 loop_var_0 对应第一个列表，loop_var_1 对应第二个列表，以此类推……</strong></li>
<li><strong>如果遍历的多个列表中一个列表较短，当它遍历完成之后将不会再参与后续的遍历（因为其它列表还没有遍历完）。</strong></li>
</ul>
</li>
<li><code>IN</code>：关键字，表示在 xxx 里边</li>
<li><code>ZIP_LISTS</code>：关键字，对应的是列表<code>list</code>，通过<code>set</code> 、<code>list</code>可以获得</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.17</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"><span class="comment"># 通过list给列表添加数据</span></span><br><span class="line"><span class="keyword">list</span>(APPEND WORD hello world <span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="keyword">list</span>(APPEND NAME ace sabo luffy zoro sanji)</span><br><span class="line"><span class="comment"># 遍历列表</span></span><br><span class="line"><span class="keyword">foreach</span>(item1 item2 IN ZIP_LISTS WORD NAME)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;当前遍历的值为: item1 = $&#123;item1&#125;, item2=$&#123;item2&#125;&quot;</span> )</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;=============================&quot;</span>)</span><br><span class="line"><span class="comment"># 遍历列表</span></span><br><span class="line"><span class="keyword">foreach</span>(item  IN ZIP_LISTS WORD NAME)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;当前遍历的值为: item1 = $&#123;item_0&#125;, item2=$&#123;item_1&#125;&quot;</span> )</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure>

<p>在这个例子中关于列表数据的添加是通过<code>list</code>来实现的。在遍历列表的时候一共使用了两种方式，一种提供了多个变量来存储当前列表中的值，另一种只有一个变量，但是实际取值的时候需要通过<code>变量名_0</code>、<code>变量名_1</code>、<code>变量名_N</code> 的方式来操作，<strong>注意事项：第一个列表对应的编号是0，第一个列表对应的编号是0，第一个列表对应的编号是0</strong>。</p>
<p>上面的例子输出的结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> build/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake ..</span></span><br><span class="line">-- 当前遍历的值为: item1 = hello, item2=ace</span><br><span class="line">-- 当前遍历的值为: item1 = world, item2=sabo</span><br><span class="line">-- 当前遍历的值为: item1 = hello world, item2=luffy</span><br><span class="line">-- 当前遍历的值为: item1 = , item2=zoro</span><br><span class="line">-- 当前遍历的值为: item1 = , item2=sanji</span><br><span class="line">=============================</span><br><span class="line">-- 当前遍历的值为: item1 = hello, item2=ace</span><br><span class="line">-- 当前遍历的值为: item1 = world, item2=sabo</span><br><span class="line">-- 当前遍历的值为: item1 = hello world, item2=luffy</span><br><span class="line">-- 当前遍历的值为: item1 = , item2=zoro</span><br><span class="line">-- 当前遍历的值为: item1 = , item2=sanji</span><br><span class="line">-- Configuring done (0.0s)</span><br><span class="line">-- Generating done (0.0s)</span><br><span class="line">-- Build files have been written to: /home/keqiudi/abc/a/build</span><br></pre></td></tr></table></figure>



<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>除了使用<code>foreach</code>也可以使用 <code>while </code>进行循环，关于循环结束对应的条件判断的书写格式和<code>if/elseif </code>是一样的。<code>while</code>的语法格式如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(&lt;condition&gt;)</span><br><span class="line">    &lt;commands&gt;</span><br><span class="line"><span class="keyword">endwhile</span>()</span><br></pre></td></tr></table></figure>

<p><code>while</code>循环比较简单，只需要指定出循环结束的条件即可：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"><span class="comment"># 创建一个列表 NAME</span></span><br><span class="line"><span class="keyword">set</span>(NAME luffy sanji zoro nami robin)</span><br><span class="line"><span class="comment"># 得到列表长度</span></span><br><span class="line"><span class="keyword">list</span>(LENGTH NAME LEN)</span><br><span class="line"><span class="comment"># 循环</span></span><br><span class="line"><span class="keyword">while</span>(<span class="variable">$&#123;LEN&#125;</span> <span class="keyword">GREATER</span>  <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;names = $&#123;NAME&#125;&quot;</span>)</span><br><span class="line">    <span class="comment"># 弹出列表头部元素</span></span><br><span class="line">    <span class="keyword">list</span>(POP_FRONT NAME)</span><br><span class="line">    <span class="comment"># 更新列表长度</span></span><br><span class="line">    <span class="keyword">list</span>(LENGTH NAME LEN)</span><br><span class="line"><span class="keyword">endwhile</span>()</span><br></pre></td></tr></table></figure>

<p>输出的结果如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> build/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake ..</span></span><br><span class="line">-- names = luffy;sanji;zoro;nami;robin</span><br><span class="line">-- names = sanji;zoro;nami;robin</span><br><span class="line">-- names = zoro;nami;robin</span><br><span class="line">-- names = nami;robin</span><br><span class="line">-- names = robin</span><br><span class="line">-- Configuring done (0.0s)</span><br><span class="line">-- Generating done (0.0s)</span><br><span class="line">-- Build files have been written to: /home/keqiudi/abc/a/build</span><br></pre></td></tr></table></figure>

<p>可以看到当列表中的元素全部被弹出之后，列表的长度变成了0，此时<code>while</code>循环也就退出了。</p>
<h1 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h1><p>下面的列表是一些<code>CMake</code>中已经预定义的常用的宏：</p>
<table>
<thead>
<tr>
<th>宏</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>PROJECT_SOURCE_DIR</strong></td>
<td>使用 cmake 命令后紧跟的目录，一般是工程的根目录</td>
</tr>
<tr>
<td><strong>PROJECT_BINARY_DIR</strong></td>
<td>执行 cmake 命令的目录</td>
</tr>
<tr>
<td><strong>CMAKE_CURRENT_SOURCE_DIR</strong></td>
<td>当前处理的 CMakeLists.txt 所在的路径</td>
</tr>
<tr>
<td><strong>CMAKE_CURRENT_BINARY_DIR</strong></td>
<td>target 编译目录</td>
</tr>
<tr>
<td><strong>EXECUTABLE_OUTPUT_PATH</strong></td>
<td>重新定义目标二进制可执行文件的存放位置</td>
</tr>
<tr>
<td><strong>LIBRARY_OUTPUT_PATH</strong></td>
<td>重新定义目标链接库文件的存放位置</td>
</tr>
<tr>
<td><strong>PROJECT_NAME</strong></td>
<td>返回通过 PROJECT 指令定义的项目名称</td>
</tr>
<tr>
<td><strong>CMAKE_BINARY_DIR</strong></td>
<td>项目实际构建路径，假设在 <code>build</code> 目录进行的构建，那么得到的就是这个目录的路径</td>
</tr>
</tbody></table>
<h1 id="基于多目录的CMake编写"><a href="#基于多目录的CMake编写" class="headerlink" title="基于多目录的CMake编写"></a>基于多目录的CMake编写</h1><p>看这个就可以了：</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV14s4y1g7Zj?spm_id_from=333.788.player.switch&vd_source=830e63bd86bd9268c1b7cd9ff383f386&p=19">爱编程的大丙-哔哩哔哩_bilibili</a></p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://i.postimg.cc/fbN6bFqP/20220206101541-14a48.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://i.postimg.cc/fbN6bFqP/20220206101541-14a48.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">THEDI</div><div class="post-copyright__author_desc">我想睡到12点!</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://www.thekqd.top/2025/06/03/CMake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://www.thekqd.top/2025/06/03/CMake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/')">CMake学习笔记</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/null" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/null" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://www.thekqd.top/2025/06/03/CMake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=CMake学习笔记&amp;url=https://www.thekqd.top/2025/06/03/CMake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/&amp;pic=/assets/30.webp" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.thekqd.top" target="_blank">THEDI的仓库</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>构建工具<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="/assets/30.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2025/05/23/2025-05-23-%E7%94%B5%E6%BA%90%E8%BD%AC%E6%8D%A2%E8%8A%AF%E7%89%87/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/16.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">电源转换芯片</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://i.postimg.cc/fbN6bFqP/20220206101541-14a48.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">THEDI</h1><div class="author-info__desc">我想睡到12点!</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="/assets/QRCode.jpg" target="_blank" title="微信"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-weixin"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/" target="_blank" title="B站"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg></a><a class="social-icon faa-parent animated-hover" href="mailto:1244381125@qq.com" target="_blank" title="QQ邮箱"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxiang"></use></svg></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">不要偷看我的博客!</div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(null) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#CMake%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">CMake概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CMake%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">CMake的基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">2.1.</span> <span class="toc-text">注释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A%E8%A1%8C"><span class="toc-number">2.1.1.</span> <span class="toc-text">注释行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A%E5%9D%97"><span class="toc-number">2.1.2.</span> <span class="toc-text">注释块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AA%E6%9C%89%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-number">2.2.</span> <span class="toc-text">只有源文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%9C%A8%E4%B8%80%E4%B8%AA%E7%9B%AE%E5%BD%95%E4%B8%8B"><span class="toc-number">2.2.1.</span> <span class="toc-text">全在一个目录下</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#build%E7%9B%AE%E5%BD%95"><span class="toc-number">2.2.2.</span> <span class="toc-text">build目录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%81%E4%BA%BA%E8%AE%A2%E5%88%B6"><span class="toc-number">2.3.</span> <span class="toc-text">私人订制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="toc-number">2.3.1.</span> <span class="toc-text">定义变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E4%BD%BF%E7%94%A8%E7%9A%84C-%E6%A0%87%E5%87%86"><span class="toc-number">2.3.2.</span> <span class="toc-text">指定使用的C++标准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E8%BE%93%E5%87%BA%E8%B7%AF%E5%BE%84"><span class="toc-number">2.3.3.</span> <span class="toc-text">指定输出路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BD%BF%E7%94%A8"><span class="toc-number">2.3.4.</span> <span class="toc-text">示例使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E6%96%87%E4%BB%B6"><span class="toc-number">2.4.</span> <span class="toc-text">搜索文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F1"><span class="toc-number">2.4.1.</span> <span class="toc-text">方式1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F2"><span class="toc-number">2.4.2.</span> <span class="toc-text">方式2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BD%BF%E7%94%A8-1"><span class="toc-number">2.4.3.</span> <span class="toc-text">示例使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E5%90%AB%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">2.5.</span> <span class="toc-text">包含头文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95"><span class="toc-number">2.5.1.</span> <span class="toc-text">添加方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BD%BF%E7%94%A8-2"><span class="toc-number">2.5.2.</span> <span class="toc-text">示例使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%B6%E4%BD%9C%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93"><span class="toc-number">2.6.</span> <span class="toc-text">制作动态库和静态库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B6%E4%BD%9C%E9%9D%99%E6%80%81%E5%BA%93"><span class="toc-number">2.6.1.</span> <span class="toc-text">制作静态库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B6%E4%BD%9C%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.6.2.</span> <span class="toc-text">制作静态链接库示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B6%E4%BD%9C%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-number">2.6.3.</span> <span class="toc-text">制作动态库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.6.4.</span> <span class="toc-text">创建动态链接库示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E5%BA%93%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-number">2.6.5.</span> <span class="toc-text">指定库文件输出的路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F1-%E9%80%82%E7%94%A8%E4%BA%8E%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-number">2.6.5.1.</span> <span class="toc-text">方式1- 适用于动态库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F2-%E9%83%BD%E9%80%82%E7%94%A8-%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E8%BF%99%E7%A7%8D"><span class="toc-number">2.6.5.2.</span> <span class="toc-text">方式2-都适用(推荐使用这种)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BD%BF%E7%94%A8-3"><span class="toc-number">2.6.5.3.</span> <span class="toc-text">示例使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%93%BE%E6%8E%A5%E5%BA%93-%E5%8C%85%E5%90%AB%E5%BA%93%E6%96%87%E4%BB%B6"><span class="toc-number">2.7.</span> <span class="toc-text">使用链接库(包含库文件)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E9%9D%99%E6%80%81%E5%BA%93"><span class="toc-number">2.7.1.</span> <span class="toc-text">链接静态库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.7.2.</span> <span class="toc-text">使用静态链接库示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-number">2.7.3.</span> <span class="toc-text">链接动态库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E7%B3%BB%E7%BB%9F%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-number">2.7.3.1.</span> <span class="toc-text">链接系统动态库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-number">2.7.3.2.</span> <span class="toc-text">链接第三方动态库</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E5%BA%93%E9%93%BE%E6%8E%A5%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.7.4.</span> <span class="toc-text">使用动态库链接示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#target-link-libraries%E5%92%8Clink-libraries%E5%8C%BA%E5%88%AB"><span class="toc-number">2.7.5.</span> <span class="toc-text">target_link_libraries和link_libraries区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97-%E8%B0%83%E8%AF%95"><span class="toc-number">2.8.</span> <span class="toc-text">日志(调试)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4"><span class="toc-number">2.8.1.</span> <span class="toc-text">命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.8.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E6%93%8D%E4%BD%9C"><span class="toc-number">2.9.</span> <span class="toc-text">变量操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%BD%E5%8A%A0"><span class="toc-number">2.9.1.</span> <span class="toc-text">追加</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8set%E6%8B%BC%E6%8E%A5"><span class="toc-number">2.9.1.1.</span> <span class="toc-text">使用set拼接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-%E4%BD%BF%E7%94%A8set%E6%8B%BC%E6%8E%A5"><span class="toc-number">2.9.1.2.</span> <span class="toc-text">示例-使用set拼接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8list%E6%8B%BC%E6%8E%A5"><span class="toc-number">2.9.1.3.</span> <span class="toc-text">使用list拼接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-%E4%BD%BF%E7%94%A8list%E6%8B%BC%E6%8E%A5"><span class="toc-number">2.9.2.</span> <span class="toc-text">示例-使用list拼接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A7%BB%E9%99%A4-list"><span class="toc-number">2.9.3.</span> <span class="toc-text">字符串移除(list)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A7%BB%E9%99%A4"><span class="toc-number">2.9.4.</span> <span class="toc-text">示例-字符串移除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD"><span class="toc-number">2.9.5.</span> <span class="toc-text">list其他功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">2.10.</span> <span class="toc-text">宏定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">2.10.1.</span> <span class="toc-text">示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97CMake"><span class="toc-number">3.</span> <span class="toc-text">嵌套CMake</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-number">3.1.</span> <span class="toc-text">准备工作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E5%85%B3%E7%B3%BB"><span class="toc-number">3.1.1.</span> <span class="toc-text">节点关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%AD%90%E7%9B%AE%E5%BD%95"><span class="toc-number">3.1.2.</span> <span class="toc-text">添加子目录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.</span> <span class="toc-text">解决问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E7%9B%AE%E5%BD%95"><span class="toc-number">3.2.1.</span> <span class="toc-text">根目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#calc%E7%9B%AE%E5%BD%95"><span class="toc-number">3.2.2.</span> <span class="toc-text">calc目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sort%E7%9B%AE%E5%BD%95"><span class="toc-number">3.2.3.</span> <span class="toc-text">sort目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#test1%E7%9B%AE%E5%BD%95"><span class="toc-number">3.2.4.</span> <span class="toc-text">test1目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#test2%E7%9B%AE%E5%BD%95"><span class="toc-number">3.2.5.</span> <span class="toc-text">test2目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="toc-number">3.2.6.</span> <span class="toc-text">构建项目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5%E7%BB%83%E4%B9%A0"><span class="toc-number">3.3.</span> <span class="toc-text">实践练习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%AD%E9%93%BE%E6%8E%A5%E9%9D%99%E6%80%81%E5%BA%93"><span class="toc-number">3.5.</span> <span class="toc-text">在静态库中链接静态库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%AD%E9%93%BE%E6%8E%A5%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-number">3.6.</span> <span class="toc-text">在静态库中链接动态库</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CMake%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">4.</span> <span class="toc-text">CMake流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD"><span class="toc-number">4.1.</span> <span class="toc-text">条件判断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.1.1.</span> <span class="toc-text">基本表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD"><span class="toc-number">4.1.2.</span> <span class="toc-text">逻辑判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83"><span class="toc-number">4.1.3.</span> <span class="toc-text">比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.4.</span> <span class="toc-text">文件操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">4.1.5.</span> <span class="toc-text">其他</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.2.</span> <span class="toc-text">循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#foreach"><span class="toc-number">4.2.1.</span> <span class="toc-text">foreach</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%951"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">方法1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%952"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">方法2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%953"><span class="toc-number">4.2.1.3.</span> <span class="toc-text">方法3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%954"><span class="toc-number">4.2.1.4.</span> <span class="toc-text">方法4</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#while"><span class="toc-number">4.2.2.</span> <span class="toc-text">while</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E5%AE%8F"><span class="toc-number">5.</span> <span class="toc-text">预定义宏</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%A4%9A%E7%9B%AE%E5%BD%95%E7%9A%84CMake%E7%BC%96%E5%86%99"><span class="toc-number">6.</span> <span class="toc-text">基于多目录的CMake编写</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/06/03/CMake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="CMake学习笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/30.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CMake学习笔记"/></a><div class="content"><a class="title" href="/2025/06/03/CMake%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="CMake学习笔记">CMake学习笔记</a><time datetime="2025-06-03T06:15:03.000Z" title="发表于 2025-06-03 14:15:03">2025-06-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/23/2025-05-23-%E7%94%B5%E6%BA%90%E8%BD%AC%E6%8D%A2%E8%8A%AF%E7%89%87/" title="电源转换芯片"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/16.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="电源转换芯片"/></a><div class="content"><a class="title" href="/2025/05/23/2025-05-23-%E7%94%B5%E6%BA%90%E8%BD%AC%E6%8D%A2%E8%8A%AF%E7%89%87/" title="电源转换芯片">电源转换芯片</a><time datetime="2025-05-23T09:47:26.000Z" title="发表于 2025-05-23 17:47:26">2025-05-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/23/2025-05-23-%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86%E8%8A%AF%E7%89%87/" title="电源管理芯片"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/100.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="电源管理芯片"/></a><div class="content"><a class="title" href="/2025/05/23/2025-05-23-%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86%E8%8A%AF%E7%89%87/" title="电源管理芯片">电源管理芯片</a><time datetime="2025-05-23T09:47:18.000Z" title="发表于 2025-05-23 17:47:18">2025-05-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/23/2025-05-23-%E7%94%B5%E5%AE%B9%E7%9A%84%E4%BD%BF%E7%94%A8/" title="电容的使用"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/wallhaven-76y9e9.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="电容的使用"/></a><div class="content"><a class="title" href="/2025/05/23/2025-05-23-%E7%94%B5%E5%AE%B9%E7%9A%84%E4%BD%BF%E7%94%A8/" title="电容的使用">电容的使用</a><time datetime="2025-05-23T09:46:44.000Z" title="发表于 2025-05-23 17:46:44">2025-05-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/23/2025-05-23-USB%E6%8E%A5%E5%8F%A3/" title="USB接口"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/21.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="USB接口"/></a><div class="content"><a class="title" href="/2025/05/23/2025-05-23-USB%E6%8E%A5%E5%8F%A3/" title="USB接口">USB接口</a><time datetime="2025-05-23T09:46:33.000Z" title="发表于 2025-05-23 17:46:33">2025-05-23</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="workboard"><img class="workSituationImg boardsign" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-上班摸鱼中.svg" alt="距离月入25k也就还差一个大佬带我~" title="距离月入25k也就还差一个大佬带我~"/><div id="runtimeTextTip"></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://blog.anheyu.com/" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"/></a><a class="github-badge" target="_blank" href="https://www.dogecloud.com/" style="margin-inline:5px" data-title="本站使用多吉云为静态资源提供CDN加速" title="本站使用多吉云为静态资源提供CDN加速"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/CDN-多吉云-3693F3.svg" alt="本站使用多吉云为静态资源提供CDN加速"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"/></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2022 - 2025 By <a class="footer-bar-link" href="/" title="THEDI" target="_blank">THEDI</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">9</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="安知鱼的博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="安知鱼的博客"/><span class="back-menu-item-text">安知鱼的博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/keqiudi/keqiudi.github.io" title="我的博客仓库"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="我的博客仓库"/><span class="back-menu-item-text">我的博客仓库</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 0.88rem;">C++<sup>2</sup></a><a href="/tags/CLion/" style="font-size: 0.88rem;">CLion<sup>1</sup></a><a href="/tags/Git/" style="font-size: 0.88rem;">Git<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem;">Linux<sup>8</sup></a><a href="/tags/MySQL/" style="font-size: 0.88rem;">MySQL<sup>2</sup></a><a href="/tags/QT/" style="font-size: 0.88rem;">QT<sup>1</sup></a><a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/" style="font-size: 0.88rem;">嵌入式<sup>7</sup></a><a href="/tags/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/" style="font-size: 0.88rem;">构建工具<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>3</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.cbd.int/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("12/01/2022 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2022 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 THEDI 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("12/01/2022 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-下班啦.svg";
        img.title = "下班了就该开开心心的玩耍，嘿嘿~";
        img.alt = "下班了就该开开心心的玩耍，嘿嘿~";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><script src="https://cdn.cbd.int/algoliasearch@4.18.0/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.cbd.int/instantsearch.js@4.60.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script async src="//at.alicdn.com/t/c/font_4169545_k8d3mxnig4s.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>