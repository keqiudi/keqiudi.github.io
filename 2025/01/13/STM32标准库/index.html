<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>STM32(标准库) | THEDI的仓库</title><meta name="keywords" content="嵌入式"><meta name="author" content="THEDI"><meta name="copyright" content="THEDI"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="STM32(标准库)"><meta name="application-name" content="STM32(标准库)"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="STM32(标准库)"><meta property="og:url" content="https://www.thekqd.top/2025/01/13/STM32%E6%A0%87%E5%87%86%E5%BA%93/index.html"><meta property="og:site_name" content="THEDI的仓库"><meta property="og:description" content="STM32标准库笔记"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://www.thekqd.top/assets/14.webp"><meta property="article:author" content="THEDI"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.thekqd.top/assets/14.webp"><meta name="description" content="STM32标准库笔记"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://www.thekqd.top/2025/01/13/STM32%E6%A0%87%E5%87%86%E5%BA%93/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="manifest" href="/manifest.json"/><meta name="msapplication-TileColor" content="var(--anzhiyu-main)"/><link rel="mask-icon" href="/img/siteicon/apple-icon-180.png" color="#5bbad5"/><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/apple-icon-180.png"/><link rel="apple-touch-icon-precomposed" sizes="180x180" href="/img/siteicon/apple-icon-180.png"/><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/16.png"/><link rel="bookmark" href="/img/siteicon/apple-icon-180.png"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2048-2732.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2732-2048.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1668-2388.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2388-1668.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1536-2048.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2048-1536.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1668-2224.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2224-1668.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1620-2160.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2160-1620.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1290-2796.jpg" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2796-1290.jpg" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1179-2556.jpg" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2556-1179.jpg" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1284-2778.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2778-1284.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1170-2532.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2532-1170.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1125-2436.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2436-1125.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1242-2688.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2688-1242.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-828-1792.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1792-828.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1242-2208.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2208-1242.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-750-1334.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1334-750.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-640-1136.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1136-640.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css#fontawesome_animation 如果有就会加载，示例值：https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: {"enable":true,"title":"与大家一起进步","addFriendPlaceholder":"昵称（请勿包含博客等字样）：\n网站地址（要求博客地址，请勿提交个人主页）：\n头像图片url（请提供尽可能清晰的图片，我会上传到我自己的图床）：\n描述：\n站点截图（可选）：\n"},
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"该回来学习啦！","backTitle":"w(ﾟДﾟ)w快认真学习！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🏠 智能家居小能手"]},
  algolia: {"appId":"PW49GHYJ6T","apiKey":"42b04be58e36cfebeb6ac1989c6e8009","indexName":"hexo","hits":{"per_page":6},"languages":{"input_placeholder":"输入关键词后按下回车查找","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: THEDI","link":"链接: ","source":"来源: THEDI的仓库","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'THEDI的仓库',
  title: 'STM32(标准库)',
  postAI: '',
  pageFillDescription: 'keil配置与芯片包下载, 固件库文件, keil新建工程, 启动文件的选择, stm32f10x.h, 新建工程步骤总结, 模块化编程, STM32启动文件, GPIO, RCC开启时钟, GPIO标准库函数, 具体流程代码, 实验-LED流水灯, 输入模式, GPIO相关寄存器, 引脚重映射(复用功能重映像), EXTI(外部中断), 介绍, 库函数, 初始化配置流程, 中断函数, 实验- 旋转编码器计数, 实验-对射式红外传感器计次, 使用中断注意事项, 共用外部中断线问题, TIM(定时器), 介绍, 计数器模式, 时基单元, 时钟源, 库函数, 定时器中断(定时或计数功能), TIM配置流程, 实验-使用定时器每秒计数(内部时钟), 实验-对射式红外传感器(外部时钟模式2), 实验-循迹模块测量商品数量(外部时钟模式2), 输出比较功能(OC), OC简介, PWM输出简介, 舵机简介, 直流电机及驱动简介, 库函数, 输出比较配置流程, 实验-PWM呼吸灯, 配置流程, 实验-PWM驱动舵机, 实验-PWM驱动DRV8833电机, 输入捕获功能(IC), IC简介, 频率测量, 输入捕获通道, 主从触发模式, 输入捕获模式和PWM输入模式(PWMI)基本结构图, 库函数, 输入捕获配置流程, 实验-输入捕获模式测频率(输入捕获直接模式), 实验-PWMI模式测频率和占空比(输入捕获交叉x2F间接模式), 编码器接口, 编码器接口简介, 正交编码器介绍, 应用, 编码器接口基本结构图, 库函数, 编码器接口配置流程, 实验-正交编码器测速, ADC, ADC简介, ADC内部结构, ADC输入通道, ADC转换模式, ADC触发控制, ADC数据对齐, ADC转换时间, ADC校准, 硬件电路, ADC基本结构图, 库函数, ADC配置流程, 实验-ADC读取电位器电压(ADC单通道), 实验- ADC多通道采集, DMA, DMA简介, STM32存储器映像, DMA框图, DMA 基本结构图, DMA请求映像, 数据宽度与对齐, 例子, 数据转运+DMA(存储器到存储器转运), ADC扫描模式+DMA(外设到存储器), 库函数, DMA配置流程, 实验-DMA数据转运(存储器到存储器), 实验-DMA+ADC多通道采集, 通信接口, 接口简介, 串口通信, 介绍, CH340串口驱动, 硬件电路, 电平标准, 串口参数及时序, USART简介, USART框图, USART基本结构, 数据帧, 起始位侦测, 数据采样, 波特率发生器, 数据模式, 库函数, USART配置流程, 测试-串口发送和串口接收, 实验-串口接收单字节(轮询+中断), 实验-USART串口数据包, 实验-printf函数的移植, 数据包, 数据包介绍, 数据包的发送和接收, 实验-串口收发HEX数据包, 实验-串口收发文本数据包, I2C, I2C介绍, 硬件电路与优缺点, I2C时序基本单元, I2C从机地址, I2C时序, MPU6050, MPU6050简介, MPU6050参数, 硬件电路, MPU6050框图, MPU6050产品手册, MPU6050寄存器映像手册, 软件模拟I2C读写, 软件I2C代码实现, MPU6050-测试读写, 读功能, 写功能, MPU6050-读取加速度x2F角速度, I2C外设(硬件读写I2C), I2C框图, I2C基本结构, 主机发送流程, 主机接收流程, 从机发送接收, 库函数, I2C外设配置, 实验-硬件I2C读取MPU6050数据, 软件和硬件I2C对比, SPI, SPI介绍, 硬件电路, 数据移位示意图, SPI时序基本单元, SPI时序, W25Q64介绍, 硬件电路, 框图, Flash操作注意事项, 芯片手册, 软件SPI读写W25Q64, 软件SPI底层代码, W25Q64测试代码, W25Q64完整代码, 硬件SPI外设(硬件读写), SPI框图, 主模式全双工连续传输, 非连续传输, TXE和RXNE标志位清除问题, 连续和非连续的优缺点, 软件硬件波形对比, SPI库函数, 硬件SPI初始化流程, 硬件SPI读写W25Q64, RTC, 常识, Unix时间戳, RTCx2FGMT, 时间戳转换, BKP简介, 基本结构, BKP库函数, 读写BKP, RTC外设, RTC简介, RTC框图, RTC基本结构, 硬件电路, RTC操作注意事项, RCC库函数, RTC库函数, RTC配置, RTC显示当前时间, BKP寄存器解决掉电时间不丢失问题, PWR电源控制, PWR简介, 电源框图, 上电复位和掉电复位(PORx2FPDR), 可编程电压检测器PVD, 低功耗模式介绍, 模式选择的图, 三种模式特性及注意事项, 节电方法, SLEEPDEEP和SLEEPONEXIT位配置, 修改主频, 睡眠模式实例, 串口收发, 停机模式实例, 库函数, 对射式红外传感器外部中断(停机模式), 待机模式实例, RTC闹钟(待机模式), 看门狗WDG, 看门狗简介, 独立看门狗IWDG, IWDG框图, IWDG键寄存器, IWDG超时时间, 窗口看门狗WWDG, WWDG框图, WWDG工作特性, WWDG超时时间, IWDG和WWDG对比, 独立看门狗代码, 相关库函数, 配置流程, 按键触发独立看门狗, 窗口看门狗代码, 库函数, 配置流程, 按键触发窗口看门狗, FLASH 闪存, FLASH简介, 闪存模块组织, FLASH基本结构, FLASH解锁, 使用指针访问存储器(指针写入操作), 程序存储器FLASH的擦除和编程, 程序存储器FLASH的全擦除, 程序存储器FLASH的页擦除, 程序存储器FLASH编程, 选项字节, 选项字节擦除, 选项字节的编程, 器件电子签名, FLASH 库函数, 实验, 简单读写FLASH(FLASH底层代码实现), 在SRAM中定义数组和标志位对FLASH数据存储, 读取芯片ID(使用指针直接访问读取), 存在的BUG-当程序很大时覆盖用户存储参数区, Flash写入之前的擦除必要性, STM32 ST-LINK Utility配置与芯片包下载固件库文件以固件库为例固件库是为系列微控制器设计的开发辅助库主要用于简化对外设的控制和配置该库封装了对各类外设如等的控制接口使开发者无需直接操作复杂的寄存器就能使用这些硬件外设通过它开发者可以轻松地进行外设的初始化配置和数据处理主要结构图片没什么用库函数的文件我们之后建工程时会用包含内核的相关定义和启动代码包含了与系列内核相关的文件主要是一些适用于内核的通用代码和数据结构用于管理核心处理器功能含与特定厂商的微控制器设备相关的文件特别是该设备特定的外设寄存器定义和访问方法它提供了内核之外的硬件支持适用于具体的型号标准外设驱动库包含系列的外设驱动源文件和头文件是官方提供的工程示例和模板使用库函数时可以参考是官方评估板的相关例程这个评估版就是官方用做的一个小电路板用来测评的文件夹内存放的就是小电路板的测评程序这个是库函数的发布文档使用手册教大家如何使用库函数新建工程新建一个设置名称后会出现选择芯片如果只有则需要将官方的芯片包在官方下载文件导入最后会弹出来的界面是一个新建工程的小助手也有固件库可以帮我快速建立工程直接勾选即可是的新功能今天我们创建工程的方式是自己去搬运官网给的库加深一下理解和增加动手能力所以没有使用来添加库直接点击即可此时就只有一个里面什么都没有我们需要给它添加一点工程的必要文件此时我们可以看到刚刚创建的项目文件夹自动生成一堆文件夹为了便于管理我们先在工程文件夹中创建一个文件夹用于存放启动文件此时打开固件库文件夹然后选中全部一起复制到刚刚我们创建的文件夹中这些就是的启动文件程序就是从这些启动文件开始执行的我们把这三个文件也复制下来粘贴到文件夹下我们可以看到和两个开头的文件是的外设寄存器描述文件用来描述有哪些寄存器和它对应的地址文件这个两个文件用于配置时钟主频就是在文件里配置的接下来因为是内核和内核外围设备外设组成的而且内核的寄存器描述和外围设备的描述文件不是在一起的所以我们还需要添加内核寄存器的描述文件进入然后也把这两个相关内核相关的文件复制到文件后所有的准备完成里面有两个和这两个文件就是内核的寄存器描述文件还有一些内核配置函数返回中将刚刚的文件添加到工程中在中然后将新建的文件夹改名为将刚刚所有的文件夹中的文件添加进去首先是启动文件的添加有一堆文件我们选择其中的一个添加到工程中有关启动文件的选择请看下面的笔记然后剩下的所有和文件都要添加进去我们可以按住键然后依次选择他们点击即可这里的文件都是里最基本的文件是不需要我们修改的添加到工程即可此时可以看到这些文件都带有钥匙图标代表只读文件点击魔术棒打开工程选项在中找到添加文件夹的路径至其中最后我们还要在工程选项里添加上该文件夹的头文件路径否则找不到文件回到该项目的文件夹下新建一个文件夹函数就放在其中再回到中在添加一个组改名为对其右键创建到其中此时在中创建我们的函数进行开发即可由于此时工程还没有添加的库函数所以是基于寄存器开发工程如果想要使用寄存器开发那么到这里就可以结束了接下来继续添加库函数打开项目文件夹新建文件夹用于存放库函数接着打开固件库的文件夹全选复制粘贴到中去然后再回到中去再次将头文件全部复制粘贴到中去其中是内核的库函数其他的就是外设库函数回到中在下添加一个组命名为再将文件夹中的所有文件添加到工程中去但是此时的库函数还不能直接使用我们还需要在添加文件继续打开固件库文中把一个文件和两个中断文件复制粘贴到文件下回到中将这三个文件添加到的组中我们可以看到一个的文件这个文件是用来配置库函数头文件包含关系以及用来参数检查的函数定义这是所有库函数都需要的两个文件是用来存放中断函数的最后我们还需要一个宏定义我们打开切换到中在中添加最后别忘了在下方的再将和目录的路径添加进去我们可以在文件中的最下方看到有一段这个的意思是如果定义了使用标准外设驱动这个宏定义才会包含即才会生效由于文件包含了所有库函数的头文件所以我们只需要文件就可以任意调用库函数了最终我们的基本模板为前三个为创建项目后自动生成的文件夹后三个为我们手动创建的一定记得将所有带有头文件的目录添加到的中以便于编译器能够找到头文件启动文件的选择我们在新建工程向文件夹添加启动文件的时候有一堆文件当时我们选择其中的一个添加到工程中现在来解释一下这个文件怎么选取启动文件有很多类型至于选择哪一个我们要根据芯片的型号来选择看这张表缩写翻译容量型号小容量产品中容量产品大容量产品加大容量产品大于互联网产品小容量产品超值系列中容量产品超值系列大容量产品超值系列先根据型号选择是哪个系列的启动文件根据容量选择对应的启动文件添加到即可我们可以在文件中的最下方看到有一段这个的意思是如果定义了使用标准外设驱动这个宏定义才会包含即才会生效由于文件包含了所有库函数的头文件所以我们只需要在编程的时候文件就可以任意调用库函数了新建工程步骤总结建立工程文件夹中新建工程选择型号工程文件夹中建立等文件夹复制固件库里面的文件到工程文件夹工程里对应建立等同名称的分组并将文件夹内的文件添加到工程分组里工程选项魔法棒内添加所有包含头文件的文件夹工程选项魔法棒中定义宏定义工程选项魔法棒下拉列表选择对应调试器里勾选模块化编程如果我们把所有的初始化代码都写到函数中就会显得很杂乱为此我们单独创建一个文件夹用于存放各外设驱动等在项目文件夹下创一个文件夹回到中添加一个名为的组然后添加或创建对应外设驱动的文件将添加到魔法棒中的的中最终我们的基本模板为前三个为创建项目后自动生成的文件夹后四个个为我们手动创建的例如在里的驱动函数就是这样写的所有的外设都可以这样独立写成驱动函数初始化函数等这样使的项目更好管理启动文件就是启动文件这是一个用汇编写的文件定义了中断向量表和中断服务函数等启动有个复位中断是程序的入口当按下复位或者上电的时候程序就会进入复位中断函数执行复位中断函数做的就是调用函数和调用函数我们可以在启动文件文件的注释中知道流程为初始化堆栈指针初始化程序计数器为初始化堆栈的大小设置中断向量表的入口地址转向执行调用函数完成系统初始化系统时钟闪存接口配置等设置库的分支入口为调用我们的函数通用输入输出端口可配置共种输入输出模式引脚电平位部分引脚可以容忍输出模式下可控制端口输出高低电平用于驱动控制蜂鸣器模拟通信协议输出时序输入模式下可读取端口的高低电平或电压用于读取按键输入外接模块电平信号输入电压采集模拟通信协议接收数据等介绍博客上下拉电阻定义强弱上拉常见作用吸电流拉电流灌电流弱上拉和强上拉的区别博客操作的分为三个步骤使用开启时钟使用库函数函数初始化使用输出或输入函数控制口开启时钟在中有很多相关函数但是我们最常用的是这三个总线外设时钟控制总线外设时钟控制总线外设时钟控制我们可以跳到这些函数的定义查看注释我们可以知道这些时钟控制函数就是使能或失能外设时钟的参数选择外设参数使能或失能如果不知道该外设是否在这个总线上我们可以在注释上面的列表看如果出现了代表在这个总线上标准库函数在中指定外设被复位指定复位初始化外设为指定的初始化使用的是我们自己创建的结构体指定结构体赋值读取函数指定端口拉高指定端口拉低端口写入指定值或读写函数对应的结构体定义如下标准库的结构体参数只有三个这些跳转到对应定义可以知道值库有个参数对比起来标准库更简单了具体流程代码假设我们需要点亮的查看手册后发现挂载再总线上开启对应外设时钟初始化定义结构体三个参数赋值调用初始化对应口函数中读取结构体自动配置写入到对应寄存器实验流水灯使用函数同时操控多个端口当有多个引脚时我们可以使用按位或的方式同时选中多个选中了和我们来看对应定义一共位每一个引脚对应一个位只需要使用按位或的操作既可以选中指定端口知道这个后我们可以使用函数同时操控多个端口由于语言不支持写进制故使用进制来写亮亮使用实现的延时函数直接使用即可使用时创建一个文件夹并把他们放到文件夹下在创建组即可微秒级延时延时时长范围无设置定时器重装值清空当前计数值设置时钟源为启动定时器等待计数到关闭定时器毫秒级延时延时时长范围无秒级延时延时时长范围无输入模式相关寄存器查看芯片对应参考手册结合对应代码可以得知如何使用相关寄存器引脚重映射复用功能重映像在参考手册中有一节复用功能和调试配置这一章节专门就是讲的引脚复用重映像功能手册描述如下为了优化脚或脚封装的外设数目可以把一些复用功能重新映射到其他引脚上设置复用重映射和调试配置寄存器实现引脚的重新映射这时复用功能不再映射到它们的原始分配如果多个外设需要使用同一组引脚默认引脚的配置可能会导致冲突引脚重映像允许开发者重新分配功能到其他引脚避免资源冲突实际意义在复杂系统中可以高效利用芯片的引脚资源而不用为了冲突放弃某些外设功能例如需要同时使用和但两者默认引脚有重叠通过重映像将从移到释放供其他功能使用这样我们就可以同时使用和了对应库函数参数对应外设重映射方式一般是部分重映像或者完全重映像具体查看对应手册参数是否是能使用方式开启时钟选择对应外设的映射映射方式即可接触复用以便于能够重映射注意使用端口映射前可能有些端口已经被占用了比如调试端口如果重映射使用的是调试端口那么使用前需要先解除端口复用外部中断介绍可以监测指定的口的电平信号当其指定的口产生电平变化时将立即向发出中断申请经过裁决后即可中断主程序使执行对应的中断程序支持的触发方式上升沿下降沿双边沿软件触发支持的口所有口但相同的不能同时触发中断如与与之间通道数个外加输出闹钟等触发响应的方式中断响应事件响应中断响应正常的引脚电平变化触发中断事件响应不会触发中断而是触发别的外设操作属于外设之间的联合工作库函数相关的库函数去中查看这里直接使初始化配置流程只需要从到这一路出现的外设模块配置好即可一共步配置打开相关的外设时钟这里涉及到的是的时钟但由于和时钟内核外设不需要开启时钟一直都是打开的不需要我们开启所以只需要开启和时钟即可开启时钟开启对应时钟配置配置我们的端口为输入模式在我们的手册中有对应外设每个引脚推荐配置模式我们可以找到推荐配置为浮空上拉下拉配置通过外设将引脚映射到外设上以便用于外部中断参数使用哪个作为外部中断源参数指定需要配置的外部中断线这里配置只需要这个函数即可没有单独写的库函数与库函数放在一起的可以去的库函数中找这个函数查看对应参数虽然写的是但是我们查看该函数定义可以发现里面操作的是的寄存器配置选择边沿触发方式比如上升沿双边沿等还有触发响应方式可以选择中断响应和事件响应对应选择的外部中断线使能或不使能两种模式一种是中断响应一种是事件响应触发方式相关的库函数去中查看这里直接使用配置给我们的中断选择一个合适的优先级优先级配置分组方式整个芯片只能只能用一种按理来说这个分组的代码整个工程只需要执行一次即可如果把这个函数放到模块里面进行分组一定要确保每个模块分组都选的是同一个也可以把这个代码放在主函数的开始这样就不用每个模块分组使能指定抢占优先级指定子优先级因为是内核外设库函数被分配到了杂项文件中去了在这里查找对应参数对应函数用法中查看注释我们可以知道需要到去找我们要选择对应芯片的选择编译这里我们是在里面的选择编译中我们找到了的到都是合并到了这个通道里所以我们定义为即可注意配置时只能接受一个中断通道号不能接收多个中断通道的组合如果有多个中断通道配置需要配置多次这样配置不会报错但是两个中断都不会生效需要单独调用两次初始化对应的设置抢占优先级和子优先级设置我们可以跳转到对应定义处继续跳转到注释中提到的中断优先级对应的优先级表查看即可只有两个按键配置流程连起来就是配置启用对应外设时钟配置配置配置对应选择的按键外部中断线使能或不使能两种模式一种是中断一种是事件触发方式为下降沿触发配置使能指定抢占优先级指定子优先级中断函数完成了外部中断初始化配置后接下来就是编写中断函数在启动文件的中断向量表中找到对应的中断函数的名字这里是将其从启动文件中复制到对应位置进行编写名字一定不能错错了就无法进入了编写步骤如下判断对应中断标志位是否为如果是清除对应中断标志位否则会一直触发中断用户干的事情用户干的事情中断函数的返回值和参数都是此函数不用声明中断触发自动调用使用的相关函数在对应的标准库中去找等有两个获取标志位的函数带有的是只能在中断中使用的不带的是在中断外使用的实验旋转编码器计数旋转编码器相关知识见库此处旋转编码器相对应相对应全局变量打开对应外设时钟选择这个外设开启时钟通常用于启用或禁用外设的时钟以便进行相应的配置操作配置对应输入模式上拉输入默认为高电平的输入方式旋转编码器分两相为相为相初始化外设配置映射到对应线上去配置将第条线路和第条线路都初始化为中断模式下降沿触发连线开启中断中断模式下降沿触发离开就配置这个地方需要两个中断初始化选两位抢占两位响应整个程序只需要配置一次外部中断抢占优先级响应优先级外部中断抢占优先级响应优先级大于和为同一抢占优先级但的响应优先级比大所以可以被打断获取中断服务函数中改变的数这个函数只有这个引脚可以触发外部中断的线被触发进入中断下降沿低电平反转计数清除中断标志位跳出中断这个函数只有这个引脚可以触发外部中断的线被触发进入中断下降沿低电平正转计数清除中断标志位正转编码器增加反转编码器增加这样写可以多次触发中断实验对射式红外传感器计次使用中断注意事项中断函数中不要执行耗时过长的代码不要使用延时函数不要在中断函数中和主函数调用相同的函数或操作同一个硬件操作用一个全局变量时要将该变量声明为避免编译器优化中断建议操作变量或者标志位状态位共用外部中断线问题内部资源有限因此产生了很多共用资源其中外部中断也是其中之一外部中断的共用资源主要包括不同端口同一口共用一个中断线如共用外部中断线不同口同一端口这个都不用说这些共用的是同一个端口寄存器之类的同一口共用一个中断线但个中断线却只共用个中断服务函数其中中断线独立拥有一个中断服务中断线共用一个中断服务函数中断线共用一个中断服务函数所以我们端口不同口相同时也不可同时配置外部中断比如配置了外部中断那么就不能配置外部中断定时器介绍定时器可以对输入的时钟进行计数并在计数值达到设定值时触发中断位计数器预分频器自动重装载寄存器的时基单元在计数时钟下可以实现最大的定时时间具备基本的定时中断功能还包含内外时钟源选择时钟捕获输出比较编码器接口主从触发模式等多种功能分为三种高级定时器通用定时器基本定时器难度依次递减计数器模式三种向上计数模式向下计数模式中央对齐模式基本定时器只支持向上计数模式通用定时器和高级定时器支持向上计数向下计数中央对齐计数时基单元定时器框图中最重要的是时基单元由三部分构成预分频器自动重装载器计数器预分频值内部有一个预分频器内部时钟先输入到这里完成分频简单来说就是分频值时钟信号被分频后的频率自动重装载值内部有一个自动重装载寄存器简单来说就是设置计数值上限最大为计数器内部有一个计数器自增会与自动重装在寄存器比较当计数值等于自动重装载值时将会触发更新中断或更新事件同时清零计数器定时器溢出时间时钟源在手册上我们可以看到通用定时器的时钟源有种内部时钟外部时钟模式外部输入引脚外部时钟模式外部触发输入内部触发输入使用一个定时器作为另一个定时器的预分频器如可以配置一个定时器而作为另一个定时器的预分频器用于定时器级联基本定时器只能选择内部时钟也就是系统主频通用高级定时器时钟源不仅可以选择内部时钟输入也可以选择外部时钟输入外部引脚输入在下面的参考手册通用定时器框图中可以看到通过引脚上可以外接一个外部方波时钟在配置内部极性选择边沿检测和预分频器再配置一下输入滤波电路对外部引脚输入进行滤波最后分为两路去外部时钟模式和外部时钟模式总结看上面手册中的框图内部时钟输入一般为系统主频外部时钟输入分为外部时钟模式和外部时钟模式引脚外部引脚输入经过一堆极性选择边沿检测滤波等后独立进入触发控制器独享是外部时钟模式通过触发器进入从模式控制器是外部时钟模式其他定时器是内部触发输入来源于其他可以实现定时器级联是外部时钟模式引脚的边沿外部时钟模式引脚外部时钟模式引脚外部时钟模式一般情况下外部时钟通过引脚就可以其他这么多输入是为了某些特定场景使用比如是为了定时器级联设置的库函数相关的库函数直接在寻找使用这里给出常用的时钟源选择内部时钟外部输入模式外部输入模式外部输入模式内部触发输入级联时基单元配置中断输出控制配置配置运行控制配置单独更改预分频值计数器模式配置计数器预装载配置手动写入计数器值手动写入值获取计数器或预分频值中断相关函数中断外使用中断内使用定时器中断定时或计数功能配置流程首先新建和文件到中我们将上方的定时中断基本结构图打通就完成了配置具体流程开启时钟查看手册我们可以发现在总线上故开启总线时钟选择时基单元的时钟源上电后单片机默认使用内部时钟这一行其实可以省略配置时基单元这里并没有对计数器的初始化如果我们想更改调用函数进行更改即可参数与滤波器相关的分频这里随便选参数重复计数器的值高级定时器才有的不用给配置中断即配置输出中断控制允许更新中断输出到配置为更新中断这里的第二个参数我们选择的是更新中断其他选择请跳转到对应函数的注释中查看配置在中打开定时器中断的通道并分配一个优先级优先级分组配置运行控制我们需要使能定时器的运行否则不会工作连起来就是使能时钟时基单元时钟源选择此处选择内部时钟上电后单片机默认使用内部时钟这一行其实可以省略时基单元配置与滤波器相关的分频这里随便选计数器模式周期也就是的值预分频器的值重复计数器的值高级定时器才有输出中断控制配置允许更新中断输出到配置为更新中断配置定时器运行控制使能一下中断函数同样在启动文件中寻找中间为用户代码上方函数调用查看更新中断的标志位实验使用定时器每秒计数内部时钟上电后单片机默认使用内部时钟这一行其实可以省略与滤波器相关的分频这里随便选计数器模式周期也就是的值预分频器的值重复计数器的值高级定时器才有避免上电立即进入中断配置为更新中断这里有个问题上电后我们可以发现计数器的值直接为这代表在上电时就已经进入了一次中断处理程序了这是由于函数中最后一排有个查看注释可以知道其手动生成了一个更新事件为了让预分频器缓冲寄存器起作用更新才会起作用导致上电立即进入中断解决方案在后开启中断前使用手动清除标志位添加到这里即可配置为更新中断实验对射式红外传感器外部时钟模式参考手册查看到芯片的复用输入引脚为可以通过引脚将传感器模块的引脚输出波形引入到定时器中有外部引脚输出故先配置外部引脚这里的输入模式在参考手册可以查到使用外部输入推荐为浮空输入这里选择的外部时钟模式对应参数选择跳转到对应函数查看注释选择的是上升沿触发最后一个参数是外部触发滤波器取值对应可以在参考手册中从模式控制寄存器中看到取值为如果我们不滤波的话就会有很多抖动脉冲计数很多次这里一般选择即可当我们把手放遮挡在拿开计数器计数次后实验循迹模块测量商品数量外部时钟模式动画讲解定时器外部时钟实战传送带测速装置哔哩哔哩参考手册查看到芯片的复用输入引脚为可以通过引脚将传感器模块的引脚输出波形引入到定时器中代码与上方完全相同同样也可以使用外部时钟模式的从模式都可以实现最终我们将任意物品从循迹模块下方穿过一个物品计数输出比较功能简介输出比较输出比较可以通过比较计数器与值的关系进行置置或者翻转的操作用于输出一定频率和占空比的波形全称捕获比较寄存器使用输入捕获时就是捕获寄存器使用输出比较时就是比较寄存器每个高级定时器和通用定时器都拥有个输出比较通道高级定时器的前三个通道额外拥有死区生成和互补输出的功能输出简介脉冲宽度调制是英文的缩写简称脉宽调制其实是在利用微控制器的定时器模块来生成一种特定频率和占空比的脉冲信号一段高低电平调整脉冲的宽度从而影响功率等信号是一种周期性的脉冲信号通过调整脉冲的宽度高电平时间可以模拟模拟信号控制电机速度亮度蜂鸣器响度等必须具有惯性的系统才能使用参数频率占空比图中的高电平占整个周期的时间分辨率占空比变化步距占空比以多少百分比跳变到到分辨率就是频率越快等效模拟的信号也就越平稳对应的性能开销也就越大一般来说的频率都在几到几十这个频率就足够快了原理图时参数计算频率占空比分辨率占空比越细腻越好舵机简介舵机是一种根据输入信号占空比来控制输出角度的装置常见的舵机型号有输入信号要求周期为高电平时长为可以查看对应舵机手册得到驱动角度对应的周期三根线一根一根一根信号线给一个舵机就会固定在某一个角度机械臂等机械机构就可以使用这里的输出当成通信协议很常见波形通过信号线输出直流电机及驱动简介直流电机是一种将电能转换为机械能的装置有两个电极当电极正接时电机正转当电极反接时电机反转对应一个引脚高电平一个引脚低电平直流电机属于大功率器件口无法直接驱动需要配合电机驱动芯片来操作是一款双路桥型的直流电机驱动芯片可以驱动两个直流电机并控制其转速和方向还有驱动芯片等在对应模块使用手册可以查看使用方法以及原理图各引脚含义库函数主要初始化函数对应的是四个输出比较通道的输出比较单元结构体的初始化用于为一个结构体赋初值极性配置对每个通道极性的单独配置带是高级定时器中互补通道的配置没有互补通道单独修改输出使能参数单独修改输出比较模式的函数单独修改寄存器的函数可用于调整占空比该函数仅高级定时器使用在使用高级定时器输出时需要调用这个函数使能主输出否则将不能正常输出一些小功能配置使用不多配置强制输出模式在运行中想要暂停输出波形并且强制输出高或低电平使用一般不怎么使用修改占空比为或也能实现用于配置寄存器的预装功能也就是影子寄存器也就是写入的值不会立即生效而是在更新时间才会生效一般不使用用于配置快速使能功能手册中单脉冲模式有介绍一般不使用外部事件时清楚信号不怎么使用输出比较配置流程开启时钟配置把对应的口初始化为复用推挽输出模式复用选择时基单元时钟源配置时基单元配置输出比较单元输出比较模式极性选择输出状态使能的值等运行控制启动对应实验呼吸灯配置流程开启时钟开启对应和时钟配置把对应的口初始化为复用推挽输出模式复用选择时基单元时钟源配置时基单元配置输出比较单元输出比较模式极性选择输出状态使能的值等运行控制启动对应开启时钟配置复用推挽模式配置时基单元时钟源配置时基单元配置输出比较单元模式极性为高有效电平为高电平输出状态使能配置这里时通用定时器只需要列举需要的参数即可高级定时器的参数可以不用管运行控制使能实验驱动舵机驱动舵机工作的频率为也就是周期为这里对应设置为设置为舵机旋转角度对应的周期为的高电平时长对应占空比为到即设置的范围应该是对应配置流程与上一个实验一样复用推挽模式为舵机的信号线模式有效电平为高电平输出状态使能配置这里时通用定时器只需要列举需要的参数即可高级定时器的参数可以不用管设置舵机角度按键按下舵机旋转度实验驱动电机相关知识见库笔记对应两个输入引脚一个输入一个给高低电平可以实现正反转对应查表见库对应章节对应占空比越高电机转速越快这里两个输入引脚为为引脚为低电平引脚配置引脚为输出模式复用推挽模式配置引脚为复用推挽输出模式模式有效电平为高电平输出状态使能修改的值可以改变转速这里时通用定时器只需要列举需要的参数即可高级定时器的参数可以不用管设置为低电平转速最大值可以设置为最大值输入捕获功能简介输入捕获输入捕获模式下当通道输入引脚出现指定电平跳变时当前的值将被锁存到捕获寄存器中可用于测量波形的频率占空比脉冲间隔电平持续时间等参数全称捕获比较寄存器使用输入捕获时就是捕获寄存器使用输出比较时就是比较寄存器每个高级定时器和通用定时器都拥有个输入捕获通道可配置为模式同时测量频率和占空比可配合主从触发模式实现硬件全自动测量频率测量测频法测频率适合测量高频信号计次数量多一些有助于减小误差特点测量结果更新速度较慢但是平均值相当于均值滤波结果比较稳定测周法测周期适合测量低频信号周期比较长计次比较多有助于减小误差特点只测量一个周期测量结果更新速度较快但结果值会受噪声的影响波动比较大为标准频率标准频率就是经过分频后的时钟频率在这里可以是使用输入捕获时定时器的频率使用时需要每次触发后将的值清才是一个周期中界频率待测信号频率中界频率时选用测频法误差更小待测信号频率中界频率时选用测周法误差更小根号下输入捕获通道同一个引脚的输入信号映射到两个输入通道和且两个通道的极性检测相反即这里的引脚的输入信号可以映射到和连接到的是输入通道连接到的是输入通道可以使用两个捕获寄存器引脚的输入信号可以映射到和连接到的是输入通道连接到的是输入通道也可以使用两个捕获寄存器一共四种连接方式输入捕获的直接模式和间接模式信号从引入在自己的捕获寄存器上进行输入捕获就叫做输入捕获的直接模式信号从引入借用捕获寄存器进行输入捕获则叫做输入捕获的间接模式交叉模式主从触发模式主从触发模式是主模式从模式触发源选择这三个功能的简称主模式可以将定时器内部信号映射到引脚用于触发别的外设从模式接收其他外设或者自身外设的一些信号用于控制自身定时器的运行也就是被别的信号控制触发源选择就是选择从模式的触发信号源的可以认为是从模式的一部分选择指定的一个信号得到去触发从模式在从模式列表中选择一项操作自动执行如选择触发源选择操作就可以自动触发从模式从模式自动清零主模式选择可以在对应手册控制寄存器中查看从模式选择可以在对应手册从模式控制寄存器中查看输入捕获模式和输入模式基本结构图特点只使用了一个通道只能测量频率使用的是测周法测量频率所以需要每次触发后将的值手动清我们可以使用选择从模式触发实现信号触发后自动清公式得来在待测频率的一个周期内的计数为所以待测频率的一个周期时长又因为所以为标准频率标准频率就是经过分频后的时钟频率在待测频率的两个上升沿期间时钟按照的频率自增当监测到第二个上升沿的值被锁存到中如果开启中断捕获事件发生时会产生中断请求进入对应的输入捕获回调函数然后可以读取的值如果没有配置从模式自动清零那么需要我们手动在回调函数中对清零因为要自增不能让他溢出所以的值要设置的足够大设置为上限模式输入模式使用两个通道来捕获可以测量频率和占空比使用的是测周法测量频率所以需要每次触发后将的值清使用从模式实现信号触发后自动清下面部分和以相反的极性检测检测上升沿检测下降沿待测频率一整个周期的计数值两个上升沿期间每一次上升沿到来时对应都会清零带测频率高电平期间的计数值上升沿和下降沿期间占空比因为要自增不能让他溢出所以的值要设置的足够大设置为上限按照待测频率进行自增如果开启中断捕获事件发生时会产生中断请求进入对应的输入捕获回调函数然后可以读取的值如果没有配置从模式自动清零那么需要我们手动在回调函数中对清零上面部分但我们选择触发源使用从模式配合输入捕获实现自动清零完成硬件自动化相关介绍对应在参考手册的输入捕获和输入模式对应部分库函数初始化函数配置输入捕获单元函数输出比较是四个通道分别有一个函数而输入捕获配置是个通道共用一个函数具体通道选择在结构体中也是配置输入捕获单元的函数但是这个函数可以快速配置两个通道将外设电路配置为模式传入一个结构体之后该函数会根据传入结构体通道配置自动初始化另外一个通道为相反的配置比如传入结构体配置为通道上升沿触发直接模式调用该函数就会配置通道为下降沿触发且为交叉模式间接模式该函数只支持通道和通道不能传入通道和通道输入捕获结构体初始化一般在某些参数不用初始化的时后调用防止没有初始化某些值造成意外错误主从模式相关函数选择输出触发源对应主模式输出的触发源选择输入触发源对应从模式的触发源选择选择从模式对应从模式执行操作预分频配置分别配置通道的预分频值这个参数可以在结构体中配置获取捕获寄存器值分别获取四个通道的捕获寄存器的值输入捕获配置流程根据上面的结构图可以得到输入捕获配置流程开启时钟将和的时钟打开初始化配置为输入模式上拉或者浮空配置时基单元的时钟源配置时基单元让计数器在内部时钟的驱动下自增运行配置输入捕获单元包括滤波器极性直连通道还是交叉通道分频器等参数配置从模式触发源触发源选择等调用库函数配置从模式执行的操作调用库函数运行控制开启定时器实验输入捕获模式测频率输入捕获直接模式这个地方没有信号发生器选择将另外一个引脚输出信号输入到该引脚从输入到开启对应和时钟配置为时基单元时钟源配置时基单元配置标准频率输入捕获单元配置滤波值越大滤波效果越好上升沿捕获对应触发信号分频器不分频就是每次触发都有效分频就是每隔一次生效一次输入捕获直接模式从模式触发源配置配置从模式输入触发源从模式执行操作配置从模式操作使自动清运行控制启动这里的是为了弥补的误差这个地方标准频率即为经过分频过后的频率测量最低频率为再低会溢出如果想要降低最低频率只需要增大的值如果想要增大最低频率只需要减小的值输出信号输入捕获实验模式测频率和占空比输入捕获交叉间接模式开启对应和时钟配置为时基单元时钟源配置时基单元配置标准频率输入捕获单元配置滤波值越大滤波效果越好上升沿捕获对应触发信号分频器不分频就是每次触发都有效分频就是每隔一次生效一次输入捕获直接模式输入捕获模式和模式差别就在这里下降沿捕获与通道一相反输入捕获交叉模式从模式触发源配置配置从模式输入触发源从模式执行操作配置从模式操作运行控制启动获取频率这里的是为了弥补的误差获取占空比弥补误差使用函数可以快速配置两个通道见源码可知该函数自动初始化该通道和初始化另外一个通道为相反的配置不使用该函数就配置两次即可即上方注释部分通道配置为上升沿捕获直接模式通道就配置为下降沿捕获交叉模式调用两次初始化函数即可输出信号输入捕获编码器接口编码器接口简介编码器接口编码器接口可接收增量正交编码器的信号根据编码器旋转产生的正交信号脉冲自动控制自增或自减从而指示编码器的位置旋转方向和旋转速度每个高级定时器和通用定时器都拥有个编码器接口基本定时器没有编码器接口两个输入引脚借用了输入捕获通道的通道和通道之前我们使用了编码器中断来手动计次使用编码器接口可以实现自动计次减少资源浪费避免频繁中断正交编码器介绍拥有相和相输出的两个正交方波信号相位相差超前和滞后代表正传和反转编码器测速使用的是测频法测量编码器的上升沿和下降沿都有效正传自增反转自减三种工作方式仅在计数仅在计数在和都计数一般我们使用第三种编码器接口执行逻辑总结下来就一句话正转的时候向上计数反转的时候向下计数正交编码器是抗噪声的原理当遇到毛刺现象时的值会来回跳动一会自增一会自减但最终的值保持不变当极性选择反相时需要将图中的波形反向后才能得到正确的计数方向当我实际使用过程中如果出现想要正传计数但是却出现的情况我们把任意一个引脚极性反相就能反转计数方向了或者直接交换相引脚即可应用比较常见的应用场景编码器测速一般应用在电机控制的项目上使用驱动电机再使用编码器测量电机的速度然后再用算法进行闭环控制一般电机旋转速度较高会使用无接触式的霍尔传感器或者光栅进行测速这里为了方便我们使用触点式的旋转编码器电机旋转呢我们就用人工旋转来模拟但实际上旋转编码器和电机的霍尔光栅编码器都是一样的效果编码器接口基本结构图对应的和的与和无关是有效的一般设置为利用补码的特性可以从自减时得到的是编码器的时钟会直接托管驱动计数器所以在编码器接口模式下时基单元不需要配置内部时钟并且计数模式无效同时输入捕获单元并没有完全使用只需要配置滤波器和极性选择即可更多内容可以在参考手册中的编码器接口模式中查看库函数配置编码器接口的函数参数哪个定时器参数编码器模式三种仅在计数仅在计数和都计数一般我们使用第三种都计数参数通道极性为不反相为反相参数通道极性为不反相为反相参数和参数根据实际情况选择编码器接口配置流程开启时钟开启和对应的时钟配置将对应引脚配置为输入模式配置时基单元预分频器不分频设置为不用配置时基单元的内部时钟编码器会托管相当于外部时钟配置输入捕获单元此处输入捕获单元只有滤波器和极性两个参数有用其他参数没用到配置编码器接口模式运行控制启动定时器初始化完成后就会随着编码器旋转而自增自减如果想要读出编码器位置直接读出的值就行了如果想要测量编码器的速度和方向就需要每隔一定阀门时间取出一次然后再把清零即测频法测量速度实验正交编码器测速我们使用的是相相对应定时器和配置开启和对应端口配置配置相端口为输入编码器接口就不用这个因为编码器接口就是一个带方向控制的外部时钟内部时钟没有用了时基单元配置参数无效编码器托管不分频编码器的时钟直接驱动计数器输入捕获单元配置部分参数未使用调用该函数防止未初始化参数产生影响编码器上升沿和下降沿都有效所以此处代表极性不反转编码器上升沿和下降沿都有效所以此处代表极性不反转编码器接口配置这里的极性与上方极性配置的同一个寄存器可以删除上方极性配置运行控制使能放到缓存的当中再清零即可最终在主循环中实现延时即可测一次速如果实现效果与想要的不符合修改编码器接口配置中任意一个引脚的极性参数即可此处在循环中使用了函数影响了效率更加好的办法是开启一个的定时器中断在定时器中断中更新的值即可简介模拟数字转换器可以将引脚上连续变化的模拟电压转换为内存中储存的数字变量建立模拟电路到数字电路的桥梁位逐次逼近型的转换时间转化频率为输入电压范围转化结果范围的次方一共个输入通道可测量个外部信号和个内部信号源内部温度传感器和内部参考电压不随外部电压变化分为规则组规则通道和注入组注入通道两个转换单元可模拟看门狗自动监测输入电压范围资源个外部输入通道对应所有的知识都能在芯片参考手册中查看内部结构逐次逼近型通过二分法给值进行比较直到找到未知电压编码比如位先给再给相当于二进制的高位到低位对于位高位到低位判断次即可找到位置电压编码对于位高位到低位判断次即可找到位置电压编码的就是对应的个外部信号温度传感器和就是内部个信号源通道分为注入通道注入组和规则通道规则组规则通道可以同时转选择个通道但是对于转化结果因为规则通道只有一个数据寄存器所以存在数据覆盖问题如果不想结果被覆盖需要在转换完成后尽快把数据拿走此时一般配合进行搬运注入通道可以同时选择个通道拥有四个数据寄存器不用担心数据被覆盖对应规则通道和注入通道可以在参考手册中找到对应介绍流程前面的通道选择后到模拟至数字转换器然后模拟至数字转换器中就执行逐次比较的过程最终结果放在了注入通道规则通道数据寄存器中转换结束后会有一个信号该信号是规则组或注入组的完成信号还有个是注入组完成的信号会置状态寄存器标志位可以读取该标志位判断是否转换完成同时这两个标志位也可以去到申请中断如果开启对应通道就可以触发中断触发转换部分对应信号启动的转换对应触发开始转换的信号有两种软件触发和硬件触发硬件触发对应图中注入组的触发源和规则组的触发源主要来自定时器在定时器章节中我们知道定时器可以通向外设用于触发转换也可以使用外部中断引脚触发比如图中我们给指定时间将的更新事件选择为输出再把选择开始触发信号为这样的更新事件就能通过硬件自动触发转换了不需要进中断软件触发程序中调用代码完成转换触发时钟时钟来自经过预分频器到达注意此处最大位分频和分频结果超过了最大值不建议使用这里至少分频预分频器小于即可模拟看门狗模拟看门狗用于监测转换结果的范围其中可以存一个阈值高限和阈值低限如果启动了看门狗并且设定了通道该看门狗就会关注看门的通道一旦超过阈值范围就可以申请一个通向的中断输入通道我们可以在引脚定义表中找到对应通道的通道对应引脚这代表该芯片只有个通道同时我们可以发现这样写代表和都是这个引脚我们可以单独使用一个也可以同时使用还有一种高级模式叫双模式就是和一起配贼和使用可以配合组成同步交叉模式等可以进一步提高采样率转换模式一共有四种转换方式多通道只能使用后面两种模式必须开启扫描模式单次转换非扫描模式只会转换第一个序列的通道每次转换都需要触发一次想要更换通道转换只需要更改序列的通道即可连续转换非扫描模式只会转换第一个序列的通道但触发转换后不会停止会一直持续转换只需要第一次触发即可单次转换扫描模式按顺序依次转换一组通道可以指定通道数目指定的所有通道转换完成后才会触发信号每次转换都需要触发连续转换扫描模式按顺序依次转换一组通道可以指定通道数目指定的所有通道转换完成后才会触发信号只需要一次触发就可以一直转换其实还有个间断模式可以说是对扫描模式的补充触发一次转换一个通道在触发在转换在所选转换通道循环由触发信号启动新一轮的转换直到转换完成为止例如可以把这四个通道进行分组可以分成一组一组也可以每个通道单独配置为一组这样每一组转换之前都需要先触发一次触发控制数据对齐寄存器总共位需要对齐高位或低位补一般使用右对齐可以直接读取寄存器就是结果左对齐得到的结果比实际值偏大倍对于裁剪分辨率使用转换时间量化编码就是逐次比较的过程位数越多花费时间越长采样保持量化编码需要时间通过开启采样开关一段时间后断开后使电压在量化编码时保持不变总转换时间中采样时间就是采样保持时间采样时间可以在程序中配置时间越长越能避免毛刺信号的干扰但会导致转换时间延长个周期量化编码所花费时间因为是位所以需要个周期多余的周期可能做了一些其他事情个周期采样时间选择需要更快的转换就选小的参数但容易受干扰需要更稳定的转换就选大的参数转换时间长校准校准过程我们不需要理解校准过程固定只需要在初始化的最后加几行代码就行了至于怎么计算怎么校准的我们不需要管流程复位校准等待复位校准判断标志位开始校准等待校准判断标志位硬件电路第一个是电位器产生可调电路通过滑动变阻器可以调节电压第二个是传感器输出电压电路光敏电阻热敏电阻等都可等效为一个可变电阻电阻阻值没法直接测量一般直接通过和一个固定电阻串联分压来得到反应电阻值电压的电路固定电阻一般可以选择和传感器阻值相近的电阻较好传感器阻值变小时下拉作用变强输出端电压就下降传感器阻值变大时下拉作用变弱输出端受上拉作用电压就会升高第三个是一个简易电压转换电路使用电阻分压根据分压公式可以得到中间的电压位高电压一般不适用比较危险高电压一般使用一些采集芯片做好高低电压的隔离基本结构图库函数配置分频器在中可以找到该函数用于配置分频器可以对的时钟选择分频输入到初始化恢复缺省配置启动开启开启输出信号使用需要调用通道配置规则组通道配置为序列添加通道参数对应参数指定通道参数对应序列号参数指定通道采样时间多个通道指定时多次调用该函数配置即可外部触发转换控制是否允许外部触发转换中断用于控制某个中断能否通往控制校准在初始化完成后依次调用即可复位校准获取复位校准状态开始校准获取开始校准复位状态触发控制软件触发控制调用即可设置为软件触发获取软件开始转换状态返回状态与转换是否结束无关一般不适用间断模式配置间断模式配置设置可以设置每隔几个通道间断一次使能间断模式转换结束判断参数给标志位可以判断是否转换完成获取转换值获取转换数据寄存器读取转换结果双模式读取转换结果注入组模拟看门狗是否启动看门狗配置看门狗高低阈值配置看门通道内部信号配置温度传感器内部参考电压控制用于开启内部两个通道需要使用时调用开启即可标志位常用的标志位相关函数带的应该在中断服务函数中使用配置流程打通上方基本结构图即可开启时钟开启和时钟配置分频器配置配置对应为模拟输入的模式配置多路开关将左边对应通道接入规则组注入组中规则注入通道配置配置转换器结构体单次转换连续转换扫描非扫描几个通道等如果需要模拟看门狗配置阈值和监测通道没有就跳过如果想要使用中断使用开启对应中断输出配置即可没有跳过开启调用函数校准减小误差实验读取电位器电压单通道对应引脚定义可知电位器对应通道为选择即可开启时钟和预分频器配置不能超过至少分频配置为模拟输入规则通道配置将通道写入规则通道的第一个位置序列如果还有其他通道继续调用配置即可如果还有其他通道继续调用配置即可转换器配置转换模式该参数为独立工作剩余的其他参数都是双模式数据右对齐这里选择软件触发剩下的都为硬件触发启动连续转换模式是否启动扫描模式指定扫描模式下总共使用的通道数开启校准复位校准寄存器由软件置后开始复位校准完成后硬件自动清该位寄存器由软件置后开始校准校准结束后硬件自动清该位在启动连续转换模式时只需要在这里触发转换一次即可不需要每次获取值都调用获取值流程触发转换判断标志位等待转换完成读取转换结果触发转换上面没开启连续转换模式开启连续转换模式只需要启动一次即可启动软件触发转换也可以使用硬件触发判断标志位等待转换完成在手册中有介绍转换完成前为转换完成后自动置等待转换时间为上面设置的采样周期个周期时间为读取转换结果读取寄存器时自动清除位根据精度对应计算出电压值注意实验中得到的值末尾持续抖动这是正常波动但是如果我们需要对该值进行判断再执行一些操作时比如值大于某一值开灯小于某一值就关灯此时由于值存在波动就可能会来回开灯关灯解决方法使用迟滞比较法设置上下阈值高于上阈值开灯低于下阈值关灯类似于施密特触发器如果数据跳变太厉害可以使用均值滤波的方式读取个值取平均值作为输出结果还可以裁剪分辨率去掉数据的尾数也可以避免跳动实验多通道采集多通道采集我们想到的是启动扫描模式但是存在数据覆盖的问题扫描模式是会一次将所有通道全部转换完之后才会发出信号每一个通道单独转换完成不会产生任何标志位也不会有中断同时转换很快所以我们很难做到在一个通道转换完成后将数据手动转移但是很难不是不行我们可以使用间断模式扫描时没转换一个通道就暂停一次我们此时可以转移数据再继续触发继续下一次转换由于没有单个通道转换完成后没有标志位我们只能通过的方式延时等待转换时间所以这种方式不推荐所以如果我们想用扫描模式实现多通道最好配合来实现扫描模式搬运实现多通道采集见下一节实验其实我们可以使用单次转换非扫描模式实现只需要为添加一个的参数调用时都重新配置规则通道再触发转换即可简介直接内存访问是一个数据转运小助手主要是协助完成数据转运的工作无须干预就可以干其他更重要的事这里的外设一般指外设数据寄存器存储器一般指运行内存和程序存储器存储变量数组和程序代码的地方存储器到存储器的数据转运一般使用软件触发比如从到因为软件触发是以最快的方式一股脑搬运过去越快越好存储器到外设的数据转运一般使用特定硬件触发每个外设对应通道比如一个通道转换完成后硬件触发一次再转运这样得到的值才正确常见的用途最常见配合的扫描模式解决数据覆盖问题各外设提高效率阅读参考手册获得所有介绍存储器映像存放我们编译后的程序以及常量数据等程序的临时变量存储变量地址都是以开头外设寄存器对应每个外设的寄存器内核外设只有和与其他外设不是一个厂家设计的所以地址被分开了在的数据手册也会有个存储器映像的图里面可以查看各外设起始地址等在对应代码的宏定义不断跳转我们可以看到定义的外设等基地址也是上表中给出的地址通过基地址偏移量可以得到各外设地址等框图主要包括用于访问各个存储器的总线内部的多个通道可以进行独立的数据转运仲裁器用于调度各个通道防止产生冲突从设备是自身的寄存器用于配置参数请求用于硬件触发的数据转运寄存器各个外设都可以看成是寄存器也是一种存储器寄存器是一种特殊的存储器一方面可以对寄存器进行读写另一方面寄存器的每一位背后都连接了一个线这些线可以用于控制外设电路的状态比如设置引脚高低电平导通和断开开关等或者多位组合起来当做计数器数据寄存器等寄存器是连接软件和硬件的桥梁软件读写寄存器就相当在控制硬件的执行外设寄存器有些是只读的有些是可读可写的具体看参考手册上的介绍请求请求就是触发的意思请求线路的触发源是各个外设请求就是的硬件触发源比如转换完成串口接收到数据时需要触发转运数据时就会通过这条线路向发出硬件触发信号之后就可以在执行数据转运的工作了这里是只读存储器的一种如果通过总线直接访问无论是还是都是只读的如果转运的目的地址填写的是就会出错可以任意读写基本结构图图中所有参数都是使用结构体配置有个方向控制的参数可以控制外设寄存器到存储器的方向外设寄存器和存储器都有三个参数起始地址数据宽度地址是否自增传输计数器用于指定转运次数是一个自建计数器每转运一次值减直到减小到之后停止转运对应自增过后的地址恢复到起始地址的位置以方便开始新一轮转换注意不能在开启时写传输计数器这是手册的规定需要写计数器时按照即可失能写传输计数器使能自动重装器传输计数器减小到之后是否需要恢复到最初的值指定重装就是循环模式触发控制决定什么时间进行转运由参数决定软件触发还是硬件触发软件触发一般用于存储器到存储器的转运这些转运不需要一定时机参数为时为软件触发并不是调用一个函数一次就触发一次而是以最快的速度连续不断的触发以最快速度将传输计数器减少到与外部中断和的软件触发可能不太一样可以理解为自动连续触发软件触发和循环模式不能同时使用因为软件触发是想把计数器清而循环模式会重载就停不下来了硬件触发一般用于与外设有关的转运转运需要一定时机当硬件达到这些时机时传一个信号触发进行转运比如转换完成等参数为时为硬件触发触发源可以选择串口定时器等等开关控制函数转运需要有三个条件使能开关控制传输计数器不为必须要有触发源请求映像每个通道有一个数据选择器选择硬件触发或者软件触发位决定数据选择器是否工作硬件触发注意每个外设触发通道都不一样所以我们在选择硬件触发源时一定要先找到对应通道触发比如在通道定时器更新事件在通道对应的有函数等软件触发和通道任意选择每个通道软件触发都是一样的优先级类似与中断优先级判断通道号越小优先级越高也可在程序中配置数据宽度与对齐源端宽度和目标宽度相同时和不同时的数据传输处理与变量赋值类似源端宽度目标宽度不变源端宽度目标宽度高位补源端宽度目标宽度高位舍弃例子数据转运存储器到存储器转运不需要转运时间同步等使用软件触发即可扫描模式外设到存储器我们需要在每个单独的通道转换完成后进行一个转运并且使目的地址自增源地址不自增方向为外设到存储器传输计数器次连续扫描可以使用自动重装使和同时工作转运时机需要和单个通道转换同步所以触发要选择硬件触发单个通道转换完成时应该可以触发传输否则无法完成库函数初始化相关函数使能对应通道第一个参数不再是而是即选择了哪个又选择了的通道几的通道几软件触发随意选择通道硬件触发先查看手册找到对应外设的通道在设置中断输出使能传输计数器值设置和获取标志位相关函数获取标志位状态清除标志位获取中断状态清除中断挂起位配置流程根据基本结构图配置如下开启时钟配置调用初始化各个参数外设和存储器站点的起始地址数据宽度地址是否自增方向传输计数器是否需要自动重装选择触发源等参数如果需要中断调用开启中断输出配置各个参数写好对应中断服务函数即可不用中断可以直接跳过使能函数别忘了对应在外设开启触发信号输出实验数据转运存储器到存储器不涉及外围硬件电路故文件放在文件夹中开启时钟配置外设站点起始地址外设站点数据宽度这里以字节传输地址是否自增这里启用存储器站点起始地址存储器站点数据宽度地址是否自增传输方向这里选择的是外设站点作为数据源传输计数器的值其实就是传输次数一次传输上面设置的数据宽度的值传输模式就是是否使用自动重装不重装是循环重装配置软件触发还是硬件触发位是软件触发配置优先级选择中等软件触发使用任意通道都可使能修改传输计数器的值使能循环传输等待转换完成清除标志位加上发现存储在区实验多通道采集多通道连续转换扫描模式循环转移有几个通道的结果长度就设定为几开启时钟和以及预分频器配置不能超过至少分频配置为模拟输入规则通道配置将通道分贝写入规则通道的第一个位置和第二个位置序列序列还有通道继续配置即可转换器配置转换模式该参数为独立工作剩余的其他参数都是双模式数据右对齐这里选择软件触发剩下的都为硬件触发启动连续转换模式是否启动扫描模式这里多通道启动指定扫描模式下总共使用的通道数使用了几个通道就填几配置寄存器地址选择半字位传输对于位舍弃位地址是否自增这里对同一个地方的值运输不启用存放到中的数组中以半字位传输由于多个值需要移动数组的地址需要自增传输方向这里选择的是外设站点作为数据源其实就是传输次数一次传输上面设置的数据宽度的值这里两个通道一共传输次传输模式就是是否使用自动重装不重装是循环重装配置硬件触发位为配置优先级选择中等查看手册得到通道为只能使用通道使能和开启到输出必须在使能之前开启输出到使能校准复位校准寄存器由软件置后开始复位校准完成后硬件自动清该位寄存器由软件置后开始校准校准结束后硬件自动清该位触发转换连续转换扫描模式下循环模式下只需要触发一次和都不用等待和就同时开始持续协同工作了这里是触发使用单次转换时需要的启动软件触发转换不需要等待转换完成了只需要等待等待传输完成清除标志位根据精度对应计算出电压值连续转换扫描模式下配合只需要触发转换后每当有一个通道转换完成迅速将值转运到中我们直接对的值进行读取即可这里我们其实还可以再加一个定时器用单次扫描再用定时器去定时触发即定时器触发触发这样的好处就是整个过程完全自动不需要手动进行操作节省软件资源实现硬件自动化通信接口接口简介这里列举的是最常用最简单的配置还有很多配置没有列出全双工一般都有两根数据线比如串口串口通信介绍串口是点对点通信就是一对一之间通讯图一转串口模块上面是芯片可以将串口协议转换为协议端可以接在电脑上另一端串口引脚接在支持串口的芯片上图二陀螺仪传感器模块测量加速度角速度一边是串口引脚一边是引脚图三蓝牙串口模块上面的芯片可以和手机互联实现手机遥控单片机的功能串口驱动芯片作为和串行通信之间的桥梁它允许你的电脑通过端口与仅支持串行通信协议的设备如许多基于的开发板进行通信安装了正确的驱动后电脑上的应用程序例如串口调试工具编程软件等才能通过这个虚拟出来的端口与开发板交换数据串口连接我们电脑时对应设备管理器中找到是否有的驱动没有的安装即可有的话就可以使用了硬件电路一般串口通信模块有四个引脚简单的串口通信只有和两个信号线复杂的还有时钟线和是单端信号它们的高低电平都是相对于所以串口通信的是必须接的对于如果两个设备都有独立供电可以不用接如果其中一个设备没有供电比如设备是设备是蓝牙串口模块有独立供电蓝牙串口模块没有独立供电此时就需要把蓝牙串口的和的接在一起两根通信线为全双工只接一根通信线的情况下就变成了单工通信电平标准不一致需要加电平转换芯片才能通信一般设备直接出来的是电平需要另外一个也是电平才能通信电平标准电平单片机这种低压小型设备使用的都是电平最远几十米所以在单片机中如果线路对地是就代表发送了逻辑对地是就代表发送了逻辑最远几十米两线压差所以电平是差分信号差分信号的抗干扰能力非常强使用电平标准通讯距离可以达到上千米不同的电平间加上电平转换芯片即可使用串口参数及时序波特率每秒传送码元的个数单片机中的话一个码元对应一位码元对应起始位空闲状态时为高电平起始位为低电平产生一个下降沿标志数据发送的开始数据位低位先行从数据的低位开始发送可以把校验位算在数据位中也可以把校验位单独出来校验位三种方式无校验奇校验偶校验根据数据来决定是还是停止位固定为高电平为下个起始位做准备数据帧格式位位起始位低电平数据位停止位高电平位位位位数据位不含有奇偶校验位位数据为最后一位添加了一位奇偶校验位简介一般串口很少使用同步功能只是多了个时钟输出只支持输出不支持输入同步模式更多是为了兼容别的协议和其他用途并不支持两个之间进行同步通信硬件流控制在之间有一根单独的一根线高低电平可以决定接收方是否准备好准备好了再发送可以防止接收方处理慢而导致数据丢失的问题我们一般不使用串口有大量的数据时可以使用减小负担提高效率框图发送数据寄存器只写当数据从全部到发送移位寄存器中后标志位发送数据寄存器为空会置此时检查这个标志位为的话就可以就可以写入下一个数据到发送移位寄存器把一个字节的数据一位一位地移出去正好对应串口协议的波形数据位通过下方发送器控制向右移位一位一位地把数据输出到引脚正好对应串口的低位先行当数据移位完成后新的数据会再次自动的从移动到发送移位寄存器中移位未完成时会等待完成发送整个过程连续效率高接收数据寄存器只读接收移位寄存器数据从引脚通向接收移位寄存器在接受器控制下一位一位地读取电平先放在最高位然后向右移当这一个字节数据移位完成后整体全部转移到接收数据寄存器中此时将接收数据寄存器非空检测到置之后就可以将数据从读走硬件数据流控流控如果发送设备发得太快接收设备来不及处理就会出现丢弃或覆盖数据得现象有了流控就可以避免这个问题一般不使用对应有两个引脚请求发送是输出脚告诉别人当前是否能接收代表低电平有效是清除发送是输入脚用于接收别人信号代表低电平有效两个有流控的设备和交叉连接即可引脚接对方引脚用于判断对方能否接收引脚接对方引脚用于告诉对方我能不能接收右边边的产生同步的时钟信号用于配合发送移位寄存器输出只支持输出不支持输入两个之间不能实现同步的串口通信我们一般不使用作用兼容别的协议串口加上时钟后和很像所以可以兼容协议自适应波特率唤醒单元实现多设备功能一般不使用中断控制两个标志位比较重要发送中断标志位和接收中断标志位这两个标志位可以去申请接收中断和发送中断就可以在接收或者发送数据时直接进入中断服务函数其他的标志位看手册可以知道有什么作用波特率发生器波特率发生器其实就是分频器对时钟进行分频得到发送器和接收器的时钟对应所有的寄存器等更多知识都能在参考手册中查看基本结构波特率发生器用于产生约定的通信速率对于和在软件层面只有一个寄存器可以让我们读写只不过是在接收或者发送时走上面或者下面这条路开关控制对应的函数数据帧发送电路四种选择位字长无校验位字长有校验位字长无校验位字长有校验起始位侦测接收电路以波特率的倍进行采样一位的长度中每三位至少有个否则认为是噪声采样位设置在之后也这样采样就能保证在数据中间数据采样连续采样三次无噪声下三次采样都为或如果有噪声以进行确定次数据就为次采样的数据就为此时会对噪声标志位置告诉收到数据但有噪声波特率发生器分频系数分为整数部分和小数部分可以实现更细腻的分频是因为内部有一个倍波特率的采样时钟所以波特率倍波特率最终计算波特率要多除以一个例配置波特率带公式得到然后将写入到该波特比率寄存器中转换为进制写入有整数位和小数位我们使用库函数直接输入需要的波特率即可自动计算配置完成数据模式通过串口助手显示的数据有以上两种方式和以原始数据等的形式显示为十六进制将原始数据按照编码码表对应显示对应编码为库函数中找到初始化函数这两个函数用于配置同步时钟输出的包括时钟使能极性相位等参数使用结构体中断配置相关使能使能开启对应的到的触发通道发送和接收数据写寄存器读寄存器标志位相关终端外使用的标志位函数中断服务程序中使用的标志位函数不常用设置地址唤醒一大段函数智能卡等相关函数不怎么使用配置流程开启时钟打开需要的和时钟配置对应配置为复用输出配置为上拉或浮空输入配置使用结构体配置即可如果需要接收中断加上和配置即可如果不需要中断跳过配置即可使能测试串口发送和串口接收包括对的初始化和对一些常用的函数封装发送一个字符发送数组发送字符串幂函数发送数字开启时钟打开需要的和时钟配置对应配置为复用输出配置为上拉或浮空输入如果只选择一种模式那么就只配置一个引脚即可引脚配置引脚配置配置使用结构体配置即可波特率配置硬件流控配置这里不适用这里配置串口接收和发送模式都使用可以只配置一个校验位不使用校验停止位配置位数据位长度没有奇偶校验位所以选择位数据位如果需要使用中断需要在此处调用函数然后再配置即可使能等待数据移动到移位寄存器中避免发生数据覆盖手册中可以知道下一次调用时该标志位会自动清加上一个字符得到对应数字的码需要两个转义字符才能换行代表回车代表换行实验串口接收单字节轮询中断在循环中轮询读取手册可知该标志位再下方调用读取时会自动清使用中断自定义标志位自定义方法开启时钟打开需要的和时钟配置对应配置为复用输出配置为上拉或浮空输入如果只选择一种模式那么就只配置一个引脚即可引脚配置引脚配置配置使用结构体配置即可波特率配置硬件流控配置这里不适用这里配置串口接收和发送模式都使用可以只配置一个校验位不使用校验停止位配置位数据位长度没有奇偶校验位所以选择位数据位如果需要使用中断需要在此处调用函数然后再配置即可配置中断和使能使用也是同样的效果自定义清除标志位中断服务函数这段代码启动了接收中断就可以通过判断标志位来多次触发中断标准库这样写可以重复触发中断发送一次触发一次而库中除了刚开始要启用还需要在中断回调函数中重新启用中断才能多次触发这就是标准库和库在使用上的不同地方该实验只能实现对单字符的接收实验串口数据包实验函数的移植在中使用函数之前我们需要打开工程选项找到勾选使用微库是为嵌入式平台优化的一个精简库方法的重定向默认输出到屏幕但是单片机没有屏幕所以需要我们重定向到串口在对应串口模块中该定义的结尾加上该头文件在中再进行引用一次即可在调用时使用了是函数底层使用时是不断调用进行打印的我们把函数重定向到串口中这种方法只能将输出到调用串口发送函数的那一个串口当中无法在其他串口中使用解决方法使用标准库函数方法函数使用中的作用是发动格式化字符串到指定中可以实现拼接字符串这样即可实现每个串口的格式化打印方法三使用可变参数封装使用头文件具体封装过程百度即可数据包数据包介绍数据包分为数据包和文本数据包分别对应文本模式和模式作用将属于同一批的数据进行打包和分割数据包通过添加包头包尾分割数据数据包头数据包尾优点传输最直接解析数据非常简单比较适合一些模块发送原始的数据比如一些使用串口通信的陀螺仪温湿度传感器数据缺点灵活性不足载荷容易和包头包尾重复可能传输的数据是包头包尾的数据解决方案限制载荷数据的范围在发送时对数据变化范围显示如果无法避免载荷数据和包头包尾重复我们就尽量使用固定长度的数据包经过几个数据包的数据对齐后剩下的数据包应该就没有问题了增加包头包尾的数量并且尽量呈现出载荷数据出现不了的状态数据包格式选择如果数据容易出现与包头包尾重复的情况就最好选择固定包长如果数据不容易出现与包头包尾重复的情况可以选择可变包长这样就非常的灵活只需要确定唯一的包头包尾就知道数据包长度文本数据包在数据包中数据是以原始字节数据本身呈现而在文本数据包中每个字节都经过了编码和译码表现出的就是文本格式但实际上都还是一个字节的数据文本数据包基本不用担心载荷和包头包尾重复的问题包头包尾载荷数据除了包头包尾的数据优点数据直观易理解非常灵活比较适合一些输入指令进行人机交互的场合比如蓝牙模块常用的指令和打印机常用的代码缺点解析效率低比如发送的就是一个字节文本数据包却是三个字符数据包的发送和接收数据包的发送使用串口对应发送数组数据包或者字符串函数文本数据包即可数据包的接收固定包长数据包接收使用状态机编程思想先根据项目要求定义状态画几个圈然后考虑号各个状态会在什么情况下会进行转移如何转移画好线和转移条件最后根据这个来编程可变包长文本数据包接收实验串口收发数据包此处只列举出了新添加的变量和函数具体的见上方发送数据包包头包尾自定义包头固定长度为的数据包尾使用状态机的编程思想每次中断接收一个字节数据使用串口助手发送可以发现串口回显上显示的数据实验串口收发文本数据包接受完成标志还可以避免接收太快来不及使用数据就被覆盖了接收慢一点等主函数使用完避免主函数中的数据可能是上一个数据包和这个数据包中的内容组成完成字符串使用完成数据标志可以避免接收太快之前那种方式可能会造成接收过快数据覆盖问题使用串口助手发送换行回车灯亮起使用串口助手发送换行回车灯熄灭介绍特点同步半双工两根通信线和第个模块模块进行姿态测量使用通信协议第个模块模块显示图片字符灯信息使用协议第个模块存储器模块使用协议第个模块实时时钟模块使用协议多主多从相当于发生总线冲突协议会进行仲裁胜利的一方取得总线控制权失败的一方变回从机同时在多主机的模型下还要进行时钟同步硬件电路与优缺点一主多从模式上挂载多个从设备任何情况下从机不允许控制对于数据线从机不允许主动发起对的控制只有等待主机发送请求时从机响应才能短暂获取采用外置弱上拉电阻加开漏输出的电路结构选择开漏输出而不选择推挽输出如果使用推挽输出如果总线时序没调整好可能主机和从机都处于输出状态且一个输出高电平一个输出低电平此时就会出现电源短路的问题而开漏输出只能直接输出低电平高电平下没有驱动能力输出取决于外部电路这样的话就保证了所有设备都只能输出低电平而不能输出高电平加上拉电阻为了避免开漏输出高电平时造成的引脚浮空同时通信需要输出高电平的能力由于开漏输出下不能直接输出高电平此时需要在外部加一个上拉电阻此时为弱上拉使能被外部拉高这样设计电路的好处完全杜绝电源短路现象保证电路安全避免引脚模式的频繁切换开漏加弱上拉的模式同时兼具了输入和输出的功能开漏模式下具有线与的特性即只要有任意一个或多个设备输出了低电平总线就处于低电平只有所有的设备输出高电平总线才输出高电平可以利用这个特性执行多主机模式下的时钟同步和总线仲裁限制由于开漏外加上拉电阻的电路结构使得通信线高电平的驱动能力比较弱导致通信线由低电平转换为高电平时上升沿耗时会比较长这样就限制了的最大通信速度所以标准模式为快速模式也只有一般来说我们就认为最快速度为相对于的速度来说慢了许多为什么需要线与特性支持多个主设备与多个从设备连接在同一根总线上如果多个设备同时占用总线怎么判断谁先占用总线呢所以就需要一种仲裁机制没有直接的来处理仲裁而是通过线与的逻辑实现仲裁仲裁过程当主设备准备占用时需要在为高时将拉高再拉低满足一个启动条件当主设备将拉高后需要检查的电平如果此时电平为高说明主设备可以占用总线然后主设备会将拉低一次满足启动条件开始传输如果此时电平为低说明总线已经被其他设备占用主设备会退出为什么为低就是被其他设备占用了呢因为线与逻辑的存在只有总线上有其他的设备将置为线与后线的电平为主设备检查线的电平时会发现为低电平所以仲裁时哪个设备更早地将线拉低谁就抢占了优先权时序基本单元起始条件和终止条件正常情况下和都处于高电平起始条件终止条件从机收到起始条件后自身复位等待主机发送信息主机发送字节时序发送字节与串口不同是高位先行串口是低位先行发送字节过程总结下来就是时钟线处于低电平时主机设置数据线的电平时钟线处于高电平时从机读取数据线的电平显然从机读取到的电平就是主机在时钟线低电平时设置的电平对中断处理如果主机一个字节发送一半突然进中断了那么此时和上的电平暂停变化会不断拉长传输完全暂停等中断结束后主机回来继续操作和控制权该过程中和都由主机掌控从机只能被动读取主机接收字节时序发送字节过程总结下来就是时钟线处于低电平时从机设置数据线的电平时钟线处于高电平时主机读取数据线的电平显然主机读取到的电平就是从机在时钟线低电平时设置的电平和控制权全程由主机控制主机在接收之前需要释放拉高此时让从机获得控制权才能将数据放到上应答机制根据应答机制可以判断对方是否接收到了该数据表示从机应答表示从机非应答从机地址从机地址介绍从机地址每个从机设备出厂时都会分配一个位或者位地址对应地址是什么可以在对应模块找到地址比如的位地址为的位地址为相同芯片挂载时对地址的处理一般不同芯片地址不同相同型号芯片地址相同当相同芯片挂载在同一条总线时此时需要用到地址中的可变部分一般地址最后几位是可以在电路中改变的比如最后一位由芯片上的引脚决定当该引脚接低电平就是接高电平就是而地址的最后三位分明由引脚决定一般的从机设备地址高位都是厂商确定低位可以由不同引脚切换这样就可以保证多个相同芯片挂载时地址都不一样时序时序指定地址写常用该时序是对指定设备的指定寄存器写入指定数据的操作上图为逻辑分析仪的结果最开始为起始条件之后必须是发送一个字节的时序内容为从机地址读写位共位上图对应为前七位为地址最后一位为代表写入操作紧跟着的单元就是接收从机的应答位之后有个上升沿代表从机释放产生交出了控制权上图对应为高电平器件主机读取发现是代表主机进行寻址有人应答了然后的一个字节为寄存器地址上图为即操作地址的寄存器紧接着又是从机应答位然后发送写入寄存器的内容上图为即发送数据为又是一个从机应答位最后一个为终止条件指定地址连续写入多个字节如果想要发送多个字节只需要将第步发送写入字节和接收应答重复次即可写入几个字节就重复几次因为地址指针会在写入一个数据后自动所以不用移动地址指针时序当前地址读不怎么使用起始条件主机发送一个字节从机地址读写位发送完后紧跟一个从机应答图上为表示读取的数据然后控制权移交给从机主机开始读取从机发送数据不用发送读取寄存器地址从机会将当前地址指针指向的寄存器的值发送不能指定读的地址接收完后紧跟发送一个非应答这样从机读取到主机非应答后就知道主机不想要继续了交还控制权图上接收的数据为结束条件由于不能指定读的地址所以该时序当前地址读用的不多当前地址连续读多个字节如果想要读取多个字节处的读取一个字节后就应该发送应答然后重复读取字节发送应答最后一个字节读取完后跟上一个非应答就可以结束读取因为地址指针也会在读取一个数据后自动所以不用移动地址指针时序指定地址读常用指定地址读为复合格式是指定地址写和当前地址读的混合复合格式前面部分为指定地址写写的数据的前面后面部分为当前地址读起始条件发送一个字节从机地址读写位此处应为写位为然后是从机应答位在发送一个字节指定写入的地址指定完成后从机寄存器指针就指向该地址然后是从机应答位该部分为指定地址写前面部分这里前面可以加一个停止也可以不加不发送写入的内容而重复起始条件相当于另起一个时序重新发送一个字节从机地址读写位此处应为读位为从机应答位主机接收一个字节主机接收到的数据就是指定写入地址处的数据然后发送一个非应答停止条件连起来就是先起始写入地址停止再起始读当前位置停止指定地址连续读多个字节如果想要读取多个字节处的读取一个字节后就应该发送应答然后重复读取字节发送应答最后一个字节读取完后跟上一个非应答就可以结束读取因为地址指针也会在读取一个数据后自动所以不用移动地址指针简介轴姿态传感器轴加速度加速度计轴角速度陀螺仪传感器轴姿态传感器轴加速度轴角速度轴磁场强度磁力计轴姿态传感器轴加速度轴角速度轴磁场强度个气压强度气压计一些术语加速度计简称为或者或三轴都有一个测量加速度上面第二幅图就是加速度计实际上加速度就是一个就是一个测力计使用加速度计求角度的时候只能在物体静止的时候使用当物体运动起来时这个角度会受运动加速度的影响而变得不准确即特性加速度计具有静态稳定性不具有动态稳定性陀螺仪传感器简称为或者可以测量三轴的角速度值分别表示芯片绕轴轴轴旋转的角速度对应上面第三幅图为陀螺仪的机械模型该芯片只能测得角速度而不能直接测得角度通过对角速度积分可以得到角度当物体静止时角速度的值会因为噪声无法完全归零经过积分的不断累积小噪声就会导致计算出来的角度产生缓慢的漂移角速度积分得到的角度经不起时间的考验但角度无论是运动还是静止都是没问题的特性陀螺仪具有动态稳定性不具有静态稳定性姿态解算这两个传感器特性刚好互补通过互补滤波就能融合得到静态和动态都稳定的姿态角了了解姿态角欧拉角什么是欧拉角姿态角欧拉角和姿态角区别博客参数部分重要参数具体参数清查看手册芯片输出的是一个随姿态变化而变化的电压要想量化电压那么就需要转换器芯片自带位输出结果是有符号数满量程决定对应位值达到最大值时对应的物理参量具有多个选择根据具体物体运动的剧烈程度实际情况选择避免超过满量程量程越小分辨率越高量程越大范围越广低通滤波如果输出数据抖动很厉害可以加一点低通滤波这样就会更平缓可配置时钟源和采样分频两个参数配合使用时钟源通过采样分频为转换和内部其他电路提供时钟控制分频系数就可以控制转换的快慢了对从机地址的处理第一种从机地址第二种从机地址读写位或者所以这两种从机地址说法都是正确的一个是没带上读写位的从机地址一个是带上从机位的地址实际发送一个字节时只需要不带读写为的从机地址左移位再或上读写位即可也可以直接就写融入读写位的从机地址硬件电路最右边的是的芯片芯片本身引脚非常多包括通信引脚供电帧同步等很多引脚用不到还有些引脚是芯片最小系统里的固定连接一般手册中有左下角是针的排针和电源供电和通信引脚可以看到外部电路已经内置两个上拉电阻了直接接即可不用再接上拉电阻了主机引脚设计是为了扩展芯片功能轴传感器不够时这个和用于外接磁力计或者气压计扩展为轴传感器等接上后主机接口可以直接访问这些扩展芯片的数据将数据读入里面有单元进行数据融合和姿态解算如果不需要解算功能可以直接把磁力计或气压计挂载到和上因为本来就可以挂载多设备位从机地址最低位电路中可以看到默认若下拉到低电平所以悬空状态下为对应从机地址为接的话就是中断输出引脚可以配置芯片内部事件触发中断引脚输出如数据准备好了主机错误等不使用可以不配置除此之外芯片内部还内置了一些实用的小功能自由落体监测运动监测零运动监测等这些信号都可以触发引脚产生电平跳变可以进行中断信号的配置左上角是低压差线性稳压器这部分是供电的逻辑手册中可以看到的供电为属于供电设备不能直接接为了扩大供电范围就加了个的稳压器使输入端电压可以再到之间经过的稳压器给芯片端供电最后跟上的是一个电源知识灯如果有点就会亮这一模块是否需要可以根据需求来如果已经有稳定的的电源就不需要这部分了框图时钟部分一般使用内部时钟硬件电路上也是直接接地和没有引出灰色部分是芯片内部传感器包括轴的加速度计等轴的角速度计等还内置了一个温度传感器也可用于测量温度这些传感器转换完成后数据统一放在传感器寄存器中读取该数据寄存器就能得到传感器测量的值芯片内部转换都是全自动进行类似与连续转换转运每个输出对应都是位数据寄存器不存在数据覆盖问题需要数据直接读取即可最左边这是芯片的自测单元当启动自测后芯片内部会模拟一个外力施加在传感器上这个外力导致传感器数据会比平时大一些自测方法先使能自测读取数据再失能自测读取数据两个数据相减得到的数据叫做自测响应芯片手册中给出了一个范围如果在这个范围内代表芯片没问题如果不在就说明芯片可能坏了使用的话就要小心点手册找到自测范围如下在这个范围内就代表芯片正常最下方电荷泵进行升压操作最右边是寄存器和通信接口部分很多寄存器配置寄存器等通信接口从机和接口主机接口用于扩展设备通信里面有个数字运动处理器简称是芯片内部自带的一个姿态解算的硬件算法配合官方库可以进行姿态解算右下角为供电部分按照手册电压要求和参考电路接线即可产品手册通信电气特性等知识均可查看寄存器映像手册所有的寄存器都在里面但是不需要全部了解需要了解的如下每个寄存器具体介绍在手册向下翻即可采样频率分频寄存器配置采样寄存器的分频系数分频越小内部转换越快数据刷新越快采样频率陀螺仪晶振陀螺仪输出时钟频率分频值值越小越快根据实际需求来对应配置对应分频配置寄存器分为外部同步设置和低通滤波器配置外部同步这里不使用不看低通滤波器可以使输出数据更平滑选择值为数值越大抖动越下代表不滤波无关位外部同步不需要给即可数字低通滤波器也是根据需求配置我们给个比较平滑的配置对应配置为陀螺仪配置寄存器高位是轴的自测使能位中间两位是满量程选择位最后三位没使用自测使能位不自测给即可满量程选择根据实际需求选择我们给为最大量程无关位对应配置为加速度计配置寄存器高位是轴的自测使能位中间两位是满量程选择位最后三位用于配置高通滤波器内置小功能会用到自测使能位不自测给即可满量程选择根据实际需求选择我们给为最大量程高通滤波器不使用给对应配置为加速度计轴寄存器表示低位表示高位加速度计轴寄存器表示低位表示高位温度传感器寄存器查看对应手册的寄存器讲解部分即可具体某位干什么查看手册对应寄存器功能电源管理寄存器设备复位配置给不复位设备睡眠配置时给不睡眠循环模式配置给不循环无关位配置给即可温度传感器失能配置给不失能选择时钟选择内部时钟手册非常建议选择陀螺仪时钟我们配置为选择轴陀螺仪时钟对应配置为电源管理寄存器循环模式唤醒频率给不需要后六位为每个轴的待机位不需要待机全部给即可对应配置为器件号只读的中间六位固定为注意这里写的是所有寄存器上电后默认都是除了号寄存器和号寄存器号电源管理寄存器默认为可以看到位为及上电默认睡眠模式使用时记得解除睡眠模式否则操作其他寄存器是无效的号器件寄存器配置初始化值为软件模拟读写使用任意口模拟即可步骤为开启对应时钟配置口为开漏输出配置和引脚默认高电平这里都配置为开漏输出并不意味着只能输出数据也可以输入数据具有输入数据的功能详细解释见另一个笔记软件模拟引脚问题软件代码实现基本单元起始条件高电平期间从高电平切换到低电平基本单元结束条件高电平期间从低电平切换到高电平基本单元发送一个字节位位的发送从最高位开始基本单元接收一个字节低从机设置高主机读取基本单元发送应答逻辑和发送字节类似基本单元接收应答逻辑和接收字节类似延时用于控制每个时序步骤之间的时间确保时序的稳定性延时用于控制每个时序步骤之间的时间确保时序的稳定性通过前面几个函数的封装我们实现了函数名称端口号的替换需要替换端口或者移植时就只需要对前四个函数修改即可这样编程很方便基本单元起始条件高电平期间从高电平切换到低电平保险起见应该先拉高能够兼容重复起始条件避免如果先被拉高电平此时为低被拉高就被误判为停止信号产生下降沿基本单元结束条件高电平期间从低电平切换到高电平这里可以省略但是保险起见应该加上一般在数据传输结束后都是低电平因为最后一个或后主控会拉低高低电平不确定为了确保释放时能产生上升沿要先拉低先拉高产生上升沿基本单元发送一个字节位位的发送从最高位开始发送最高位进来时为低电平因为保证了是低电平所以此时直接放入数据即可先拉高后从机会立刻读取刚刚放入的数据拉低完成一个脉冲发送次高位这里使用循环直接实现个字节的发送低主机设置高从机读取基本单元接收一个字节低从机设置高主机读取主机在接受数据前需要将释放让从机获取控制权使从机能够将数据放入从机发送的数据设置第位为否则为基本单元发送应答逻辑和发送字节类似进来时为低电平主机发送为高从机接收结束一个脉冲基本单元接收应答逻辑和接收字节类似进来时为低电平释放使从机能操控线使其具有能拉高或拉低的能力在置高电平之前从机将放到线上读取地址写位地址写位测试是否能收到改变对应从机地址后是否应答测试读写指定地址写对应时序指定地址读对应时序指定写当前读指定地址写对应时序起始对应从机地址应答可以对应答位判断是否收到从机数据进行处理这里默认应答发送要写入的寄存器地址应答发送写入数据这里只发送一个字节当要写入多个字节时使用循环依次将数组的各个字节发送出去结束指定地址读对应时序指定写当前读前一半为写的时序后一半为读的时序最后一位改成读接收从机数据想继续读数据给应答这里只读一位直接不应答了最后一位读取后不应答读取多个数据给应答多个数据读取读功能读取寄存器寄存器读读取后得到的结果是与手册对应代表一字节时序正确写功能在使用写功能是必须先接触睡眠模式否则操控其他寄存器无效睡眠模式由该电源资源管理寄存器的位控制对应寄存器地址为初始值为位为只需要对该寄存器写入即可电源资源管理寄存器必选先接触睡眠模式采样分频寄存器测试发现对应寄存器值修改成功串口显示读取加速度角速度当需要使用的寄存器宏定义比较多时建议单独创建头文件管理该头文件为部分寄存器从寄存器手册搬过来即可指定地址写对应时序指定地址读对应时序指定写当前读读取对应指定地址写对应时序起始对应从机地址应答可以对应答位判断是否收到从机数据进行处理这里默认应答发送要写入的寄存器地址应答发送写入数据这里只发送一个字节当要写入多个字节时使用循环依次将数组的各个字节发送出去结束指定地址读对应时序指定写当前读前一半为写的时序后一半为读的时序最后一位改成读接收从机数据想继续读数据给应答这里只读一位直接不应答了最后一位读取后不应答读取多个数据给应答多个数据读取主要修改如下配置电源管理寄存器解除睡眠选择陀螺仪时钟配置电源管理寄存器个轴均不待机配置采样分频寄存器选择分频滤波参数给最大配置寄存器滤波参数陀螺仪最大量程加速度计最大量程这里配置完后陀螺仪内部就在不停的转换了对应数据存放在对应各轴数据寄存器中对应轴的数据都是位分为高位和低位分别读取高位和低位拼接后这里的读取分为次我们可以改进使用连续读取的时序大大提升效率对应数据轴加速度水平基本没加速度轴加速度水平基本没加速度轴加速度平放在水面通过得到我们选择的是满量程看手册上对应加速度计算公式为解方程的得到的为轴方向加速度这个值理论上来说应该是重力加速度轴角速度轴角速度轴角速度上方所有数据计算的公式为读取的数据满量程解出对应的值即可外设硬件读写由硬件电路自动实现引脚电平反转软件只需要写入控制寄存器和数据寄存器即可为了监控时序状态软件还得读取状态寄存器来了解当前的外设电路处于什么状态这就像开车一样写入控制寄存器就像是踩油门打方向盘来控制汽车的运行读取状态寄存器就像是观看仪表盘来了解汽车的运行状态使用库函数封装后有了外设硬件就可以自动实现时序就可以减轻的负担节省软件资源一主多从一个主机多个从设备多主机模式分为固定多主机和可变多主机固定多主机固定有几个主机多个主机控制产生冲突时需要仲裁可变多主机总线上无固定主机和从机任何设备可以在总线空闲时主动跳出作为主机与其他从机通信通信完成后回归从机对于使用的是可变多主机模型地址模式位位一个字节中的前位为设备地址最后一位是读写位位使用两个字节如果第二个字节也是寻址的话第一个字节的前位必须是位地址标志位第一个字节剩下位和第二个字节的位一共位作为寻址位与位区别前位是否为通讯速度标准速度快速速度兼容系统管理总线类似于是兼容的另一种总线对应寄存器标志位查看芯片参考手册的接口模块阅读即可框图对应使用时一般是口复用查询对应引脚定义表即可使用硬件时只能使用指定的引脚不能像软件那样引脚任意指定由于是半双工只有一组移位寄存器和数据寄存器接收和发送都是使用这组而串口有两组比较器和地址寄存器从机模式使用支持同时响应两个从机地址在多主机模式下使用帧错误校验计算校验算法数据有效性验证对应数据错误标志位置位中断某个紧急事件发生后可以申请中断配合提高效率是相关使用时不用管它基本结构图中是简化的一主多从结构如果是多主机应该还有时钟输入图中的两个一个是复用输入另一个是复用输出移位寄存器和数据寄存器发送时数据先写入数据寄存器如果移位寄存器没有数据就会转到移位寄存器进行发送主机发送流程事件是多个标志位的集合所有标志位在手册中都可以找到流程简化下来就是操作等待操作等待主机接收流程图中给的时序是当前地址读的想要指定地址读数据需要组合一下即可具体的流程见下面的代码从机发送接收见手册库函数初始化函数起始条件和终止条件调用该函数生成起始条件对寄存器中的位置调用该函数生成终止条件对寄存器中的位置应答手动配置在收到一个字节后是否给从机应答发送和接收数据写入数据到数据寄存器读取数据寄存器作为返回值接收到下一个字节之前读出数据寄存器防止数据覆盖实现连续数据流发送地址专用函数主要用于设置自动设置读写位这个函数可以不使用而是自己确定读写位的最后一位直接使用函数进行发送中断配置相关使能函数标志位中断外使用中断中使用状态监控给了三种方法第一种基本状态监控同时判断一个或多个标志位来确定几几这个状态是否发生对应发送接收流程推荐使用第二个参数为监测的事件第二种高级状态监控实际上并不高级对应库函数注释可以找到是将和这两个状态寄存器拼接成位数据然后给你就完了一般不使用了解即可第三种基于标志位的状态监控我们一直使用的判断某个标志位方法外设配置参考上方框图和基本结构进行配置开启外设和对应口的时钟结构体配置对应口为复用开漏输出模式区别软件模拟是直接开漏没有复用开漏结构体配置使能实验硬件读取数据部分与软件相同去掉了软件最底层的部分使用库函数代替指定地址写对应时序指定地址读对应时序指定写当前读程序中出现大量等待的情况比较危险容易发生卡死的现象所以我们需要让它超时退出不必使用定时器我们只需要简单用一个计数值循环判断即可该值根据实际情况更改大小循环正常不会执行到该函数为的封装下方没有替换该函数使用时只需要将使用循环的部分直接使用该函数全部替换即可指定地址写对应时序软件代码起始对应从机地址应答可以对应答位判断是否收到从机数据进行处理这里默认应答发送要写入的寄存器地址应答发送写入数据这里只发送一个字节当要写入多个字节时使用循环依次将数组的各个字节发送出去结束硬件下使用的都是非阻塞的函数需要等待标志位结束才能保证对应波形执行完成对应等待的事件根据硬件发送流程中来写发送起始条件等待事件完成发送从机地址第三个参数自动置读写位应答位会自动处理等待发送模式的事件完成发送指定寄存器地址等待事件发送多个字节数据时中间的数据发送完成后等待事件而最后一个字节变为等待事件发送要写入的数据发送最后一个字节完成后等待事件终止条件指定地址读对应时序指定写当前读软件模拟前一半为写的时序后一半为读的时序最后一位改成读接收从机数据想继续读数据给应答这里只读一位直接不应答了最后一位读取后不应答读取多个数据给应答多个数据读取硬件实现指定地址接收一个字节使用的是复合形式发送起始条件起始条件等待事件完成发送从机地址第三个参数自动置读写位应答位会自动处理等待发送模式的事件完成发送指定寄存器地址这里因为是数据流最后一个字节所以变成了等待事件前一半为写的时序后一半为读的时序重复起始条件这个地方会等待上方字节发送完成后才会产生所以上方用或都可以起始条件等待事件完成发送从机地址这个地方应变成读的方向第三个参数修改等待接收模式的事件完成与上方事件不同如果只需要读取一个字节需要恰好在之后立刻把置置避免在本次发送之后才去置这样时序会多一个字节如果是需要读取多个字节直接等待事件读取就能收到数据依次接收直到最后一个字节之前也就是事件不用等待提前把置置置后该终止条件不会截断当前字节会等当前字节接收完成后再产生终止条件波形等待事件完成接收从机数据置后该终止条件不会截断当前字节会等当前字节接收完成后再产生终止条件波形等待事件完成接收多个字节使用循环处理最后一个字节前执行一次和最后再恢复默认方便收多个字节软件硬件第步第步第步确认要发送应答位最大为为标准速度为快速时钟占空比参数用与快速模式只有当时钟频率大于才有效小于是占空比固定为响应或位地址作为从机时才使用作为主机随便给自身地址作为从机才使用方便别的主机呼叫指定地址位数上一个参数选择响应的位数作为主机随便给第步配置电源管理寄存器解除睡眠选择陀螺仪时钟配置电源管理寄存器个轴均不待机配置采样分频寄存器选择分频滤波参数给最大配置寄存器滤波参数陀螺仪最大量程加速度计最大量程这里配置完后陀螺仪内部就在不停的转换了对应数据存放在对应各轴数据寄存器中对应轴的数据都是位分为高位和低位分别读取高位和低位拼接后这里的读取分为次我们可以改进使用连续读取的时序大大提升效率程序中出现大量等待的情况比较危险容易发生卡死的现象所以我们需要让它超时退出不必使用定时器我们只需要简单用一个计数值循环判断即可该值根据实际情况更改大小循环正常不会执行到软件和硬件对比波形对比上方是软件波形下方是硬件波形从时钟线的规整程度上看硬件波形会更加规整每个时钟的周期占空比都非常一致软件由于操作引脚后都加了延时有时候加的多有时候加的少所以软件时序的时钟周期占空比可能不规整但由于是同步时序不规整也不会影响通信在低电平写高电平读的时候可以在整个电平的任意时候都可以读写但是一般要求保证尽早原则所以可以认为下降沿写上升沿读软件波形中因为操作端口后有延时所以都是等了一会在写的硬件波形中可以看到下降沿的时候也立马切换数据读写都是紧贴上下沿进行应答结束时最为明显从机在下降沿立刻释放但是软件由于有延时所以在应答结束后主机等了一会才变换数据所以在软件中有一个短暂的高电平后才拉低硬件中应答结束后从机在下降沿立刻释放同时主机也立刻拉低所以就是直接一个小尖峰软件模拟优点灵活性高可以完全控制每个数据位的发送和接收过程适用于没有硬件模块的型号或者需要多个总线时可以通过软件模拟多个设备成本低不依赖硬件外设因此适合成本敏感的应用可以在任意上运行可以自定义和引脚不需要专用的硬件引脚缺点效率低每个数据位的发送和接收都需要进行软件延时处理导致比硬件慢得多对于高速通信可能无法满足实时性要求占用资源模拟需要不断参与数据的传输可能影响系统其他任务的执行尤其是当系统负载较高时稳定性差如果系统中有其他任务需要占用大量时间可能会导致通信不稳定或者丢失数据硬件利用硬件模块优点高效硬件通过专用的控制器进行数据传输不需要参与数据位的传送速度快且稳定通常能够提供更高的传输速率节省资源硬件控制器可以自动完成数据传输任务释放处理其他任务特别适合多任务或实时系统稳定性强硬件模块有专门的硬件实现避免了由于软件延迟或占用过高导致的通信不稳定问题缺点硬件资源有限不同型号的有不同数量的硬件模块因此可用的硬件通道有限如果需要多个总线可能无法满足需求引脚固定硬件通常需要专用的引脚和不能任意选择如果这些引脚已被占用或在项目设计中不方便可能会限制设计的灵活性复杂性较高硬件需要配置硬件相关的寄存器和管理中断等比软件模拟配置复杂一些使用场景总结软件模拟灵活成本低但效率低占用资源不受限制引脚够基本上就是想开几路就是几路硬件不足时可以使用软件硬件效率高稳定节省资源但受硬件资源和引脚限制对性能指标要求比较高实时性多任务等时使用硬件介绍图中的四种使用通信的芯片引脚名称可能不标注可以查看对应手册了解存储芯片作为从机引脚写的和屏幕无线通信模块芯片型号为卡官方通信协议为但也支持协议可以对其进行读写操作特点同步全双工四根通信线的四根线时钟线也叫做等主机输出从机输入线也叫做对应从机输入主机输入从机输出线也叫做对应从机输出从机选择线片选也叫做片选有几个从机就用几条线这样以后就不用像那样先发送一个字节寻址分配地址等操作注意主机和从机不能同时配置为输入或输出没有应答位是不管你有没有收到信息的相对于的优缺点速度上传输比更快协议并没有严格规定最大传输速度最大传输速度一般由芯片厂商的设计需求如存储器芯片手册中写的是最大可达设计上设计比较简单粗暴实现的功能没有那么多仅支持一主多从因为没有仲裁机制不支持多主机开销上的硬件开销比较大通信线的个数比较多通信过程中经常会有资源浪费的情况硬件电路主机一般是从机一般是存储器显示屏通信模块传感器等对应有几个从设备就有几个线时钟线完全由主机掌控对于主机来说时钟线为输出对于从机来说时钟线为输入主机输出从机输入左边主机对应主机输出右边从机从机输入数据从输出所有从机从输入主机输入从机输入与类似从机选择线低电平有效主机初始化后所有的都输出高电平代表都不指定需要与谁通信就将对应的线拉低即可当对应从机通信完之后对应线就重新置回高电平同一时间只能选择一个从机只能置一个为低电平输出引脚配置为推挽输出高低电平均有很强驱动能力使得信号引脚上升沿和下降沿信号非常迅速不像那样下降沿迅速上升沿缓慢所以信号变化的快所以具有更快的传输速度一般的信号都能轻松达到的速度级别输出引脚为输入引脚配置为浮空或上拉输入输入引脚为可能存在的冲突对于的从机引脚当某个从机的引脚被选择后其他从机的引脚会被保持为高阻态相当于断开不输出这样可以防止一条线有多个输出而导致的电平冲突的问题数据移位示意图数据是高位先行通信基础是交换一个字节数据收发都是基于字节交换这个基本单元进行主机要发送的数据跑到从机从机要发送的数据跑到主机这样就可以实现发送一个字节接收一个字节发送同时接收一个字节三种功能对于只想接收数据时我们会随便发送数据一般统一为或把数据置换过来即可对于只想发送数据时只需要把数据发送过去对方置换过来的数据不管即可这里波特率发生器就是时钟主机移位寄存器左边出去的数据通过引脚输入到从机移位寄存器的右边从机移位寄存器左边移出去的数据通过引脚输入到主机移位寄存器的右边形成一个环每当规定的时钟沿上升沿下降沿到来时对应移位寄存器的最高位分别移动分别放到和的通信线上然后对应的时钟沿上升沿或下降沿再次到来时数据分别从和线上采样到从机和主机的最低位这样就完成了一个时钟例规定上升沿数据移动下降沿数据采集就是在上升沿时移位寄存器的最高位到对应的线上下降沿时会采样输入到对应的最低位时序基本单元起始条件和终止条件起始条件由高到低代表选中从机通信开始结束条件由低到高代表结束选中从机通信结束所以低电平期间就代表正在通信中有两个可以配置的位每一位可以配置为或组合起来就有模式模式模式模式共四种模式但功能实际都是一样的任意选择一种使用即可时钟极性决定空闲时的低电平值为或时钟相位决定第一个时钟采样移入还是第二时钟采样移入并不是规定上升沿采样还是下降沿采样值为或模式使用最多重点掌握代表空闲状态低电平第一个边沿移入数据第二个边沿移出数据由于数据需要先移出来才能移入所以第一个边沿之前就要提前开始移出数据了这里把当作了时钟下降沿所以要移出数据就提前移出数据等上升沿来到两个数据分别移入到主机和从机然后到下降沿两个数据就移出上升沿的两个数据采样输入到主机和从机一直到最后一位拉高任意高阻态这样一个字节的交换就完成如果想要交换多个字节只需要在最后继续紧跟第二个字节的重复前述过程即可总结交换字节步骤拉低后主机和从机立刻移出数据主机移出它的数据最高位放到上从机移出它的最高位数据放到上从机的事主机不管所以我们直接写即可上升沿主机和从机同时移入数据从机会自动把这位数据读走主机只需要读入的数据位即可下降沿主机和从机同时移出次高位数据开始循环次共字节模式与上方的移位过程相同模式与模式的区别模式把数据变化的实际提前了而模式没有代表空闲状态低电平第一个边沿移出数据第二个边沿移入数据也能表述为表示的第二个边沿进行数据采样或的偶数边沿进行数据采样为主机发送的默认状态下没有规定高低电平均可为从机发送的默认状态下应为高阻态模式模式与模式区别就把极性取反即可模式模式与模式区别就把极性取反即可时序对字节流功能的规定与不同是有效数据流第一个字节是寄存器地址之后依次是读写的数据使用的是读写寄存器的模型而在中通常采用指令码加读写数据的模型即第一个发送给从机的数据叫做指令码在从机中对应的会定义一个指令集只需要发送指令集中对应的数据即可指定想要完成的功能不同的指令可以有不同的数据个数有的指令只需要一个字节的指令码就可以完成比如的写使能失能等而写数据时包含指令码在哪里写写的数据对应的指令集都会在从机芯片手册中可以找到时序举例写使能在中代表写使能这里使用模式拉低后立马准备移出数据这里数据第一个为所以没有变化第一个上升沿采样移入数据从机采样输入得到主机采样输入得到然后第一个下降沿移除数据一直到最后一位交换完成一个字节置回高电平结束结果主机用收到从机的即从机输出不使用为默认值从机收到主机的就会进行写使能由于使用软件模拟时序有延时所以图中的数据变化有些延迟没有紧贴的下降沿是正常的指定地址写一个多个字节由于有的存储空间一个字节的位地址不够所以这里的指定地址使用位分成个字节发送在的地址下写入数据指令码第一个字节主机先发送指令代表写数据收到从机数据为不使用指定地址第二个字节主机发送地址前位第位为收到从机数据第三个字节主机发送地址中位第位为收到从机数据第四个字节主机发送地址后位第位为收到从机数据从机收到的地址为发送的数据第五个字节主机写入的数据收到从机数据到这里便写入一个字节没有应答位一个接一个交换字节即可如果想指定地址写入多个字节中也有类似于中的地址指针每读写一个字节地址指针自动如果发送一个字节后不停止继续发送的字节就会依次写入到后续的存储空间里这样即实现多个字节写入指定地址读一个多个字节和指定地址写时序差不多指令码地址三个字节读取的数据主机随便发送数据交换数据后得到这样就读取到了地址的数据为实现读取指定地址的多个字节也是有地址指针读取自动实现连续读取即可时序细节图中是硬件控制波形所以数据变化紧贴下降沿介绍容量该芯片存储为级别在手机可能很小但是在嵌入式领域还是挺大的还有的芯片是级别的例如芯片使用的通信的芯片存储器分类分为非易失性存储器和易失性存储器该芯片是非易失性存储器数据掉电不丢失存储介质为通信协议使用串行通信时钟线频率最大为双重模式等效频率为四重模式等效的频率为频率相对于非常快应用数据存储字库存储可以存放中文字库等使用时读取数据后显示中文型号芯片使用位地址个字节的方所以位地址的最大寻址空间为所都是够用的但是是的存储不够用分为字节地址模式和字节地址模式使用字节模式下只能读写到前地址而要想读写所有的地址进入字节地址模式即可更换芯片型号硬件电路和底层驱动程序都不用更改硬件电路该芯片的供电接写保护低电平不允许写高电平可以写数据保持低电平有效作用在正常读写时突然产生中断然后想用通信线去操控其他器件此时如果把置回高电平那时序就会终止但如果不想终止总线又想操作其他器件此时就可以将引脚置低电平芯片释放总线芯片的时序也不会终止会记住当前的状态操作完后可以回来置高电平继续之前的时序相当于总线进了一次中断和如果想用就接到引脚上如果不想用就直接接即可与双重和四重有关框图几个基本概念块扇区页块大小扇区大小页大小的地址空间从到右边以为一个基本单元块划分为若干个块块块左上以为一个基本单元再将每个划分为若干个单元每个单元叫做扇区个扇区扇区我们在写入数据时其实还有一个划分叫做页是对扇区进行的一个更细的划分一页为字节页页左下角芯片的控制逻辑芯片内部的地址锁存数据读写等操作都由控制逻辑自动完成控制逻辑的左边连接的是的引脚控制逻辑上方是状态寄存器可以知道芯片是否处于忙状态是否写使能等状态寄存器上方是写控制逻辑与引脚连接实现硬件写保护内部集成了高电压发生器用于实现掉电不丢失最下方字节地址锁存计数器用于指定地址放过来个字节的地址前个字节进到页地址锁存计数器最后一个字节进入字节地址锁存计数器中然后页地址锁存计数器通过写保护和行解码选择操作的哪一页字节地址锁存计数器通过列解码和字节页缓存来进行指定字节的读写操作其中的计数器与地址指针自动有关右下方列解码和页缓冲区实际上是个缓冲区写入数据时先放到这个缓冲区时序结束后芯片对应状态会置芯片再将缓冲区的数据复制到对应的中此时不会响应新的写入缓冲区作用的写入频率是非常高的而的写入速度比较慢掉电不丢失特性所以需要使用一个页缓存区来存储写入的数据从而可以跟得上总线的速度操作注意事项第条规定直接使能即可第条规定不擦除写入数据可能会与实际不符实际值为写入数据芯片内数据第条规定是为了弥补第条规定设立保证每次写入数据不出错由专门的擦除电路自动进行我们只需要发送擦除的指令即可一定要在每次写入前擦除数据第条规定擦除时只能选择整个芯片擦除按块擦除按扇区擦除所以最小的擦除单元是一个扇区为字节不能指定对某个字节擦除如果想要擦除某一个字节只能对该字节所在的扇区的个字节进行擦除为了弥补这个缺点我们需要在程序逻辑上进行一些优化比如上电后先将备份一份到中第条规定一次性不能写太多一个写入时序最多写字节由缓冲区限制第条规定写入时序结束或者擦除芯片之后芯片进入忙状态位当状态寄存器位为后才会继续响应第条规定读取时序基本没有限制唯一就是不能在忙状态时读取由于掉电不丢失的特性成本低存储量大所以在操作的便携性上不是很友好以及速度不是很快但在非易失性存储器中速度却是很快的与想在哪些就在哪写想写多少就写多少不同且可以覆盖写入区别较大芯片手册主要包含写保护配置表状态寄存器指令集以及对每条指令的详细解释还有芯片电器特性供电电压范围等状态寄存器位当设备执行页编程扇区擦除块擦除芯片擦除或写状态寄存器指令时会被设置为在该位为时表示设备正在忙碌不会响应其他指令除了读取状态寄存器和进入擦除挂起操作的指令程序擦除或写状态寄存器操作完成后位会清零表明设备已准备好接收新的指令位写使能锁存位是一个状态寄存器中的位仅在执行了指令后被设置为在数据写入完成后该位会被清零以禁用写操作当电源关闭或者执行以下任一指令时也会被禁用页编程扇区擦除块擦除芯片擦除和写入数据后会自动进行写使能例子说明假设你有一块闪存芯片在你想要向其写入数据之前必须先发送指令来激活位只有当这个位是激活状态即值为才能对芯片进行编程或擦除操作一旦这些操作完成或者直接通过发送特定指令显式地禁用它比如会回到未激活状态即值为从而防止意外改变数据注意一条写指令只能保证后续的一条写指令可以执行所以每次写入都要进行写使能其他的位请自行查看手册指令集厂商是设备如果使用和来读使用来读写使能发送写失能发送读取状态寄存器第位发送用于查看忙状态是位是位页编程就是写数据发送然后继续发送地址位位位三个字节然后发送写入的数据注意该芯片不能跨页写入在执行跨页写入时多出来的数据会从页首的地方覆盖写入一页为对应进制为若确实需要跨页写入需要连续写入很大的数组只能从软件上进行分批次写入先计算数组要跨多少也擦除对应区域最后分批次一页一页写最后封装成一个函数块擦除包括按的块擦除的块擦除的扇区擦除发送再发送三个字节的地址即可扇区擦除包括的扇区擦除发送再发送三个字节的地址即可对应一个扇区为发送或即可读取指令发送然后连续交换三个字节数据得到的第一个字节是厂商后两个字节是设备读取数据发送之后交换发送个字节地址接下来读取的就是该地址下的数据执行所用时间页编程以及各种擦除所用时间基本都是级别数据手册中可以看到发送的数据为这个就代表无用数据发送即可此时发送和接收的数据都没有意义作用可能是做一些延时软件读写软件底层代码上面四个函数只有中会使用所以我们不用放在头文件中保持模块的独立封装写写写读由于速度很快操作引脚后就不用加延时了上面这样单独对写入引脚的封装有利于单片机移植或者添加延时开启对应引脚配置三个推挽输出引脚一个上拉浮空输入引脚配置默认电平初始化引脚为高电平由于使用模式所以初始化引脚为低电平起始条件终止条件字节交换由于是交换字节所以需要有返回值得到从机发送的字节依次位位操作移出第一位数据接收从机发送的第一位数据最高位一个时序的结束移出第二位数据接收从机发送的第二位数据次高位一位一位发送可以简化为循环通过掩码依次挑出每一位进行操作移出第位数据每次只发送了接收从机发送的第位数据时为最高位每次只接收了通过中主机和从机移位寄存器交换字节的方式更加契合的移位模型讲解移出第位数据每次只发送了最高位发送后左移位后最低位为空出最低为接收从机发送的第位数据时为最高位每次只接收了主机发送数据的移位寄存器最后置为从机移位发送的最终得到的就是移位交换后的数据就可以不用定义提高效率上面演示的是模式的时序如果需要修改模式只需要对照时序图进行修改即可比如修改为模式对照模式的时序图只需要将循环中的前两行代码交换顺序即可这两行这里的模式和模式的时钟极性相同如果改为模式或模式时只需要将所有出现的地方电平全部翻转一下即可测试代码由于指令码直接书写不太美观也不够清楚所以我们可以对指令集进行宏定义新建一个头文件单独存放指令集的宏定义根据的手册将所有的指令码抄过来用于表示接受时交换过去的无用数据查看芯片手册对应指令集编写时序发送读取厂商和设备的指令码交换数据得到从机返回的第一个字节厂商主机随便发送什么默认交换数据得到从机返回的第二个字节设备前为存储器类型后为存储器大小主机随便发送什么默认设置高位设置低位不能直接等于否则高八位会被置测试代码先使用该读取的代码测试是否能使用业务代码我们读取的指令码为对应手册上收到的应该是厂商设备将上显示或者串口发送的结果对比发现正确完整代码由于每次操作需要我们判断是否芯片是否处于所有我们可以在每次写操作的时候进行等待位等待分为事前等待和事后等待事前等待在写操作开始前调用等待位置事后等待在写操作结束后需要调用两者区别事后等待比事前等待更保险事后等待可以保证在进行写操作之外的地方芯片肯定不处于状态保证安全事前等待效率比事后等待效率高可以在执行完写操作后执行其他代码刚好可以利用这段代码来消耗等待时间事前等待需要在读取和写入前都要调用因为读的时候也需要在位不为的时候而事后等待只需要在写入后调用这两个函数为了模块化不用外部调用了查看芯片手册对应指令集编写时序发送读取厂商和设备的指令码交换数据得到从机返回的第一个字节厂商主机随便发送什么默认交换数据得到从机返回的第二个字节设备前为存储器类型后为存储器大小主机随便发送什么默认设置高位设置低位不能直接等于否则高八位会被置每次写之前都要写使能等待状态寄存器位状态寄存器有位最低位代表位读取判断位若为就一直等待状态寄存器可以被连续读取如果不停止就会一直发送状态寄存器当前的值超时退出避免程序卡死页编程也就是写入数据到需要先写使能读取最大值为所以要定义为每次写入数据前都要进行写使能在这里可以方便我们避免每次都要手动写使能取高位取中位该函数只会发送数据高位会舍弃取低位发送写操作进行事后等待扇区擦除其他擦除同理为指定擦拭的个字节也就是个扇区需要先写使能每次写入数据前都要进行写使能在这里可以方便我们避免每次都要手动写使能取高位取中位该函数只会发送数据高位会舍弃取低位发送写操作进行事后等待读取时数量没有限制发送读取数据指令码发送读取的位地址取高位取中位该函数只会发送数据高位会舍弃取低位发送置换得到数据发送将数据置换过来指定擦除扇区起始地址后位代表一个扇区内地址位代表块地址每次写入数据前要先写使能每次写入前一定要记得擦除最终上显示发送和读取的数据相同断电后不写入直接读取数据也不变硬件外设硬件读写最常用配置就是位数据帧高位先行位和低位先行用的很少时钟频率的时钟由外设时钟分频得来可以分频时钟频率越快对应传输速率越快频率不能任意指定也就是说的时钟频率只能是对面种分频后对应的时钟频率且对于和来说也不相同挂载在是挂载在是多主机模型使用较少可以看手册学习主机或从机通常作为主机精简为半双工单工通信可以节省一条数据线半双工或单工通信一般不适用大量数据传输时使用兼容协议数字音频传输专用协议与有一些共同特征以上所有内容都可以查看参考手册进行学习框图与对应寄存器描述结合理解左上角通过控制位控制低位先行还是高位先行移位寄存器通过和分别移动和接收一位位数据发送和接收可以同时进行接收缓冲区就是寄存器发送缓冲区就是寄存器和占用同一个地址统一叫作写入经过发送数据经过对应也是发送寄存器空和接收寄存器非空两个标志位移位寄存器配合数据寄存器实现连续数据流发送数据先写入再转到移位寄存器发送发送的同时接收数据接收的同时转到我们再从读取数据左下角波特率发生器内部有一个分频器输入时钟为或经过分频器后输出到生成时钟与移位寄存器同步右下角用于控制高位先行还是低位先行使能位用于控制分频系数配置主从模式和选择四种模式右上角一些使能位与控制位重要的是和引脚与多主机有关外设基本结构整体转入移位寄存器的时刻置标志位为移位寄存器数据整体转入的时刻置标志位为图中没画出引脚我们使用普通的口来模拟主模式全双工连续传输这里演示的是模式低位先行的模式首先等待后就软件写入数据到也就变为转入完成后立马将数据再移动到移位寄存器转入到移位寄存器瞬间把置为表示发送寄存器空波形产生开始传输但此时又要立马把下个数据写入到中流程简述下来就是发送数据发送数据接收数据发送数据接收数据发送数据接收数据数据交换的流程是交叉的要求很严格对程序设计不太友好如果对效率要求很高就可以研究这个非连续传输这里演示的是模式低位先行的模式接收时序与发送时序是同步的具体见连续传输的图因为是主机和从机交换字节发送所以发送的同时也在接收但是必须先发送才会产生时序然后才会有接收首先等待后就软件写入数据到也就变为转入完成后立马将数据再移动到移位寄存器转入到移位寄存器瞬间把置为表示发送寄存器空一旦移位寄存器有数据了时序波形会自动产生开始交换数据此时不立马将下个数据写入而是等待第一个字节时序结束意味着接收第一个字节也结束了置先把第一个接收到的数据读出来之后再写入数据流程即四行代码完成任务第步等待为第步写入发送的数据至第步等待为第步读取接收的数据然后重复第字节所以我们只需要将这四步封装到一个函数中就可以实现字节的交换与软件的流程基本上是一样的非连续与连续传输的区别没有及时将数据送入寄存器等到第一个字节时序完成后第二个字节还没有送过来数据传输就会等候所以时钟和数据的时序在字节与字节之间产生了间隙拖慢了整体数据传输的速度间隙在频率低时影响不大但在非常高时就非常严重频率在分频下的波形可以看到等待时间都远大于数据交换时间了所以我们要在想在极限频率下进一步提高数据传输速率我们需要使用连续传输模式或者使用和标志位清除问题手册上的描述和会在写入和读的时候由硬件清除所以我们不需要手动调用清除标志位连续和非连续的优缺点非连续传输好处容易封装好理解好用缺点会损失一点点性能连续传输对传输效率有要求的话可以使用好处传输更快缺点操作起来相对复杂对软件的需求较高每个标志位产生后数据都要及时处理软件硬件波形对比区别下降沿和低电平期间都可以作为数据变化的时刻只是硬件波形一般会紧贴边沿软件波形一般只能在电平期间无论哪种方式都不会影响数据传输对于软件波形尽量要贴近边沿否则等待太久贴近下一个边沿了数据也会容易出错库函数标准库函数中包含的很多名称中带有相关的函数因为与共用一套电路直接使用即可初始化外设使能中断配置发送和接收数据数据到从读数据不常用函数引脚配置数据帧位数配置位或为数据帧配置校验配置半双工时双向线的方向配置标志位硬件初始化流程根据框图开启对应和口的时钟初始化口和是硬件控制输出的信号配置为复用推挽输出是是硬件外设配置的输入信号配置为上拉输入还有一个引脚使用软件模拟控制的输出信号配置为通用推挽输出即可配置外设调用配置各参数即可使能开关控制调用即可默认为高电平不使用从机硬件读写对于驱动层的代码我们不需要修改我们只需要修改底层代码即可写开启对应引脚配置和复用推挽输出引脚使用软件模拟通用推挽输出引脚上拉输入引脚配置选择主机选择全双工位先行频率为多我们使用的引脚模拟使用软件我们不使用校验只需要随便给个值即可使能默认不选中从机起始条件终止条件字节交换硬件自动控制引脚对应非连续传输的四个步骤等待为代表发送数据寄存器为空可以写入数据了写入发送数据到发送数据寄存器同时自动清除等待为接收数据寄存器非空代表接收完成从接收数据寄存器读取接收到的数据同时自动清除常识时间戳时间戳年月日时分秒开始所经过的秒数没有进位不同时区通过对秒计数器添加偏移就可以得到当地时间计算机底层使用时间戳会很方便只需要一个很大的寄存器存储秒数即可给人类观看的时候只需要将时间戳转换为对应的日期即可但是时间戳比较占用软件资源在每次进行秒计数器和日期时间转换时软件都需要经过比较复杂的运算闰秒由于地球自转会越转越慢地球自转一周的时间会变化当地球自转一周的时间与原子钟计时一天的时间相差超过时就会执行闰秒操作即多走来等等地球分钟可能会出现现在世界使用的就是时间戳转换是在的基础上加一个时区偏移得到简介其实就是一个存储器只有当和都断电了数据才会清零引脚侵入事件将所有备份寄存器内容清除用于安全等引脚输出校准时钟或输出闹钟脉冲字节中容量和小容量字节大容量和互联型基本结构橙色部分叫后备区域处于后备区域但后备区域不只有还有相关电路后备区域特性当主电源掉电时后备区域仍可以由的备用电池供电当主电源上电时后备区域供电会由切换到也就是在主电源有电时不会用到这样可以节省电池电量每个数据寄存器空间为个字节的几个功能侵入检测可以从位置的引脚引入一个检测信号当产生上升沿或者下降沿时清除所有的内容以保证安全时钟输出可以从位置的引脚输出出去供外部使用其中输出校准时钟时配合校准寄存器可以对的误差进行校准库函数手动清空所有寄存器配置引脚有效电平是否开启侵入检测功能中断配置时钟输出配置可选择输入校准时钟闹钟脉冲或秒脉冲设置校准值写入校准寄存器写备份寄存器读备份寄存器标志位相关函数读写使用或必须先执行前两步开启和时钟设置使能和的访问开启对应和时钟使能使能和的访问写寄存器写入寄存器读寄存器外设简介其中计数都是用一个秒计数器对应的时间戳使用库中的库中函数可以得到年月日时分秒信息了可选三种时钟源输入一般都使用提供给时钟特殊情况下和为备选时钟选择原因和都有自己的用途而是专用同时只有时钟可以通过备用电池供电和在主电源掉电后是停止运行的所以要想实现主电源掉电继续走时的功能必须选择专用时钟和内容都可以在参考手册中查看框图图中灰色部分都处于后备区域主电源掉电后可以使用备用电池供电左边核心的分频和计数计时部分为时钟来源在配置主要选择预分频器实际上就是一个计数器计几个数就溢出次就是几分频由重装载寄存器相当于和余数寄存器相当于计数器但是为自减计数器若来一个输入时钟自减一次直到变为然后再来一个输入时钟就会产生一个溢出信号同时变回也就是每来个输入脉冲计数器就溢出一次产生一个输出脉冲也就是产生了分频分频后输出的时钟频率为也就是提供给后续就是时间戳的秒计数器闹钟寄存器位值可以在其写入一个秒数设定闹钟当这时闹钟响了就会产生信号通往右边的中断系统执行对应操作同时闹钟信号可以让退出待机模式可以实现定时唤醒待机芯片采集数据完成后继续待机以节省电源的作用右边中断使能和部分秒信号触发秒中断每秒触发一次中断溢出信号触发溢出中断计数值溢出触发一次中断这个一般不会触发闹钟信号触发闹钟中断可以设定闹钟或者唤醒待机设备上边总线相关部分读写寄存器可以通过总线完成且是总线上的设备下边关联的部分基本结构硬件电路在最小系统的电路上需要额外添加两个部分备用电池电路根据数据手册得到简单连接参考手册得到推荐连接图右上角使用纽扣电池充当备用电池型号位等有字的那面为正极画板子设计产品应该选择推荐连接方案更保险外部低速晶振根据参考手册设计图右下角黑色的为外部低速晶振白色的为外部高速晶振操作注意事项使用或必须先执行前两步开启和时钟设置使能和的访问由于和使用的是不同时钟面临着同步问题所以需要在初始化时调用一个等待同步的函数有一个进入配置模式的标志位必须先将中的中的标志位置才能进入配置模式当然在每个写入寄存器的库函数中都自动加上了这个操作我们可以不用写每次写入操作都需要等待中的标志位只有为时才能写入寄存器也就是调用一个等待上一个任务函数原因因为和时钟频率不一样使用的频率写入后这个值不能直接更新到寄存器中因为是由驱动所以写完后需要等一下时钟来一个上升沿使值更新到寄存器中库函数配置外部低速时钟配置内部低速时钟配置配置时钟源选择在调用上面的配置函数后需要再次调用该函数使能调用时钟启动函数后需要该函数等待标志位置时钟才算启动完成稳定库函数进入配置模式退出配置模式获取计数器写入写入预分频器写入闹钟值该该寄存器是只写的不可读读取预分频器种的余数寄存器注意事项中的两个等待函数等待上次操作完成循环直到状态位为等待同步等待置标志位相关函数配置开启和时钟设置使能和的访问使用开启时钟不行的话换成的且使用开启时钟省电默认关闭且等待标志位为配置时钟源指定为时钟源并且调用使能调用两个等待函数注意事项中的等待同步与等待上一次操作完成配置预分频器并且再调用等待上一次操作完成函数配置并且再调用等待上一次操作完成函数如果有闹钟值则配置闹钟如果有中断就配置中断没有结构体进行配置且没有函数开启时钟后就会运行显示当前时间开启和时钟设置使能和的访问使用开启时钟等待标志位为使用修改处使用修改处配置数据选择器指定为并且调用使能使用修改处调用两个等待函数注意事项中的等待同步与等待上一次操作完成这两行代码是安全保障措施防止因为时钟不同步而出现配置预分频器并且再调用等待上一次操作完成函数频率为分频后可以使频率为使用修改处对应分频得到配置并且再调用等待上一次操作完成函数设置起始时间类型数据数组指定时间填充到结构体中使用得到秒数此处是北京时间转为伦敦时间因为中的秒数是以伦敦时间计算的写入到中也应该是伦敦时间写入的中类型数据此处是伦敦时间转换为北京时间东区要多个小时对应个小时的秒数在程序中由于芯片等的可能使用时不会起振此时函数会卡死在初始化中我们可以用示波器观察是否产生波形判断一下解决方案此时我们可以使用作为时钟源但是就不能实现掉电时间不重置了因为不像一样可以由备用电池供电模块初始化初始化初始化显示静态字符串读取时间最新的时间存储到数组中显示数组中的时间值年月日时分秒显示位的秒计数器显示余数寄存器寄存器解决掉电时间不丢失问题在对的初始化中我们要有判断的去执行当系统完全断电了备用电池也断电了我们就执行初始化当系统只是主电源断电备用电池没断的话一直都在运行就不用执行初始化我们只需要修改的代码即可为其添加一个寄存器自定义标志位的判断开启时钟开启的时钟开启的时钟备份寄存器访问使能使用开启对备份寄存器的访问通过写入备份寄存器的标志位判断是否是第一次配置成立则执行第一次的配置开启时钟等待准备就绪选择来源为使能等待同步等待上一次操作完成设置预分频器预分频后的计数频率为等待上一次操作完成设置时间调用此函数全局数组里时间值刷新到硬件电路在备份寄存器写入自己规定的标志位用于判断是不是第一次执行配置不是第一次配置等待同步等待上一次操作完成如果无法起振导致程序卡死在初始化函数中可将初始化函数替换为下述代码使用当作无法由备用电源供电故主电源掉电时走时会暂停即使不是第一次配置也需要再次开启时钟电源控制简介实现可编程电压检测器和低功耗模式可编程电压检测器监视电压在供电电压下降到阀值以下时或上升到阈值以上时产生一个中断通知软件做紧急处理低功耗模式睡眠模式停机模式待机模式在空闲状态时关闭不必要的硬件比如把断电或关闭时钟但需要保留必要的唤醒电路所有知识在手册上可以找到电源框图内部供电方案图可分为三个部分模拟部分供电包括转换器温度传感器复位模块供电正极为供电负极为其中还有两个参考电压供电脚和在该芯片中直接接入了和也可能会单独引出去数字部分供电供电区域和供电区域供电区域电路待机电路电压调节器为区域供电供电区域存储器外设我们可以看到存储器和外设都是以的低电压运行的当需要与外界交流时才会通过电路转换为后备供电区域为以下供电晶体振荡器后备寄存器寄存器即备份域控制寄存器低电压检测器控制开关有电时由供电没电时由供电上电复位和掉电复位设置了阈值电压迟滞避免电压来回波动造成输出也来回抖动低电平有效对应滞后时间在数据手册可以找到可编程电压检测器作用监视电压在供电电压下降到阀值以下时或上升到阈值以上时产生一个中断通知软件做紧急处理在电压过低时为正常时输出在上升沿或下降沿时触发中断通过外部中断实现提醒用户处理的阈值电压可以使用程序指定配置寄存器位迟滞电压上限为低功耗模式介绍手册中的低功耗模式介绍三种模式从上到下睡眠停机止待机关闭的电路越来越多越来越省电越来越难唤醒图中可以知道关闭电路通常由两个做法关闭时钟或关闭电源关闭时钟所有的运算和涉及时序的操作都会暂停寄存器和存储器保存的数据可以维持不会消失关闭电源电路直接断电电路操作和寄存器数据都丢失比关闭时钟更省电睡眠模式一般省电等待中断对应唤醒条件为中断唤醒意思就是处于睡眠状态如果有中断发生再叫我起来调用进入的睡眠模式任何外设发生任何中断时芯片都会立刻醒来进入中断处理程序等待事件对应唤醒条件为唤醒事件可以是外部中断配置为事件模式也可以是使能了中断但没有配置调用进入的睡眠模式产生唤醒事件时会立刻醒来一般不需要进中断函数对电路影响只关闭了时钟其他电路没有影响看上图中描述停机模式非常省电位置进入深度睡眠位区分停机和待机进入停机模式进入待机模式位设置电压调节器开启或进入低功耗模式电压调节器开启电压调节器进入低功耗更省电但唤醒延迟更高设置流程再调用或芯片就可以进入停止模式了唤醒条件只有任一的外部中断能唤醒其他中断不能唤醒用外部中断中断模式唤醒用外部中断事件唤醒对电路影响关闭所有区域的时钟外设以及和振荡器但不会关闭和电压调节器开启区域电源仍开启看上图中描述待机模式极为省电设置流程再调用或芯片就可以进入停止模式了唤醒条件普通外设中断或外部中断都无法唤醒待机模式只能由以下四个信号唤醒引脚上升沿如即闹钟事件引脚的外部复位一下复位对电路影响关闭所有区域的时钟外设两个高速时钟关闭两个低速时钟不会关闭电压调节器关闭即区域电源关闭看上图中描述模式选择的图配置其他寄存器在执行或之前图中最左边是执行后根据各个寄存器判断启动什么模式的流程三种模式特性及注意事项高低电平保持睡眠前运行时的状态唤醒后程序从暂停的地方继续运行手册对事件唤醒描述比较麻烦所以还是使用中断唤醒吧高低电平保持睡眠前运行时的状态唤醒后程序从暂停的地方继续运行注意停止模式唤醒时因为被选为了系统时钟所以变成了的主频所以我们在停止模式唤醒后第一时间应该重新启动配置主频为调用即可待机模式下输出引脚变为高阻态浮空输入唤醒后程序从头开始运行仅备份寄存器和待机电路供电仅四种方式退出待机模式节电方法在数据手册工作条件的供电电流特性测试电流部分可以得到省电方法关闭不需要的外设对应时钟降低主频耗电电流下降对于省电也挺划算的设备需要连续运行但是对于主频和性能没这么高要求的话就可以选择降低主频产品使用电池的话低功耗模式也是很必要使用的和位配置这两个位位于内核系统控制块没有提供什么简单的配置方法只能通过操作寄存器来配置默认值为我们需要打开编程手册第章内核外设的系统控制块中找到寄存器介绍对应寄存器等按照配置编程手册上的位配置即可修改主频在文件中可以看到的描述是有两个函数和一个变量与系统主频有关在文件中也可以找到系统时钟系统时钟初始化系统时钟更新在文件中对应部分找到自己的型号然后进行修改主频即可修改主频后使用主频的地方需要修改比如函数在下是正确延时指定时间但是变为后就会变为原来的所以最好将变量带入计算中做自适应所以一般条件下不推荐修改主频除非有需求睡眠模式实例睡眠模式使用寄存器都是内核中的与没什么关系所以没使用库函数串口收发对于这种靠任意中断触发没中断就没什么事的平时主循环会耗电我们就可以给它加入低功耗模式根据分析这种情况下串口只能使用睡眠模式定义用于接收串口数据的变量初始化显示静态字符串串口初始化检查串口接收数据的标志位获取串口接收的数据串口将收到的数据回传回去用于测试显示串口接收的数据闪烁指示当前主循环正在运行执行指令睡眠并等待中断唤醒事件唤醒对于睡眠模式我们在循环中加入或即可实现睡眠模式唤醒后继续执行上一次执行的操作执行指令睡眠并等待中断唤醒事件唤醒现象上不再持续显示此时用串口助手发送信息每发送一次闪烁显示一次说明只有接收中断后才会唤醒工作一次然后立马睡眠停机模式实例库函数停机模式涉及内核外的电路操作需要使用库函数使能后备区域的访问在初始化时需要使用使能阈值电压配置引脚唤醒功能使用需要调用此函数开启停机模式调用该函数就可以进入停止模式了待机模式调用该函数就可以进入待机模式了标志位相关函数对射式红外传感器外部中断停机模式使用外部中断触发的可以考虑使用更省电的停机模式虽然停机模式关闭了外设时钟但是外部中断使用不需要时钟就能工作模块初始化初始化红外计数传感器初始化开启时钟开启的时钟停止模式和待机模式一定要记得开启显示静态字符串不断刷新显示的返回值闪烁指示当前主循环正在运行指令进入停止模式并等待中断唤醒唤醒后要重新配置时钟该函数最后调用了或指令之后就进入了静止模式唤醒后时钟变为了的需要我们重新启动配置的主频调用该函数即可现象红外传感器计数一次闪烁一次确实进入了停机模式待机模式实例闹钟待机模式模块初始化初始化初始化开启时钟开启的时钟停止模式和待机模式一定要记得开启时钟显示静态字符串使能引脚使能位于的引脚引脚上升沿唤醒待机模式接上即可唤醒设定闹钟由于该寄存器是只写的不可读所以我们使用变量显示闹钟为唤醒后当前时间的后写入闹钟值到的寄存器显示闹钟值显示位的秒计数器显示闹钟标志位闪烁指示当前主循环正在运行闪烁指示即将进入待机模式清屏模拟关闭外部所有的耗电设备以达到极度省电进入停止模式并等待指定的唤醒事件上升沿或闹钟待机模式唤醒后程序会重头开始运行该函数最后统一调用指令进入待机模式待机模式下只有这四种可以唤醒引脚上升沿如即手册中对应描述不需要初始化被强制下拉只需要接即可唤醒闹钟事件引脚的外部复位一下复位现象等待后闪烁一下后消失和的值都更新说明待机模式下唤醒后程序从头开始运行所以我们不用重新调用了最大化省电进入待机模式前把外接的模块能关的全关需要精心设计电路否则待机模式无法做到真正的极度省电看门狗看门狗简介看门狗由于程序出现漏洞硬件故障电磁干扰等原因出现卡死或跑飞现象时可以及时复位程序本质是一个定时器在指定时间范围内程序没有执行喂狗手动重装计数器操作时看门狗硬件电路就自动产生复位信号作用提高系统的可靠性和健壮性避免程序陷入长时间罢工状态可以预料的漏洞应该尽量解决开门狗只是一个复位的作用可能会出现复位也不能解决的问题内置两个看门狗独立看门狗和窗口看门狗独立看门狗使用专门的时钟即使主时钟出现问题独立看门狗也能正常工作这就是独立的命名对时间精度要求较低只有一个喂狗最晚界限窗口看门狗使用时钟要求看门狗在精确的计时窗口作用有喂狗最早界限和最晚界限必须在这个界限窗口内喂狗这就是窗口的命名喂早和喂晚都会发生复位对应更多内容请查看参考手册独立看门狗框图其实就是定时器中的预分频缩写位最大为就是定时器中的位最大为状态寄存器工作流程计数器为递减计数器自减到之前执行喂狗操作重置计数器为当计数器自减到时就会进行复位上面寄存器处于供电区而下面的电路处于供电区所以在停机和待机模式下只会关闭时钟所以可以在停机和待机模式下可以运行待机模式下的唤醒条件之一就包含看门狗键寄存器在多个位确定代替一位的情况下该寄存器就算值变化也很难恰巧出现以上的值这样就更保险同时对设计了写保护只有写入键寄存器的值为时才会解除写保护其他情况下都不允许写入由于是只读的就不用管超时时间就是定时器溢出时间和定时器溢出时间相同最大值只能是写入固定上面几个分频系数窗口看门狗框图时钟源进入预分频器前还进行了分频图中没画出看门狗的预分频器与独立看门狗和定时器的都是一样的道理看门狗控制寄存器包看门狗使能位和计数器与计数器合二为一了位递减计数器的有效位为位用于判断是否溢出启动时必须将此位写入值为代表计数器没有溢出值为代表计数器溢出产生看门狗复位位于控制寄存器中计数器和控制寄存器合二为一窗口看门狗没有重装寄存器直接向写数据当位为第位为标志位为位计数器的值为再减一次后位变为计数器溢出通过图中线路产生复位信号如果把看成计数器就是位计数器那么就是自减到时溢出如果把为看成计数器就是位计数器那么就是自减小于时溢出喂狗操作写入寄存器也就是写入看门狗配置寄存器用于设置喂狗的窗口值的最早界限写入位数据固定不变最左边是比较器逻辑什么时候产生复位操作的逻辑工作流程首先时钟从时钟进入然后经过预分频器分频驱动计数器进行计数每来一个时钟自减一次最终比较进行复位工作特性定期写入寄存器喂狗避免复位喂狗的最早界限对应窗口时间喂狗的计数器值对应超时时间喂狗的最晚界限由得到对应超时时间的最大值窗口时间超时时间之间喂狗才不会复位递减计数器产生早期唤醒中断超时时间和对比窗口看门狗的精度比独立看门狗高独立看门狗代码相关库函数写使能控制键寄存器写入就是就是设置预分频设置重装载值喂狗操作重新装载寄存器启用独立看门狗键寄存器写入库函数使用中的获取标志位函数可以根据可选参数得到是什么造成的复位这里用于判断复位是否由看门狗完成同时我们的看门狗标志位必须手动清除因为及时按下复位键也不会手动清如果不清零下次即使是复位键复位也会判断为看门狗复位配置流程开启时钟不需要我们写代码开启看门狗时会自动强制开启在手册的看门狗时钟部分可以看到开启独立看门狗后会被强制打开等稳定后就可以自动为独立看门狗提供时钟写入键寄存器关闭写保护再写入预分频值和重装值直接调用库函数不需要我们寄存器操作写入键寄存器启动看门狗直接调用库函数主循环执行喂狗操作按键触发独立看门狗设置超时图中可以看到前两个分频系数最大超时时间不满足所以选下面的优先选择预分频系数小的最大化利用计数器值时钟计算预分频系数计算重载寄存器重载寄存器值模块初始化初始化按键初始化显示静态字符串判断复位信号来源如果是独立看门狗复位闪烁字符串清除标志位否则即为其他复位闪烁字符串初始化独立看门狗写使能设置预分频为上面计算的设置重装值为双面计算的独立看门狗的超时时间为重装计数器喂狗这样更严谨一点使下个周期为独立看门狗使能调用阻塞式的按键扫描函数模拟主循环卡死重装计数器喂狗避免复位闪烁字符串喂狗间隔为没到不会重装模拟超时喂狗多留一点冗余时间按键使用的是阻塞式消抖其中包含循环一直按着不松就会卡死在循环这样就会造成超时主循环阻塞没喂狗触发看门狗复位现象正常情况下屏幕间断显示正常按下按键屏幕显示复位按下按键不松手屏幕显示窗口看门狗代码库函数写入预分频器设置窗口最早界限使能中断喂狗操作使能看门狗手册上说明了计数器时刻自减所以可能是任何值所以需要使能的时候喂一下狗配置流程开启总线上的时钟设置预分频值窗口值使能看门狗带有喂狗值需要使能的时候喂一下狗主循环在窗口时间超时时间内喂狗按键触发窗口看门狗设定超时时间图中看到只能选择最后一个分频系数的是进入预分频前对的一个分频计算预分频系数的次方计算写入计数器的值取整喂狗值超时时间约为设定窗口时间为的是进入预分频前对的一个分频计算窗口值取整窗口值窗口时间约为最终我们主循环的喂狗周期为模块初始化初始化按键初始化显示静态字符串判断复位信号来源如果是窗口看门狗复位闪烁字符串清除标志位否则即为其他复位闪烁字符串开启时钟开启的时钟初始化设置预分频为设置窗口值窗口时间为使能并第一次喂狗超时时间为调用阻塞式的按键扫描函数模拟主循环卡死如果把喂狗放在这里的话程序会一直触发看门狗复位因为距离第一次喂狗时间就会触发看门狗复位闪烁字符串喂狗间隔为重装计数器喂狗代码中的或上操作每次喂狗或上是对计数器的位设置为避免每次喂狗后立即产生一个复位而设置窗口时的或上是为了使位也为这样才能将该窗口值与喂狗值比较否则窗口值一直小于喂狗值闪存简介程序存储器系统存储器选项字节三部分通过闪存存储器接口外设可以对程序存储器和选项字节进行擦除和编程读写的用途利用程序存储器的剩余空间来保存掉电不丢失的用户数据通过在程序中编程实现程序的自我更新在线编程用于更新程序存储器的全部内容它通过协议或系统加载程序下载程序在程序中编程可以使用微制器支持的任一种通信接口下载程序下图各个流程都是闪存编程参考手册中的内容可以观看闪存编程手册编程当有些参数数据需要掉电不丢失的时候我们可以将其写入内部中这样不用外挂存储器芯片节省了资源闪存模块组织闪存三部分主存储器对应程序存储器起始地址也是我们平时说的闪存容量的部分另外两部分也属于闪存但不统计进入容量内信息块启动程序代码对应系统存储器存放起始地址用户选择字节对应选项字节起始地址闪存存储器接口寄存器外设从地址来看就是普通的外设寄存器的内容与分为块扇区页不同内部只有页为基本单位每页大小为以结尾的都一定是页的起始地址对于不同容量产品闪存的分配方式有些区别参考单独的闪存编程参考手册基本结构闪存存储器接口也叫闪存编程和擦除控制器可以对程序存储器擦除和编程选项字节擦除和编程选项字节可以配置程序存储器的读写保护解锁闪存存储器接口闪存编程和擦除控制器其中的键寄存器有三个键值通过向键寄存器写入指定值可以解锁的写操作对于读操作不用执行解锁操作解锁方式先向写入再向写入保护机制一旦没有先写入再写入就会锁死除非复位加锁方式设置中给的位锁住和操作闪存方式先解锁操作完后再加锁即可使用指针访问存储器指针写入操作想以什么形式的方式读出数据就把改为对应类型即可比如想以位读取将改为即可使用原因当单片机通过指针访问外部硬件设备的寄存器时由于这些寄存器的值可能会由硬件自动更新例如一个定时器寄存器的值会随时间变化因此应该将这些寄存器对应的变量声明为这样每次访问这些变量时都会直接从硬件寄存器中读取值而不是使用可能已过时的缓存值程序存储器的擦除和编程以下内容对应闪存编写手册的节和节程序存储器的全擦除程序的全擦除在库函数中使用了一个函数我们可以直接使用以下就是函数的底层寄存器操作步骤步骤如下读取的位如果锁住了需要先解锁库函数都是直接解锁置的表示执行的是全擦除置的为触发条件置后芯片开始干活检测的位是否为为就一直等待直到位置后全擦除结束读出并验证被擦除页的数据我们可以不管程序存储器的页擦除程序的页擦除在库函数中使用了一个函数我们可以直接使用以下就是函数的底层寄存器操作步骤步骤如下读取的位如果锁住了需要先解锁库函数都是直接解锁置的表示执行的是页擦除然后在中选择要擦除的页此地址提前写入最后置的为触发条件置后芯片开始干活检测的位是否为为就一直等待直到位置后全擦除结束读出并验证被擦除页的数据我们可以不管程序存储器编程注的闪存会在写入前检查指定地址有没有擦除如果没有擦除不执行写入操作除非写入的全为程序的全擦除在库函数中使用了一个函数我们可以直接使用以下就是函数的底层寄存器操作步骤步骤如下读取的位如果锁住了需要先解锁库函数都是直接解锁置的表示执行的是编程操作在指定地址写入半字位只能以半字写入位使用指针写入操作检测的位是否为为就一直等待直到位置后全擦除结束每次流程只能写入半字如果想要写入很多字节只需循环调用上面的步骤即可字半字字节字位数据半字位数据字节位数据选项字节选项字节存放独立于程序代码的配置参数内容对应闪存编程手册节选项字节擦除先解锁闪存检查的位以确认没有其他正在进行的闪存操作解锁的位即对写入类似对解锁的两个操作设置的位为设置的位为等待位变为即擦除结束读出被擦除的选择字节并做验证不必要操作选项字节的编程先解锁闪存检查的位以确认没有其他正在进行的闪存操作解锁的位即对写入类似对解锁的两个操作设置的位为写入要编程的半字到指定地址等待位变为即写入结束读出被擦除的选择字节并做验证不必要操作器件电子签名器件电子签名相关内容对应参考手册第章的内容电子签名其实就是芯片号存放在系统存储器区域包含和几个字节的电子签名库函数内核运行代码相关我们不需要使用加锁解锁芯片的加锁和解锁芯片擦除分别是页擦除全擦除选项字节擦除芯片写入编程指定地址写入字指定地址写入半字选项字节读写相关选项字节写入选项字节写保护使能选项字节都保护用户选项的三个配置位选项字节状态获取标志位相关等待上一次操作也就是等待为在上面读写擦除的库函数内部已经调用了我们不需要调用我们这里用不到下面的函数上面三个库函数分为部分通用函数新加的通用函数新加的只能被大容量系列使用的函数图中的是后面新推出加大容量系列新加的一块实验简单读写底层代码实现读取一个字使用指针访问指定地址下的数据并返回读取半字使用指针访问指定地址下的数据并返回将位地址强转为指向数据的指针值也就是该指针不会变仅仅将这个指针地址指向的数据变为了读取字节使用指针访问指定地址下的数据并返回全擦除解锁全擦除加锁页擦除解锁全擦除加锁选项字节擦除解锁全擦除加锁写入字解锁编程字加锁写入半字解锁编程半字加锁写入前要先擦除写入区域写入最后的区域一个字数据为写入半个字数据为最终读取的结果如下变量的值以及内存中的值如图我们也可以使用软件直接观察在中定义数组和标志位对数据存储在定义数组写入数据到并且实现上电数据读取到操作对于这种在很多地方出现对应不同芯片有不同值得数据我们使用宏定义提高程序的复用存储的起始地址存储数据的个数定义数组函数参数存储模块初始化参数无返回值无地址的第一个半字存储标志位以此判断是不是第一次使用读取第一个半字的标志位成立则执行第一次使用的初始化擦除指定页在第一个半字写入自己规定的标志位用于判断是不是第一次使用循环次除了第一个标志位除了标志位的有效数据全部清上电时将闪存数据加载回数组实现数组的掉电不丢失循环次包括第一个标志位将闪存的数据加载回数组函数参数存储模块保存数据到闪存参数无返回值无擦除指定页循环次包括第一个标志位将数组的数据备份保存到闪存函数参数存储模块将所有有效数据清参数无返回值无循环次除了第一个标志位数组有效数据清保存数据到闪存定义用于接收按键键码的变量模块初始化初始化按键初始化参数存储模块初始化在上电的时候将闪存的数据加载回实现掉电不丢失显示静态字符串获取按键键码按键按下变换测试数据将的数据备份保存到闪存实现掉电不丢失按键按下将的数据全部清显示的第一位标志位显示的有效存储数据实现按键按下存入中按键按下清除数据读取芯片使用指针直接访问读取对应手册章内容初始化显示静态字符串使用指针读取指定地址下的闪存容量寄存器显示静态字符串使用指针读取指定地址下的产品唯一身份标识寄存器闪存容量寄存器使用半字读取产品唯一身份标识寄存器个半字和个字读取全部显示到上去存在的当程序很大时覆盖用户存储参数区问题描述我们上面由于程序较小程序存储在的靠前区域我们使用最后一页存储用户数据但是如果程序很大的时候可能就会到最后一页造成程序和用户数据存储的位置冲突解决方法给程序文件限定一个存储范围不让它分配到后面我们的用户数据空间来打开工程管理目前使用的是起始地址为大小为刚好使用完了程序存储区如果我们想把程序区的最后自己使用修改为这样到之前就是程序存储的地方后面地址我们可以自己存放用户参数注意修改大小不能太小太小了也会报错写入之前的擦除必要性默认状态是全存储器在擦除之前的默认值是即每个字节的每一位都设为当你想要写入数据时必须将目标区域从改为但是存储器并不支持直接将恢复为只能将其设置为擦除是将区域复位为全擦除操作是将整个存储单元如页面或扇区恢复为全状态为后续的写入做好准备只有当区域恢复为全后才能写入新的数据的写入操作是增量你可以在一个已擦除区域中写入数据但不能直接覆盖其中的我们可以使用这个软件直接查看和修改我们芯片内部的各个地址的内容关于上方的内部和选项字节模块对应都可以查看和修改使用代码配置读写保护时如果造成了芯片自锁但程序里没有预留解除写保护的代码造成没法下载程序了我们可以使用这个这个软件直接去掉读写保护就可以解除芯片的自锁',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-07-13 00:28:17',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://i.postimg.cc/fbN6bFqP/20220206101541-14a48.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="安知鱼的博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="安知鱼的博客"/><span class="back-menu-item-text">安知鱼的博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/keqiudi/keqiudi.github.io" title="我的博客仓库"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="我的博客仓库"/><span class="back-menu-item-text">我的博客仓库</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">THEDI的仓库</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/null"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/null"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AWS/" style="font-size: 1.05rem;">AWS<sup>2</sup></a><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>2</sup></a><a href="/tags/CLion/" style="font-size: 1.05rem;">CLion<sup>2</sup></a><a href="/tags/CMake/" style="font-size: 1.05rem;">CMake<sup>1</sup></a><a href="/tags/ESP32/" style="font-size: 1.05rem;">ESP32<sup>1</sup></a><a href="/tags/FreeRTOS/" style="font-size: 1.05rem;">FreeRTOS<sup>5</sup></a><a href="/tags/Git/" style="font-size: 1.05rem;">Git<sup>1</sup></a><a href="/tags/LCD/" style="font-size: 1.05rem;">LCD<sup>2</sup></a><a href="/tags/LVGL/" style="font-size: 1.05rem;">LVGL<sup>7</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem;">Linux<sup>8</sup></a><a href="/tags/MySQL/" style="font-size: 1.05rem;">MySQL<sup>2</sup></a><a href="/tags/PCB/" style="font-size: 1.05rem;">PCB<sup>2</sup></a><a href="/tags/QT/" style="font-size: 1.05rem;">QT<sup>1</sup></a><a href="/tags/keil/" style="font-size: 1.05rem;">keil<sup>1</sup></a><a href="/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1/" style="font-size: 1.05rem;">云服务<sup>3</sup></a><a href="/tags/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" style="font-size: 1.05rem;">启动流程<sup>2</sup></a><a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/" style="font-size: 1.05rem;">嵌入式<sup>2</sup></a><a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%89%E5%85%A8/" style="font-size: 1.05rem;">嵌入式安全<sup>3</sup></a><a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 1.05rem;">架构<sup>2</sup></a><a href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" style="font-size: 1.05rem;">环境配置<sup>4</sup></a><a href="/tags/%E7%A1%AC%E4%BB%B6/" style="font-size: 1.05rem;">硬件<sup>5</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>3</sup></a><a href="/tags/%E8%B0%83%E8%AF%95/" style="font-size: 1.05rem;">调试<sup>5</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/08/"><span class="card-archive-list-date">八月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">35</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/06/"><span class="card-archive-list-date">六月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/05/"><span class="card-archive-list-date">五月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/01/"><span class="card-archive-list-date">一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/02/"><span class="card-archive-list-date">二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">九月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6/" itemprop="url">嵌入式软件</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>嵌入式</span></a></span></div></div><h1 class="post-title" itemprop="name headline">STM32(标准库)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-01-13T13:48:37.000Z" title="发表于 2025-01-13 21:48:37">2025-01-13</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-07-12T16:28:17.907Z" title="更新于 2025-07-13 00:28:17">2025-07-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">68.5k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>242分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="STM32(标准库)"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为成都"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>成都</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="/assets/14.webp"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://www.thekqd.top/2025/01/13/STM32%E6%A0%87%E5%87%86%E5%BA%93/"><header><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6/" itemprop="url">嵌入式软件</a><a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/" tabindex="-1" itemprop="url">嵌入式</a><h1 id="CrawlerTitle" itemprop="name headline">STM32(标准库)</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">THEDI</span><time itemprop="dateCreated datePublished" datetime="2025-01-13T13:48:37.000Z" title="发表于 2025-01-13 21:48:37">2025-01-13</time><time itemprop="dateCreated datePublished" datetime="2025-07-12T16:28:17.907Z" title="更新于 2025-07-13 00:28:17">2025-07-13</time></header><h1 id="keil配置与芯片包下载"><a href="#keil配置与芯片包下载" class="headerlink" title="keil配置与芯片包下载"></a>keil配置与芯片包下载</h1><h2 id="固件库文件"><a href="#固件库文件" class="headerlink" title="固件库文件"></a>固件库文件</h2><p>以F103固件库为例：</p>
<p>STM32F10x_StdPeriph_Lib_V3.5.0固件库是为STM32F1系列微控制器设计的开发辅助库，主要用于简化对STM32F1外设的控制和配置。该库封装了对各类外设（如GPIO、ADC、USART、SPI、I2C等）的控制接口，使开发者无需直接操作复杂的寄存器就能使用这些硬件外设。通过它，开发者可以轻松地进行外设的初始化、配置和数据处理。</p>
<p><strong>主要结构</strong>：</p>
<ul>
<li><strong>_htmresc</strong>：图片没什么用</li>
<li><strong>Libraries</strong>：库函数的文件，我们之后建工程时会用<ul>
<li><strong>CMSIS</strong>：包含Cortex-Mx内核的相关定义和启动代码。<ul>
<li>CoreSupport：包含了与Cortex-M系列内核相关的文件，主要是一些适用于ARM Cortex-M内核的通用代码和数据结构，用于管理核心处理器功能。</li>
<li>DeviceSupport：含与特定厂商的微控制器设备相关的文件，特别是该设备特定的外设寄存器定义和访问方法。它提供了Cortex-M内核之外的硬件支持，适用于具体的MCU型号。</li>
</ul>
</li>
<li><strong>STM32F10x_StdPeriph_Driver</strong>：<strong>标准外设驱动库</strong>，包含STM32F1系列的外设驱动源文件和头文件。</li>
</ul>
</li>
<li><strong>Projects</strong>：是官方提供的工程示例和模板，使用库函数时可以参考</li>
<li><strong>Utilities</strong>：是STM32官方评估板的相关例程，这个评估版就是官方用STM32做的一个小电路板用来测评STM32的，文件夹内存放的就是小电路板的测评程序</li>
<li><strong>Release_Notes.html</strong>：这个是库函数的发布文档</li>
<li><strong>stm32f10x_stdperiph_lib_um.chm</strong>：使用手册，教大家如何使用库函数</li>
</ul>
<h2 id="keil新建工程"><a href="#keil新建工程" class="headerlink" title="keil新建工程"></a>keil新建工程</h2><ol>
<li>新建一个 new μVision Project，设置名称后，会出现选择芯片，如果只有ARM，则需要将官方的芯片包(在官方下载.pack文件)导入。</li>
</ol>
<blockquote>
<p> 最后会弹出来Manage Run-time Environment的界面，manage run-time environment是一个新建工程的小助手也有固件库，可以帮我快速建立工程，直接勾选即可，是keil5的新功能**。今天我们创建工程的方式是自己去搬运官网给的库，加深一下理解和增加动手能力，所以没有使用manage run-time environment来添加库，直接点击OK即可**</p>
</blockquote>
<p>此时就只有一个Target里面什么都没有，我们需要给它添加一点工程的必要文件。</p>
<p>此时我们可以看到刚刚创建的项目文件夹自动生成一堆文件夹，为了便于管理<strong>我们先在工程文件夹中创建一个Startup文件夹用于存放启动文件</strong></p>
<ol start="2">
<li>此时打开固件库文件夹-&gt;“STM32F10x_StdPeriph_Lib_V3.5.0”-“Libraries”-“CMSIS”-“CM3”-“DeviceSupport”-“ST”-“STM32F10x”-“startup”，然后选中全部一起复制到刚刚我们创建的Startup文件夹中。</li>
</ol>
<blockquote>
<p>这些就是STM32的启动文件，STM32程序就是从这些启动文件开始执行的</p>
</blockquote>
<ol start="3">
<li>“Libraries”-“CMSIS”-“CM3”-“DeviceSupport”-“ST”-“STM32F10x，我们把这三个文件也复制下来粘贴到Startup文件夹下</li>
</ol>
<blockquote>
<p>我们可以看到stm32f10x.h和两个system开头的文件</p>
<p>stm32f10x.h：是STM32的<strong>外设寄存器描述文件，用来描述STM32有哪些寄存器和它对应的地址。</strong></p>
<p>system文件：这个两个system文件(system_stm32f10x.c&#x2F;h)用于配置时钟，STM32F103主频72MHz就是在system文件里配置的。</p>
</blockquote>
<hr>
<p><strong>接下来，因为STM32是内核和内核外围设备(外设)组成的，而且内核的寄存器描述和外围设备的描述文件不是在一起的，所以我们还需要添加内核寄存器的描述文件</strong></p>
<ol start="4">
<li>进入“STM32F10x_StdPeriph_Lib_V3.5.0”-“Libraries”-“CMSIS”-“CM3”-“CoreSupport”。然后也把这两个相关内核相关的文件复制到Startup文件后所有的准备完成</li>
</ol>
<blockquote>
<p>里面有两个cm3(core_cm3.c和core_cm3.h)，这两个Cortex-M3文件就是<strong>内核的寄存器描述文件</strong>，还有一些内核配置函数</p>
</blockquote>
<ol start="5">
<li>返回keil中将刚刚的文件添加到工程中，在Target 1中add group然后将新建的文件夹改名为Startup，将刚刚所有的Startup文件夹中的文件添加进去。</li>
</ol>
<blockquote>
<ol>
<li><p>首先是启动文件的添加，有一堆startup文件，我们选择其中的一个startup_stm32f10x_md.s添加到工程中。</p>
<p><strong>有关启动文件的选择，请看下面的笔记</strong></p>
</li>
<li><p>然后剩下的所有.c和.h文件都要添加进去</p>
</li>
</ol>
<p>我们可以按住Ctrl键，然后依次选择他们，点击Add，Close即可</p>
<p>这里的文件都是STM32里最基本的文件，是不需要我们修改的，添加到工程即可，此时可以看到这些文件都带有钥匙图标，代表只读文件</p>
</blockquote>
<ol start="6">
<li>点击魔术棒，打开工程选项，在C&#x2F;C++中找到include Paths，添加Startup文件夹的路径至其中。</li>
</ol>
<blockquote>
<p>最后我们还要在工程选项里添加上该文件夹的头文件路径，否则找不到.h文件</p>
</blockquote>
<ol start="7">
<li>回到该项目的文件夹下，新建一个User文件夹，main函数就放在其中。再回到keil中，在Target添加一个组，改名为User，对其右键创建main.c到其中，此时在main.c中创建我们的main函数，进行开发即可。</li>
</ol>
<p><code>由于此时工程还没有添加STM32的库函数，所以是基于寄存器开发工程，如果想要使用寄存器开发那么到这里就可以结束了</code></p>
<hr>
<p><code>接下来继续添加库函数</code></p>
<ol start="8">
<li>打开项目文件夹，新建Library文件夹用于存放库函数，接着打开固件库的文件夹，“STM32F10x_StdPeriph_Lib_V3.5.0”-“Libraries”-“STM32F10x_StdPeriph_Driver”-“src”，全选复制粘贴到Library中去，然后再回到Inc中去，再次将头文件全部复制粘贴到Library中去。</li>
</ol>
<blockquote>
<ol>
<li><p>其中misc.c是内核的库函数</p>
</li>
<li><p>其他的就是外设库函数</p>
</li>
</ol>
</blockquote>
<ol start="9">
<li>回到keil中，在Target下添加一个组命名为Library，再将Library文件夹中的所有文件添加到工程中去，但是此时的库函数还不能直接使用，我们还需要在添加文件。继续打开固件库文“STM32F10x_StdPeriph_Lib_V3.5.0”-“Project”-“STM32F10x_StdPeriph_Template”中，把一个conf.h文件和两个it中断文件复制粘贴到User文件下，<strong>回到keil中将这三个文件添加到User的组中</strong></li>
</ol>
<blockquote>
<p>我们可以看到一个stm32f10x_conf.h的文件，这个config文件是用来配置库函数头文件包含关系，以及用来参数检查的函数定义，这是所有库函数都需要的</p>
<p>两个stm32f10x_it.c&#x2F;h文件是用来存放中断函数的</p>
</blockquote>
<ol start="10">
<li>最后我们还需要一个宏定义USE_STDPERIPH_DRIVER，我们打开<strong>b</strong>，切换到C&#x2F;C++中，在Define中添加”USE_STDPERIPH_DRIVER”，最后别忘了在下方的include Paths再将User和Library目录的路径添加进去。</li>
</ol>
<blockquote>
<p>我们可以在stm32f10x.h文件中的最下方看到有一段</p>
<p>#ifdef USE_STDPERIPH_DRIVER<br>#include “stm32f10x_conf.h”<br>#endif</p>
<p>这个的意思是如果定义了USE_STDPERIPH_DRIVER(使用标准外设驱动)这个宏定义，才会包含stm32f10x_conf.h，即才会生效。</p>
<p><code>由于stm32f10x_conf.h文件包含了所有库函数的头文件，所以我们只需要include stm32f10x.h文件就可以任意调用库函数了</code></p>
</blockquote>
<p>最终我们的基本模板为：</p>
<blockquote>
<ul>
<li>DebugConfig</li>
<li>Listings</li>
<li>Objects</li>
<li>Library</li>
<li>Startup</li>
<li>User</li>
</ul>
<p>前三个为创建项目后自动生成的文件夹，后三个为我们手动创建的。</p>
</blockquote>
<p><code>一定记得将所有带有头文件的目录添加到C/C++的include Paths中以便于编译器能够找到头文件</code></p>
<h2 id="启动文件的选择"><a href="#启动文件的选择" class="headerlink" title="启动文件的选择"></a>启动文件的选择</h2><p>我们在新建工程向Startup文件夹添加启动文件的时候，有一堆startup文件。当时我们选择其中的一个startup_stm32f10x_md.s添加到工程中。</p>
<p>现在来解释一下这个文件怎么选取：</p>
<p><strong>启动文件有很多类型，至于选择哪一个，我们要根据芯片的型号来选择</strong></p>
<p>看这张表：</p>
<blockquote>
<p>缩写                                翻译             FLASH容量        型号</p>
<p>LD(High Density)       小容量产品        16-32K             STM32F101&#x2F;102&#x2F;103</p>
<p>MD(Middle Density)      中容量产品      64-128K             STM32F101&#x2F;102&#x2F;103</p>
<p>HD(High Density)       大容量产品     256-512K             STM32F101&#x2F;102&#x2F;103</p>
<p>XL(Extra Large)       加大容量产品    大于512K             STM32F101&#x2F;102&#x2F;103</p>
<p>CL                                互联网产品       -                           STMF105&#x2F;107 </p>
<p>LD_VL(value line)       小容量产品超值系列        16-32K             STM32F100</p>
<p>MD_V                      中容量产品超值系列      64-128K             STM32F100</p>
<p>HD_VL                     大容量产品超值系列     256-512K             STM32F100</p>
</blockquote>
<ol>
<li><strong>先根据型号选择是哪个系列的启动文件</strong></li>
<li><strong>根据Flash容量选择对应的启动文件添加到Startup即可</strong></li>
</ol>
<h2 id="stm32f10x-h"><a href="#stm32f10x-h" class="headerlink" title="stm32f10x.h"></a>stm32f10x.h</h2><p>我们可以在stm32f10x.h文件中的最下方看到有一段</p>
<p>#ifdef USE_STDPERIPH_DRIVER<br>#include “stm32f10x_conf.h”<br>#endif</p>
<p>这个的意思是如果定义了USE_STDPERIPH_DRIVER(使用标准外设驱动)这个宏定义，才会包含stm32f10x_conf.h，即才会生效。</p>
<p><code>由于stm32f10x_conf.h文件包含了所有库函数的头文件，所以我们只需要在编程的时候include stm32f10x.h文件就可以任意调用库函数了</code></p>
<h2 id="新建工程步骤总结"><a href="#新建工程步骤总结" class="headerlink" title="新建工程步骤总结"></a>新建工程步骤总结</h2><ol>
<li><strong>建立工程文件夹，Keil中新建工程、选择型号</strong></li>
<li><strong>工程文件夹中建立Startup、Library、User等文件夹，复制固件库里面的文件到工程文件夹</strong></li>
<li><strong>工程里对应建立Start、Library、User等同名称的分组，并将文件夹内的文件添加到工程分组里</strong></li>
<li><strong>工程选项(魔法棒)，C&#x2F;C++ Include Paths内添加所有包含头文件的文件夹</strong></li>
<li><strong>工程选项(魔法棒)，C&#x2F;C++，Define中定义宏定义USE_STDPERIPH_DRIVER</strong></li>
<li><strong>工程选项(魔法棒)，Debug，下拉列表选择对应调试器，Settings，Flash，Download里勾选Reset and Run</strong></li>
</ol>
<h1 id="模块化编程"><a href="#模块化编程" class="headerlink" title="模块化编程"></a>模块化编程</h1><p>如果我们把所有的初始化代码都写到main函数中就会显得很杂乱，为此我们单独创建一个Hardware文件夹用于存放各外设驱动(LED.c，LED.h，Key.c，Key.h等)</p>
<ol>
<li>在项目文件夹下创一个Hartware文件夹</li>
<li>回到keil中添加一个名为Hardware的组，然后添加或创建对应外设驱动的文件。</li>
<li>将Hardware添加到魔法棒中的C&#x2F;C++的include Paths中</li>
</ol>
<p>最终我们的基本模板为：</p>
<blockquote>
<ul>
<li>DebugConfig</li>
<li>Listings</li>
<li>Objects</li>
<li>Library</li>
<li>Startup</li>
<li><strong>Hardware</strong></li>
<li>User</li>
</ul>
<p>前三个为创建项目后自动生成的文件夹，后四个个为我们手动创建的。</p>
</blockquote>
<p>例如在Hardware里的，LED驱动函数就是这样写的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LED_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED1_ON</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LED1_OFF</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED2_ON</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LED2_OFF</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED1_Turn</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	GPIO_SetBits(GPIOA,GPIO_Pin_6 | GPIO_Pin_7);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED1_ON</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_ResetBits(GPIOC,GPIO_Pin_2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED1_Turn</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(GPIO_ReadOutputDataBit(GPIOC,GPIO_Pin_2)==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		GPIO_SetBits(GPIOC,GPIO_Pin_2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		GPIO_ResetBits(GPIOC,GPIO_Pin_2);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>所有的外设都可以这样独立写成驱动函数，初始化函数等。这样使的项目更好管理</p>
</blockquote>
<h1 id="STM32启动文件"><a href="#STM32启动文件" class="headerlink" title="STM32启动文件"></a>STM32启动文件</h1><p>startup_stm32xx.s就是启动文件，这是一个用汇编写的文件，定义了中断向量表和中断服务函数等。启动有个复位中断是程序的入口，当stm32按下复位或者上电的时候，程序就会进入复位中断函数执行，复位中断函数做的就是调用SystemInit函数和调用main函数。</p>
<p>我们可以在启动文件文件的注释中知道流程为：</p>
<ol>
<li>初始化堆栈指针SP</li>
<li>初始化程序计数器PC为Reset_Handler</li>
<li>初始化堆、栈的大小</li>
<li>设置中断向量表的入口地址</li>
</ol>
<p> 转向Reset_Handler执行：</p>
<ol start="5">
<li>调用SystemInit()函数完成系统初始化(系统时钟、闪存接口配置等)</li>
<li>设置C库的分支入口为 __main(调用我们的main函数)</li>
</ol>
<hr>
<h1 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h1><ul>
<li><p>GPIO(General Purpose Input Output) 通用输入输出端口，可配置共8种输入输出模式。</p>
</li>
<li><p>引脚电平位0~3.3V，部分引脚可以容忍5V</p>
</li>
<li><p>输出模式下可控制端口输出高低电平，用于驱动LED，控制蜂鸣器，模拟通信协议输出时序</p>
</li>
<li><p>输入模式下可读取端口的高低电平或电压，用于读取按键输入、外接模块电平信号输入、ADC电压采集、模拟通信协议接收数据等</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44016222/article/details/123206403?ops_request_misc=&request_id=&biz_id=102&utm_term=stm32GPIO&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-123206403.nonecase&spm=1018.2226.3001.4187">STM32-GPIO介绍_stm32 gpio-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_52162042/article/details/121278274?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%BC%B1%E4%B8%8A%E6%8B%89%E5%92%8C%E5%BC%BA%E4%B8%8A%E6%8B%89&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-121278274.142%5Ev100%5Epc_search_result_base6&spm=1018.2226.3001.4187">上、下拉电阻（定义、强弱上拉、常见作用、吸电流、拉电流、灌电流）_弱上拉和强上拉的区别-CSDN博客</a></p>
<p><strong>操作stm32的GPIO分为三个步骤</strong>：</p>
<ol>
<li><strong>使用RCC开启GPIO时钟</strong></li>
<li><strong>使用GPIO_Init(库函数)函数初始化GPIO</strong></li>
<li><strong>使用输出或输入函数控制GPIO口</strong></li>
</ol>
<h2 id="RCC开启时钟"><a href="#RCC开启时钟" class="headerlink" title="RCC开启时钟"></a>RCC开启时钟</h2><p>在stm32f10x_rcc.h中，有很多RCC相关函数但是我们最常用的是这三个：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RCC_AHBPeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_AHBPeriph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*RCC AHB总线外设时钟控制*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB2PeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB2Periph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*RCC APB2总线外设时钟控制*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB1PeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB1Periph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*RCC APB1总线外设时钟控制*/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p> 我们可以跳到这些函数的定义查看注释我们可以知道，这些时钟控制函数就是<code>使能或失能外设时钟的</code></p>
<p> 参数1：选择外设</p>
<p> 参数2：使能或失能</p>
<p> 如果不知道该外设是否在这个总线上，我们可以在注释上面的列表看，如果出现了代表在这个总线上</p>
</blockquote>
<h2 id="GPIO标准库函数"><a href="#GPIO标准库函数" class="headerlink" title="GPIO标准库函数"></a>GPIO标准库函数</h2><p>在stm32f10x_gpio.h中:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIO_DeInit</span><span class="params">(GPIO_TypeDef* GPIOx)</span>;</span><br><span class="line"><span class="comment">/*指定GPIO外设被复位*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_AFIODeInit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">/*指定AFIO复位*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Init</span><span class="params">(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</span>;</span><br><span class="line"><span class="comment">/*初始化外设，为指定的GPIO初始化，使用的是我们自己创建的结构体*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_StructInit</span><span class="params">(GPIO_InitTypeDef* GPIO_InitStruct)</span>;</span><br><span class="line"><span class="comment">/*指定结构体赋值*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">GPIO_ReadInputDataBit</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">GPIO_ReadInputData</span><span class="params">(GPIO_TypeDef* GPIOx)</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">GPIO_ReadOutputDataBit</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">GPIO_ReadOutputData</span><span class="params">(GPIO_TypeDef* GPIOx)</span>;</span><br><span class="line"><span class="comment">/*GPIO读取函数*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_SetBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;<span class="comment">//指定端口拉高</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_ResetBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;<span class="comment">//指定端口拉低</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_WriteBit</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin, BitAction BitVal)</span>;<span class="comment">//端口写入指定值：Bit_SET或Bit_RESET</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Write</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> PortVal)</span>;</span><br><span class="line"><span class="comment">/*读写GPIO函数*/</span></span><br></pre></td></tr></table></figure>



<ul>
<li>对应GPIO的结构体定义如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint16_t</span> GPIO_Pin;             <span class="comment">/*!&lt; Specifies the GPIO pins to be configured.</span></span><br><span class="line"><span class="comment">                                      This parameter can be any value of @ref GPIO_pins_define */</span></span><br><span class="line"></span><br><span class="line">  GPIOSpeed_TypeDef GPIO_Speed;  <span class="comment">/*!&lt; Specifies the speed for the selected pins.</span></span><br><span class="line"><span class="comment">                                      This parameter can be a value of @ref GPIOSpeed_TypeDef */</span></span><br><span class="line"></span><br><span class="line">  GPIOMode_TypeDef GPIO_Mode;    <span class="comment">/*!&lt; Specifies the operating mode for the selected pins.</span></span><br><span class="line"><span class="comment">                                      This parameter can be a value of @ref GPIOMode_TypeDef */</span></span><br><span class="line">&#125;GPIO_InitTypeDef;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>标准库的GPIO_InitTypeDef结构体参数只有三个：mode、pin、speed</strong></p>
<p><strong>这些跳转到对应定义可以知道值</strong></p>
<p>HAL库有5个参数，对比起来标准库更简单了</p>
</blockquote>
<h2 id="具体流程代码"><a href="#具体流程代码" class="headerlink" title="具体流程代码"></a>具体流程代码</h2><p>假设我们需要点亮PC2的LED，查看手册后发现挂载再APB2总线上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*1.开启对应外设时钟*/</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/*2. 初始化GPIOC*/</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    <span class="comment">//定义GPIO_InitStructure结构体，三个参数赋值</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    <span class="comment">//调用GPIO_Init初始化对应GPIO口，函数中读取结构体自动配置写入到对应寄存器</span></span><br><span class="line">	GPIO_Init(GPIOC,&amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="实验-LED流水灯"><a href="#实验-LED流水灯" class="headerlink" title="实验-LED流水灯"></a>实验-LED流水灯</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOC,&amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		GPIO_WriteBit(GPIOC,GPIO_Pin_2,Bit_RESET);</span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		GPIO_WriteBit(GPIOC,GPIO_Pin_2,Bit_SET);</span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		GPIO_WriteBit(GPIOC,GPIO_Pin_3,Bit_RESET);</span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		GPIO_WriteBit(GPIOC,GPIO_Pin_3,Bit_SET);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*使用Write函数同时操控多个端口*/</span></span><br><span class="line"> <span class="comment">//		GPIO_Write(GPIOC,~0x0004);</span></span><br><span class="line"><span class="comment">//		Delay_ms(500);</span></span><br><span class="line"><span class="comment">//		GPIO_Write(GPIOC,0x0004);</span></span><br><span class="line"><span class="comment">//		Delay_ms(500);</span></span><br><span class="line"><span class="comment">//		GPIO_Write(GPIOC,~0x0008);</span></span><br><span class="line"><span class="comment">//		Delay_ms(500);</span></span><br><span class="line"><span class="comment">//		GPIO_Write(GPIOC,0x0008);</span></span><br><span class="line"><span class="comment">//		Delay_ms(500);</span></span><br><span class="line">        </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>当有多个引脚时，我们可以使用<strong>按位或的方式同时选中多个Pin</strong>：</p>
<p>GPIO_InitStructure.GPIO_Pin &#x3D; GPIO_Pin_2 | GPIO_Pin_3 | …….;      选中了Pin2和Pin3</p>
<p>我们来看对应定义：</p>
<p>#define GPIO_Pin_0                 ((uint16_t)0x0001)<br>#define GPIO_Pin_1                 ((uint16_t)0x0002)  </p>
<p>#define GPIO_Pin_3                 ((uint16_t)0x0008)</p>
<p>…….</p>
<p>#define GPIO_Pin_15                ((uint16_t)0x8000)</p>
<p>#define GPIO_Pin_All               ((uint16_t)0xFFFF)</p>
<p><code>一共16位，每一个引脚对应一个位，只需要使用按位或的操作既可以选中指定端口</code></p>
</blockquote>
<p><strong>知道这个后我们可以使用GPIO_Write函数同时操控多个端口：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*由于C语言不支持写2进制，故使用16进制来写*/</span></span><br><span class="line">		GPIO_Write(GPIOC,~<span class="number">0x0004</span>);<span class="comment">//~(0000 0000 0000 0100),pin2亮</span></span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		GPIO_Write(GPIOC,<span class="number">0x0004</span>);</span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		GPIO_Write(GPIOC,~<span class="number">0x0008</span>);<span class="comment">//~(0000 0000 0000 1000),pin3亮</span></span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		GPIO_Write(GPIOC,<span class="number">0x0008</span>);</span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<ul>
<li><strong>使用Systick实现的延时函数，直接使用即可</strong>，使用时创建一个System文件夹，并把他们放到System文件夹下，在keil创建System组即可</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Delay.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DELAY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DELAY_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_us</span><span class="params">(<span class="type">uint32_t</span> us)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_ms</span><span class="params">(<span class="type">uint32_t</span> ms)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_s</span><span class="params">(<span class="type">uint32_t</span> s)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Delay.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  微秒级延时</span></span><br><span class="line"><span class="comment">  * @param  xus 延时时长，范围：0~233015</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_us</span><span class="params">(<span class="type">uint32_t</span> xus)</span></span><br><span class="line">&#123;</span><br><span class="line">	SysTick-&gt;LOAD = <span class="number">72</span> * xus;				<span class="comment">//设置定时器重装值</span></span><br><span class="line">	SysTick-&gt;VAL = <span class="number">0x00</span>;					<span class="comment">//清空当前计数值</span></span><br><span class="line">	SysTick-&gt;CTRL = <span class="number">0x00000005</span>;				<span class="comment">//设置时钟源为HCLK，启动定时器</span></span><br><span class="line">	<span class="keyword">while</span>(!(SysTick-&gt;CTRL &amp; <span class="number">0x00010000</span>));	<span class="comment">//等待计数到0</span></span><br><span class="line">	SysTick-&gt;CTRL = <span class="number">0x00000004</span>;				<span class="comment">//关闭定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  毫秒级延时</span></span><br><span class="line"><span class="comment">  * @param  xms 延时时长，范围：0~4294967295</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_ms</span><span class="params">(<span class="type">uint32_t</span> xms)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(xms--)</span><br><span class="line">	&#123;</span><br><span class="line">		Delay_us(<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  秒级延时</span></span><br><span class="line"><span class="comment">  * @param  xs 延时时长，范围：0~4294967295</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_s</span><span class="params">(<span class="type">uint32_t</span> xs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(xs--)</span><br><span class="line">	&#123;</span><br><span class="line">		Delay_ms(<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h2><h2 id="GPIO相关寄存器"><a href="#GPIO相关寄存器" class="headerlink" title="GPIO相关寄存器"></a>GPIO相关寄存器</h2><p>查看芯片对应参考手册，结合对应代码可以得知如何使用GPIO相关寄存器</p>
<h2 id="引脚重映射-复用功能重映像"><a href="#引脚重映射-复用功能重映像" class="headerlink" title="引脚重映射(复用功能重映像)"></a>引脚重映射(复用功能重映像)</h2><p>在<code>参考手册</code>中，有一节复用功能I&#x2F;O和调试配置(AFIO)，这一章节专门就是讲的引脚复用重映像功能，手册描述如下：</p>
<p>为了优化64脚或100脚封装的外设数目，可以把一些复用功能重新映射到其他引脚上。设置复用重映射和调试I&#x2F;O配置寄存器(AFIO_MAPR)实现引脚的重新映射。这时，复用功能不再映射到它们的原始分配</p>
<blockquote>
<p>如果多个外设需要使用同一组引脚，默认引脚的配置可能会导致冲突。引脚重映像允许开发者重新分配功能到其他引脚，避免资源冲突。<br><strong>实际意义：</strong><br>在复杂系统中，可以高效利用芯片的引脚资源，而不用为了冲突放弃某些外设功能。</p>
<p>例如：</p>
<ul>
<li>需要同时使用<code>USART1</code>和<code>SPI1</code>，但两者默认引脚有重叠。</li>
<li>通过重映像将<code>USART1</code>从<code>PA9/PA10</code>移到<code>PB6/PB7</code>，释放<code>PA9/PA10</code>供其他功能使用。</li>
<li>这样我们就可以同时使用<code>USART1</code>和<code>SPI1</code>了</li>
</ul>
</blockquote>
<p><strong>对应库函数</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIO_PinRemapConfig</span><span class="params">(<span class="type">uint32_t</span> GPIO_Remap, FunctionalState NewState)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数1：对应外设重映射方式，一般是部分重映像或者完全重映像，具体查看对应手册</span></span><br><span class="line"><span class="comment"> * 参数2：是否是能</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><strong>使用方式</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PWM_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*1.开启AFIO时钟*/</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);</span><br><span class="line">    <span class="comment">/*2.选择对应外设的映射，映射方式即可*/</span></span><br><span class="line">	GPIO_PinRemapConfig(GPIO_PartialRemap1_TIM2,ENABLE);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable,ENABLE);</span></span><br><span class="line">    <span class="comment">/*接触JTAG复用，以便于TIM2能够重映射/</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>注意使用端口映射前，可能有些端口已经被占用了，比如调试端口JTAG，如果重映射使用的是调试端口，那么使用前需要先解除JTAG端口复用</p>
</blockquote>
<h1 id="EXTI-外部中断"><a href="#EXTI-外部中断" class="headerlink" title="EXTI(外部中断)"></a>EXTI(外部中断)</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>EXTI可以监测指定的GPIO口的电平信号，当其指定的GPIO口产生电平变化时，EXTI将立即向NVIC发出中断申请，经过NVIC裁决后即可中断CPU主程序，使CPU执行EXTI对应的中断程序。</strong></p>
<p><strong>支持的触发方式</strong>：上升沿&#x2F;下降沿&#x2F;双边沿&#x2F;软件触发</p>
<p><strong>支持的GPIO口</strong>：所有GPIO口，但相同的Pin不能同时触发中断(如：PA1与PB1与PC1之间)</p>
<p><strong>通道数</strong>：16个GPIO_Pin，外加PVD输出、RTC闹钟等</p>
<p><strong>触发响应的方式</strong>：<strong>中断响应&#x2F;事件响应</strong></p>
<ul>
<li><strong>中断响应</strong>：正常的引脚电平变化触发中断</li>
<li><strong>事件响应</strong>：不会触发中断，而是触发别的外设操作，属于外设之间的联合工作</li>
</ul>
<h2 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h2><p><code>相关的EXTI库函数去stm32f10x_exti.h中查看，这里直接使</code></p>
<h2 id="初始化配置流程"><a href="#初始化配置流程" class="headerlink" title="初始化配置流程"></a>初始化配置流程</h2><p>只需要从GPIO到NVIC这一路出现的外设模块配置好即可，一共5步</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/98-1752337644184-489.png" alt="image-20241117144622580"></p>
<ol>
<li><strong>配置RCC，打开相关的外设时钟</strong>。这里涉及到的是GPIO、AFIO、EXTI、NVIC的时钟，但由于EXTI和NVIC时钟(内核外设不需要开启时钟)一直都是打开的，不需要我们开启，所以只需要开启GPIO和AFIO时钟即可。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<span class="comment">//开启GPIOA时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);<span class="comment">//开启对应AFIO时钟</span></span><br></pre></td></tr></table></figure>



<ol start="2">
<li><strong>配置GPIO，配置我们的端口为输入模式</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);</span><br><span class="line">	</span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOC,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>在我们的手册中有对应外设每个引脚推荐配置模式，我们可以找到EXTI推荐配置为:浮空，上拉，下拉</strong></p>
</blockquote>
<ol start="3">
<li><strong>配置AFIO 通过 AFIO 外设将 PC13 引脚映射到 EXTI 外设上，以便用于外部中断</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 参数1：使用哪个GPIO作为外部中断源,GPIO_PortSourceGPIOx where x can be (A..G).</span></span><br><span class="line"><span class="comment"> * 参数2：指定需要配置的外部中断线, GPIO_PinSourcex where x can be (0..15).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*这里配置AFIO只需要这个函数即可*/</span></span><br><span class="line">GPIO_EXTILineConfig(GPIO_PortSourceGPIOC,GPIO_PinSource13);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>没有单独写AFIO的库函数，与GPIO库函数放在一起的，可以去gpio的库函数中找这个函数查看对应参数。虽然写的是GPIO，但是我们查看该函数定义可以发现里面操作的是AFIO的寄存器</p>
</blockquote>
<ol start="4">
<li><strong>配置EXTI，选择边沿触发方式，比如上升沿、双边沿等，还有触发响应方式，可以选择中断响应和事件响应。</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class="line">EXTI_InitStructure.EXTI_Line= EXTI_Line13;<span class="comment">//对应选择的外部中断线</span></span><br><span class="line">EXTI_InitStructure.EXTI_LineCmd= ENABLE; <span class="comment">// 使能或不使能</span></span><br><span class="line">EXTI_InitStructure.EXTI_Mode= EXTI_Mode_Interrupt ; <span class="comment">//两种模式，一种是中断响应，一种是事件响应</span></span><br><span class="line">EXTI_InitStructure.EXTI_Trigger= EXTI_Trigger_Falling; <span class="comment">// 触发方式</span></span><br><span class="line">EXTI_Init(&amp;EXTI_InitStructure);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>相关的EXTI库函数去stm32f10x_exti.h中查看，这里直接使用</p>
</blockquote>
<ol start="5">
<li><strong>配置NVIC，给我们的中断选择一个合适的优先级</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//优先级配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NVIC_PriorityGroupConfig()分组方式整个芯片只能只能用一种，按理来说这个分组的代码整个工程只需要执行一次即可。如果把这个函数放到模块里面进行分组，一定要确保每个模块分组都选的是同一个。也可以把这个代码放在主函数的开始，这样就不用每个模块分组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; <span class="comment">// 使能</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span> ; <span class="comment">//指定抢占优先级</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">2</span> ;  <span class="comment">//指定子优先级</span></span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br></pre></td></tr></table></figure>



<blockquote>
<p>因为NVIC是内核外设，库函数被分配到了misc.h&#x2F;c(杂项)文件中去了，在这里查找对应参数，对应函数用法。</p>
<p>NVIC_InitTypeDef 中查看注释我们可以知道IRQ需要到stm32f10x.h去找，我们要选择对应芯片的<strong>选择编译</strong>，这里我们是stm32f10x_MD</p>
<p>在里面的选择编译中，我们找到了EXTI15_10_IRQn &#x3D; 40 (stm32的EXTI10到15都是合并到了这个通道里)</p>
<p>所以我们定义为EXTI15_10_IRQn即可</p>
<hr>
<p><code>注意:配置NVIC时，NVIC_IRQChannel只能接受一个中断通道号，不能接收多个中断通道的组合，如果有多个中断通道配置需要配置多次</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn | EXTI0_IRQn;</span><br></pre></td></tr></table></figure>

<p><code>这样配置不会报错，但是两个中断都不会生效!!!</code></p>
<p><code>需要单独调用两次NVIC_Init初始化</code></p>
<hr>
<p>对应的设置抢占优先级和子优先级设置我们可以跳转到对应定义处，继续跳转到注释中提到的中断优先级对应的优先级表查看即可</p>
</blockquote>
<p><strong>只有两个按键配置流程连起来就是</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Key_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*1.配置RCC启用对应外设时钟*/</span></span><br><span class="line">     RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);</span><br><span class="line">	 RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);</span><br><span class="line">	 <span class="comment">/*2.配置GPIO*/</span></span><br><span class="line">     GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13|GPIO_Pin_12;</span><br><span class="line">	 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	 GPIO_Init(GPIOC,&amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	 <span class="comment">/*3.配置AFIO*/</span>			    GPIO_EXTILineConfig(GPIO_PortSourceGPIOC,GPIO_PinSource12);	 GPIO_EXTILineConfig(GPIO_PortSourceGPIOC,GPIO_PinSource13);</span><br><span class="line">     <span class="comment">/*4.配置EXTI*/</span></span><br><span class="line">	  EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class="line">	  EXTI_InitStructure.EXTI_Line= EXTI_Line12 | EXTI_Line13;<span class="comment">//对应选择的按键外部中断线</span></span><br><span class="line">      EXTI_InitStructure.EXTI_LineCmd= ENABLE; <span class="comment">// 使能或不使能</span></span><br><span class="line">	  EXTI_InitStructure.EXTI_Mode= EXTI_Mode_Interrupt ; <span class="comment">//两种模式，一种是中断，一种是事件</span></span><br><span class="line">      EXTI_InitStructure.EXTI_Trigger= EXTI_Trigger_Falling; <span class="comment">// 触发方式为下降沿触发</span></span><br><span class="line">	  EXTI_Init(&amp;EXTI_InitStructure);</span><br><span class="line">    </span><br><span class="line">	  <span class="comment">/*5.配置NVIC*/</span></span><br><span class="line">	  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">		</span><br><span class="line">      NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">	  NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;</span><br><span class="line">	  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; <span class="comment">// 使能</span></span><br><span class="line">	  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span> ; <span class="comment">//指定抢占优先级</span></span><br><span class="line">	  NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">2</span> ;  <span class="comment">//指定子优先级</span></span><br><span class="line">	  NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="中断函数"><a href="#中断函数" class="headerlink" title="中断函数"></a>中断函数</h2><p><strong>完成了外部中断初始化配置后，接下来就是编写中断函数</strong></p>
<p>在启动文件的中断向量表中找到对应的中断函数的名字，这里是<code>EXTI15_10_IRQHandler</code></p>
<p>将其从启动文件中复制到对应位置进行编写，名字一定不能错，错了就无法进入了</p>
<p><strong>编写步骤如下</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EXTI15_10_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*1.判断对应中断标志位是否为1(SET),如果是*/</span></span><br><span class="line">	<span class="keyword">if</span>(EXTI_GetITStatus(EXTI_Line12) == SET)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">/*2.清除对应中断标志位，否则会一直触发中断*/</span></span><br><span class="line">		EXTI_ClearITPendingBit(EXTI_Line12);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*3.用户干的事情*/</span></span><br><span class="line">		        </span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(EXTI_GetITStatus(EXTI_Line13) == SET)</span><br><span class="line">	&#123;</span><br><span class="line">		EXTI_ClearITPendingBit(EXTI_Line13);</span><br><span class="line">         <span class="comment">/*用户干的事情*/</span></span><br><span class="line">  		...</span><br><span class="line">		        </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><p>中断函数的返回值和参数都是void</p>
</li>
<li><p>此函数不用声明，中断触发自动调用</p>
</li>
<li><p>使用的相关函数在对应的exti标准库中去找(EXTI_GetITStatus等)，有两个获取标志位的函数，带有IT的是只能在中断中使用的，不带IT的是在中断外使用的</p>
</li>
</ol>
</blockquote>
<h2 id="实验-旋转编码器计数"><a href="#实验-旋转编码器计数" class="headerlink" title="实验- 旋转编码器计数"></a>实验- 旋转编码器计数</h2><p>旋转编码器相关知识见HAL库</p>
<p>此处旋转编码器<strong>A相对应：PB0</strong>，<strong>B相对应：PB1</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Encoder.h*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ENCODER_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ENCODER_</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Encoder_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> <span class="title function_">Encoder_Get</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int16_t</span> EncoderCount;<span class="comment">//全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Encoder_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 1.打开对应外设时钟 */</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE );</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE );<span class="comment">//选择AFIO这个外设，开启时钟，通常用于启用或禁用 AFIO 外设的时钟，以便进行相应的配置操作。</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 2.配置对应GPIO输入模式 */</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<span class="comment">//上拉输入，默认为高电平的输入方式</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0|GPIO_Pin_1;<span class="comment">//旋转编码器分两相，PB0 为A相，PB1为B相</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init (GPIOB ,&amp;GPIO_InitStructure);<span class="comment">//初始化GPIOB外设</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 3.AFIO配置，映射到对应EXTI线上去 */</span></span><br><span class="line">	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB,GPIO_PinSource0);</span><br><span class="line">	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB,GPIO_PinSource1);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* 4.EXTI配置 */</span></span><br><span class="line">	EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class="line">	EXTI_InitStructure.EXTI_Line=EXTI_Line0|EXTI_Line1;<span class="comment">//将第0条线路和第1条线路都初始化为中断模式，下降沿触发连线</span></span><br><span class="line">	EXTI_InitStructure.EXTI_LineCmd=ENABLE;<span class="comment">//开启中断</span></span><br><span class="line">	EXTI_InitStructure.EXTI_Mode=EXTI_Mode_Interrupt;<span class="comment">//中断模式</span></span><br><span class="line">	EXTI_InitStructure.EXTI_Trigger=EXTI_Trigger_Falling;<span class="comment">//下降沿触发，离开就+1</span></span><br><span class="line">	EXTI_Init(&amp;EXTI_InitStructure); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 5.NVIC配置,这个地方需要两个中断初始化 */</span></span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//选两位抢占两位响应，整个程序只需要配置一次</span></span><br><span class="line">	</span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannel=EXTI0_IRQn;<span class="comment">//外部中断0</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;/</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">1</span>;<span class="comment">//抢占优先级</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">1</span>;<span class="comment">//响应优先级</span></span><br><span class="line">	NVIC_Init (&amp;NVIC_InitStructure);</span><br><span class="line">	</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannel=EXTI1_IRQn;<span class="comment">//外部中断1</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">1</span>;<span class="comment">//抢占优先级</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">2</span>;<span class="comment">//响应优先级2大于1</span></span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">	<span class="comment">//PB0和PB1为同一抢占优先级，但PB1的响应优先级比PB0大，所以PB0可以被PB1打断</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int8_t</span> <span class="title function_">Encoder_Get</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//获取中断服务函数中改变的数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int8_t</span> num;</span><br><span class="line">	num=EncoderCount;</span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI0_IRQHandler</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//这个函数只有0这个引脚可以触发</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(EXTI_GetFlagStatus (EXTI_Line0)==SET)<span class="comment">//外部中断0的线被触发，进入中断</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_0)==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_1)==<span class="number">0</span>)<span class="comment">//A下降沿，B低电平，反转</span></span><br><span class="line">			&#123;</span><br><span class="line">				EncoderCount --;<span class="comment">//计数--</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		EXTI_ClearITPendingBit(EXTI_Line0);<span class="comment">//清除中断标志位，跳出中断</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//这个函数只有1这个引脚可以触发</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(EXTI_GetFlagStatus (EXTI_Line1)==SET)<span class="comment">//外部中断1的线被触发，进入中断</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_1)==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_0)==<span class="number">0</span>)<span class="comment">//B下降沿，A低电平正转，</span></span><br><span class="line">			&#123;</span><br><span class="line">				EncoderCount ++;<span class="comment">//计数++</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		EXTI_ClearITPendingBit(EXTI_Line1);<span class="comment">//清除中断标志位</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>正转编码器，counter增加，反转编码器，counter增加</strong></p>
</blockquote>
<p><code>这样写可以多次触发中断!!!</code></p>
<h2 id="实验-对射式红外传感器计次"><a href="#实验-对射式红外传感器计次" class="headerlink" title="实验-对射式红外传感器计次"></a>实验-对射式红外传感器计次</h2><h2 id="使用中断注意事项"><a href="#使用中断注意事项" class="headerlink" title="使用中断注意事项"></a>使用中断注意事项</h2><ol>
<li><strong>中断函数中不要执行耗时过长的代码，不要使用延时函数</strong></li>
<li><strong>不要在中断函数中和主函数调用相同的函数或操作同一个硬件，操作用一个全局变量时要将该变量声明为volatile,避免编译器优化</strong></li>
<li><strong>中断建议操作变量或者标志位(状态位)</strong></li>
</ol>
<h2 id="共用外部中断线问题"><a href="#共用外部中断线问题" class="headerlink" title="共用外部中断线问题"></a>共用外部中断线问题</h2><p>stm32内部资源有限，因此产生了很多共用资源，其中外部中断也是其中之一。外部中断的共用资源主要包括：</p>
<p><strong>1. 不同端口、同一pin口，共用一个中断线：如PA1、PB1、PC1共用外部中断线1——EXTI_Line1；</strong></p>
<p><strong>2. 不同pin口、同一端口：这个都不用说，PA1、PA2、PA3这些共用的是同一个端口寄存器之类的；</strong></p>
<p><strong>3. 同一pin口共用一个中断线，但16个中断线却只共用7个中断服务函数：其中中断线EXTI_Line0-4独立拥有一个中断服务，中断线5-9共用一个中断服务函数，中断线10-15共用一个中断服务函数。</strong></p>
<blockquote>
<p><strong>所以我们端口不同，pin口相同时也不可同时配置外部中断，比如PA1配置了外部中断那么PB1就不能配置外部中断！！！</strong></p>
</blockquote>
<h1 id="TIM-定时器"><a href="#TIM-定时器" class="headerlink" title="TIM(定时器)"></a>TIM(定时器)</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li><p>定时器可以对输入的时钟进行计数，并在计数值达到设定值时触发中断。</p>
</li>
<li><p>16位计数器、预分频器、自动重装载寄存器的时基单元，在72HZ计数时钟下可以实现最大59.65s((65535*65535)&#x2F;72MHz)的定时时间</p>
</li>
<li><p>具备基本的定时中断功能，还包含内外时钟源选择、时钟捕获、输出比较、编码器接口，主从触发模式等多种功能</p>
</li>
<li><p>分为三种：<strong>高级定时器、通用定时器、基本定时器</strong>，难度依次递减</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/33-1752337644184-488.png" alt="image-20241118144626208"></p>
<h2 id="计数器模式"><a href="#计数器模式" class="headerlink" title="计数器模式"></a>计数器模式</h2><p><strong>三种：向上计数模式、向下计数模式，中央对齐模式</strong></p>
<p><strong>基本定时器</strong>：只支持向上计数模式</p>
<p><strong>通用定时器和高级定时器</strong>：支持向上计数、向下计数、中央对齐计数</p>
<h2 id="时基单元"><a href="#时基单元" class="headerlink" title="时基单元"></a>时基单元</h2><p>定时器框图中最重要的是时基单元，由三部分构成：<strong>预分频器PSC、自动重装载器ARR、计数器CNT</strong></p>
<ol>
<li><p><strong>Prescaler(psc)-预分频值</strong>：内部有一个预分频器PSC，内部时钟先输入到这里完成分频。简单来说就是分频值</p>
<p>时钟信号被分频后的频率 F&#x3D; TCLK&#x2F;(PSC+1) </p>
</li>
<li><p><strong>auto-reload preload(arr)-自动重装载值</strong>：内部有一个自动重装载寄存器，简单来说就是设置计数值上限，最大为65535</p>
</li>
<li><p><strong>CNT-计数器</strong>：内部有一个计数器自增，会与自动重装在寄存器比较，当计数值等于自动重装载值arr时，将会触发<strong>更新中断或更新事件</strong>，同时清零计数器</p>
</li>
</ol>
<p><code>定时器溢出时间 Tout =  (arr+1)/F   =   (arr+1)*(PSC+1) /TCLK</code></p>
<h2 id="时钟源"><a href="#时钟源" class="headerlink" title="时钟源"></a>时钟源</h2><p><strong>在手册上我们可以看到，stm32通用定时器的时钟源有4种</strong>：</p>
<p>1、<strong>内部时钟(CK_INT)</strong></p>
<p>2、<strong>外部时钟模式1</strong>：外部输入引脚(TIx)</p>
<p>3、<strong>外部时钟模式2</strong>：外部触发输入(ETR)</p>
<p>4、<strong>内部触发输入(ITRx)</strong>：使用一个定时器作为另一个定时器的预分频器。如可以配置一个定时器Timer1而作为另一个定时器Timer2的预分频器。用于定时器级联</p>
<hr>
<p>基本定时器：只能选择内部时钟，也就是系统主频72MHz(F103)</p>
<p>通用(高级)定时器：时钟源不仅可以选择<strong>内部时钟输入</strong>，也可以选择<strong>外部时钟输入ETR</strong>(外部引脚输入)</p>
<p>在下面的<strong>参考手册通用定时器框图</strong>中可以看到通过TIMx_ETR引脚上可以外接一个外部方波时钟，在配置内部极性选择，边沿检测和预分频器，再配置一下输入滤波电路(对外部引脚输入进行滤波)，最后分为两路去<strong>ETRF(外部时钟模式2)<strong>和</strong>TRGI（外部时钟模式1）</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241118151537820-1752337644184-487.png" alt="image-20241118151537820"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/0-1752337644184-490.png" alt="image-20241118153011362"></p>
<blockquote>
<p>总结：看上面手册中的框图</p>
<p><strong>内部时钟输入</strong>：APB1&#x2F;APB2，一般为系统主频</p>
<p><strong>外部时钟输入</strong>：分为外部时钟模式1和外部时钟模式2</p>
<ol>
<li><p>ETR引脚(外部引脚输入)：经过一堆(极性选择、边沿检测、滤波等)后</p>
<ul>
<li>独立进入触发控制器(ETR独享)，是外部时钟模式2</li>
<li>通过触发器进入从模式控制器，是外部时钟模式1</li>
</ul>
</li>
<li><p>其他定时器(ITR)：是内部触发输入，来源于其他TIM，可以实现定时器级联，是外部时钟模式1</p>
</li>
<li><p>TIMx_CH1引脚的边沿(TI1F_ED)：外部时钟模式1</p>
</li>
<li><p>TIMx_CH1引脚(TI1FP1)：外部时钟模式1  </p>
</li>
<li><p>TIMx_CH2引脚(TI2FP2)：外部时钟模式1</p>
</li>
</ol>
<p>TI1FP1：Timer Input 1 Filter Polarity 1</p>
</blockquote>
<blockquote>
<p><code>一般情况下外部时钟通过ETR引脚就可以，其他这么多输入是为了某些特定场景使用，比如：ITR是为了定时器级联设置的</code></p>
</blockquote>
<h2 id="库函数-1"><a href="#库函数-1" class="headerlink" title="库函数"></a>库函数</h2><p><code>相关的库函数直接在stm32f10x_tim.h寻找使用,这里给出常用的</code></p>
<p><strong>时钟源选择</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_InternalClockConfig</span><span class="params">(TIM_TypeDef* TIMx)</span>;</span><br><span class="line"><span class="comment">//1.内部时钟</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ETRClockMode1Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ExtTRGPrescaler, <span class="type">uint16_t</span> TIM_ExtTRGPolarity,<span class="type">uint16_t</span> ExtTRGFilter)</span>;</span><br><span class="line"><span class="comment">//2.外部输入模式1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ETRClockMode2Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ExtTRGPrescaler, <span class="type">uint16_t</span> TIM_ExtTRGPolarity, <span class="type">uint16_t</span> ExtTRGFilter)</span>;</span><br><span class="line"><span class="comment">//3.外部输入模式2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_TIxExternalClockConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_TIxExternalCLKSource,<span class="type">uint16_t</span> TIM_ICPolarity, <span class="type">uint16_t</span> ICFilter)</span>;</span><br><span class="line"><span class="comment">//4.外部输入模式1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ITRxExternalClockConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_InputTriggerSource)</span>;</span><br><span class="line"><span class="comment">//5.内部触发输入，级联</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ETRConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ExtTRGPrescaler, <span class="type">uint16_t</span> TIM_ExtTRGPolarity,<span class="type">uint16_t</span> ExtTRGFilter)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>时基单元配置</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_TimeBaseInit</span><span class="params">(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)</span>;</span><br></pre></td></tr></table></figure>



<p><strong>中断输出控制配置</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_ITConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_IT, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure>



<p><strong>NVIC配置</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">NVIC_Init</span><span class="params">()</span></span><br></pre></td></tr></table></figure>



<p><strong>运行控制配置</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_Cmd</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>单独更改预分频值</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_PrescalerConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Prescaler, <span class="type">uint16_t</span> TIM_PSCReloadMode)</span>;</span><br></pre></td></tr></table></figure>



<p><strong>计数器模式配置</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_CounterModeConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_CounterMode)</span>;</span><br></pre></td></tr></table></figure>



<p><strong>计数器预装载配置</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_ARRPreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure>



<p><strong>手动写入计数器值</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetCounter</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Counter)</span>;</span><br></pre></td></tr></table></figure>



<p><strong>手动写入ARR值</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetAutoreload</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Autoreload)</span>;</span><br></pre></td></tr></table></figure>



<p><strong>获取计数器或预分频值</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> <span class="title function_">TIM_GetCounter</span><span class="params">(TIM_TypeDef* TIMx)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">TIM_GetPrescaler</span><span class="params">(TIM_TypeDef* TIMx)</span>;</span><br></pre></td></tr></table></figure>



<p><strong>中断相关函数</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FlagStatus <span class="title function_">TIM_GetFlagStatus</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_FLAG)</span>;<span class="comment">//中断外使用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearFlag</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_FLAG)</span>;</span><br><span class="line">ITStatus <span class="title function_">TIM_GetITStatus</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_IT)</span>;<span class="comment">//中断内使用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearITPendingBit</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_IT)</span>;</span><br></pre></td></tr></table></figure>



<h2 id="定时器中断-定时或计数功能"><a href="#定时器中断-定时或计数功能" class="headerlink" title="定时器中断(定时或计数功能)"></a>定时器中断(定时或计数功能)</h2><p><a target="_blank" rel="noopener" href="https://postimg.cc/kR4B9vCC"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241118154510279-1752337644181-485.png" alt="image-20241118154510279.png"></a></p>
<h3 id="TIM配置流程"><a href="#TIM配置流程" class="headerlink" title="TIM配置流程"></a>TIM配置流程</h3><p>首先新建Timer.c和Timer.h文件到Hardware中</p>
<p>我们将上方的定时中断基本结构图打通就完成了配置</p>
<p>具体流程：</p>
<ol>
<li><strong>RCC开启时钟</strong>：查看手册我们可以发现TIM2在APB1总线上，故开启APB1总线时钟</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);</span><br></pre></td></tr></table></figure>



<ol start="2">
<li><strong>选择时基单元的时钟源</strong>：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIM_InternalClockConfig(TIM2);<span class="comment">//上电后单片机默认使用内部时钟，这一行其实可以省略</span></span><br></pre></td></tr></table></figure>



<ol start="3">
<li><strong>配置时基单元</strong>：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode =TIM_CounterMode_Up;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period = <span class="number">10000</span><span class="number">-1</span>; </span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">7200</span><span class="number">-1</span>;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里并没有对CNT计数器的初始化，如果我们想更改，调用TIM_SetCounter函数进行更改即可</p>
<p>TIM_ClockDivision参数：与滤波器相关的分频，这里随便选</p>
<p>TIM_RepetitionCounter参数：<strong>重复计数器的值，高级定时器才有的，不用给0</strong></p>
</blockquote>
<ol start="4">
<li><strong>配置中断，即配置输出中断控制，允许更新中断输出到NVIC</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);<span class="comment">//配置为更新中断</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>这里的第二个参数我们选择的是更新中断，其他选择请跳转到对应函数的注释中查看</strong></p>
</blockquote>
<ol start="5">
<li><strong>配置NVIC，在NVIC中打开定时器中断的通道，并分配一个优先级</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//优先级分组</span></span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;<span class="comment">//NVIC配置</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn  ;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><strong>运行控制，我们需要使能定时器的运行，否则不会工作</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIM_Cmd(TIM2,ENABLE);</span><br></pre></td></tr></table></figure>



<p><strong>连起来就是</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Timer_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="comment">/*1.RCC使能时钟*/</span></span><br><span class="line">		RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);</span><br><span class="line">    </span><br><span class="line">		<span class="comment">/*2.时基单元时钟源选择：此处选择内部时钟*/</span></span><br><span class="line">		TIM_InternalClockConfig(TIM2);<span class="comment">//上电后单片机默认使用内部时钟，这一行其实可以省略</span></span><br><span class="line">    </span><br><span class="line">		<span class="comment">/*3.时基单元配置*/</span></span><br><span class="line">		TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">		TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;<span class="comment">//与滤波器相关的分频，这里随便选</span></span><br><span class="line">		TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<span class="comment">//计数器模式</span></span><br><span class="line">		TIM_TimeBaseInitStructure.TIM_Period = <span class="number">10000</span><span class="number">-1</span>; <span class="comment">//周期，也就是ARR的值</span></span><br><span class="line">		TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">7200</span><span class="number">-1</span>;<span class="comment">//预分频器的值</span></span><br><span class="line">		TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;<span class="comment">//重复计数器的值，高级定时器才有</span></span><br><span class="line">		TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">/*4.输出中断控制配置，允许更新中断输出到NVIC*/</span></span><br><span class="line">		TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);<span class="comment">//配置为更新中断</span></span><br><span class="line">		</span><br><span class="line">    	<span class="comment">/*5.NVIC配置*/</span></span><br><span class="line">		NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">		NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">		NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn  ;</span><br><span class="line">		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;</span><br><span class="line">		NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">		NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">/*6.定时器运行控制，使能一下*/</span></span><br><span class="line">		TIM_Cmd(TIM2,ENABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>中断函数</strong>：同样在启动文件中寻找</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(TIM_GetITStatus(TIM2,TIM_IT_Update)== SET)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*中间为用户代码*/</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">		TIM_ClearITPendingBit(TIM2,TIM_IT_Update);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>上方函数调用查看更新中断的标志位</strong></p>
</blockquote>
<h3 id="实验-使用定时器每秒计数-内部时钟"><a href="#实验-使用定时器每秒计数-内部时钟" class="headerlink" title="实验-使用定时器每秒计数(内部时钟)"></a>实验-使用定时器每秒计数(内部时钟)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Timer.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __TIMER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TIMER_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Timer.c*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint16_t</span> Num;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">		RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);</span><br><span class="line">	</span><br><span class="line">		TIM_InternalClockConfig(TIM2);<span class="comment">//上电后单片机默认使用内部时钟，这一行其实可以省略</span></span><br><span class="line">		</span><br><span class="line">		TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">		TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;<span class="comment">//与滤波器相关的分频，这里随便选</span></span><br><span class="line">		TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<span class="comment">//计数器模式</span></span><br><span class="line">		TIM_TimeBaseInitStructure.TIM_Period = <span class="number">10000</span><span class="number">-1</span>; <span class="comment">//周期，也就是ARR的值</span></span><br><span class="line">		TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">7200</span><span class="number">-1</span>;<span class="comment">//预分频器的值</span></span><br><span class="line">		TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;<span class="comment">//重复计数器的值，高级定时器才有</span></span><br><span class="line">		TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);</span><br><span class="line">	    </span><br><span class="line">        TIM_ClearFlag(TIM2,TIM_FLAG_Update);<span class="comment">//避免上电立即进入中断    </span></span><br><span class="line">    </span><br><span class="line">		TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);<span class="comment">//配置为更新中断</span></span><br><span class="line">		</span><br><span class="line">		NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">		NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">		NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;</span><br><span class="line">		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;</span><br><span class="line">		NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">		NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">	</span><br><span class="line">		TIM_Cmd(TIM2,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(TIM_GetITStatus(TIM2,TIM_IT_Update)== SET)</span><br><span class="line">	&#123;</span><br><span class="line">		Num++;</span><br><span class="line">		</span><br><span class="line">		TIM_ClearITPendingBit(TIM2,TIM_IT_Update);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> Num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	Timer_Init();</span><br><span class="line">	OLED_Init();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		OLED_ShowSignedNum(<span class="number">1</span>,<span class="number">5</span>,Num,<span class="number">5</span>);</span><br><span class="line">        OLED_ShowSignedNum(<span class="number">2</span>,<span class="number">5</span>,TIM_GetCounter(TIM2),<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里有个问题，上电后我们可以发现计数器的值直接为1，这代表在上电时就已经进入了一次中断处理程序了。</p>
<p>这是由于TIM_TimeBaseInit()函数中最后一排有个TIMx-&gt;EGR &#x3D; TIM_PSCReloadMode_Immediate; </p>
<p>查看注释可以知道其手动生成了一个更新事件(为了让预分频器缓冲寄存器起作用，更新才会起作用)，导致上电立即进入中断。</p>
<p>解决方案：</p>
<p>在TIM_TimeBaseInit()后，开启中断前使用手动清除标志位。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);</span><br><span class="line"><span class="comment">/*添加到这里即可*/</span></span><br><span class="line">TIM_ClearFlag(TIM2,TIM_FLAG_Update);</span><br><span class="line"></span><br><span class="line">TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);<span class="comment">//配置为更新中断</span></span><br></pre></td></tr></table></figure>



<h3 id="实验-对射式红外传感器-外部时钟模式2"><a href="#实验-对射式红外传感器-外部时钟模式2" class="headerlink" title="实验-对射式红外传感器(外部时钟模式2)"></a>实验-对射式红外传感器(外部时钟模式2)</h3><p><strong>参考手册查看到芯片的TIM2_CH1_ETR复用输入引脚为PA0，可以通过PA0引脚将传感器0模块的DO引脚输出波形引入到定时器TIM2中</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Timer.c*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint16_t</span> Num;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">		RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);</span><br><span class="line">		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line">		</span><br><span class="line">    <span class="comment">//有外部引脚输出，故先配置外部引脚</span></span><br><span class="line">		GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    <span class="comment">/*这里的GPIO输入模式在参考手册可以查到，使用TIM2外部输入，推荐为浮空输入*/</span></span><br><span class="line">		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class="line">		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;</span><br><span class="line">		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">		GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*这里选择的外部时钟模式2，对应参数选择跳转到对应函数查看注释*/</span></span><br><span class="line">		TIM_ETRClockMode2Config(TIM2,TIM_ExtTRGPSC_OFF,TIM_ExtTRGPolarity_NonInverted,<span class="number">0x0F</span>);</span><br><span class="line">    <span class="comment">//选择的是上升沿触发，最后一个参数是外部触发滤波器，取值对应可以在参考手册中从模式控制寄存器(TIMx_SMCR)中看到，取值为0x00~0x0f,如果我们不滤波(0x00)的话就会有很多抖动脉冲，计数很多次。这里一般选择0x0F(15)即可</span></span><br><span class="line">		</span><br><span class="line">		TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">		TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">		TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">		TIM_TimeBaseInitStructure.TIM_Period = <span class="number">10</span><span class="number">-1</span>; </span><br><span class="line">		TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">1</span><span class="number">-1</span>;</span><br><span class="line">		TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">		TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);</span><br><span class="line">		</span><br><span class="line">		TIM_ClearFlag(TIM2,TIM_FLAG_Update);</span><br><span class="line">		TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);</span><br><span class="line">		</span><br><span class="line">		NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">		NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">		NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;</span><br><span class="line">		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;</span><br><span class="line">		NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">		NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">	</span><br><span class="line">		TIM_Cmd(TIM2,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(TIM_GetITStatus(TIM2,TIM_IT_Update)== SET)</span><br><span class="line">	&#123;</span><br><span class="line">		Num++;</span><br><span class="line">		</span><br><span class="line">		TIM_ClearITPendingBit(TIM2,TIM_IT_Update);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> Num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	Timer_Init();</span><br><span class="line">	Key_Init();</span><br><span class="line">	LED_Init();</span><br><span class="line">	OLED_Init();</span><br><span class="line"><span class="comment">//	OLED_ShowChar(10,10,&#x27;a&#x27;);</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;	</span><br><span class="line">		OLED_ShowSignedNum(<span class="number">1</span>,<span class="number">5</span>,Num,<span class="number">5</span>);</span><br><span class="line">		</span><br><span class="line">		OLED_ShowSignedNum(<span class="number">2</span>,<span class="number">5</span>,TIM_GetCounter(TIM2),<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当我们把手放遮挡在拿开，计数器+1，计数9次后，Num+1</p>
</blockquote>
<h3 id="实验-循迹模块测量商品数量-外部时钟模式2"><a href="#实验-循迹模块测量商品数量-外部时钟模式2" class="headerlink" title="实验-循迹模块测量商品数量(外部时钟模式2)"></a>实验-循迹模块测量商品数量(外部时钟模式2)</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1N94y1u7Uz?spm_id_from=333.788.videopod.sections&vd_source=830e63bd86bd9268c1b7cd9ff383f386">【STM32】动画讲解定时器外部时钟 &amp; 实战传送带测速装置_哔哩哔哩_bilibili</a></p>
<p><strong>参考手册查看到芯片的TIM2_CH1_ETR复用输入引脚为PA0，可以通过PA0引脚将传感器0模块的DO引脚输出波形引入到定时器TIM2中。</strong></p>
<p>代码与上方完全相同</p>
<p>同样也可以使用外部时钟模式1的ETR从模式、TI1F_ED、TI1FP1、TI1FP2都可以实现</p>
<blockquote>
<p>最终我们将任意物品从循迹模块下方穿过，一个物品计数+1</p>
</blockquote>
<h2 id="输出比较功能-OC"><a href="#输出比较功能-OC" class="headerlink" title="输出比较功能(OC)"></a>输出比较功能(OC)</h2><h3 id="OC简介"><a href="#OC简介" class="headerlink" title="OC简介"></a>OC简介</h3><p>OC(Output Compare)——–输出比较</p>
<p>输出比较可以通过比较<strong>CNT计数器</strong>与<strong>CCR</strong>(Capture&#x2F;Compare Register)值的关系进行置1、置0或者翻转的操作，用于输出一定频率和占空比的PWM波形</p>
<blockquote>
<p><strong>CCR全称：Capture&#x2F;Compare Register  –   捕获&#x2F;比较寄存器</strong></p>
<p><strong>使用输入捕获时：就是捕获寄存器</strong></p>
<p><strong>使用输出比较时：就是比较寄存器</strong></p>
</blockquote>
<ul>
<li>每个高级定时器和通用定时器都拥有4个输出比较通道</li>
<li>高级定时器的前三个通道额外拥有死区生成和互补输出的功能</li>
</ul>
<h3 id="PWM输出简介"><a href="#PWM输出简介" class="headerlink" title="PWM输出简介"></a>PWM输出简介</h3><p> <strong>脉冲宽度调制-PWM</strong>，是英文“Pulse Width Modulation”的缩写，简称<strong>脉宽调制</strong>，其实是在利用微控制器的<strong>定时器模块</strong>来生成一种特定频率和占空比的<strong>脉冲信号(一段高低电平)</strong>，调整脉冲的宽度从而影响功率等。PWM信号是一种周期性的脉冲信号，通过调整脉冲的宽度（高电平时间）可以模拟模拟信号，控制电机速度、LED亮度、蜂鸣器响度等。必须具有惯性的系统才能使用PWM。</p>
<p><strong>PWM参数</strong>：</p>
<ol>
<li><p><strong>频率</strong> &#x3D; 1 &#x2F; Ts</p>
</li>
<li><p><strong>占空比</strong> &#x3D;  Ton &#x2F; Ts (图中的高电平占整个周期的时间)</p>
</li>
<li><p><strong>分辨率</strong> &#x3D; 占空比变化步距(占空比以多少百分比跳变，1%到%2到%3，分辨率就是1%)</p>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/1-1752337644184-491.png" alt="image-20241119175400365"></p>
<blockquote>
<p> PWM频率越快，等效模拟的信号也就越平稳，对应的性能开销也就越大</p>
<p> <strong>一般来说PWM的频率都在几K到几十K，这个频率就足够快了</strong></p>
</blockquote>
<hr>
<p><strong>原理图：CCR&#x3D;30时</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/2-1752337644184-492.png" alt="image-20241120214655665"></p>
<blockquote>
<p>参数计算：</p>
<p>PWM频率：Freq &#x3D; CK_PSC&#x2F;(PSC+1)*(ARR+1)</p>
<p>PWM占空比：Duty &#x3D; CCR&#x2F;(ARR+1)</p>
<p>PWM分辨率：Reso &#x3D; 1 &#x2F; (ARR+1)   <strong>占空比越细腻越好</strong></p>
</blockquote>
<h3 id="舵机简介"><a href="#舵机简介" class="headerlink" title="舵机简介"></a>舵机简介</h3><p>舵机是一种根据输入<strong>PWM信号占空比来控制输出角度的装置</strong></p>
<p>常见的舵机型号有：SG90，SG92</p>
<p>输入PWM信号要求：<strong>周期为20ms</strong>，<strong>高电平时长为0.5ms<del>2.5ms(0</del>180°)，可以查看对应舵机手册得到驱动角度对应PWM的周期</strong></p>
<p>三根线：一根VCC，一根GND，一根信号线</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/3-1752337644184-493.png" alt="image-20241120215627230"></p>
<blockquote>
<p>给一个PWM，舵机就会固定在某一个角度，机械臂等机械机构就可以使用</p>
<p><strong>这里的PWM输出当成通信协议很常见，PWM波形通过信号线输出</strong></p>
</blockquote>
<h3 id="直流电机及驱动简介"><a href="#直流电机及驱动简介" class="headerlink" title="直流电机及驱动简介"></a>直流电机及驱动简介</h3><p>直流电机是一种将电能转换为机械能的装置，有两个电极，当电极正接时，电机正转，当电极反接时，电机反转。(对应一个引脚高电平一个引脚低电平)</p>
<p><strong>直流电机属于大功率器件，GPIO口无法直接驱动，需要配合<code>电机驱动芯片</code>来操作</strong></p>
<p>TB6612是一款双路H桥型的直流电机驱动芯片，可以驱动两个直流电机并控制其转速和方向，还有<strong>DRV8833驱动芯片</strong>等</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/4-1752337644184-494.png" alt="image-20241120221616621"></p>
<blockquote>
<p>在对应模块使用手册可以查看使用方法以及原理图，各引脚含义</p>
</blockquote>
<h3 id="库函数-2"><a href="#库函数-2" class="headerlink" title="库函数"></a>库函数</h3><p>主要初始化函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC1Init</span><span class="params">(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC2Init</span><span class="params">(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC3Init</span><span class="params">(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC4Init</span><span class="params">(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</span>;</span><br><span class="line"><span class="comment">/*对应的是四个输出比较通道的输出比较单元结构体的初始化*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OCStructInit</span><span class="params">(TIM_OCInitTypeDef* TIM_OCInitStruct)</span>;</span><br><span class="line"><span class="comment">/*用于为一个结构体赋初值*/</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC1PolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPolarity)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC2PolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPolarity)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC3PolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPolarity)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC4PolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPolarity)</span>;</span><br><span class="line"><span class="comment">/*极性配置</span></span><br><span class="line"><span class="comment"> * 对每个通道极性的单独配置 </span></span><br><span class="line"><span class="comment"> * 带N是高级定时器中互补通道的配置，OC4没有互补通道</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC1NPolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCNPolarity)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC2NPolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCNPolarity)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC3NPolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCNPolarity)</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_CCxCmd</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_Channel, <span class="type">uint16_t</span> TIM_CCx)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_CCxNCmd</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_Channel, <span class="type">uint16_t</span> TIM_CCxN)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*单独修改输出使能参数*/</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_SelectOCxM</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_Channel, <span class="type">uint16_t</span> TIM_OCMode)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*单独修改输出比较模式的函数*/</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetCompare1</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Compare1)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetCompare2</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Compare2)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetCompare3</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Compare3)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetCompare4</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Compare4)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*单独修改CCR寄存器的函数</span></span><br><span class="line"><span class="comment"> * 可用于调整占空比</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_CtrlPWMOutputs</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该函数仅高级定时器使用，在使用高级定时器输出PWM时，需要调用这个函数，使能主输出，否则PWM将不能正常输出</p>
</blockquote>
<hr>
<p><strong>一些小功能配置：使用不多</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_ForcedOC1Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ForcedAction)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ForcedOC2Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ForcedAction)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ForcedOC3Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ForcedAction)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ForcedOC4Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ForcedAction)</span>;</span><br><span class="line"><span class="comment">/*配置强制输出模式：在运行中想要暂停输出波形并且强制输出高或低电平使用</span></span><br><span class="line"><span class="comment"> * 一般不怎么使用，修改占空比为0或100也能实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_CCPreloadControl</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC1PreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPreload)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC2PreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPreload)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC3PreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPreload)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC4PreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPreload)</span>;</span><br><span class="line"><span class="comment">/*用于配置CCR寄存器的预装功能，也就是影子寄存器</span></span><br><span class="line"><span class="comment"> * 也就是：写入的值不会立即生效，而是在更新时间才会生效</span></span><br><span class="line"><span class="comment"> * 一般不使用</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC1FastConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCFast)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC2FastConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCFast)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC3FastConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCFast)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC4FastConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCFast)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*用于配置快速使能</span></span><br><span class="line"><span class="comment"> * 功能手册中，单脉冲模式有介绍</span></span><br><span class="line"><span class="comment"> * 一般不使用</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearOC1Ref</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCClear)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearOC2Ref</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCClear)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearOC3Ref</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCClear)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearOC4Ref</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCClear)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*外部事件时清楚REF信号</span></span><br><span class="line"><span class="comment"> * 不怎么使用</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="输出比较配置流程"><a href="#输出比较配置流程" class="headerlink" title="输出比较配置流程"></a>输出比较配置流程</h3><ol>
<li><p><strong>RCC开启时钟</strong></p>
</li>
<li><p><strong>配置GPIO：把PWM对应的GPIO口初始化为复用推挽输出模式(TIM复用)</strong></p>
</li>
<li><p><strong>选择时基单元时钟源</strong></p>
</li>
<li><p><strong>配置时基单元</strong></p>
</li>
<li><p><strong>配置输出比较单元：输出比较模式、极性选择、输出状态使能、CCR的值等</strong></p>
</li>
<li><p><strong>运行控制：启动对应TIM</strong></p>
</li>
</ol>
<h3 id="实验-PWM呼吸灯"><a href="#实验-PWM呼吸灯" class="headerlink" title="实验-PWM呼吸灯"></a>实验-PWM呼吸灯</h3><h4 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h4><ol>
<li><p><strong>RCC开启时钟，开启对应GPIO和TIM时钟</strong></p>
</li>
<li><p><strong>配置GPIO：把PWM对应的GPIO口初始化为复用推挽输出模式(TIM复用)</strong></p>
</li>
<li><p><strong>选择时基单元时钟源</strong></p>
</li>
<li><p><strong>配置时基单元</strong></p>
</li>
<li><p><strong>配置输出比较单元：输出比较模式、极性选择、输出状态使能、CCR的值等</strong></p>
</li>
<li><p><strong>运行控制：启动对应TIM</strong></p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*PWM.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __PWM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __PWM_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*PWM.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	 <span class="comment">//1.RCC开启时钟</span></span><br><span class="line">	 RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,ENABLE);</span><br><span class="line">	 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	 <span class="comment">//2.配置GPIO</span></span><br><span class="line">	 GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;<span class="comment">//复用推挽模式</span></span><br><span class="line">	 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;</span><br><span class="line">	 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	 GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	 <span class="comment">//3.配置时基单元时钟源</span></span><br><span class="line">	 TIM_InternalClockConfig(TIM3);</span><br><span class="line">	 <span class="comment">//4.配置时基单元</span></span><br><span class="line">	 TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">	 TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">	 TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up ;</span><br><span class="line">	 TIM_TimeBaseInitStructure.TIM_Period = <span class="number">100</span><span class="number">-1</span>;</span><br><span class="line">	 TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">720</span><span class="number">-1</span>;</span><br><span class="line">	 TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">	 TIM_TimeBaseInit(TIM3,&amp;TIM_TimeBaseInitStructure); </span><br><span class="line">	 <span class="comment">//5.配置输出比较单元</span></span><br><span class="line">	 TIM_OCInitTypeDef TIM_OCInitStructure;</span><br><span class="line">	 TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1 ;  <span class="comment">/*PWM1模式*/</span></span><br><span class="line">	 TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High ; <span class="comment">/*极性为高：有效电平为高电平*/</span></span><br><span class="line">	 TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;  <span class="comment">/*输出状态使能*/</span></span><br><span class="line">	 TIM_OCInitStructure.TIM_Pulse = <span class="number">0</span>; <span class="comment">//配置CCR</span></span><br><span class="line">	<span class="comment">/*这里时通用定时器，只需要列举需要的参数即可，高级定时器的参数可以不用管*/</span></span><br><span class="line">	 TIM_OC2Init(TIM3,&amp;TIM_OCInitStructure);</span><br><span class="line">	 <span class="comment">//6.运行控制，TIM使能</span></span><br><span class="line">	 TIM_Cmd(TIM3,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PWM.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> Num = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> pwmVal = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">		</span><br><span class="line">	PWM_Init();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;	</span><br><span class="line">	 </span><br><span class="line">		<span class="keyword">for</span>(;pwmVal&lt;<span class="number">100</span>;pwmVal++)</span><br><span class="line">		&#123;</span><br><span class="line">			TIM_SetCompare2(TIM3,pwmVal);</span><br><span class="line">			Delay_ms(<span class="number">10</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(;pwmVal&gt;<span class="number">0</span>;pwmVal--)</span><br><span class="line">		&#123;</span><br><span class="line">			TIM_SetCompare2(TIM3,pwmVal);</span><br><span class="line">			Delay_ms(<span class="number">10</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="实验-PWM驱动舵机"><a href="#实验-PWM驱动舵机" class="headerlink" title="实验-PWM驱动舵机"></a>实验-PWM驱动舵机</h3><blockquote>
<p>驱动舵机工作的频率为50HZ，也就是周期为20ms。</p>
<p>这里对应PSC设置为72-1，ARR设置为20000-1</p>
<p>舵机旋转角度对应的周期为500us<del>2500us(0.5ms</del>2.5ms)的高电平时长，对应占空比为：0.5ms&#x2F;20ms &#x3D; 2.5%  到    2.5ms&#x2F;20 &#x3D;12.5%  </p>
<p>即设置ARR的范围应该是500<del>2500(对应0</del>180°)</p>
</blockquote>
<p><code>配置流程与上一个实验一样</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Servo.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SERVO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SERVO_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Servo_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Servo_SetAngle</span><span class="params">(<span class="type">float</span> Angle)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Servo.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Servo_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	 RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4,ENABLE);</span><br><span class="line">	 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line"></span><br><span class="line">	 GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;<span class="comment">//复用推挽模式</span></span><br><span class="line">	 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;</span><br><span class="line">	 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	 GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line">	 <span class="comment">/*PB8为舵机的信号线*/</span></span><br><span class="line">	</span><br><span class="line">	 TIM_InternalClockConfig(TIM4);</span><br><span class="line">	</span><br><span class="line">	 TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">	 TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">	 TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up ;</span><br><span class="line">	 TIM_TimeBaseInitStructure.TIM_Period = <span class="number">20000</span><span class="number">-1</span>;</span><br><span class="line">	 TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">72</span><span class="number">-1</span>;</span><br><span class="line">	 TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">	 TIM_TimeBaseInit(TIM4,&amp;TIM_TimeBaseInitStructure); </span><br><span class="line">	</span><br><span class="line">	 TIM_OCInitTypeDef TIM_OCInitStructure;</span><br><span class="line">	 TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1 ;  <span class="comment">/*PWM1模式*/</span></span><br><span class="line">	 TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High ; <span class="comment">/*有效电平为高电平*/</span></span><br><span class="line">	 TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;  <span class="comment">/*输出状态使能*/</span></span><br><span class="line">	 TIM_OCInitStructure.TIM_Pulse = <span class="number">500</span>; <span class="comment">//配置CCR</span></span><br><span class="line">	<span class="comment">/*这里时通用定时器，只需要列举需要的参数即可，高级定时器的参数可以不用管*/</span></span><br><span class="line">	 TIM_OC3Init(TIM4,&amp;TIM_OCInitStructure);</span><br><span class="line">	 </span><br><span class="line">	 TIM_Cmd(TIM4,ENABLE);</span><br><span class="line">	 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置舵机角度*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Servo_SetAngle</span><span class="params">(<span class="type">float</span> Angle)</span></span><br><span class="line">&#123;</span><br><span class="line">	TIM_SetCompare3(TIM4,(Angle/<span class="number">180</span>)*(<span class="number">2000</span>)+<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Servo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> Num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">		</span><br><span class="line">	Key_Init();</span><br><span class="line"></span><br><span class="line">	Servo_Init();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;	</span><br><span class="line">		 Num = Key_GetNum();</span><br><span class="line">       <span class="keyword">if</span>(Num == <span class="number">1</span>)</span><br><span class="line">         &#123;</span><br><span class="line">                <span class="type">static</span> <span class="type">float</span> angle=<span class="number">0</span>;</span><br><span class="line">                  angle+=<span class="number">30</span>;</span><br><span class="line">                  <span class="keyword">if</span>(angle &gt; <span class="number">180</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        angle = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">              Servo_SetAngle(angle);</span><br><span class="line">       &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>按键按下，舵机旋转30度</strong></p>
</blockquote>
<h3 id="实验-PWM驱动DRV8833电机"><a href="#实验-PWM驱动DRV8833电机" class="headerlink" title="实验-PWM驱动DRV8833电机"></a>实验-PWM驱动DRV8833电机</h3><p>DRV8833相关知识见HAL库笔记</p>
<blockquote>
<p>DRV8833对应两个输入引脚，一个PWM输入，一个给高&#x2F;低电平可以实现正反转，对应查表见HAL库对应章节。</p>
<p><strong>对应PWM占空比越高，电机转速越快</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*DRV8833.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DRV8833_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DRV8833_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DRV8833_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DRV8833_SetSpeed</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>这里两个输入引脚为：PA0，PA1。PA0为PWM引脚，PA1为低电平引脚</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*DRV8833.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DRV8833_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">//1.</span></span><br><span class="line">	 RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);</span><br><span class="line">	 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">      </span><br><span class="line">     <span class="comment">//2.</span></span><br><span class="line">	 GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;</span><br><span class="line">	 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	 GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line">	 <span class="comment">/*配置PA1引脚为输出模式*/</span></span><br><span class="line">	  </span><br><span class="line">	 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;<span class="comment">//复用推挽模式</span></span><br><span class="line">	 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">	 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	 GPIO_Init(GPIOA,&amp;GPIO_InitStructure); </span><br><span class="line">	 <span class="comment">/*配置PWM引脚PA0，为复用推挽输出模式*/</span> </span><br><span class="line">     </span><br><span class="line">     <span class="comment">//3.</span></span><br><span class="line">	 TIM_InternalClockConfig(TIM2);</span><br><span class="line">	 <span class="comment">//4.</span></span><br><span class="line">	 TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">	 TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">	 TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up ;</span><br><span class="line">	 TIM_TimeBaseInitStructure.TIM_Period = <span class="number">100</span><span class="number">-1</span>;</span><br><span class="line">	 TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">72</span><span class="number">-1</span>;</span><br><span class="line">	 TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">	 TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure); </span><br><span class="line">	 </span><br><span class="line">     <span class="comment">//5.</span></span><br><span class="line">	 TIM_OCInitTypeDef TIM_OCInitStructure;</span><br><span class="line">	 TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1 ;  <span class="comment">/*PWM1模式*/</span></span><br><span class="line">	 TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High ; <span class="comment">/*有效电平为高电平*/</span></span><br><span class="line">	 TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;  <span class="comment">/*输出状态使能*/</span></span><br><span class="line">	 TIM_OCInitStructure.TIM_Pulse = <span class="number">0</span>; <span class="comment">//修改CCR的值可以改变转速</span></span><br><span class="line">	<span class="comment">/*这里时通用定时器，只需要列举需要的参数即可，高级定时器的参数可以不用管*/</span></span><br><span class="line">	 TIM_OC1Init(TIM2,&amp;TIM_OCInitStructure);</span><br><span class="line">	 </span><br><span class="line">     <span class="comment">//6.</span></span><br><span class="line">	 TIM_Cmd(TIM2,ENABLE);</span><br><span class="line">   </span><br><span class="line">	 GPIO_ResetBits(GPIOA,GPIO_Pin_1);</span><br><span class="line">	 <span class="comment">/*设置PA1为低电平*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DRV8833_SetSpeed</span><span class="params">(<span class="type">uint8_t</span> speed)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(speed&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TIM_SetCompare1(TIM2,speed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DRV8833.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">		</span><br><span class="line">	DRV8833_Init();</span><br><span class="line">    DRV8833_SetSpeed(<span class="number">50</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;	</span><br><span class="line">        </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>转速最大值可以设置100，为ARR最大值</strong></p>
</blockquote>
<h2 id="输入捕获功能-IC"><a href="#输入捕获功能-IC" class="headerlink" title="输入捕获功能(IC)"></a>输入捕获功能(IC)</h2><h3 id="IC简介"><a href="#IC简介" class="headerlink" title="IC简介"></a>IC简介</h3><p><strong>IC(Input Capture)——–输入捕获</strong></p>
<p>输入捕获模式下，当通道输入引脚出现指定电平跳变时，当前CNT的值将被锁存到CCR(捕获寄存器)中，<strong>可用于测量PWM波形的频率、占空比、脉冲间隔、电平持续时间等参数。</strong></p>
<blockquote>
<p> <strong>CCR全称：Capture&#x2F;Compare Register  –   捕获&#x2F;比较寄存器</strong></p>
<p> <strong>使用输入捕获时：就是捕获寄存器</strong></p>
<p> <strong>使用输出比较时：就是比较寄存器</strong></p>
</blockquote>
<p>每个高级定时器和通用定时器都拥有4个输入捕获通道：</p>
<ul>
<li><p>可配置为<code>PWMI模式</code>，同时测量频率和占空比</p>
</li>
<li><p>可配合主从触发模式，实现硬件全自动测量</p>
</li>
</ul>
<h3 id="频率测量"><a href="#频率测量" class="headerlink" title="频率测量"></a>频率测量</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/5-1752337644184-495.png" alt="image-20241125154510808"></p>
<blockquote>
<p><strong>测频法(测频率)</strong>：适合测量<code>高频</code>信号，<strong>计次数量多一些，有助于减小误差</strong></p>
<p><strong>特点</strong>：测量结果更新速度较慢，但是平均值，相当于均值滤波，结果比较稳定</p>
<p>fx &#x3D; N &#x2F; T</p>
<hr>
<p><strong>测周法(测周期)</strong>：适合测量<code>低频</code>信号，<strong>周期比较长，计次比较多，有助于减小误差</strong></p>
<p><strong>特点：只测量一个周期</strong>，测量结果更新速度较快，但结果值会受噪声的影响，波动比较大</p>
<p>fx &#x3D; fc &#x2F; N     fc为标准频率：标准频率就是经过PSC分频后的时钟频率</p>
<p><strong>在这里fc可以是使用输入捕获时定时器的频率，使用时需要每次触发后将CNT的值清0才是一个周期</strong></p>
<hr>
<p><strong>中界频率</strong>fm：</p>
<p>待测<code>信号频率&lt;中界频率</code>时，选用<code>测频法</code>误差更小</p>
<p>待测<code>信号频率&gt;中界频率</code>时，选用<code>测周法</code>误差更小</p>
<p>fm &#x3D; 根号下(fc &#x2F; T)</p>
</blockquote>
<h3 id="输入捕获通道"><a href="#输入捕获通道" class="headerlink" title="输入捕获通道"></a>输入捕获通道</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/6-1752337644184-496.png" alt="image-20241125161551723"></p>
<blockquote>
<p>同一个引脚TIx的输入信号映射到两个输入通道IC1和IC2，且两个通道的<code>极性检测相反</code>即这里的</p>
<p><strong>TI1引脚的输入信号可以映射到TI1FP1和TI1FP2</strong></p>
<p>TI1FP1连接到的是输入通道1，TI1FP2连接到的是输入通道2，可以使用两个捕获寄存器CCR</p>
<p><strong>T2引脚的输入信号可以映射到TI2FP1和TI2FP2</strong></p>
<p>TI2FP1连接到的是输入通道1，TI2FP2连接到的是输入通道2，也可以使用两个捕获寄存器CCR</p>
<p>一共四种连接方式</p>
</blockquote>
<blockquote>
<p><code>输入捕获的直接模式和间接模式</code>：信号从TI1引入，在自己的捕获寄存器1上进行输入捕获，就叫做<strong>输入捕获的直接模式</strong>。信号从TI1引入借用捕获寄存器2进行输入捕获，则叫做<strong>输入捕获的间接模式(交叉模式)</strong>。</p>
</blockquote>
<h3 id="主从触发模式"><a href="#主从触发模式" class="headerlink" title="主从触发模式"></a>主从触发模式</h3><p>主从触发模式是：<code>主模式</code>、<code>从模式</code>、<code>触发源</code>选择这三个功能的简称</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/7-1752337644184-497.png" alt="image-20241125162539989"></p>
<blockquote>
<p><code>主模式</code>：可以将定时器内部信号映射到TRGO 引脚，用于触发别的外设</p>
<p><code>从模式</code>：接收其他外设或者自身外设的一些信号，用于控制自身定时器的运行，也就是被别的信号控制</p>
<p><code>触发源选择</code>：就是选择从模式的触发信号源的，可以认为是从模式的一部分。选择指定的一个信号，得到TRGI，TRGI去触发从模式，在从模式列表中选择一项操作自动执行</p>
<p><strong>如：选择TI1FP1触发源，选择Reset操作就可以自动触发从模式，从模式<code>自动清零CNT</code></strong></p>
</blockquote>
<blockquote>
<p><code>主模式选择</code>可以在对应手册<strong>TIMx_CRx控制寄存器</strong>中查看</p>
<p><code>从模式选择</code>可以在对应手册<strong>TIMx_SMCR从模式控制寄存器</strong>中查看</p>
</blockquote>
<h3 id="输入捕获模式和PWM输入模式-PWMI-基本结构图"><a href="#输入捕获模式和PWM输入模式-PWMI-基本结构图" class="headerlink" title="输入捕获模式和PWM输入模式(PWMI)基本结构图"></a>输入捕获模式和PWM输入模式(PWMI)基本结构图</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/8-1752337644184-498.png" alt="image-20241125163454859"></p>
<blockquote>
<p><strong>特点</strong>：只使用了一个通道，<code>只能测量频率</code>，使用的是<code>测周法</code>测量频率，所以需要每次触发后将CNT的值手动清0。我们可以使用选择从模式触发实现信号触发后CNT自动清0</p>
<p><strong>F &#x3D; fc &#x2F; N</strong></p>
<p>**公式得来：**fc在待测频率的一个周期内的计数为N，所以待测频率的一个周期时长T &#x3D; N&#x2F;fc，又因为F &#x3D; 1 &#x2F; T ,所以F &#x3D; fc &#x2F; N</p>
<p><strong>fc为<code>标准频率</code>：标准频率就是经过PSC分频后的时钟频率</strong></p>
<p><strong>在待测频率的两个上升沿期间，CNT时钟按照fc的频率自增，当监测到第二个上升沿，CNT的值被锁存到CCR1中</strong></p>
<p><code>如果开启中断：</code><strong>捕获事件发生时，会产生中断请求，进入对应的输入捕获回调函数，然后可以读取CCR的值。如果没有配置从模式自动清零，那么需要我们手动在回调函数中对CNT清零</strong></p>
<hr>
<p><strong>因为CNT要自增，不能让他溢出，所以ARR的值要设置的足够大，设置为上限65535</strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/9-1752337644184-500.png" alt="image-20241125164342932"></p>
<blockquote>
<p><code>PWMI模式（PWM输入模式）</code>：<strong>使用两个通道来捕获，可以测量<code>频率</code>和<code>占空比</code>，使用的是测周法测量频率，所以需要每次触发后将CNT的值清0，使用从模式实现信号触发后自动清0</strong></p>
<p><strong>下面部分</strong>：</p>
<p>TI1FP1和TI1FP2以相反的极性检测(TI1FP1检测上升沿，TI1FP2检测下降沿)</p>
<p>CCR1：待测频率一整个周期的计数值(两个上升沿期间)，每一次上升沿到来时对应CNT都会清零</p>
<p>CCR2：带测频率高电平期间的计数值(上升沿和下降沿期间)</p>
<p>占空比：duty &#x3D; CCR2 &#x2F; CCR1</p>
<p><strong>因为CNT要自增，不能让他溢出，所以ARR的值要设置的足够大，设置为上限65535</strong></p>
<p><strong>CNT按照待测频率fc进行自增</strong></p>
<p><code>如果开启中断：</code><strong>捕获事件发生时，会产生中断请求，进入对应的输入捕获回调函数，然后可以读取CCR的值。如果没有配置从模式自动清零，那么需要我们手动在回调函数中对CNT清零</strong></p>
<hr>
<p><strong>上面部分</strong>：</p>
<p>但我们选择TI1FP1触发源，使用从模式配合输入捕获，实现CNT自动清零(Reset)，完成硬件自动化</p>
</blockquote>
<p><code>相关介绍对应在参考手册的输入捕获和PWM输入模式对应部分</code></p>
<h3 id="库函数-3"><a href="#库函数-3" class="headerlink" title="库函数"></a>库函数</h3><p><code>初始化函数：</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_ICInit</span><span class="params">(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)</span>;</span><br><span class="line"><span class="comment">/*配置输入捕获单元函数，输出比较是四个通道分别有一个函数，而输入捕获配置是4个通道共用一个函数，具体通道选择在结构体中*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_PWMIConfig</span><span class="params">(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)</span>;</span><br><span class="line"><span class="comment">/* 也是配置输入捕获单元的函数，但是这个函数可以快速配置两个通道，将外设电路配置为PWMI模式</span></span><br><span class="line"><span class="comment"> * 传入一个结构体之后，该函数会根据传入结构体通道配置自动初始化另外一个通道为相反的配置</span></span><br><span class="line"><span class="comment"> * 比如：传入结构体配置为通道1，上升沿触发，直接模式，调用该函数就会配置通道2为下降沿触发，且为交叉模式(间接模式)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 该函数只支持通道1和通道2，不能传入通道3和通道4!!!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ICStructInit</span><span class="params">(TIM_ICInitTypeDef* TIM_ICInitStruct)</span>;</span><br><span class="line"><span class="comment">/*输入捕获结构体初始化，一般在某些参数不用初始化的时后调用，防止没有初始化某些值造成意外错误*/</span></span><br></pre></td></tr></table></figure>



<p><code>主从模式相关函数</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_SelectOutputTrigger</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_TRGOSource)</span>;</span><br><span class="line"><span class="comment">/*选择输出触发源TRGO，对应主模式输出的触发源*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SelectInputTrigger</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_InputTriggerSource)</span>;</span><br><span class="line"><span class="comment">/*选择输入触发源TRGI，对应从模式的触发源选择*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SelectSlaveMode</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_SlaveMode)</span>;</span><br><span class="line"><span class="comment">/*选择从模式，对应从模式执行操作*/</span></span><br></pre></td></tr></table></figure>



<p><code>预分频配置</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetIC1Prescaler</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ICPSC)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetIC2Prescaler</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ICPSC)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetIC3Prescaler</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ICPSC)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetIC4Prescaler</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ICPSC)</span>;</span><br><span class="line"><span class="comment">/*分别配置通道1~4的预分频值，这个参数可以在结构体中配置*/</span></span><br></pre></td></tr></table></figure>



<p><code>获取捕获寄存器值</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> <span class="title function_">TIM_GetCapture1</span><span class="params">(TIM_TypeDef* TIMx)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">TIM_GetCapture2</span><span class="params">(TIM_TypeDef* TIMx)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">TIM_GetCapture3</span><span class="params">(TIM_TypeDef* TIMx)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">TIM_GetCapture4</span><span class="params">(TIM_TypeDef* TIMx)</span>;</span><br><span class="line"><span class="comment">/*分别获取四个通道的捕获寄存器CCR的值*/</span></span><br></pre></td></tr></table></figure>



<h3 id="输入捕获配置流程"><a href="#输入捕获配置流程" class="headerlink" title="输入捕获配置流程"></a>输入捕获配置流程</h3><p><code>根据上面的结构图可以得到输入捕获配置流程:</code></p>
<ol>
<li><p><strong>RCC开启时钟，将GPIO和TIM的时钟打开</strong></p>
</li>
<li><p><strong>GPIO初始化，配置GPIO为输入模式(上拉或者浮空)</strong></p>
</li>
<li><p><strong>配置时基单元的时钟源</strong></p>
</li>
<li><p><strong>配置时基单元，让CNT计数器在内部时钟的驱动下自增运行</strong></p>
</li>
<li><p><strong>配置输入捕获单元，包括滤波器、极性、直连通道还是交叉通道、分频器等参数</strong></p>
</li>
<li><p><strong>配置从模式触发源，触发源选择TI1FP1等</strong> (调用库函数)</p>
</li>
<li><p><strong>配置从模式执行的操作</strong>（调用库函数）</p>
</li>
<li><p><strong>运行控制，开启定时器TIM</strong></p>
</li>
</ol>
<h3 id="实验-输入捕获模式测频率-输入捕获直接模式"><a href="#实验-输入捕获模式测频率-输入捕获直接模式" class="headerlink" title="实验-输入捕获模式测频率(输入捕获直接模式)"></a>实验-输入捕获模式测频率(输入捕获直接模式)</h3><blockquote>
<p>这个地方没有信号发生器，选择将另外一个引脚TIM输出信号输入到该TIM引脚。从PB8输入到PA0</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*IC.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __IC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __IC_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IC_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">IC_GetFreq</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*IC.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IC_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.开启对应GPIO和TIM时钟</span></span><br><span class="line">	  RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);</span><br><span class="line">	  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"> 	<span class="comment">//2.配置GPIO为</span></span><br><span class="line">	  GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_0;</span><br><span class="line">	  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">      GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line">	<span class="comment">//3.时基单元时钟源配置	</span></span><br><span class="line">	  TIM_InternalClockConfig(TIM2);</span><br><span class="line">	<span class="comment">//4.时基单元配置</span></span><br><span class="line">      TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">	  TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">	  TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">	  TIM_TimeBaseInitStructure.TIM_Period = <span class="number">65536</span><span class="number">-1</span>;<span class="comment">//ARR</span></span><br><span class="line">	  TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">72</span><span class="number">-1</span>;<span class="comment">//PSC,标准频率fc = 72M/72 = 1MHz</span></span><br><span class="line">	  TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span> ;</span><br><span class="line">		TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);</span><br><span class="line">	  </span><br><span class="line">	<span class="comment">//5.输入捕获单元配置</span></span><br><span class="line">	  TIM_ICInitTypeDef TIM_ICInitStructure;</span><br><span class="line">	  TIM_ICInitStructure.TIM_Channel = TIM_Channel_1; <span class="comment">//CH1</span></span><br><span class="line">	  TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>; <span class="comment">//滤波值，越大滤波效果越好</span></span><br><span class="line">	  TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising ;<span class="comment">//上升沿捕获</span></span><br><span class="line">	  TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1; <span class="comment">//对应触发信号分频器，不分频DIV1就是每次触发都有效，2分频就是每隔一次生效一次</span></span><br><span class="line">      TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;<span class="comment">//输入捕获直接模式</span></span><br><span class="line">	  TIM_ICInit(TIM2,&amp;TIM_ICInitStructure);</span><br><span class="line">		</span><br><span class="line">    <span class="comment">//6.从模式触发源配置</span></span><br><span class="line">		TIM_SelectInputTrigger(TIM2,TIM_TS_TI1FP1);<span class="comment">//配置从模式输入触发源</span></span><br><span class="line">    <span class="comment">//7.从模式执行操作</span></span><br><span class="line">		TIM_SelectSlaveMode(TIM2,TIM_SlaveMode_Reset);<span class="comment">//配置从模式操作，使CNT自动清0</span></span><br><span class="line">	<span class="comment">//8.运行控制，启动TIM</span></span><br><span class="line">		TIM_Cmd(TIM2,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">IC_GetFreq</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1000000</span>/TIM_GetCapture1(TIM2)<span class="number">-1</span>; <span class="comment">//这里的-1是为了弥补+-1的误差</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个地方标准频率fc &#x3D; 72MHz &#x2F; 72 &#x3D; 1MHz &#x3D; 1000000</p>
<p>fc即为经过PSC分频过后的频率</p>
<p>测量最低频率为：1MHz &#x2F; 65535 &#x3D; 15Hz，再低会溢出。</p>
<p><strong>如果想要降低最低频率，只需要增大PSC的值</strong></p>
<p><strong>如果想要增大最低频率，只需要减小PSC的值</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PWM.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">	  PWM_Init();<span class="comment">//输出PWM信号</span></span><br><span class="line">	  PWM_SetPrescaler(<span class="number">720</span><span class="number">-1</span>);</span><br><span class="line">	  PWM_SetCompare3(<span class="number">25</span>);<span class="comment">//CCR = 25</span></span><br><span class="line">	   </span><br><span class="line">	  IC_Init();<span class="comment">//输入捕获</span></span><br><span class="line">	</span><br><span class="line">	  OLED_Init();</span><br><span class="line">	  OLED_ShowString(<span class="number">5</span>,<span class="number">1</span>,<span class="string">&quot;Freq:00000HZ&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;	</span><br><span class="line">		OLED_ShowNum(<span class="number">5</span>,<span class="number">6</span>,IC_GetFreq(),<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="实验-PWMI模式测频率和占空比-输入捕获交叉-间接模式"><a href="#实验-PWMI模式测频率和占空比-输入捕获交叉-间接模式" class="headerlink" title="实验-PWMI模式测频率和占空比(输入捕获交叉&#x2F;间接模式)"></a>实验-PWMI模式测频率和占空比(输入捕获交叉&#x2F;间接模式)</h3><blockquote>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*IC.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __IC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __IC_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IC_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">IC_GetFreq</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*IC.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IC_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.开启对应GPIO和TIM时钟</span></span><br><span class="line">	  RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);</span><br><span class="line">	  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"> 	<span class="comment">//2.配置GPIO为</span></span><br><span class="line">	  GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_0;</span><br><span class="line">	  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">      GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line">	<span class="comment">//3.时基单元时钟源配置	</span></span><br><span class="line">	  TIM_InternalClockConfig(TIM2);</span><br><span class="line">	<span class="comment">//4.时基单元配置</span></span><br><span class="line">      TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">	  TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">	  TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">	  TIM_TimeBaseInitStructure.TIM_Period = <span class="number">65536</span><span class="number">-1</span>;<span class="comment">//ARR</span></span><br><span class="line">	  TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">72</span><span class="number">-1</span>;<span class="comment">//PSC,标准频率fc = 72M/72 = 1MHz</span></span><br><span class="line">	  TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span> ;</span><br><span class="line">		TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);</span><br><span class="line">	  </span><br><span class="line">	<span class="comment">//5.输入捕获单元配置</span></span><br><span class="line">	  TIM_ICInitTypeDef TIM_ICInitStructure;</span><br><span class="line">		TIM_ICInitStructure.TIM_Channel = TIM_Channel_1; <span class="comment">//CH1</span></span><br><span class="line">	  TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>; <span class="comment">//滤波值，越大滤波效果越好</span></span><br><span class="line">		TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising ;<span class="comment">//上升沿捕获</span></span><br><span class="line">		TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1; <span class="comment">//对应触发信号分频器，不分频DIV1就是每次触发都有效，2分频就是每隔一次生效一次</span></span><br><span class="line">		TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;<span class="comment">//输入捕获直接模式</span></span><br><span class="line">	    TIM_PWMIConfig(TIM2,&amp;TIM_ICInitStructure);</span><br><span class="line">        <span class="comment">/*输入捕获模式和PWMI模式差别就在这里*/</span></span><br><span class="line"><span class="comment">//	  TIM_ICInit(TIM2,&amp;TIM_ICInitStructure);</span></span><br><span class="line"><span class="comment">//	  TIM_ICInitStructure.TIM_Channel = TIM_Channel_2; //CH2</span></span><br><span class="line"><span class="comment">//	  TIM_ICInitStructure.TIM_ICFilter = 0xF; </span></span><br><span class="line"><span class="comment">//		TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Falling ;//下降沿捕获，与通道一相反</span></span><br><span class="line"><span class="comment">//		TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1; </span></span><br><span class="line"><span class="comment">//		TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_IndirectTI;//输入捕获交叉模式</span></span><br><span class="line"><span class="comment">//		TIM_ICInit(TIM2,&amp;TIM_ICInitStructure);</span></span><br><span class="line">		</span><br><span class="line">    <span class="comment">//6.从模式触发源配置</span></span><br><span class="line">		TIM_SelectInputTrigger(TIM2,TIM_TS_TI1FP1);<span class="comment">//配置从模式输入触发源</span></span><br><span class="line">    <span class="comment">//7.从模式执行操作</span></span><br><span class="line">		TIM_SelectSlaveMode(TIM2,TIM_SlaveMode_Reset);<span class="comment">//配置从模式操作</span></span><br><span class="line">	<span class="comment">//8.运行控制，启动TIM</span></span><br><span class="line">		TIM_Cmd(TIM2,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*获取频率*/</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">IC_GetFreq</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1000000</span>/TIM_GetCapture1(TIM2)<span class="number">-1</span>; <span class="comment">//这里的-1是为了弥补+-1的误差</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*获取占空比*/</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">IC_GetDuty</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> TIM_GetCapture2(TIM2)*<span class="number">100</span>/TIM_GetCapture1(TIM2)+<span class="number">1</span>;<span class="comment">//弥补误差</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><p><strong>使用TIM_PWMIConfig(TIM2,&amp;TIM_ICInitStructure)函数可以快速配置两个通道，见源码可知，该函数自动初始化该通道和初始化另外一个通道为相反的配置。</strong></p>
</li>
<li><p><strong>不使用该函数，就配置两次即可，即上方注释部分，通道1配置为上升沿捕获，直接模式，通道2就配置为下降沿捕获，交叉模式，调用两次初始化函数即可。</strong></p>
</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PWM.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">	  PWM_Init();<span class="comment">//输出PWM信号</span></span><br><span class="line">	  PWM_SetPrescaler(<span class="number">720</span><span class="number">-1</span>);</span><br><span class="line">	  PWM_SetCompare3(<span class="number">25</span>);<span class="comment">//CCR = 25</span></span><br><span class="line">	   </span><br><span class="line">	  IC_Init();<span class="comment">//输入捕获</span></span><br><span class="line">	</span><br><span class="line">	  OLED_Init();</span><br><span class="line">	  OLED_ShowString(<span class="number">5</span>,<span class="number">1</span>,<span class="string">&quot;Freq:00000HZ&quot;</span>);</span><br><span class="line">	  OLED_ShowString(<span class="number">10</span>,<span class="number">1</span>,<span class="string">&quot;Duty:00%&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;	</span><br><span class="line">		OLED_ShowNum(<span class="number">5</span>,<span class="number">6</span>,IC_GetFreq(),<span class="number">5</span>);</span><br><span class="line">		OLED_ShowNum(<span class="number">10</span>,<span class="number">6</span>,IC_GetDuty(),<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="编码器接口"><a href="#编码器接口" class="headerlink" title="编码器接口"></a>编码器接口</h2><h3 id="编码器接口简介"><a href="#编码器接口简介" class="headerlink" title="编码器接口简介"></a>编码器接口简介</h3><p>Encoder Interface - 编码器接口</p>
<p>编码器接口可接收增量(正交编码器)的信号，根据编码器旋转产生的正交信号脉冲，自动控制<code>CNT</code>自增或自减，从而指示编码器的位置、<strong>旋转方向和旋转速度</strong></p>
<ul>
<li><p>每个高级定时器和通用定时器都拥有1个编码器接口，基本定时器没有编码器接口</p>
</li>
<li><p>两个输入引脚(CH1、CH2)借用了输入捕获通道的<code>通道1</code>和<code>通道2</code></p>
</li>
</ul>
<blockquote>
<p>之前我们使用了编码器中断来手动计次，使用编码器接口可以实现自动计次，减少资源浪费，避免频繁中断</p>
</blockquote>
<h3 id="正交编码器介绍"><a href="#正交编码器介绍" class="headerlink" title="正交编码器介绍"></a>正交编码器介绍</h3><p>拥有A相和B相，输出的两个<code>正交方波信号</code>，相位相差90°，超前90°和滞后90°代表正传和反转。</p>
<p>编码器测速使用的是<code>测频法</code>测量</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/10-1752337644184-499.png" alt="image-20241126213304783"></p>
<blockquote>
<p><code>编码器的上升沿和下降沿都有效</code></p>
<p>正传CNT自增</p>
<p>反转CNT自减</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/12-1752337644184-501.png" alt="image-20241126222220541"></p>
<blockquote>
<p><strong>三种工作方式</strong>：</p>
<p>1.仅在T1计数 </p>
<p>2.仅在T2计数 </p>
<p>3.在T1和T2都计数 </p>
<p><code>一般我们使用第三种</code></p>
<p><strong>编码器接口执行逻辑总结下来就一句话</strong>：</p>
<p>正转的时候向上计数，反转的时候向下计数</p>
</blockquote>
<hr>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/13-1752337644184-502.png" alt="image-20241126222801623"></p>
<blockquote>
<p><code>正交编码器是抗噪声的原理</code>：</p>
<p>当遇到毛刺现象时，CNT的值会来回跳动，一会自增一会自减，但最终的值保持不变。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/14-1752337644184-503.png" alt="image-20241126223216790"></p>
<blockquote>
<p>当TI极性选择反相时，需要将图中TI的波形反向后才能得到正确的计数方向。</p>
<p>当我实际使用过程中如果出现想要正传计数+1，但是却出现-1的情况，我们把任意一个引脚极性反相，就能反转计数方向了。或者直接交换A、B相引脚即可</p>
</blockquote>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>比较常见的应用场景：</p>
<p>编码器测速一般应用在电机控制的项目上，使用PWM驱动电机，再使用编码器测量电机的速度，然后再用PID算法进行闭环控制。</p>
<p>一般电机旋转速度较高，会使用无接触式的霍尔传感器或者光栅进行测速。</p>
<p>这里为了方便，我们使用触点式的旋转编码器。电机旋转呢，我们就用人工旋转来模拟，但实际上旋转编码器和电机的霍尔，光栅编码器都是一样的效果</p>
<h3 id="编码器接口基本结构图"><a href="#编码器接口基本结构图" class="headerlink" title="编码器接口基本结构图"></a>编码器接口基本结构图</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/11-1752337644184-504.png" alt="image-20241126221118178"></p>
<blockquote>
<p>对应CH1的TI1FP1和CH2的TI2FP2，与CH3和CH4无关。</p>
<p>ARR是有效的，一般设置为65535，利用补码的特性可以CNT从0自减时得到的是65535、65534….</p>
<p><code>编码器的时钟会直接托管驱动计数器，所以在编码器接口模式下时基单元不需要配置内部时钟并且计数模式无效</code></p>
<hr>
<p><code>同时输入捕获单元并没有完全使用，只需要配置滤波器和极性选择即可</code></p>
</blockquote>
<p><code>更多内容可以在参考手册中的TIM编码器接口模式中查看</code></p>
<h3 id="库函数-4"><a href="#库函数-4" class="headerlink" title="库函数"></a>库函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_EncoderInterfaceConfig</span></span><br><span class="line"><span class="params">(TIM_TypeDef* TIMx,</span></span><br><span class="line"><span class="params"> <span class="type">uint16_t</span> TIM_EncoderMode,</span></span><br><span class="line"><span class="params"> <span class="type">uint16_t</span> TIM_IC1Polarity, </span></span><br><span class="line"><span class="params"> <span class="type">uint16_t</span> TIM_IC2Polarity)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**配置编码器接口的函数</span></span><br><span class="line"><span class="comment"> * 参数1：哪个定时器</span></span><br><span class="line"><span class="comment"> * 参数2：编码器模式,三种：1.仅在T1计数 2.仅在TI2计数 3.T1和T2都计数</span></span><br><span class="line"><span class="comment"> * 一般我们使用第三种T1,T2都计数</span></span><br><span class="line"><span class="comment"> * 参数3：通道1极性,Rising为不反相，Falling为反相</span></span><br><span class="line"><span class="comment"> * 参数4：通道2极性,Rising为不反相，Falling为反相</span></span><br><span class="line"><span class="comment"> * 参数3和参数4根据实际情况选择</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="编码器接口配置流程"><a href="#编码器接口配置流程" class="headerlink" title="编码器接口配置流程"></a>编码器接口配置流程</h3><ol>
<li><p><strong>RCC开启时钟，开启GPIO和对应TIM的时钟</strong></p>
</li>
<li><p><strong>配置GPIO，将对应引脚配置为输入模式</strong></p>
</li>
<li><p><strong>配置时基单元，预分频器不分频，ARR设置为65535</strong>(不用配置时基单元的内部时钟，编码器会托管相当于外部时钟)</p>
</li>
<li><p><strong>配置输入捕获单元，此处输入捕获单元只有滤波器和极性两个参数有用，其他参数没用到</strong></p>
</li>
<li><p><strong>配置编码器接口模式</strong></p>
</li>
<li><p><strong>运行控制，启动定时器</strong></p>
</li>
</ol>
<blockquote>
<p>初始化完成后，CNT就会随着编码器旋转而自增自减。</p>
<p>如果想要读出编码器位置，直接读出CNT的值就行了</p>
<p>如果想要测量编码器的速度和方向，就需要每隔一定阀门时间，取出一次CNT，然后再把CNT清零，即<code>测频法</code>测量速度</p>
</blockquote>
<h3 id="实验-正交编码器测速"><a href="#实验-正交编码器测速" class="headerlink" title="实验-正交编码器测速"></a>实验-正交编码器测速</h3><p>我们使用的是A相：PA8，B相PA9，对应定时器TIM1_CH1和TIM1_CH2</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Encoder.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ENCODER_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ENCODER_</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Encoder_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> <span class="title function_">Encoder_Get</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Encoder.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Encoder_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	  <span class="comment">//1.配置RCC，开启GPIO和对应TIM </span></span><br><span class="line">		RCC_APB1PeriphClockCmd(RCC_APB2Periph_TIM1,ENABLE);</span><br><span class="line">		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">    </span><br><span class="line">	  <span class="comment">//2.GPIO端口配置，配置A，B相端口为输入</span></span><br><span class="line">	  GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_8 | GPIO_Pin_9;</span><br><span class="line">	  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//	  TIM_InternalClockConfig(TIM1); </span></span><br><span class="line">	  <span class="comment">/*编码器接口就不用这个，因为编码器接口就是一个带方向控制的外部时钟，内部时钟没有用了*/</span></span><br><span class="line">	  </span><br><span class="line">	  <span class="comment">//3.时基单元配置</span></span><br><span class="line">		TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">		TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">		TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<span class="comment">//参数无效，编码器托管</span></span><br><span class="line">	  TIM_TimeBaseInitStructure.TIM_Period = <span class="number">65536</span><span class="number">-1</span>;<span class="comment">//ARR</span></span><br><span class="line">		TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">1</span><span class="number">-1</span>;<span class="comment">//不分频，编码器的时钟直接驱动计数器</span></span><br><span class="line">	  TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span> ;</span><br><span class="line">		TIM_TimeBaseInit(TIM1,&amp;TIM_TimeBaseInitStructure);</span><br><span class="line">	  </span><br><span class="line">	  <span class="comment">//4.输入捕获单元配置</span></span><br><span class="line">	  TIM_ICInitTypeDef TIM_ICInitStructure;</span><br><span class="line">		TIM_ICStructInit(&amp;TIM_ICInitStructure);<span class="comment">//部分参数未使用，调用该函数防止未初始化参数产生影响</span></span><br><span class="line">		TIM_ICInitStructure.TIM_Channel = TIM_Channel_1; </span><br><span class="line">	  TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>; </span><br><span class="line">		TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising ;<span class="comment">//编码器上升沿和下降沿都有效，所以此处代表极性不反转</span></span><br><span class="line">	  TIM_ICInit(TIM1,&amp;TIM_ICInitStructure);</span><br><span class="line">		 </span><br><span class="line">		TIM_ICInitStructure.TIM_Channel = TIM_Channel_2; </span><br><span class="line">	  TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>; </span><br><span class="line">		TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising ;<span class="comment">//编码器上升沿和下降沿都有效，所以此处代表极性不反转</span></span><br><span class="line">    TIM_ICInit(TIM1,&amp;TIM_ICInitStructure);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//5.编码器接口配置</span></span><br><span class="line">		TIM_EncoderInterfaceConfig(TIM1,TIM_EncoderMode_TI12,TIM_ICPolarity_Rising,TIM_ICPolarity_Rising);<span class="comment">//这里的极性与上方极性配置的同一个寄存器，可以删除上方极性配置</span></span><br><span class="line">    <span class="comment">//6.运行控制TIM使能</span></span><br><span class="line">		TIM_Cmd(TIM1,ENABLE);</span><br><span class="line">		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> <span class="title function_">Encoder_Get</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int16_t</span> speed = TIM_GetCounter(TIM1);</span><br><span class="line">	TIM_SetCounter(TIM1,<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> speed;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*放到缓存的speed当中，再清零CNT即可，最终在主循环中实现延时即可*/</span></span><br><span class="line"></span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Encoder.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">		 OLED_Init();</span><br><span class="line">		 Encoder_Init();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;	</span><br><span class="line">		OLED_ShowNum(<span class="number">2</span>,<span class="number">5</span>,Encoder_Get(),<span class="number">5</span>);</span><br><span class="line">        Delay_ms(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">/*1s测一次速*/</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果实现效果与想要的不符合，修改编码器接口配置中任意一个引脚的极性参数即可</p>
<p><code>此处在循环中使用了Delay函数，影响了效率，更加好的办法是开启一个1s的定时器中断，在定时器中断中更新speed的值即可</code></p>
</blockquote>
<h1 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h1><h2 id="ADC简介"><a href="#ADC简介" class="headerlink" title="ADC简介"></a>ADC简介</h2><p>ADC(Analog-Digital Converter)模拟-数字转换器</p>
<p>ADC可以将引脚上连续变化的模拟电压转换为内存中储存的数字变量，建立模拟电路到数字电路的桥梁</p>
<p>12位逐次逼近型ADC，1us的转换时间(ADC转化频率为1MHz)</p>
<p><strong>输入电压范围：0<del>3.3V，转化结果范围：0</del>4095(2的12次方)</strong></p>
<p>一共<code>18个输入通道</code>，可测量<code>16个外部信号</code>和<code>2个内部信号源</code><strong>(内部温度传感器和内部参考电压，不随外部电压变化)</strong></p>
<p>分为<code>规则组(规则通道)</code>和<code>注入组(注入通道)</code>两个转换单元</p>
<p>可模拟看门狗自动监测输入电压范围</p>
<p>STM32F103C8T6 ADC资源：ADC1、ADC2，10个外部输入通道</p>
<p><code> 对应所有的知识都能在芯片参考手册中查看</code></p>
<h2 id="ADC内部结构"><a href="#ADC内部结构" class="headerlink" title="ADC内部结构"></a>ADC内部结构</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/15-1752337644184-505.png" alt="image-20241127201536862"></p>
<blockquote>
<p>逐次逼近型通过二分法给DAC值进行比较，直到找到未知电压编码</p>
<p>比如8位：0~255，先给128，再给64……相当于二进制的高位到低位</p>
<p>对于8位ADC，高位到低位判断8次即可找到位置电压编码</p>
<p>对于12位ADC，高位到低位判断12次即可找到位置电压编码</p>
</blockquote>
<hr>
<p><code>STM32的ADC</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/16-1752337644184-506.png" alt="image-20241127202456782"></p>
<blockquote>
<p>ADCx_IN0~15 就是对应的16个外部信号</p>
<p>温度传感器和Vrefint就是内部2个信号源</p>
<hr>
<p>通道分为<strong>注入通道(注入组)<strong>和</strong>规则通道(规则组)</strong></p>
<p><code>规则通道</code>：可以同时转选择16个通道，但是对于转化结果，因为<strong>规则通道只有一个数据寄存器</strong>，所以存在<code>数据覆盖问题</code>。如果不想结果被覆盖，需要在转换完成后尽快把数据拿走。此时一般配合DMA进行搬运</p>
<p><code>注入通道</code>：可以同时选择4个通道，拥有四个数据寄存器，不用担心数据被覆盖</p>
<p><code>对应规则通道和注入通道可以在参考手册中找到对应介绍</code></p>
<hr>
<p><code>流程</code>：</p>
<p>前面的通道选择后到模拟至数字转换器，</p>
<p>然后模拟至数字转换器中就执行逐次比较的过程，最终结果放在了注入通道&#x2F;规则通道数据寄存器中。</p>
<p><strong>转换结束后会有一个EOC信号，该信号是规则组或注入组的完成信号，还有个JEOC是注入组完成的信号，会置状态寄存器标志位，可以读取该标志位判断是否转换完成</strong></p>
<p><strong>同时这两个标志位也可以去到NVIC申请中断，如果开启对应NVIC通道就可以触发中断</strong></p>
</blockquote>
<hr>
<p><strong>触发转换部分</strong>：对应START信号启动ADC的转换</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/17-1752337644184-507.png" alt="image-20241127203720470"></p>
<blockquote>
<p>对应STM32ADC，触发ADC开始转换的信号有两种：<code>软件触发</code>和<code>硬件触发</code></p>
<p><code>硬件触发</code>：对应图中注入组的触发源和规则组的触发源，主要来自<strong>定时器</strong>，在定时器章节中我们知道，定时器可以通向ADC、DAC外设，用于触发转换。也可以使用<strong>外部中断引脚</strong>触发</p>
<p>比如图中我们给TIM3指定1ms时间，将TIM3的更新事件选择为TIM3_TRGO输出，再把ADC选择开始触发信号为TIM3_TRGO，这样TIM3的更新事件就能通过硬件自动触发ADC转换了，不需要进中断</p>
<p><code>软件触发</code>：程序中调用代码完成ADC转换触发。</p>
</blockquote>
<hr>
<p><code>ADC时钟</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/18-1752337644184-509.png" alt="image-20241127204615868"></p>
<blockquote>
<p>ADC时钟来自RCC，经过ADC预分频器到达，注意此处最大位14MHz，2分频和4分频结果超过了最大值，不建议使用，这里<strong>至少6分频</strong></p>
<p>ADC预分频器小于14MHz即可</p>
</blockquote>
<p><code>模拟看门狗</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/19-1752337644184-508.png" alt="image-20241127204756265"></p>
<blockquote>
<p><strong>模拟看门狗用于监测转换结果的范围</strong>，其中可以存一个阈值高限和阈值低限，如果启动了看门狗并且设定了通道，该看门狗就会关注看门的通道，一旦超过阈值范围就可以申请一个通向NVIC的ADC中断。</p>
</blockquote>
<h2 id="ADC输入通道"><a href="#ADC输入通道" class="headerlink" title="ADC输入通道"></a>ADC输入通道</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/21-1752337644184-510.png" alt="image-20241127210445125"></p>
<blockquote>
<p>我们可以在引脚定义表中找到对应ADC通道0~9的通道对应引脚，这代表该芯片只有10个通道</p>
<p>同时我们可以发现ADC12_INx 这样写代表ADC1和ADC2都是这个引脚。我们可以单独使用一个ADC，也可以同时使用。</p>
<p><strong>ADC还有一种高级模式叫双ADC模式，就是ADC1和ADC2一起配贼和使用，可以配合组成同步、交叉模式等，可以进一步提高采样率</strong></p>
</blockquote>
<h2 id="ADC转换模式"><a href="#ADC转换模式" class="headerlink" title="ADC转换模式"></a>ADC转换模式</h2><p><strong>一共有四种转换方式：多通道只能使用后面两种模式，必须开启扫描模式</strong></p>
<ol>
<li><code>单次转换，非扫描模式</code></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/22-1752337644184-511.png" alt="image-20241127211229845"></p>
<blockquote>
<p>只会转换第一个序列的通道，每次转换都需要触发一次</p>
<p>想要更换通道转换只需要更改序列1的通道即可</p>
</blockquote>
<ol start="2">
<li><code>连续转换，非扫描模式</code></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/23-1752337644184-512.png" alt="image-20241127211310674"></p>
<blockquote>
<p>只会转换第一个序列的通道，但触发转换后不会停止，会一直持续转换。只需要第一次触发即可</p>
</blockquote>
<ol start="3">
<li><code>单次转换，扫描模式</code></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/24-1752337644184-513.png" alt="image-20241127211656061"></p>
<blockquote>
<p><strong>按顺序依次转换一组通道</strong>，可以指定通道数目，指定的所有通道转换完成后才会触发EOC信号。每次转换都需要触发</p>
</blockquote>
<ol start="4">
<li><code>连续转换，扫描模式</code></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/25-1752337644184-514.png" alt="image-20241127211932067"></p>
<blockquote>
<p><strong>按顺序依次转换一组通道</strong>，可以指定通道数目，指定的所有通道转换完成后才会触发EOC信号。只需要一次触发就可以一直转换</p>
</blockquote>
<p><code>其实还有个间断模式</code>：可以说是对扫描模式的补充</p>
<blockquote>
<p>触发一次，转换一个通道，在触发，在转换。在所选转换通道循环，**由触发信号启动新一轮的转换，直到转换完成为止。**例如：可以把0,1,4,5这四个通道进行分组。可以分成0,1一组，4,5一组。也可以每个通道单独配置为一组。这样每一组转换之前都需要先触发一次。</p>
</blockquote>
<h2 id="ADC触发控制"><a href="#ADC触发控制" class="headerlink" title="ADC触发控制"></a>ADC触发控制</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/26-1752337644184-515.png" alt="image-20241127212108346"></p>
<h2 id="ADC数据对齐"><a href="#ADC数据对齐" class="headerlink" title="ADC数据对齐"></a>ADC数据对齐</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/27-1752337644184-516.png" alt="image-20241127212138053"></p>
<blockquote>
<p>寄存器总共16位需要对齐，高位或低位补0</p>
<p><strong>一般使用右对齐，可以直接读取寄存器就是结果</strong></p>
<p>左对齐得到的结果比实际值偏大16倍，对于裁剪分辨率使用</p>
</blockquote>
<h2 id="ADC转换时间"><a href="#ADC转换时间" class="headerlink" title="ADC转换时间"></a>ADC转换时间</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/28-1752337644185-517.png" alt="image-20241127212422377"></p>
<blockquote>
<p><code>量化、编码</code>：就是ADC逐次比较的过程，位数越多花费时间越长</p>
<p><code>采样、保持</code>：量化编码需要时间，通过开启采样开关，一段时间后断开后使电压在量化编码时保持不变</p>
<hr>
<p><strong>ADC总转换时间中</strong>：</p>
<p><code>采样时间：</code>就是采样保持时间，采样时间可以在程序中配置，时间越长越能避免毛刺信号的干扰，但会导致转换时间延长。</p>
<p><code>12.5个ADC周期：</code>量化编码所花费时间，因为是12位，所以需要12个周期，多余的0.5周期可能做了一些其他事情</p>
<p>14个周期：14&#x2F;14MHz &#x3D; 1μs</p>
<hr>
<p><code>采样时间选择</code>：</p>
<p><strong>需要更快的转换，就选小的参数，但容易受干扰</strong></p>
<p><strong>需要更稳定的转换，就选大的参数，转换时间长</strong></p>
</blockquote>
<h2 id="ADC校准"><a href="#ADC校准" class="headerlink" title="ADC校准"></a>ADC校准</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/29-1752337644185-518.png" alt="image-20241127220041612"></p>
<blockquote>
<p><strong>校准过程我们不需要理解，校准过程固定，只需要在ADC初始化的最后，加几行代码就行了，至于怎么计算、怎么校准的，我们不需要管</strong></p>
<hr>
<p><strong>流程</strong>：</p>
<p><code>复位校准</code>-<code>等待复位校准(判断标志位)</code>-<code>开始校准</code>-<code>等待校准(判断标志位)</code></p>
</blockquote>
<h2 id="硬件电路"><a href="#硬件电路" class="headerlink" title="硬件电路"></a>硬件电路</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/30-1752337644185-519.png" alt="image-20241127220346370"></p>
<blockquote>
<p>第一个是电位器产生可调电路，通过滑动变阻器可以调节电压0~3.3V</p>
<hr>
<p>第二个是传感器输出电压电路，光敏电阻、热敏电阻等都可等效为一个可变电阻，电阻阻值没法直接测量，<strong>一般直接通过和一个固定电阻串联分压来得到反应电阻值电压</strong>的电路。</p>
<p><code>固定电阻一般可以选择和传感器阻值相近的电阻较好</code></p>
<p>传感器阻值变小时，下拉作用变强，输出端电压就下降，传感器阻值变大时，下拉作用变弱，输出端受上拉作用电压就会升高</p>
<hr>
<p>第三个是一个简易电压转换电路，使用电阻分压。根据分压公式可以得到中间的电压位(VIN&#x2F;50K) * 33K，高电压一般不适用比较危险，高电压一般使用一些采集芯片，做好高低电压的隔离</p>
</blockquote>
<h2 id="ADC基本结构图"><a href="#ADC基本结构图" class="headerlink" title="ADC基本结构图"></a>ADC基本结构图</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/20-1752337644185-520.png" alt="image-20241127205844255"></p>
<h2 id="库函数-5"><a href="#库函数-5" class="headerlink" title="库函数"></a>库函数</h2><p><code>配置ADCCLK分频器</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RCC_ADCCLKConfig</span><span class="params">(<span class="type">uint32_t</span> RCC_PCLK2)</span>;</span><br><span class="line"><span class="comment">/*在stm32f10x_rcc.h中可以找到，该函数用于配置ADCCLK分频器，可以对APB2的72MHz时钟选择2、4、6、8分频，输入到ADCCLK*/</span></span><br></pre></td></tr></table></figure>



<p><code>ADC初始化:stm32f10x_adc.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_DeInit</span><span class="params">(ADC_TypeDef* ADCx)</span>;<span class="comment">//恢复缺省配置</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_Init</span><span class="params">(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_StructInit</span><span class="params">(ADC_InitTypeDef* ADC_InitStruct)</span>;</span><br></pre></td></tr></table></figure>



<p><code>ADC启动</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_Cmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;<span class="comment">//开启ADC</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_DMACmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;<span class="comment">//开启DMA输出信号，使用DMA需要调用</span></span><br></pre></td></tr></table></figure>



<p><code>ADC通道配置</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_RegularChannelConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_Channel, <span class="type">uint8_t</span> Rank, <span class="type">uint8_t</span> ADC_SampleTime)</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 规则组通道配置，为序列添加通道</span></span><br><span class="line"><span class="comment"> * 参数1：对应ADC</span></span><br><span class="line"><span class="comment"> * 参数2：指定ADC通道</span></span><br><span class="line"><span class="comment"> * 参数3：对应序列号</span></span><br><span class="line"><span class="comment"> * 参数4：指定通道采样时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//多个通道指定时，多次调用该函数配置即可</span></span><br></pre></td></tr></table></figure>



<p><code>ADC外部触发转换控制</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_ExternalTrigConvCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*是否允许外部触发转换*/</span></span><br></pre></td></tr></table></figure>





<p><code>ADC中断</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_ITConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint16_t</span> ADC_IT, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*用于控制某个中断，能否通往NVIC*/</span></span><br></pre></td></tr></table></figure>



<p><code>ADC控制校准：在ADC初始化完成后依次调用即可</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_ResetCalibration</span><span class="params">(ADC_TypeDef* ADCx)</span>;</span><br><span class="line"><span class="comment">/*复位校准*/</span></span><br><span class="line">FlagStatus <span class="title function_">ADC_GetResetCalibrationStatus</span><span class="params">(ADC_TypeDef* ADCx)</span>;</span><br><span class="line"><span class="comment">/*获取复位校准状态*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_StartCalibration</span><span class="params">(ADC_TypeDef* ADCx)</span>;</span><br><span class="line"><span class="comment">/*开始校准*/</span></span><br><span class="line">FlagStatus <span class="title function_">ADC_GetCalibrationStatus</span><span class="params">(ADC_TypeDef* ADCx)</span>;</span><br><span class="line"><span class="comment">/*获取开始校准复位状态*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><code>ADC触发控制</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_SoftwareStartConvCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*ADC软件触发控制，调用即可设置为软件触发*/</span></span><br><span class="line"></span><br><span class="line">FlagStatus <span class="title function_">ADC_GetSoftwareStartConvStatus</span><span class="params">(ADC_TypeDef* ADCx)</span>;</span><br><span class="line"><span class="comment">/*ADC获取软件开始转换状态，返回SWSTART状态，与转换是否结束无关，一般不适用*/</span></span><br></pre></td></tr></table></figure>



<p><code>ADC间断模式配置</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_DiscModeChannelCountConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> Number)</span>;</span><br><span class="line"><span class="comment">/*ADC间断模式配置，设置Number可以设置每隔几个通道间断一次*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_DiscModeCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*使能间断模式*/</span></span><br></pre></td></tr></table></figure>





<p><code>ADC转换结束判断</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FlagStatus <span class="title function_">ADC_GetFlagStatus</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_FLAG)</span>;</span><br><span class="line"><span class="comment">/*参数给EOC标志位可以判断是否转换完成*/</span></span><br></pre></td></tr></table></figure>



<p><code>ADC获取转换值</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> <span class="title function_">ADC_GetConversionValue</span><span class="params">(ADC_TypeDef* ADCx)</span>;</span><br><span class="line"><span class="comment">//获取AD转换数据寄存器，读取转换结果</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ADC_GetDualModeConversionValue</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//双ADC模式读取转换结果</span></span><br></pre></td></tr></table></figure>



<p><code>ADC注入组</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_AutoInjectedConvCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_InjectedDiscModeCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_ExternalTrigInjectedConvConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint32_t</span> ADC_ExternalTrigInjecConv)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_ExternalTrigInjectedConvCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_SoftwareStartInjectedConvCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;</span><br><span class="line">FlagStatus <span class="title function_">ADC_GetSoftwareStartInjectedConvCmdStatus</span><span class="params">(ADC_TypeDef* ADCx)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_InjectedChannelConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_Channel, <span class="type">uint8_t</span> Rank, <span class="type">uint8_t</span> ADC_SampleTime)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_InjectedSequencerLengthConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> Length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_SetInjectedOffset</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_InjectedChannel, <span class="type">uint16_t</span> Offset)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ADC_GetInjectedConversionValue</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_InjectedChannel)</span>;</span><br></pre></td></tr></table></figure>



<p><code>ADC模拟看门狗</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_AnalogWatchdogCmd</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint32_t</span> ADC_AnalogWatchdog)</span>;</span><br><span class="line"><span class="comment">/*是否启动看门狗*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_AnalogWatchdogThresholdsConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint16_t</span> HighThreshold, <span class="type">uint16_t</span> LowThreshold)</span>;</span><br><span class="line"><span class="comment">/*配置看门狗高低阈值*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_AnalogWatchdogSingleChannelConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_Channel)</span>;</span><br><span class="line"><span class="comment">/*配置看门通道*/</span></span><br></pre></td></tr></table></figure>



<p><code>ADC内部信号配置</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_TempSensorVrefintCmd</span><span class="params">(FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*ADC温度传感器，内部参考电压控制，用于开启内部两个通道，需要使用时调用开启即可*/</span></span><br></pre></td></tr></table></figure>



<p><code>ADC标志位</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FlagStatus <span class="title function_">ADC_GetFlagStatus</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_FLAG)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_ClearFlag</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_FLAG)</span>;</span><br><span class="line"></span><br><span class="line">ITStatus <span class="title function_">ADC_GetITStatus</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint16_t</span> ADC_IT)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_ClearITPendingBit</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint16_t</span> ADC_IT)</span>;</span><br><span class="line"><span class="comment">//常用的标志位相关函数，带IT的应该在中断服务函数中使用</span></span><br></pre></td></tr></table></figure>



<h2 id="ADC配置流程"><a href="#ADC配置流程" class="headerlink" title="ADC配置流程"></a>ADC配置流程</h2><p>打通上方ADC基本结构图即可：</p>
<ol>
<li><p><strong>RCC开启时钟，开启ADC和GPIO时钟，配置ADCCLK分频器</strong></p>
</li>
<li><p><strong>配置GPIO，配置对应GPIO为<code>模拟输入</code>的模式</strong></p>
</li>
<li><p><strong>配置多路开关，将左边对应通道接入规则组&#x2F;注入组中(规则&#x2F;注入通道配置)</strong></p>
</li>
<li><p><strong>配置ADC转换器，结构体(单次转换&#x2F;连续转换、扫描&#x2F;非扫描，几个通道等)</strong></p>
</li>
<li><p>如果需要模拟看门狗，配置阈值和监测通道，没有就跳过</p>
</li>
<li><p>如果想要使用中断，使用ADITConfig开启对应中断输出，配置NVIC即可，没有跳过</p>
</li>
<li><p><strong>开启ADC，调用ADC_Cmd函数</strong></p>
</li>
<li><p><strong>校准ADC，减小误差</strong></p>
</li>
</ol>
<h2 id="实验-ADC读取电位器电压-ADC单通道"><a href="#实验-ADC读取电位器电压-ADC单通道" class="headerlink" title="实验-ADC读取电位器电压(ADC单通道)"></a>实验-ADC读取电位器电压(ADC单通道)</h2><p>对应引脚定义可知电位器PA5对应通道为ADC_IN5，选择ADC_Channel_5即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*AD.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __AD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __AD_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ADC_GetValue</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*AD.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//1.开启RCC时钟，ADC和GPIO</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.ADC预分频器配置，72Mhz / 6 =12Mhz，不能超过14Mhz，至少6分频</span></span><br><span class="line">	RCC_ADCCLKConfig(RCC_PCLK2_Div6);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3.GPIO配置为模拟输入</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AIN;</span><br><span class="line">	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5;</span><br><span class="line">	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//4.规则通道配置,将通道5写入规则通道的第一个位置(序列1)</span></span><br><span class="line">  ADC_RegularChannelConfig(ADC1,ADC_Channel_5,<span class="number">1</span>,ADC_SampleTime_239Cycles5);</span><br><span class="line"><span class="comment">//	ADC_RegularChannelConfig(ADC1,ADC_Channel_1,2,ADC_SampleTime_55Cycles5); 如果还有其他通道，继续调用配置即可</span></span><br><span class="line"><span class="comment">//	ADC_RegularChannelConfig(ADC1,ADC_Channel_2,3,ADC_SampleTime_239Cycles5); 如果还有其他通道，继续调用配置即可</span></span><br><span class="line">	<span class="comment">//5.ADC转换器配置</span></span><br><span class="line">	ADC_InitTypeDef ADC_InitStruct;</span><br><span class="line">	ADC_InitStruct.ADC_Mode = ADC_Mode_Independent; <span class="comment">//ADC转换模式，该参数为独立ADC工作，剩余的其他参数都是双ADC模式</span></span><br><span class="line">	ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right;<span class="comment">//数据右对齐</span></span><br><span class="line">	ADC_InitStruct.ADC_ExternalTrigConv =ADC_ExternalTrigConv_None;<span class="comment">//这里选择软件触发，剩下的都为硬件触发</span></span><br><span class="line">	ADC_InitStruct.ADC_ContinuousConvMode = DISABLE;<span class="comment">//启动连续转换模式</span></span><br><span class="line">	ADC_InitStruct.ADC_ScanConvMode = DISABLE;<span class="comment">//是否启动扫描模式</span></span><br><span class="line">	ADC_InitStruct.ADC_NbrOfChannel = <span class="number">1</span>; <span class="comment">// 指定扫描模式下总共使用的通道数</span></span><br><span class="line">	ADC_Init(ADC1,&amp;ADC_InitStruct);</span><br><span class="line">	</span><br><span class="line">  <span class="comment">//5.开启ADC</span></span><br><span class="line">	ADC_Cmd(ADC1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//6.ADC校准</span></span><br><span class="line">	ADC_ResetCalibration(ADC1);<span class="comment">//复位校准</span></span><br><span class="line">	<span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADC1)== SET)&#123;&#125;;<span class="comment">//RSTCAL寄存器由软件置1后开始复位校准，完成后硬件自动清0该位</span></span><br><span class="line">	ADC_StartCalibration(ADC1);</span><br><span class="line">	<span class="keyword">while</span>(ADC_GetCalibrationStatus(ADC1) == SET)&#123;&#125;;<span class="comment">//CAL寄存器由软件置1后开始校准，校准结束后硬件自动清0该位</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ADC_SoftwareStartConvCmd(ADC1, ENABLE);在启动连续转换模式时，只需要在这里触发转换一次即可，不需要每次获取值都调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ADC_GetValue</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *  获取ADC值流程：</span></span><br><span class="line"><span class="comment">	 *  1.触发转换</span></span><br><span class="line"><span class="comment">	 *  2.判断标志位等待转换完成</span></span><br><span class="line"><span class="comment">	 *  3.读取转换结果</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.触发转换,上面没开启连续转换模式，开启连续转换模式只需要启动一次即可</span></span><br><span class="line">	ADC_SoftwareStartConvCmd(ADC1, ENABLE);<span class="comment">//启动软件触发转换,也可以使用硬件触发</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//2.判断标志位,等待转换完成</span></span><br><span class="line">	<span class="keyword">while</span>(ADC_GetFlagStatus(ADC1,ADC_FLAG_EOC) == RESET)&#123;&#125;;<span class="comment">//在手册中有介绍，转换完成前为0，转换完成后自动置1</span></span><br><span class="line">		<span class="comment">/*等待转换时间为上面设置的采样周期，239+12.5=251.5个周期，时间为251.5/12Mhz=20.9us*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.读取转换结果</span></span><br><span class="line">	<span class="keyword">return</span> ADC_GetConversionValue(ADC1);<span class="comment">//读取DR寄存器时自动清除EOC位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AD.h&quot;</span></span></span><br><span class="line"><span class="type">float</span> Voltage = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">		 OLED_Init();</span><br><span class="line">		 AD_Init();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="type">uint16_t</span> adValue = ADC_GetValue();</span><br><span class="line">		Voltage = (<span class="type">float</span>)adValue / <span class="number">4095</span> * <span class="number">3.3</span>;<span class="comment">//根据精度对应计算出电压值</span></span><br><span class="line">		OLED_ShowNum(<span class="number">5</span>,<span class="number">5</span>,adValue,<span class="number">4</span>);</span><br><span class="line">		OLED_ShowNum(<span class="number">10</span>,<span class="number">5</span>,Voltage,<span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意实验中OLED得到的AD值末尾持续抖动，这是正常波动</p>
<p><strong>但是如果我们需要对该AD值进行判断，再执行一些操作时，比如AD值大于某一值开灯，小于某一值就关灯。此时由于AD值存在波动就可能会来回开灯关灯。</strong></p>
<p><code>解决方法</code>：</p>
<ol>
<li><strong>使用迟滞比较法，设置上下阈值，高于上阈值开灯，低于下阈值关灯，类似于施密特触发器</strong></li>
<li><strong>如果数据跳变太厉害，可以使用均值滤波的方式，读取10~20个值取平均值作为输出结果</strong></li>
<li><strong>还可以裁剪分辨率去掉数据的尾数，也可以避免跳动</strong></li>
</ol>
</blockquote>
<h2 id="实验-ADC多通道采集"><a href="#实验-ADC多通道采集" class="headerlink" title="实验- ADC多通道采集"></a>实验- ADC多通道采集</h2><blockquote>
<p>多通道采集，我们想到的是启动扫描模式，但是存在<code>数据覆盖</code>的问题。扫描模式是会一次将所有通道全部转换完之后才会发出EOC信号，每一个通道单独转换完成不会产生任何标志位，也不会有中断，同时AD转换很快，所以我们很难做到在一个通道转换完成后将数据手动转移。</p>
<p>但是很难不是不行，我们可以使用间断模式，扫描时没转换一个通道就暂停一次，我们此时可以转移数据，再继续触发，继续下一次转换。由于没有单个通道转换完成后没有标志位，我们只能通过Delay的方式延时等待转换时间，所以这种方式不推荐</p>
<p><strong>所以如果我们想用扫描模式实现多通道，最好配合DMA来实现</strong></p>
<p><code>扫描模式+DMA搬运实现ADC多通道采集见下一节DMA实验</code></p>
</blockquote>
<p>其实我们可以使用<strong>单次转换非扫描模式</strong>实现，只需要为AD_GetValue添加一个ADC_Channel的参数，调用时都重新配置规则通道再触发转换即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    adValue1 = ADC_GetValue(ADC_Channel_0);</span><br><span class="line">    adValue2 = ADC_GetValue(ADC_Channel_1);</span><br><span class="line">    adValue3 = ADC_GetValue(ADC_Channel_2);</span><br><span class="line">    adValue4 = ADC_GetValue(ADC_Channel_3);</span><br><span class="line">    Delay_ms(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h1><h2 id="DMA简介"><a href="#DMA简介" class="headerlink" title="DMA简介"></a>DMA简介</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/31-1752337644185-521.png" alt="image-20241128195544055"></p>
<blockquote>
<p><strong>DMA-直接内存访问，是一个数据转运小助手，主要是协助CPU完成数据转运的工作，无须CPU干预，CPU就可以干其他更重要的事</strong></p>
<p>这里的<code>外设</code>一般指<code>外设数据寄存器</code>，<code>存储器</code>一般指<code>运行内存SRAM和程序存储器</code>(存储变量数组和程序代码的地方)</p>
<hr>
<p><strong>存储器到存储器</strong>的数据转运，一般使用<code>软件触发</code>，比如从FLASH到SRAM，因为软件触发是以最快的方式一股脑搬运过去，越快越好</p>
<p><strong>存储器到外设</strong>的数据转运，一般使用<code>特定硬件触发</code>(每个外设对应DMA通道)，比如ADC一个通道转换完成后，硬件触发一次DMA，DMA再转运。这样得到的值才正确</p>
</blockquote>
<blockquote>
<p><code>常见的用途：</code></p>
<ul>
<li><strong>最常见：配合ADC的扫描模式，解决ADC数据覆盖问题</strong></li>
<li><strong>各外设提高效率</strong></li>
</ul>
</blockquote>
<p><code>阅读参考手册获得所有介绍!!!</code></p>
<h2 id="STM32存储器映像"><a href="#STM32存储器映像" class="headerlink" title="STM32存储器映像"></a>STM32存储器映像</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/32-1752337644185-522.png" alt="image-20241128201135199"></p>
<blockquote>
<p><code>FLASH：</code>存放我们编译后的程序以及常量数据(const等)</p>
<p><code>SRAM：</code>程序的临时变量存储，变量地址都是以20开头</p>
<p><code>外设寄存器：</code>对应每个外设的寄存器</p>
<p><code>内核外设</code>：<strong>只有NVIC和Systick</strong>，与其他外设不是一个厂家设计的，所以地址被分开了</p>
<hr>
<p><code>1.在STM32的数据手册，也会有个存储器映像的图,里面可以查看各外设起始地址等</code></p>
<p><code>2.在对应代码的宏定义不断跳转我们可以看到定义的SRAM、外设等基地址也是上表中给出的地址，通过基地址+偏移量可以得到各外设地址等</code></p>
</blockquote>
<h2 id="DMA框图"><a href="#DMA框图" class="headerlink" title="DMA框图"></a>DMA框图</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241129210721223-1752337644185-523.png" alt="image-20241129210721223"></p>
<p><strong>主要包括</strong>：</p>
<ul>
<li><p><strong>用于访问各个存储器的DMA总线</strong></p>
</li>
<li><p><strong>内部的多个通道，可以进行独立的数据转运</strong></p>
</li>
<li><p><strong>仲裁器，用于调度各个通道，防止产生冲突</strong></p>
</li>
<li><p><strong>AHB从设备：是DMA自身的寄存器，用于配置DMA参数</strong></p>
</li>
<li><p><strong>DMA请求，用于硬件触发DMA的数据转运</strong></p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/34-1752337644185-524.png" alt="image-20241129204758768"></p>
<blockquote>
<p><code>寄存器：</code></p>
<p>各个外设都可以看成是寄存器，也是一种SRAM存储器，寄存器是一种特殊的存储器，一方面，CPU可以对寄存器进行读写，另一方面寄存器的每一位背后，都连接了一个线，这些线可以用于控制外设电路的状态，比如设置引脚高低电平，导通和断开开关等，或者多位组合起来当做计数器、数据寄存器等</p>
<p>寄存器是连接软件和硬件的桥梁，软件读写寄存器就相当在控制硬件的执行</p>
<hr>
<p>外设寄存器，有些是只读的，有些是可读可写的，具体看参考手册上的介绍</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241129205958030-1752337644185-525.png" alt="image-20241129205958030"></p>
<blockquote>
<p><code>DMA请求：</code></p>
<p>请求就是触发的意思，DMA请求线路的触发源是各个外设，DMA请求就是DMA的硬件触发源，比如ADC转换完成、串口接收到数据时，需要触发DMA转运数据时，就会通过这条线路向DMA发出硬件触发信号，之后DMA就可以在执行数据转运的工作了。</p>
</blockquote>
<blockquote>
<p><code>FLASH :</code></p>
<p>这里是ROM只读存储器的一种，如果通过总线直接访问，无论是CPU还是DMA都是只读的，如果DMA转运的目的地址填写的是FLASH就会出错。</p>
<p><code>SRAM:</code>可以任意读写</p>
</blockquote>
<h2 id="DMA-基本结构图"><a href="#DMA-基本结构图" class="headerlink" title="DMA 基本结构图"></a>DMA 基本结构图</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241129213600867-1752337644185-526.png" alt="image-20241129213600867"></p>
<blockquote>
<p><code>图中所有参数都是使用结构体配置</code></p>
<p>有个方向控制的参数可以控制外设寄存器到存储器的方向</p>
<p>外设寄存器和存储器(Flash、SRAM)都有三个参数：</p>
<ol>
<li>起始地址</li>
<li>数据宽度</li>
<li>地址是否自增</li>
</ol>
<hr>
<p><code>传输计数器：</code>用于指定转运次数，是一个自建计数器，每转运一次，值减1，直到减小到0之后DMA停止转运，对应自增过后的地址恢复到起始地址的位置，以方便DMA开始新一轮转换</p>
<p><strong>注意：不能在DMA开启时，写传输计数器，这是手册的规定！！！</strong></p>
<p><strong>需要写计数器时按照即可：DMA失能–写传输计数器–DMA使能</strong></p>
<p><code>自动重装器：</code>传输计数器减小到0之后是否需要恢复到最初的值，指定重装就是循环模式</p>
<hr>
<p><strong>触发控制</strong>：决定DMA什么时间进行转运，由M2M(Memory to Memory)参数决定软件触发还是硬件触发</p>
<p><code>软件触发：</code><strong>一般用于存储器到存储器的转运，这些转运不需要一定时机</strong>，参数<code>M2M为1时</code>为软件触发，并不是调用一个函数一次就触发一次，而是以最快的速度，连续不断的触发DMA，以最快速度将传输计数器减少到0，与外部中断和ADC的软件触发可能不太一样，可以理解为<strong>自动连续触发</strong>  </p>
<p><strong>软件触发和循环模式不能同时使用，因为软件触发是想把计数器清0，而循环模式会重载，DMA就停不下来了</strong></p>
<p><code>硬件触发：</code><strong>一般用于与外设有关的转运，转运需要一定时机当硬件达到这些时机时传一个信号，触发DMA进行转运，比如ADC转换完成等</strong>，<code>参数M2M为0</code>时为硬件触发，触发源可以选择ADC、串口、定时器等等</p>
<hr>
<p><code>开关控制</code>：</p>
<p>DMA_Cmd函数</p>
</blockquote>
<blockquote>
<p><code>DMA转运需要有三个条件：</code></p>
<ol>
<li>使能DMA，开关控制</li>
<li>传输计数器不为0</li>
<li>必须要有触发源</li>
</ol>
</blockquote>
<h2 id="DMA请求映像"><a href="#DMA请求映像" class="headerlink" title="DMA请求映像"></a>DMA请求映像</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241129223925869-1752337644185-527.png" alt="image-20241129223925869"></p>
<blockquote>
<p>每个通道有一个数据选择器，选择硬件触发或者软件触发，EN位决定数据选择器是否工作</p>
<p><code>硬件触发注意</code>：<strong>M2M &#x3D; 0</strong></p>
<p><strong>每个外设触发通道都不一样，所以我们在选择硬件触发源时，一定要先找到对应通道触发</strong>，比如ADC1在通道1，定时器更新事件(TIM2_UP)在通道2</p>
<p>对应的有ADC_DMACmd、TIM_DMACmd函数等</p>
<p><code>软件触发</code>：<strong>M2M &#x3D; 1</strong></p>
<p><strong>DMA和通道任意选择，每个通道软件触发都是一样的</strong></p>
<hr>
<p><code>优先级:</code></p>
<p>类似与中断优先级判断，通道号越小优先级越高，也可在程序中配置</p>
</blockquote>
<h2 id="数据宽度与对齐"><a href="#数据宽度与对齐" class="headerlink" title="数据宽度与对齐"></a>数据宽度与对齐</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241129224639834-1752337644185-528.png" alt="image-20241129224639834"></p>
<blockquote>
<p><code>源端宽度</code>和<code>目标宽度</code>相同时和不同时的数据传输处理：与变量赋值类似</p>
<p>源端宽度&#x3D;目标宽度，不变</p>
<p>源端宽度&lt;目标宽度，高位补0</p>
<p>源端宽度&gt;目标宽度，高位舍弃</p>
</blockquote>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="数据转运-DMA-存储器到存储器转运"><a href="#数据转运-DMA-存储器到存储器转运" class="headerlink" title="数据转运+DMA(存储器到存储器转运)"></a>数据转运+DMA(存储器到存储器转运)</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241129225329602-1752337644185-529.png" alt="image-20241129225329602"></p>
<blockquote>
<p>不需要转运时间同步等，使用软件触发即可</p>
</blockquote>
<h3 id="ADC扫描模式-DMA-外设到存储器"><a href="#ADC扫描模式-DMA-外设到存储器" class="headerlink" title="ADC扫描模式+DMA(外设到存储器)"></a>ADC扫描模式+DMA(外设到存储器)</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241129225519836-1752337644185-530.png" alt="image-20241129225519836"></p>
<blockquote>
<p>我们需要在每个单独的通道转换完成后，进行一个DMA转运，并且使目的地址自增，源地址不自增，方向为外设到存储器，传输计数器7次</p>
<p>ADC连续扫描，DMA可以使用自动重装，使ADC和DMA同时工作</p>
<p>DMA转运时机需要和ADC单个通道转换同步，所以DMA触发要选择ADC硬件触发。</p>
<p><strong>单个通道转换完成时应该可以触发DMA传输，否则无法完成</strong></p>
</blockquote>
<h2 id="库函数-6"><a href="#库函数-6" class="headerlink" title="库函数"></a>库函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始化相关函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_DeInit</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_Init</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_StructInit</span><span class="params">(DMA_InitTypeDef* DMA_InitStruct)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 使能DMA对应通道,第一个参数不再是DMAx，而是DMAy_x,即选择了哪个DMA，又选择了DMA的通道，DMA几的通道几</span></span><br><span class="line"><span class="comment">  * 软件触发随意选择通道</span></span><br><span class="line"><span class="comment">  * 硬件触发，先查看手册找到对应外设的通道在设置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_Cmd</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*DMA中断输出使能*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_ITConfig</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx, <span class="type">uint32_t</span> DMA_IT, FunctionalState NewState)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*传输计数器值设置和获取*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_SetCurrDataCounter</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx, <span class="type">uint16_t</span> DataNumber)</span>; </span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">DMA_GetCurrDataCounter</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*标志位相关函数*/</span></span><br><span class="line">FlagStatus <span class="title function_">DMA_GetFlagStatus</span><span class="params">(<span class="type">uint32_t</span> DMAy_FLAG)</span>;<span class="comment">//获取标志位状态</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_ClearFlag</span><span class="params">(<span class="type">uint32_t</span> DMAy_FLAG)</span>;<span class="comment">//清除标志位</span></span><br><span class="line">ITStatus <span class="title function_">DMA_GetITStatus</span><span class="params">(<span class="type">uint32_t</span> DMAy_IT)</span>;<span class="comment">//获取中断状态</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_ClearITPendingBit</span><span class="params">(<span class="type">uint32_t</span> DMAy_IT)</span>;<span class="comment">//清除中断挂起位</span></span><br></pre></td></tr></table></figure>





<h2 id="DMA配置流程"><a href="#DMA配置流程" class="headerlink" title="DMA配置流程"></a>DMA配置流程</h2><p><code>根据DMA基本结构图配置如下：</code></p>
<ol>
<li><strong>RCC开启DMA时钟</strong></li>
<li><strong>配置DMA，调用DMA_Init，初始化各个参数(外设和存储器站点的起始地址、数据宽度、地址是否自增、方向、传输计数器、是否需要自动重装、选择触发源等参数)</strong></li>
<li>如果需要DMA中断，调用DMA_ITConfig开启中断输出，配置NVIC各个参数，写好对应中断服务函数即可，<strong>不用中断可以直接跳过</strong></li>
<li><strong>DMA使能，DMA_Cmd函数(别忘了对应在外设XXX_DMACmd开启触发信号输出)</strong></li>
</ol>
<h2 id="实验-DMA数据转运-存储器到存储器"><a href="#实验-DMA数据转运-存储器到存储器" class="headerlink" title="实验-DMA数据转运(存储器到存储器)"></a>实验-DMA数据转运(存储器到存储器)</h2><p><code>DMA不涉及外围硬件电路，故.c/.h文件放在System文件夹中</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*DMA.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DMA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DMA_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMAInit</span><span class="params">(<span class="type">uint32_t</span> AddrA,<span class="type">uint32_t</span> AddrB,<span class="type">uint32_t</span> Size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_Transfer</span><span class="params">()</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*DMA.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> DMA_Size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMAInit</span><span class="params">(<span class="type">uint32_t</span> AddrA,<span class="type">uint32_t</span> AddrB,<span class="type">uint32_t</span> Size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//1.RCC开启DMA时钟</span></span><br><span class="line">	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.配置DMA</span></span><br><span class="line">	DMA_InitTypeDef DMA_InitStruct;</span><br><span class="line">	DMA_InitStruct.DMA_PeripheralBaseAddr = AddrA;<span class="comment">//外设站点起始地址</span></span><br><span class="line">	DMA_InitStruct.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;	<span class="comment">//外设站点数据宽度,这里以字节传输</span></span><br><span class="line">	DMA_InitStruct.DMA_PeripheralInc = DMA_PeripheralInc_Enable;<span class="comment">//地址是否自增(Increment)，这里启用</span></span><br><span class="line">	DMA_InitStruct.DMA_MemoryBaseAddr = AddrB;<span class="comment">//存储器站点起始地址</span></span><br><span class="line">	DMA_InitStruct.DMA_MemoryDataSize = DMA_PeripheralDataSize_Byte;<span class="comment">//存储器站点数据宽度</span></span><br><span class="line">	DMA_InitStruct.DMA_MemoryInc = DMA_MemoryInc_Enable;<span class="comment">//地址是否自增</span></span><br><span class="line">	DMA_InitStruct.DMA_DIR = DMA_DIR_PeripheralSRC ; <span class="comment">// 传输方向(direction),这里选择的是外设站点作为数据源</span></span><br><span class="line">	DMA_InitStruct.DMA_BufferSize = Size; <span class="comment">// 传输计数器的值,其实就是传输次数,一次传输上面设置的数据宽度的值</span></span><br><span class="line">	DMA_InitStruct.DMA_Mode = DMA_Mode_Normal; <span class="comment">// 传输模式，就是是否使用自动重装。Normal不重装，circular是循环重装</span></span><br><span class="line">	DMA_InitStruct.DMA_M2M = DMA_M2M_Enable; <span class="comment">//配置软件触发还是硬件触发位(0,1),Enable是软件触发</span></span><br><span class="line">	DMA_InitStruct.DMA_Priority = DMA_Priority_Medium; <span class="comment">// 配置优先级，选择中等</span></span><br><span class="line">	DMA_Init(DMA1_Channel1,&amp;DMA_InitStruct);<span class="comment">//软件触发使用任意通道都可</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3.DMA使能</span></span><br><span class="line">	DMA_Cmd(DMA1_Channel1,DISABLE);</span><br><span class="line">	</span><br><span class="line">	DMA_Size = Size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*修改传输计数器的值，使DMA能循环传输*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_Transfer</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	DMA_Cmd(DMA1_Channel1,DISABLE);</span><br><span class="line">	DMA_SetCurrDataCounter(DMA1_Channel1,DMA_Size); </span><br><span class="line">	DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET)&#123;&#125;;<span class="comment">//等待转换完成</span></span><br><span class="line">	</span><br><span class="line">	DMA_ClearFlag(DMA1_FLAG_TC1);<span class="comment">//清除标志位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DMA.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> DataA[] = &#123;<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x03</span>,<span class="number">0x04</span>&#125;;<span class="comment">//加上const发现存储在FLASH区</span></span><br><span class="line"><span class="type">uint8_t</span> DataB[] =  &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">		OLED_Init();</span><br><span class="line">		DMAInit((<span class="type">uint32_t</span>)DataA,(<span class="type">uint32_t</span>)DataB,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">		OLED_ShowString(<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;DataA:&quot;</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">1</span>,<span class="number">8</span>,(<span class="type">uint32_t</span>)DataA,<span class="number">8</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">2</span>,<span class="number">2</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">2</span>,<span class="number">5</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">2</span>,<span class="number">8</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">2</span>,<span class="number">11</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">		OLED_ShowString(<span class="number">3</span>,<span class="number">2</span>,<span class="string">&quot;DataB:&quot;</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">3</span>,<span class="number">8</span>,(<span class="type">uint32_t</span>)DataB,<span class="number">8</span>);</span><br><span class="line">	  	OLED_ShowHexNum(<span class="number">4</span>,<span class="number">2</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">4</span>,<span class="number">5</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">4</span>,<span class="number">8</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">4</span>,<span class="number">11</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;	</span><br><span class="line">			<span class="comment">//DataA[0]++;</span></span><br><span class="line">			<span class="comment">//DataA[1]++;</span></span><br><span class="line">			<span class="comment">//DataA[2]++;</span></span><br><span class="line">			<span class="comment">//DataA[3]++;</span></span><br><span class="line">			</span><br><span class="line">			OLED_ShowString(<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;DataA:&quot;</span>);</span><br><span class="line"></span><br><span class="line">			OLED_ShowHexNum(<span class="number">2</span>,<span class="number">2</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">			OLED_ShowHexNum(<span class="number">2</span>,<span class="number">5</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">			OLED_ShowHexNum(<span class="number">2</span>,<span class="number">8</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">			OLED_ShowHexNum(<span class="number">2</span>,<span class="number">11</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line">      </span><br><span class="line">			Delay_ms(<span class="number">1000</span>);</span><br><span class="line">			</span><br><span class="line">			DMA_Transfer();</span><br><span class="line">			</span><br><span class="line">			OLED_ShowString(<span class="number">3</span>,<span class="number">2</span>,<span class="string">&quot;DataB:&quot;</span>);</span><br><span class="line">			OLED_ShowHexNum(<span class="number">4</span>,<span class="number">2</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">			OLED_ShowHexNum(<span class="number">4</span>,<span class="number">5</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">			OLED_ShowHexNum(<span class="number">4</span>,<span class="number">8</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">			OLED_ShowHexNum(<span class="number">4</span>,<span class="number">11</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line">			</span><br><span class="line">			Delay_ms(<span class="number">1000</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="实验-DMA-ADC多通道采集"><a href="#实验-DMA-ADC多通道采集" class="headerlink" title="实验-DMA+ADC多通道采集"></a>实验-DMA+ADC多通道采集</h2><p><code>ADC多通道(连续转换+扫描模式+DMA循环转移):</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*AD.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __AD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __AD_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint16_t</span> ADValue[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//void ADC_GetValue();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> ADValue[<span class="number">2</span>];<span class="comment">//有几个通道的结果长度就设定为几</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//1.开启RCC时钟，ADC和GPIO,以及DMA</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.ADC预分频器配置，72Mhz / 6 =12Mhz，不能超过14Mhz，至少6分频</span></span><br><span class="line">	RCC_ADCCLKConfig(RCC_PCLK2_Div6);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3.GPIO配置为模拟输入</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AIN;</span><br><span class="line">	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_4;</span><br><span class="line">	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//4.规则通道配置,将通道4,5,分贝写入规则通道的第一个位置和第二个位置(序列1，序列2)</span></span><br><span class="line">  ADC_RegularChannelConfig(ADC1,ADC_Channel_4,<span class="number">1</span>,ADC_SampleTime_239Cycles5);</span><br><span class="line">	ADC_RegularChannelConfig(ADC1,ADC_Channel_5,<span class="number">2</span>,ADC_SampleTime_55Cycles5);</span><br><span class="line"><span class="comment">//  ADC_RegularChannelConfig(ADC1,ADC_Channel_6,3,ADC_SampleTime_55Cycles5); 	还有通道继续配置即可</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//5.ADC转换器配置</span></span><br><span class="line">	ADC_InitTypeDef ADC_InitStruct;</span><br><span class="line">	ADC_InitStruct.ADC_Mode = ADC_Mode_Independent; <span class="comment">//ADC转换模式，该参数为独立ADC工作，剩余的其他参数都是双ADC模式</span></span><br><span class="line">	ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right;<span class="comment">//数据右对齐</span></span><br><span class="line">	ADC_InitStruct.ADC_ExternalTrigConv =ADC_ExternalTrigConv_None;<span class="comment">//这里选择软件触发，剩下的都为硬件触发</span></span><br><span class="line">	ADC_InitStruct.ADC_ContinuousConvMode = ENABLE;<span class="comment">//启动连续转换模式</span></span><br><span class="line">	ADC_InitStruct.ADC_ScanConvMode = ENABLE;<span class="comment">//是否启动扫描模式,这里多通道启动</span></span><br><span class="line">	ADC_InitStruct.ADC_NbrOfChannel = <span class="number">2</span>; <span class="comment">// 指定扫描模式下总共使用的通道数，使用了几个通道就填几</span></span><br><span class="line">	ADC_Init(ADC1,&amp;ADC_InitStruct);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//6.配置DMA</span></span><br><span class="line">	DMA_InitTypeDef DMA_InitStruct;</span><br><span class="line">	DMA_InitStruct.DMA_PeripheralBaseAddr = (<span class="type">uint32_t</span>)&amp;ADC1-&gt;DR;<span class="comment">//ADC1寄存器地址</span></span><br><span class="line">	DMA_InitStruct.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;	<span class="comment">//ADC选择半字16位传输,对于12位，舍弃4位</span></span><br><span class="line">	DMA_InitStruct.DMA_PeripheralInc = DMA_PeripheralInc_Disable;<span class="comment">//地址是否自增(Increment)，这里对同一个地方的值运输，不启用</span></span><br><span class="line">	DMA_InitStruct.DMA_MemoryBaseAddr = (<span class="type">uint32_t</span>)ADValue;<span class="comment">//存放到SRAM中的数组中</span></span><br><span class="line">	DMA_InitStruct.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;<span class="comment">//以半字16位传输</span></span><br><span class="line">	DMA_InitStruct.DMA_MemoryInc = DMA_MemoryInc_Enable;<span class="comment">//由于多个值，需要移动数组的地址，需要自增</span></span><br><span class="line">	DMA_InitStruct.DMA_DIR = DMA_DIR_PeripheralSRC ; <span class="comment">// 传输方向(direction),这里选择的是外设站点作为数据源</span></span><br><span class="line">	DMA_InitStruct.DMA_BufferSize = <span class="number">2</span>; <span class="comment">//其实就是传输次数,一次传输上面设置的数据宽度的值，这里两个通道一共传输2次</span></span><br><span class="line">	DMA_InitStruct.DMA_Mode = DMA_Mode_Circular; <span class="comment">// 传输模式，就是是否使用自动重装。Normal不重装，circular是循环重装</span></span><br><span class="line">	DMA_InitStruct.DMA_M2M = DMA_M2M_Disable; <span class="comment">// 配置硬件触发，M2M位为0</span></span><br><span class="line">	DMA_InitStruct.DMA_Priority = DMA_Priority_Medium; <span class="comment">// 配置优先级，选择中等</span></span><br><span class="line">	DMA_Init(DMA1_Channel1,&amp;DMA_InitStruct);<span class="comment">//查看手册得到ADC1通道为1，只能使用通道1</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//7.使能DMA和开启ADC到DMA输出	</span></span><br><span class="line">	DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line">	ADC_DMACmd(ADC1,ENABLE);<span class="comment">//必须在ADC使能之前开启输出到DMA</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//8.使能ADC</span></span><br><span class="line">	ADC_Cmd(ADC1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//9.ADC校准</span></span><br><span class="line">	ADC_ResetCalibration(ADC1);<span class="comment">//复位校准</span></span><br><span class="line">	<span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADC1)== SET)&#123;&#125;;<span class="comment">//RSTCAL寄存器由软件置1后开始复位校准，完成后硬件自动清0该位</span></span><br><span class="line">	ADC_StartCalibration(ADC1);</span><br><span class="line">	<span class="keyword">while</span>(ADC_GetCalibrationStatus(ADC1) == SET)&#123;&#125;;<span class="comment">//CAL寄存器由软件置1后开始校准，校准结束后硬件自动清0该位</span></span><br><span class="line">	</span><br><span class="line">  	<span class="comment">//10.ADC触发转换</span></span><br><span class="line">	ADC_SoftwareStartConvCmd(ADC1, ENABLE);</span><br><span class="line">    <span class="comment">/*连续转换，扫描模式下，DMA循环模式下只需要触发一次，ADC和DMA都不用等待，ADC和DMA就同时开始持续协同工作了*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*这里是触发使用单次转换时需要的*/</span></span><br><span class="line"><span class="comment">//void ADC_GetValue()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	DMA_Cmd(DMA1_Channel1,DISABLE);</span></span><br><span class="line"><span class="comment">//	DMA_SetCurrDataCounter(DMA1_Channel1,2); </span></span><br><span class="line"><span class="comment">//	DMA_Cmd(DMA1_Channel1,ENABLE);</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//	ADC_SoftwareStartConvCmd(ADC1, ENABLE);//启动软件触发转换</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//	/*不需要等待ADC转换完成了，只需要等待DMA*/</span></span><br><span class="line"><span class="comment">//	while(DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET)&#123;&#125;;//等待DMA传输完成</span></span><br><span class="line"><span class="comment">//	DMA_ClearFlag(DMA1_FLAG_TC1);//清除标志位</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AD.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Voltage = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">		</span><br><span class="line">		OLED_Init();</span><br><span class="line">		AD_Init();</span><br><span class="line">	  </span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;	</span><br><span class="line">			</span><br><span class="line">		Voltage = (<span class="type">float</span>)ADValue[<span class="number">1</span>] / <span class="number">4095</span> * <span class="number">3.3</span>;<span class="comment">//根据精度对应计算出电压值</span></span><br><span class="line">			</span><br><span class="line">		OLED_ShowNum(<span class="number">5</span>,<span class="number">5</span>,ADValue[<span class="number">0</span>],<span class="number">4</span>);</span><br><span class="line">		OLED_ShowNum(<span class="number">10</span>,<span class="number">5</span>,ADValue[<span class="number">1</span>],<span class="number">4</span>);</span><br><span class="line">		OLED_ShowNum(<span class="number">15</span>,<span class="number">5</span>,Voltage,<span class="number">4</span>);</span><br><span class="line">		</span><br><span class="line">		Delay_ms(<span class="number">1000</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>ADC连续转换+扫描模式下，配合DMA，只需要触发ADC转换后，每当有一个通道转换完成，DMA迅速将值转运到ADValue中，我们直接对ADValue的值进行读取即可</strong></p>
<hr>
<p><strong>这里我们其实还可以再加一个定时器，ADC用单次扫描，再用定时器去定时触发</strong></p>
<p><code>即：定时器触发ADC-&gt;ADC触发DMA</code></p>
<p><strong>这样的好处就是整个过程完全自动，不需要手动进行操作，节省软件资源，实现硬件自动化</strong></p>
</blockquote>
<h1 id="通信接口"><a href="#通信接口" class="headerlink" title="通信接口"></a>通信接口</h1><h2 id="接口简介"><a href="#接口简介" class="headerlink" title="接口简介"></a>接口简介</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241130220652564-1752337644185-531.png" alt="image-20241130220652564"></p>
<blockquote>
<p><strong>这里列举的是最常用，最简单的配置，还有很多配置没有列出</strong></p>
<p><strong>全双工一般都有两根数据线，比如串口、SPI</strong></p>
</blockquote>
<h2 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241201171647997-1752337644185-532.png" alt="image-20241201171647997"></p>
<blockquote>
<p><strong>串口是点对点通信，就是一对一之间通讯</strong></p>
<p><strong>图一</strong>：<strong>USB转串口模块</strong>，上面是<strong>CH340芯片</strong>，可以将串口协议转换为USB协议，USB端可以接在电脑上，另一端串口引脚接在支持串口的芯片上</p>
<p><strong>图二</strong>：<strong>陀螺仪传感器模块</strong>，测量加速度，角速度，一边是串口引脚，一边是I2C引脚</p>
<p><strong>图三</strong>：<strong>蓝牙串口模块</strong>，上面的芯片可以和手机互联，实现手机遥控单片机的功能</p>
</blockquote>
<h3 id="CH340串口驱动"><a href="#CH340串口驱动" class="headerlink" title="CH340串口驱动"></a>CH340串口驱动</h3><p>CH340芯片作为USB和串行通信之间的桥梁，它允许你的电脑通过USB端口与仅支持串行通信协议的设备（如许多基于STM32的开发板）进行通信。安装了正确的驱动后，电脑上的应用程序（例如串口调试工具、编程软件等）才能通过这个虚拟出来的COM端口与STM32开发板交换数据。</p>
<p><strong>串口连接我们电脑时，对应设备管理器中找到是否有CH340的驱动，没有的安装即可，有的话就可以使用了。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241203185913944-1752337644185-533.png" alt="image-20241203185913944"></p>
<h3 id="硬件电路-1"><a href="#硬件电路-1" class="headerlink" title="硬件电路"></a>硬件电路</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241201172828258-1752337644185-534.png" alt="image-20241201172828258"></p>
<blockquote>
<p><strong>一般串口通信模块有四个引脚：VCC、TX、RX、GND</strong></p>
<p><strong>简单的串口通信只有RX和TX两个信号线，复杂的还有时钟线</strong></p>
<p>TX和RX是<code>单端信号</code>，它们的高低电平都是相对于GND，所以串口通信的RX、TX、GND是必须接的</p>
<p>对于VCC，如果两个设备都有独立供电，VCC可以不用接。如果其中一个设备没有供电，比如设备1是STM32，设备2是蓝牙串口模块，STM32有独立供电，蓝牙串口模块没有独立供电，此时就需要把蓝牙串口的VCC和STM32的VCC接在一起</p>
<hr>
<p><strong>两根通信线为全双工，只接一根通信线的情况下就变成了单工通信</strong></p>
<hr>
<p><strong>电平标准不一致需要加电平转换芯片才能通信，一般设备直接出来的是TTL电平，需要另外一个也是TTL电平才能通信</strong></p>
</blockquote>
<h3 id="电平标准"><a href="#电平标准" class="headerlink" title="电平标准"></a>电平标准</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241201173753315-1752337644185-535.png" alt="image-20241201173753315"></p>
<blockquote>
<p><code>TTL电平</code>：单片机这种低压小型设备，使用的都是TTL电平，最远几十米。所以在单片机中如果线路对地是3.3V，就代表发送了逻辑1，对地是0V，就代表发送了逻辑0</p>
<p><code>RS232</code>：最远几十米。</p>
<p><code>RS485</code>：两线压差，所以电平是差分信号，差分信号的抗干扰能力非常强，使用RS485电平标准，通讯距离可以达到上千米</p>
<p><strong>不同的电平间，加上电平转换芯片即可使用</strong></p>
</blockquote>
<h3 id="串口参数及时序"><a href="#串口参数及时序" class="headerlink" title="串口参数及时序"></a>串口参数及时序</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241201174831622-1752337644185-536.png" alt="image-20241201174831622"></p>
<blockquote>
<p><code>波特率</code>：每秒传送码元的个数，单片机中的话一个码元对应一位，码元&#x2F;s对应bit&#x2F;s</p>
<p><code>起始位</code>：空闲状态时为<strong>高电平</strong>，起始位为<strong>低电平</strong>产生一个下降沿，标志数据发送的开始</p>
<p><code>数据位</code>：<strong>低位先行</strong>，从数据的低位开始发送。可以把校验位算在数据位中，也可以把校验位单独出来</p>
<p><code>校验位</code>：三种方式，无校验，奇校验，偶校验，根据数据来决定是0还是1</p>
<p><code>停止位</code>：固定为<strong>高电平</strong>为下个起始位做准备</p>
<hr>
<p><code>数据帧格式：</code></p>
<p>&lt;——–10位&#x2F;11位 ———–&gt;</p>
<p><strong>起始位(低电平)+数据位+停止位(高电平)</strong>   </p>
<p>​            1位               8&#x2F;9位        1 位</p>
<p>8位数据位：不含有奇偶校验位</p>
<p>9位数据为：最后一位添加了一位奇偶校验位</p>
<hr>
</blockquote>
<h3 id="USART简介"><a href="#USART简介" class="headerlink" title="USART简介"></a>USART简介</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241201231743375-1752337644185-538.png" alt="image-20241201231743375"></p>
<blockquote>
<p><strong>一般串口很少使用同步功能，只是多了个时钟输出，只支持输出不支持输入，同步模式更多是为了兼容别的协议和其他用途，并不支持两个USART之间进行同步通信</strong></p>
<hr>
<p><code>硬件流控制:</code>在A、B之间有一根单独的一根线，高低电平可以决定接收方是否准备好，准备好了再发送，可以防止接收方处理慢而导致数据丢失的问题。我们一般不使用</p>
<p><code>DMA:</code>串口有大量的数据时，可以使用DMA，减小CPU负担，提高效率</p>
</blockquote>
<h3 id="USART框图"><a href="#USART框图" class="headerlink" title="USART框图"></a>USART框图</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241202174332315-1752337644185-537.png" alt="image-20241202174332315"></p>
<blockquote>
<p><code>发送数据寄存器TDR</code>：只写，当数据从TDR全部到发送移位寄存器中后，<code>TXE标志位</code>(TX Empty)-<strong>发送数据寄存器为空</strong>，会置1，此时检查这个标志位为1的话就可以就可以写入下一个数据到TDR</p>
<p><code>发送移位寄存器</code>：把一个字节的数据一位一位地移出去，正好对应串口协议的波形数据位。通过下方发送器控制，向右移位，一位一位地把数据输出到TX引脚，正好对应串口的低位先行，当数据移位完成后，新的数据会再次自动的从TDR移动到发送移位寄存器中(移位未完成时TDR会等待完成)。</p>
<p>发送整个过程连续，效率高</p>
<hr>
<p><code>接收数据寄存器RDR</code>：只读</p>
<p><code>接收移位寄存器</code>：数据从RX引脚通向接收移位寄存器，在接受器控制下，一位一位地读取RX电平，先放在最高位，然后向右移。当这一个字节数据移位完成后，整体全部转移到<strong>接收数据寄存器RDR</strong>中，此时将<code>RXNE</code>(RX Not Empty )-<strong>接收数据寄存器非空</strong>，检测到RXNE置1之后，就可以将数据从RDR读走</p>
<hr>
<p><code>硬件数据流控(流控)</code>：<strong>如果发送设备发得太快，接收设备来不及处理，就会出现丢弃或覆盖数据得现象，有了流控就可以避免这个问题。一般不使用！！！</strong></p>
<p>对应有两个引脚：</p>
<p><code>nRTS(Request To Send)：</code>请求发送，是输出脚，告诉别人当前是否能接收，n代表低电平有效</p>
<p><code>nCTS(Clear To Send)：</code>是清除发送，是输入脚，用于接收别人nRTS信号b，n代表低电平有效</p>
<p>两个有流控的设备RTS和CTS交叉连接即可，CTS引脚接对方RTS引脚，用于判断对方能否接收，RTS引脚接对方CTS引脚，用于告诉对方我能不能接收</p>
<hr>
<p><code>右边边的SCLK</code>：</p>
<p>产生同步的时钟信号，用于配合发送移位寄存器输出。只支持输出不支持输入，两个USART之间不能实现同步的串口通信。我们一般不使用</p>
<p>作用：</p>
<ol>
<li>兼容别的协议，串口加上时钟后和SPI很像，所以可以兼容SPI协议</li>
<li>自适应波特率</li>
</ol>
<hr>
<p><code>唤醒单元：</code></p>
<p>实现多设备功能，一般不使用</p>
<hr>
<p><code>中断控制：</code></p>
<p>两个标志位比较重要，<code>TXE</code>(发送中断标志位)和<code>RXNE</code>(接收中断标志位)，这两个标志位可以去申请接收中断和发送中断，就可以在接收或者发送数据时，直接进入中断服务函数</p>
<p><strong>其他的标志位看手册可以知道有什么作用</strong></p>
<hr>
<p><code>波特率发生器：</code></p>
<p>波特率发生器其实就是<strong>分频器</strong>，对APB时钟进行分频，得到发送器和接收器的时钟</p>
</blockquote>
<p><code>对应所有的寄存器等更多知识都能在参考手册中查看！！！！</code></p>
<h3 id="USART基本结构"><a href="#USART基本结构" class="headerlink" title="USART基本结构"></a>USART基本结构</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241202164204771-1752337644185-539.png" alt="image-20241202164204771"></p>
<blockquote>
<p><code> 波特率发生器</code>：用于产生约定的通信速率</p>
<p><code>对于TDR和RDR</code>：在软件层面，只有一个DR寄存器可以让我们读写，只不过是在接收或者发送时走上面或者下面这条路</p>
<p><code>开关控制</code>：对应的Cmd函数</p>
</blockquote>
<h3 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h3><p><code>发送电路：</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241202164659015-1752337644185-540.png" alt="image-20241202164659015"></p>
<blockquote>
<p><strong>四种选择：</strong></p>
<p><strong>8位字长，无校验</strong></p>
<p><strong>8位字长，有校验</strong></p>
<p><strong>9位字长，无校验</strong></p>
<p><strong>9位字长，有校验</strong></p>
</blockquote>
<h3 id="起始位侦测"><a href="#起始位侦测" class="headerlink" title="起始位侦测"></a>起始位侦测</h3><p><code>接收电路:</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241202165836050-1752337644185-541.png" alt="image-20241202165836050"></p>
<blockquote>
<p><strong>以波特率的16倍进行采样，一位的长度中，每三位至少有2个0，否则认为是噪声。</strong></p>
<p><strong>采样位设置在8，9，10，之后也这样采样就能保证在数据中间</strong></p>
</blockquote>
<h3 id="数据采样"><a href="#数据采样" class="headerlink" title="数据采样"></a>数据采样</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241202170417412-1752337644185-542.png" alt="image-20241202170417412"></p>
<blockquote>
<p><strong>连续采样三次，无噪声下三次采样都为0或1</strong></p>
<p><strong>如果有噪声，以2:1进行确定，2次0，数据就为0，2次1，采样的数据就为1。此时会对噪声标志位NE置1，告诉收到数据，但有噪声</strong></p>
</blockquote>
<h3 id="波特率发生器"><a href="#波特率发生器" class="headerlink" title="波特率发生器"></a>波特率发生器</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241202170724981-1752337644185-543.png" alt="image-20241202170724981"></p>
<blockquote>
<p><strong>DIV(分频系数)分为整数部分和小数部分，可以实现更细腻的分频</strong></p>
<p>16是因为内部有一个16倍波特率的采样时钟，所以**（fpclk2&#x2F;1 &#x2F; DIV)&#x3D; 16  * 波特率(16倍波特率)**，最终计算波特率要多除以一个16</p>
<p><strong>例：配置9600波特率</strong></p>
<p>带公式：9600 &#x3D; 72MHz &#x2F;(16*DIV) ，得到DIV &#x3D; 468.75</p>
<p>然后将DIV写入到该波特比率寄存器USART_BRR中，转换为2进制写入，有整数位和小数位</p>
<p><code>我们使用库函数直接输入需要的波特率9600即可，自动计算配置完成</code></p>
</blockquote>
<h3 id="数据模式"><a href="#数据模式" class="headerlink" title="数据模式"></a>数据模式</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241203190308931-1752337644185-544.png" alt="image-20241203190308931"></p>
<blockquote>
<p><strong>通过串口助手显示的数据有以上两种方式：HEX和ASCII</strong></p>
<p>HEX：以原始数据(0x41等)的形式显示，为十六进制</p>
<p>ASCII：将原始数据(0x41)按照ASCII编码码表对应显示(0x41对应编码为‘A’)</p>
</blockquote>
<h3 id="库函数-7"><a href="#库函数-7" class="headerlink" title="库函数"></a>库函数</h3><p>stm32f10x_usart.h中找到</p>
<p><code>初始化函数：</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">USART_DeInit</span><span class="params">(USART_TypeDef* USARTx)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_Init</span><span class="params">(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_StructInit</span><span class="params">(USART_InitTypeDef* USART_InitStruct)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*这两个函数用于配置同步时钟输出的，包括时钟使能，极性，相位等参数使用结构体*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_ClockInit</span><span class="params">(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_ClockStructInit</span><span class="params">(USART_ClockInitTypeDef* USART_ClockInitStruct)</span>;</span><br></pre></td></tr></table></figure>

<p><code>中断配置：</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">USART_ITConfig</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_IT, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure>

<p><code>USART相关使能：</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">USART_Cmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*使能USART*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_DMACmd</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_DMAReq, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*开启对应的USART到DMA的触发通道*/</span></span><br></pre></td></tr></table></figure>

<p><code>USART发送和接收数据：</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">USART_SendData</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> Data)</span>;</span><br><span class="line"><span class="comment">//写DR寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">USART_ReceiveData</span><span class="params">(USART_TypeDef* USARTx)</span>;</span><br><span class="line"><span class="comment">//读DR寄存器</span></span><br></pre></td></tr></table></figure>

<p><code>标志位相关：</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FlagStatus <span class="title function_">USART_GetFlagStatus</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_FLAG)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_ClearFlag</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_FLAG)</span>;</span><br><span class="line"><span class="comment">/*终端外使用的标志位函数*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断服务程序中使用的标志位函数*/</span></span><br><span class="line">ITStatus <span class="title function_">USART_GetITStatus</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_IT)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_ClearITPendingBit</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_IT)</span>;</span><br></pre></td></tr></table></figure>



<hr>
<p><code>不常用</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">USART_SetAddress</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint8_t</span> USART_Address)</span>;<span class="comment">//设置地址</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_WakeUpConfig</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_WakeUp)</span>;<span class="comment">//唤醒</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_ReceiverWakeUpCmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_LINBreakDetectLengthConfig</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_LINBreakDetectLength)</span>;<span class="comment">//LIN</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_LINCmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*一大段函数，智能卡、IrDA等相关函数不怎么使用*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_SendBreak</span><span class="params">(USART_TypeDef* USARTx)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_SetGuardTime</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint8_t</span> USART_GuardTime)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_SetPrescaler</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint8_t</span> USART_Prescaler)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_SmartCardCmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_SmartCardNACKCmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_HalfDuplexCmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_OverSampling8Cmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_OneBitMethodCmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_IrDAConfig</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_IrDAMode)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_IrDACmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="USART配置流程"><a href="#USART配置流程" class="headerlink" title="USART配置流程"></a>USART配置流程</h3><ol>
<li><p><strong>RCC开启时钟，打开需要的USART和GPIO时钟</strong></p>
</li>
<li><p><strong>配置GPIO，对应TX配置为复用输出，RX配置为上拉或浮空输入</strong></p>
</li>
<li><p><strong>配置USART，使用结构体配置即可</strong></p>
</li>
<li><p>如果需要接收中断，加上ITConfig和NVIC配置即可。如果不需要中断跳过配置即可</p>
</li>
<li><p><strong>使能USART，USART_Cmd</strong></p>
</li>
</ol>
<h3 id="测试-串口发送和串口接收"><a href="#测试-串口发送和串口接收" class="headerlink" title="测试-串口发送和串口接收"></a>测试-串口发送和串口接收</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*usart.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __USART_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __USART_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*包括对Usart的初始化，和对一些常用的函数封装*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartInit</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSend</span><span class="params">(<span class="type">uint8_t</span> Data)</span>;<span class="comment">//发送一个字符</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendArray</span><span class="params">(<span class="type">uint8_t</span>* Array,<span class="type">uint8_t</span> Length)</span>;<span class="comment">//发送数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendString</span><span class="params">(<span class="type">char</span>* String)</span>;<span class="comment">//发送字符串</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">UsartPow</span><span class="params">(<span class="type">uint32_t</span> x,<span class="type">uint8_t</span> y)</span>;<span class="comment">//幂函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendNum</span><span class="params">(<span class="type">uint32_t</span> Num,<span class="type">uint8_t</span> Length)</span>;<span class="comment">//发送数字</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>





<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*usart.c*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartInit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//1. RCC开启时钟，打开需要的USART和GPIO时钟</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2,ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.配置GPIO，对应TX配置为复用输出，RX配置为上拉或浮空输入，如果只选择一种模式，那么就只配置一个引脚即可</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_2;</span><br><span class="line">	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStruct);<span class="comment">//TX引脚配置</span></span><br><span class="line">	</span><br><span class="line">	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_3;</span><br><span class="line">	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStruct);<span class="comment">//RX引脚配置</span></span><br><span class="line">  </span><br><span class="line">	<span class="comment">//3.配置USART，使用结构体配置即可</span></span><br><span class="line">	USART_InitTypeDef USART_InitStruct;</span><br><span class="line">	USART_InitStruct.USART_BaudRate = <span class="number">9600</span>;<span class="comment">//波特率配置</span></span><br><span class="line">	USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;<span class="comment">//硬件流控配置,这里不适用</span></span><br><span class="line">	USART_InitStruct.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; <span class="comment">//这里配置串口接收和发送模式都使用，可以只配置一个</span></span><br><span class="line">	USART_InitStruct.USART_Parity = USART_Parity_No; <span class="comment">//校验位，不使用校验</span></span><br><span class="line">	USART_InitStruct.USART_StopBits = USART_StopBits_1; <span class="comment">//停止位配置1位</span></span><br><span class="line">	USART_InitStruct.USART_WordLength = USART_WordLength_8b;<span class="comment">//数据位长度，没有奇偶校验位，所以选择8位数据位</span></span><br><span class="line">	USART_Init(USART2,&amp;USART_InitStruct);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/*如果需要使用中断，需要在此处调用USART_ITConfig函数，然后再配置NVIC即可*/</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="comment">//4.使能USART，USART_Cmd</span></span><br><span class="line">	USART_Cmd(USART2,ENABLE);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSend</span><span class="params">(<span class="type">uint8_t</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">	USART_SendData(USART2,Data);</span><br><span class="line">	<span class="keyword">while</span>(USART_GetFlagStatus(USART2,USART_FLAG_TXE) == RESET);<span class="comment">//等待数据移动到移位寄存器中，避免发生数据覆盖</span></span><br><span class="line">	<span class="comment">/*手册中可以知道，下一次调用SendData时该TXE标志位会自动清0*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendArray</span><span class="params">(<span class="type">uint8_t</span>* Array,<span class="type">uint8_t</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		UsartSend(Array[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendString</span><span class="params">(<span class="type">char</span>* String)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;String[i]!=<span class="string">&#x27;\0&#x27;</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		UsartSend(String[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">UsartPow</span><span class="params">(<span class="type">uint32_t</span> x,<span class="type">uint8_t</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> result = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(y--)</span><br><span class="line">	&#123;</span><br><span class="line">		result*=x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendNum</span><span class="params">(<span class="type">uint32_t</span> Num,<span class="type">uint8_t</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		UsartSend((Num/UsartPow(<span class="number">10</span>,Length-i<span class="number">-1</span>))%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);<span class="comment">//加上一个字符0得到对应数字的ascii码</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="type">uint8_t</span> myArray[] = &#123;<span class="number">0x42</span>,<span class="number">0x43</span>,<span class="number">0x44</span>,<span class="number">0x45</span>&#125;;</span><br><span class="line"></span><br><span class="line">	  	UsartInit();</span><br><span class="line">    </span><br><span class="line">	  	UsartSend(<span class="number">0x41</span>);</span><br><span class="line">		</span><br><span class="line">		UsartSendArray(myArray,<span class="number">4</span>);</span><br><span class="line">		</span><br><span class="line">		UsartSendString(<span class="string">&quot;hello\r\nworld&quot;</span>);<span class="comment">//需要两个转义字符才能换行，\r代表回车，\n代表换行</span></span><br><span class="line">		</span><br><span class="line">		UsartSendNum(<span class="number">65535</span>,<span class="number">5</span>);</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;	</span><br><span class="line">			<span class="keyword">if</span>()</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="实验-串口接收单字节-轮询-中断"><a href="#实验-串口接收单字节-轮询-中断" class="headerlink" title="实验-串口接收单字节(轮询+中断)"></a>实验-串口接收单字节(轮询+中断)</h3><p><code>在while循环中轮询读取：</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> rData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;	</span><br><span class="line">	   <span class="keyword">if</span>(USART_GetFlagStatus(USART2,USART_FLAG_RXNE)== SET)<span class="comment">//手册可知该RXNE标志位再下方调用读取时会自动清0</span></span><br><span class="line">		&#123;</span><br><span class="line">				rData = USART_ReceiveData(USART2);</span><br><span class="line">		&#125;</span><br><span class="line">      OLED_ShowHexNum(<span class="number">2</span>,<span class="number">2</span>,rData,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><code>使用中断:</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __USART_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __USART_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartInit</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSend</span><span class="params">(<span class="type">uint8_t</span> Data)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendArray</span><span class="params">(<span class="type">uint8_t</span>* Array,<span class="type">uint8_t</span> Length)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendString</span><span class="params">(<span class="type">char</span>* String)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">UsartPow</span><span class="params">(<span class="type">uint32_t</span> x,<span class="type">uint8_t</span> y)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendNum</span><span class="params">(<span class="type">uint32_t</span> Num,<span class="type">uint8_t</span> Length)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">UsartGetFlag</span><span class="params">()</span>;<span class="comment">//自定义标志位</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">UsartGetData</span><span class="params">()</span>;<span class="comment">//自定义Get方法</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*usart.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> rData;</span><br><span class="line"><span class="type">uint8_t</span> rFlag=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartInit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//1. RCC开启时钟，打开需要的USART和GPIO时钟</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2,ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.配置GPIO，对应TX配置为复用输出，RX配置为上拉或浮空输入，如果只选择一种模式，那么就只配置一个引脚即可</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_2;</span><br><span class="line">	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStruct);<span class="comment">//TX引脚配置</span></span><br><span class="line">	</span><br><span class="line">	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_3;</span><br><span class="line">	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStruct);<span class="comment">//RX引脚配置</span></span><br><span class="line">  </span><br><span class="line">	<span class="comment">//3.配置USART，使用结构体配置即可</span></span><br><span class="line">	USART_InitTypeDef USART_InitStruct;</span><br><span class="line">	USART_InitStruct.USART_BaudRate = <span class="number">9600</span>;<span class="comment">//波特率配置</span></span><br><span class="line">	USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;<span class="comment">//硬件流控配置,这里不适用</span></span><br><span class="line">	USART_InitStruct.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; <span class="comment">//这里配置串口接收和发送模式都使用，可以只配置一个</span></span><br><span class="line">	USART_InitStruct.USART_Parity = USART_Parity_No; <span class="comment">//校验位，不使用校验</span></span><br><span class="line">	USART_InitStruct.USART_StopBits = USART_StopBits_1; <span class="comment">//停止位配置1位</span></span><br><span class="line">	USART_InitStruct.USART_WordLength = USART_WordLength_8b;<span class="comment">//数据位长度，没有奇偶校验位，所以选择8位数据位</span></span><br><span class="line">	USART_Init(USART2,&amp;USART_InitStruct);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*如果需要使用中断，需要在此处调用USART_ITConfig函数，然后再配置NVIC即可*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//4.配置中断和NVIC</span></span><br><span class="line">	USART_ITConfig(USART2,USART_IT_RXNE,ENABLE);</span><br><span class="line">	</span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStruct;</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannel = USART2_IRQn;</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStruct);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//5.使能USART，USART_Cmd</span></span><br><span class="line">	USART_Cmd(USART2,ENABLE);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">UsartGetData</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> rData;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用extern也是同样的效果’</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">UsartGetFlag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(rFlag == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		rFlag = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//自定义清除标志位</span></span><br><span class="line">	</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART2_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(USART_GetITStatus(USART2,USART_IT_RXNE)== SET)</span><br><span class="line">	&#123;</span><br><span class="line">	  	rData = USART_ReceiveData(USART2);</span><br><span class="line">	  	rFlag = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">		USART_ClearITPendingBit(USART2,USART_IT_RXNE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中断服务函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这段代码启动了接收中断USART_ITConfig(USART2,USART_IT_RXNE,ENABLE)就可以通过判断标志位来多次触发中断<br><code>标准库这样写可以重复触发中断，发送一次触发一次!!!</code></p>
<hr>
<p>而HAL库中除了刚开始要启用HAL_UART_Receive_IT()，还需要在中断回调函数中重新启用中断HAL_UART_Receive_IT()才能多次触发。</p>
<p><strong>这就是标准库和HAL库在使用上的不同地方</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">		<span class="type">uint8_t</span> Data;</span><br><span class="line">		OLED_Init();</span><br><span class="line"></span><br><span class="line">	  	UsartInit();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;	</span><br><span class="line">	    	<span class="keyword">if</span>(UsartGetFlag()== <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				Data = UsartGetData();</span><br><span class="line">				UsartSend(Data);</span><br><span class="line">			&#125;</span><br><span class="line">      	OLED_ShowHexNum(<span class="number">2</span>,<span class="number">2</span>,Data,<span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>该实验只能实现对单字符的接收</strong></p>
</blockquote>
<h3 id="实验-USART串口数据包"><a href="#实验-USART串口数据包" class="headerlink" title="实验-USART串口数据包"></a>实验-USART串口数据包</h3><h3 id="实验-printf函数的移植"><a href="#实验-printf函数的移植" class="headerlink" title="实验-printf函数的移植"></a>实验-printf函数的移植</h3><blockquote>
<p><strong>在Keil中，使用printf函数之前我们需要打开工程选项，找到Target，勾选Use MicroLIB(使用微库)</strong></p>
<p>MicroLIB：是Keil为嵌入式平台优化的一个精简库</p>
</blockquote>
<p><code>方法1：printf的重定向：</code>printf默认输出到屏幕，但是单片机没有屏幕，所以需要我们重定向到串口</p>
<p>在对应串口模块中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*该定义usart.c的结尾加上*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span><span class="comment">//该stdio.h头文件在usart.h中再进行引用一次，即可在调用usart.h时使用printf了</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch,FILE* f)</span></span><br><span class="line">&#123;</span><br><span class="line">    UsartSend(ch);</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*fputc是printf函数底层，使用printf时，是不断调用fputc进行打印的，我们把fputc函数重定向到串口，printfzi*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c中*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    UsartInit();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Num=%d\r\n&quot;</span>,<span class="number">66666</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>这种方法只能将printf输出到调用串口发送函数的那一个串口当中，无法在其他串口中使用。</p>
<p>解决方法：使用标准库函数sprintf</p>
</blockquote>
<p><code>方法2：sprintf函数使用</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c中*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    UsartInit();</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line"> 	<span class="built_in">sprintf</span>(String,<span class="string">&quot;Num=%d\r\n&quot;</span>,<span class="number">99999</span>);</span><br><span class="line">	UsartSendString(String);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>sprintf的作用是：发动格式化字符串到指定str中，可以实现拼接字符串，这样即可实现每个串口的格式化打印</strong></p>
</blockquote>
<p><code>方法三：使用可变参数封装sprintf</code></p>
<p>使用头文件<code>&lt;stdarg.h&gt;</code></p>
<p>具体封装过程百度即可</p>
<h3 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h3><h4 id="数据包介绍"><a href="#数据包介绍" class="headerlink" title="数据包介绍"></a>数据包介绍</h4><p><strong>数据包分为</strong>：<code>HEX数据包</code>和<code>文本数据包</code>，分别对应<strong>文本模式和HEX模式</strong></p>
<p><strong>作用</strong>：将属于同一批的数据进行打包和分割。</p>
<ol>
<li><code>HEX数据包:</code></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241204165308342-1752337644185-545.png" alt="image-20241204165308342"></p>
<blockquote>
<p>通过添加包头包尾分割数据</p>
<p>数据包头：0xFF</p>
<p>数据包尾：0xFE</p>
<hr>
<p><code>优点:</code><strong>传输最直接，解析数据非常简单，比较适合一些模块发送原始的数据，比如一些使用串口通信的陀螺仪、温湿度传感器数据</strong></p>
<p><code>缺点：</code>灵活性不足，载荷容易和包头包尾重复(可能传输的数据是包头包尾的数据)</p>
<p><code>解决方案：</code></p>
<ol>
<li><strong>限制载荷数据的范围，在发送时对数据变化范围显示</strong></li>
<li><strong>如果无法避免载荷数据和包头包尾重复，我们就尽量使用固定长度的数据包，经过几个数据包的数据对齐后，剩下的数据包应该就没有问题了</strong></li>
<li><strong>增加包头包尾的数量，并且尽量呈现出载荷数据出现不了的状态</strong></li>
</ol>
<hr>
<p><code>HEX数据包格式选择</code>：</p>
<ol>
<li>如果数据容易出现与包头包尾重复的情况，就最好选择固定包长</li>
<li>如果数据不容易出现与包头包尾重复的情况，可以选择可变包长，这样就非常的灵活，只需要确定唯一的包头包尾就知道数据包长度</li>
</ol>
</blockquote>
<ol start="2">
<li><code>文本数据包:</code></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241204184721167-1752337644186-555.png" alt="image-20241204184721167"></p>
<blockquote>
<p>在HEX数据包中，数据是以原始字节数据本身呈现，而在文本数据包中，每个字节都经过了编码和译码，表现出的就是文本格式，但实际上都还是一个字节的HEX数据</p>
</blockquote>
<blockquote>
<p><strong>文本数据包基本不用担心载荷和包头包尾重复的问题</strong></p>
<p><strong>包头：‘@’</strong></p>
<p><strong>包尾：’\r’  ‘\n’</strong></p>
<p><strong>载荷数据：除了包头包尾的数据</strong></p>
<hr>
<p><code>优点:</code><strong>数据直观易理解，非常灵活，比较适合一些输入指令进行人机交互的场合，比如蓝牙模块常用的AT指令，CNC和3D打印机常用的G代码</strong></p>
<p><code>缺点：</code>解析效率低，比如100，HEX发送的就是一个字节100，文本数据包却是三个字符’1’，’1’，’0’。</p>
</blockquote>
<h4 id="数据包的发送和接收"><a href="#数据包的发送和接收" class="headerlink" title="数据包的发送和接收"></a>数据包的发送和接收</h4><ol>
<li><p><code>数据包的发送:</code>使用串口对应发送**数组(HEX数据包)<strong>或者</strong>字符串函数(文本数据包)**即可</p>
</li>
<li><p><code>数据包的接收</code>：</p>
</li>
</ol>
<ul>
<li>固定包长HEX数据包接收</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241204190804966-1752337644185-546.png" alt="image-20241204190804966"></p>
<blockquote>
<p><strong>使用状态机编程思想</strong>：先根据项目要求定义状态，画几个圈，然后考虑号各个状态会在什么情况下会进行转移，如何转移，画好线和转移条件，最后根据这个来编程</p>
</blockquote>
<ul>
<li>可变包长文本数据包接收</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241204192226109-1752337644185-547.png" alt="image-20241204192226109"></p>
<h3 id="实验-串口收发HEX数据包"><a href="#实验-串口收发HEX数据包" class="headerlink" title="实验-串口收发HEX数据包"></a>实验-串口收发HEX数据包</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*usart.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __USART_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __USART_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/*此处只列举出了新添加的变量和函数，具体的见上方*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> RxPacket[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> TxPacket[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendPacket</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*usart.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*发送数据包,包头包尾自定义*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendPacket</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	UsartSend(<span class="number">0xFF</span>);<span class="comment">//包头</span></span><br><span class="line">	UsartSendArray(TxPacket,<span class="number">4</span>);<span class="comment">//固定长度为4的数据</span></span><br><span class="line">  	UsartSend(<span class="number">0xFE</span>);<span class="comment">//包尾</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用状态机的编程思想，每次中断接收一个字节数据*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART2_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">uint8_t</span> RxState = <span class="number">0</span>;</span><br><span class="line">	<span class="type">static</span> <span class="type">uint8_t</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(USART_GetITStatus(USART2,USART_IT_RXNE)== SET)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">uint8_t</span> RxData = USART_ReceiveData(USART2);</span><br><span class="line">		</span><br><span class="line">	  <span class="keyword">if</span>(RxState == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(RxData == <span class="number">0xFF</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				RxState = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(RxState == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			RxPacket[count++] = RxData;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(count&gt;=<span class="number">4</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				RxState = <span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(RxState == <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(RxData == <span class="number">0xFE</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				RxState = <span class="number">0</span>;</span><br><span class="line">				rFlag = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		USART_ClearITPendingBit(USART2,USART_IT_RXNE);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">		LED_Init();</span><br><span class="line">		Key_Init();</span><br><span class="line">		OLED_Init();</span><br><span class="line"></span><br><span class="line">	  	UsartInit();</span><br><span class="line">		</span><br><span class="line">	  </span><br><span class="line">	  	</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;	</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(UsartGetFlag()== <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">                UsartSendPacket(TxPacket);</span><br><span class="line">				OLED_ShowHexNum(<span class="number">1</span>,<span class="number">2</span>,TxPacket[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">				OLED_ShowHexNum(<span class="number">1</span>,<span class="number">2</span>,TxPacket[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">				OLED_ShowHexNum(<span class="number">1</span>,<span class="number">2</span>,TxPacket[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">				OLED_ShowHexNum(<span class="number">1</span>,<span class="number">2</span>,TxPacket[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用串口助手发送FF 05 06 07 08 FE，可以发现串口回显FF 05 06 07 08 FE，OLED上显示05 06 07 08的数据</p>
</blockquote>
<h3 id="实验-串口收发文本数据包"><a href="#实验-串口收发文本数据包" class="headerlink" title="实验-串口收发文本数据包"></a>实验-串口收发文本数据包</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*usart.h*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __USART_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __USART_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> RxTextPacket[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> rFlag=<span class="number">0</span>;<span class="comment">//接受完成标志,还可以避免接收太快来不及使用数据就被覆盖了</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*usart.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART2_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">uint8_t</span> RxState = <span class="number">0</span>;</span><br><span class="line">	<span class="type">static</span> <span class="type">uint8_t</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(USART_GetITStatus(USART2,USART_IT_RXNE)== SET)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">uint8_t</span> RxData = USART_ReceiveData(USART2);</span><br><span class="line">		</span><br><span class="line">	  <span class="keyword">if</span>(RxState == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(RxData == <span class="string">&#x27;@&#x27;</span>&amp;&amp;rFlag == <span class="number">0</span>)<span class="comment">//接收慢一点，等主函数使用完,避免主函数中的数据可能是上一个数据包和这个数据包中的内容</span></span><br><span class="line">			&#123;</span><br><span class="line">				RxState = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(RxState == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(RxData == <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				RxState = <span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				RxTextPacket[count++] = RxData;</span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(RxState == <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(RxData == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				RxTextPacket[count] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//组成完成字符串</span></span><br><span class="line">				count = <span class="number">0</span>;</span><br><span class="line">				</span><br><span class="line">				RxState = <span class="number">0</span>;</span><br><span class="line">				rFlag = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		USART_ClearITPendingBit(USART2,USART_IT_RXNE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">		LED_Init();</span><br><span class="line">		OLED_Init();</span><br><span class="line">	  	UsartInit();</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;	</span><br><span class="line">	    </span><br><span class="line">			<span class="keyword">if</span>(rFlag == <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				 <span class="keyword">if</span>(<span class="built_in">strcmp</span>(RxTextPacket,<span class="string">&quot;LED_ON&quot;</span>)== <span class="number">0</span>)</span><br><span class="line">				 &#123;</span><br><span class="line">					 LED1_ON();</span><br><span class="line">					 UsartSendString(<span class="string">&quot;LED1_ON_OK\r\n&quot;</span>);</span><br><span class="line">				 &#125;</span><br><span class="line">				 <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(RxTextPacket,<span class="string">&quot;LED_OFF&quot;</span>)== <span class="number">0</span>)</span><br><span class="line">				 &#123;</span><br><span class="line">					 LED1_OFF();</span><br><span class="line">					 UsartSendString(<span class="string">&quot;LED1_OFF_OK\r\n&quot;</span>);</span><br><span class="line">				 &#125;</span><br><span class="line">				 </span><br><span class="line">				 <span class="keyword">else</span></span><br><span class="line">				 &#123;</span><br><span class="line">					 UsartSendString(<span class="string">&quot;ERROR\r\n&quot;</span>);</span><br><span class="line">				 &#125;</span><br><span class="line">				</span><br><span class="line">				 rFlag = <span class="number">0</span>;<span class="comment">//使用完成数据标志，可以避免接收太快，之前那种方式可能会造成接收过快数据覆盖问题</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>使用串口助手发送@LED_ON + 换行回车，LED灯亮起</strong></p>
<p><strong>使用串口助手发送@LED_OFF + 换行回车，LED灯熄灭</strong></p>
</blockquote>
<h2 id="I2C"><a href="#I2C" class="headerlink" title="I2C"></a>I2C</h2><h3 id="I2C介绍"><a href="#I2C介绍" class="headerlink" title="I2C介绍"></a>I2C介绍</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241206141429374-1752337644185-548.png" alt="image-20241206141429374"></p>
<blockquote>
<p><strong>I2C特点</strong>：同步、半双工，两根通信线SCL和SDA</p>
<hr>
<p>第1个模块：MPU6050模块，进行姿态测量，使用I2C通信协议</p>
<p>第2个模块：OLED模块，显示图片，字符灯信息，使用I2C协议</p>
<p>第3个模块：AT24C02，存储器模块，使用I2C协议</p>
<p>第4个模块：DS3231，实时时钟模块，使用I2C协议</p>
<hr>
<p>I2C多主多从：相当于发生总线冲突，I2C协议会进行仲裁，胜利的一方取得总线控制权，失败的一方变回从机。同时在多主机的模型下，还要进行时钟同步</p>
</blockquote>
<h3 id="硬件电路与优缺点"><a href="#硬件电路与优缺点" class="headerlink" title="硬件电路与优缺点"></a>硬件电路与优缺点</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241206144150840-1752337644185-549.png" alt="image-20241206144150840"></p>
<blockquote>
<p><code>一主多从模式：</code></p>
<p>SCL上挂载多个从设备，任何情况下从机不允许控制SCL，对于SDA数据线，从机不允许主动发起对SDA的控制，只有等待主机发送请求时，从机响应才能短暂获取</p>
<hr>
<p><strong>I2C采用外置<code>弱上拉电阻加开漏输出</code>的电路结构</strong>：</p>
<p><code>1.选择开漏输出，而不选择推挽输出：</code></p>
<p>如果使用推挽输出，如果总线时序没调整好，可能主机和从机都处于输出状态，且一个输出高电平，一个输出低电平，此时就会出现电源短路的问题。</p>
<p>而开漏输出只能直接输出低电平，高电平下没有驱动能力，输出取决于外部电路。</p>
<p>这样的话，就保证了所有设备都只能输出低电平而不能输出高电平</p>
<p><code>2.加上拉电阻:</code></p>
<p>为了避免开漏输出高电平时造成的引脚浮空，同时I2C通信需要输出高电平的能力，由于开漏输出下不能直接输出高电平，此时需要在外部加一个上拉电阻，此时为弱上拉，使能被外部拉高</p>
<p><code>这样设计电路的好处:</code></p>
<ol>
<li>完全杜绝电源短路现象，保证电路安全</li>
<li>避免引脚模式的频繁切换，开漏加弱上拉的模式，同时兼具了输入和输出的功能</li>
<li><strong>开漏模式下具有”线与”的特性，即：只要有任意一个或多个设备输出了低电平，总线就处于低电平，只有所有的设备输出高电平，总线才输出高电平。I2C可以利用这个特性，执行多主机模式下的时钟同步和总线仲裁。</strong></li>
</ol>
<p><code>限制：</code></p>
<p>​	<strong>由于I2C开漏外加上拉电阻的电路结构，使得通信线高电平的驱动能力比较弱，导致通信线由低电平转换为高电平时，上升沿耗时会比较长，这样就限制了I2C的最大通信速度，所以I2C标准模式为100Khz，快速模式也只有400Khz，一般来说我们就认为I2C最快速度为400khz，相对于SPI的速度来说慢了许多</strong></p>
<hr>
<p><strong>为什么需要线与特性？</strong></p>
<p>I2C 支持<strong>多个主设备与多个从设备连接在同一根总线上，如果多个设备同时占用总线，怎么判断谁先占用总线呢？<strong>所以就需要一种仲裁机制。I2C 没有 Arbiter 直接的来处理仲裁，而是</strong>通过线与的逻辑实现仲裁</strong>。</p>
<p>仲裁过程：当主设备A准备占用I2C时，需要在SCL为高时，将SDA拉高，再拉低，满足一个启动条件。当主设备A将SDA拉高后，需要检查SDA的电平：</p>
<p>如果此时SDA电平为高，说明主设备可以占用总线，然后主设备A会将SDA拉低，一次满足启动条件，开始传输；<br>如果此时SDA电平为低，说明总线已经被其他设备占用，主设备A会退出。<br>为什么SDA为低，就是被其他设备占用了呢？<br>因为线与逻辑的存在。只有总线上有其他的设备将SDA置为0，线与后，SDA线的电平为0。主设备A检查SDA线的电平时，会发现为低电平。所以仲裁时，哪个设备更早地将SDA线拉低，谁就抢占了优先权。</p>
</blockquote>
<h3 id="I2C时序基本单元"><a href="#I2C时序基本单元" class="headerlink" title="I2C时序基本单元"></a>I2C时序基本单元</h3><ul>
<li><code>1.起始条件和终止条件:</code></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241206170442283-1752337644186-550.png" alt="image-20241206170442283"></p>
<blockquote>
<p><strong>正常情况下：SCL和SDA都处于高电平</strong></p>
<p><strong>起始条件：S&#x2F;Sr</strong></p>
<p><strong>终止条件：P</strong></p>
<p>从机收到起始条件后，自身复位，等待主机发送信息</p>
</blockquote>
<ul>
<li><code>2.主机发送字节时序</code>：</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241206170806836-1752337644186-551.png" alt="image-20241206170806836"></p>
<blockquote>
<p><strong>I2C发送字节与串口不同，I2C是高位先行，串口是低位先行</strong></p>
<p><code>发送字节过程总结下来就是</code>：</p>
<p><strong>时钟线SCL处于低电平时，主机设置数据线SDA的电平</strong></p>
<p><strong>时钟线SCL处于高电平时，从机读取数据线SDA的电平。</strong></p>
<p>显然，从机读取到的电平就是主机在时钟线低电平时设置的电平</p>
<hr>
<p><code>对中断处理：</code></p>
<p>如果主机一个字节发送一半，突然进中断了，那么此时SCL和SDA上的电平暂停变化，会不断拉长，传输完全暂停，等中断结束后，主机回来继续操作</p>
<hr>
<p><code>SCL和SDA控制权：</code></p>
<p><strong>该过程中，SCL和SDA都由主机掌控，从机只能被动读取</strong></p>
</blockquote>
<ul>
<li><code>主机接收字节时序:</code></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241206172222919-1752337644186-552.png" alt="image-20241206172222919"></p>
<blockquote>
<p><code>发送字节过程总结下来就是</code>：</p>
<p><strong>时钟线SCL处于低电平时，从机设置数据线SDA的电平</strong></p>
<p><strong>时钟线SCL处于高电平时，主机读取数据线SDA的电平。</strong></p>
<p>显然，主机读取到的电平就是从机在时钟线低电平时设置的电平</p>
<hr>
<p><code>SCL和SDA控制权:</code></p>
<p>SCL全程由主机控制</p>
<p><strong>主机在接收之前，需要释放SDA(SDA拉高)，此时让从机获得SDA控制权才能将数据放到SDA上!!!!!!!</strong></p>
</blockquote>
<ul>
<li><code>3.应答机制:</code></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241206172908982-1752337644186-553.png" alt="image-20241206172908982"></p>
<blockquote>
<p>根据应答机制，可以判断对方是否接收到了该数据</p>
<p>0：表示从机应答</p>
<p>1：表示从机非应答</p>
</blockquote>
<h3 id="I2C从机地址"><a href="#I2C从机地址" class="headerlink" title="I2C从机地址"></a>I2C从机地址</h3><blockquote>
<p><code>从机地址介绍:</code></p>
<p>从机地址，每个从机设备出厂时都会分配一个7位或者10位地址，对应地址是什么可以在对应模块找到地址，比如MPU6050的7位地址为1101 000，AT24C02的7位地址为1010 000</p>
<hr>
<p><code>相同芯片挂载时对地址的处理:</code></p>
<p>一般不同芯片地址不同，相同型号芯片地址相同。</p>
<p>当相同芯片挂载在同一条总线时，此时需要用到地址中的可变部分，一般地址最后几位是可以在电路中改变的，比如MPU6050，最后一位由芯片上的AD0引脚决定，当该引脚接低电平就是1101 000，接高电平就是1101 001。而AT24C02地址的最后三位分明由引脚A0,A1,A2决定</p>
<p>一般I2C的从机设备地址，高位都是厂商确定，低位可以由不同引脚切换，这样就可以保证多个相同芯片挂载时地址都不一样</p>
</blockquote>
<h3 id="I2C时序"><a href="#I2C时序" class="headerlink" title="I2C时序"></a>I2C时序</h3><p><code>时序1：指定地址写(常用)</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241206174948487-1752337644186-554.png" alt="image-20241206174948487"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241206175159856-1752337644186-557.png" alt="image-20241206175159856"></p>
<blockquote>
<p> <strong>该时序是对指定设备的指定寄存器写入指定数据的操作</strong></p>
<p> 上图为逻辑分析仪的结果：</p>
<ol>
<li><p><strong>最开始为起始条件</strong></p>
</li>
<li><p><strong>之后，必须是发送一个字节的时序，内容为从机地址+读写位(7+1共8位)</strong></p>
</li>
</ol>
<p> 上图对应为：1101 000 0(前七位为MPU6050地址，最后一位为0代表写入操作)</p>
<ol start="3">
<li><strong>紧跟着的单元就是，接收从机的应答位(ACK，RA)。RA之后有个上升沿，代表从机释放SDA产生，交出了SDA控制权。</strong></li>
</ol>
<p> 上图对应为：高电平器件，主机读取SDA，发现是0，代表主机进行寻址，有人应答了</p>
<ol start="4">
<li><strong>然后的一个字节为寄存器地址。</strong></li>
</ol>
<p> 上图为00011001(0x19)，即操作0x19地址的寄存器</p>
<ol start="5">
<li><p><strong>紧接着又是从机应答位</strong></p>
</li>
<li><p><strong>然后发送写入寄存器的内容</strong></p>
</li>
</ol>
<p> 上图为10101010，即发送数据为0xAA</p>
<ol start="7">
<li><p><strong>又是一个从机应答位</strong></p>
</li>
<li><p><strong>最后一个为终止条件</strong></p>
</li>
</ol>
<hr>
<p> <code>指定地址连续写入多个字节：</code></p>
<p> <strong>如果想要发送多个字节，只需要将第6步发送写入字节和接收应答重复N次即可，写入几个字节就重复几次。</strong></p>
<p> <strong>因为地址指针会在写入一个数据后自动+1，所以不用移动地址指针</strong></p>
</blockquote>
<p><code>时序2：当前地址读(不怎么使用):</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241206213240665-1752337644186-556.png" alt="image-20241206213240665"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241206213259135-1752337644186-558.png" alt="image-20241206213259135"></p>
<blockquote>
<ol>
<li><strong>起始条件</strong></li>
<li><strong>主机发送一个字节(从机地址+读写位)，发送完后紧跟一个从机应答ACK</strong></li>
</ol>
<p><strong>图上为1101000 1 表示读取1101000的数据</strong></p>
<ol start="3">
<li><strong>然后SDA控制权移交给从机，主机开始读取从机发送数据(不用发送读取寄存器地址，从机会将当前地址指针指向的寄存器的值发送)，不能指定读的地址。接收完后紧跟发送一个非应答(SA:1)，这样从机读取到主机非应答后，就知道主机不想要继续了，交还SDA控制权</strong></li>
</ol>
<p><strong>图上接收的数据为00001111(0x0F)</strong></p>
<ol start="4">
<li><strong>结束条件</strong></li>
</ol>
<p><code>由于不能指定读的地址。所以该时序(当前地址读)用的不多</code></p>
<hr>
<p><code>当前地址连续读多个字节：</code></p>
<p><strong>如果想要读取多个字节，3处的读取一个字节后，就应该发送<code>应答</code>(RA:0)，然后重复读取字节，发送应答，最后一个字节读取完后，跟上一个<code>非应答</code>就可以结束读取</strong></p>
<p><strong>因为地址指针也会在读取一个数据后自动+1，所以不用移动地址指针</strong></p>
</blockquote>
<p><code>时序3：指定地址读(常用):</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241206214232444-1752337644186-559.png" alt="image-20241206214232444"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241206214817354-1752337644186-560.png" alt="image-20241206214817354"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241206214842186-1752337644186-561.png" alt="image-20241206214842186"></p>
<blockquote>
<p><strong>指定地址读为复合格式，是指定地址写和当前地址读的混合</strong></p>
<p>复合格式：前面部分为指定地址写(写的数据的前面)，后面部分为当前地址读</p>
<hr>
<ol>
<li><strong>起始条件</strong></li>
<li><strong>发送一个字节，从机地址+读写位(此处应为写位为0)，然后是从机应答位ACK(RA:0)</strong></li>
<li><strong>在发送一个字节，指定写入的地址，指定完成后从机寄存器指针就指向该地址，然后是从机应答位ACK(RA:0</strong>)</li>
</ol>
<p><code>该部分为指定地址写前面部分</code></p>
<hr>
<ol start="4">
<li><strong>(这里前面可以加一个停止，也可以不加)不发送写入的内容，而重复起始条件Sr(Start Repeat)，相当于另起一个时序</strong></li>
<li><strong>重新发送一个字节，从机地址+读写位(此处应为读位为0），从机应答位ACK(RA:0)</strong></li>
<li><strong>主机接收一个字节，主机接收到的数据就是指定写入地址处的数据，然后发送一个非应答(SA:1)</strong></li>
<li><strong>停止条件</strong></li>
</ol>
<p><strong>连起来就是：先起始，写入地址，停止。再起始，读当前位置，停止</strong></p>
<hr>
<p><code>指定地址连续读多个字节：</code></p>
<p><strong>如果想要读取多个字节，6处的读取一个字节后，就应该发送<code>应答</code>(RA:0)，然后重复读取字节，发送应答，最后一个字节读取完后，跟上一个<code>非应答</code>就可以结束读取</strong></p>
<p><strong>因为地址指针也会在读取一个数据后自动+1，所以不用移动地址指针</strong></p>
</blockquote>
<h3 id="MPU6050"><a href="#MPU6050" class="headerlink" title="MPU6050"></a>MPU6050</h3><h4 id="MPU6050简介"><a href="#MPU6050简介" class="headerlink" title="MPU6050简介"></a>MPU6050简介</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241207201409336-1752337644186-562.png" alt="image-20241207201409336"></p>
<blockquote>
<p><code>6轴姿态传感器：</code>3轴加速度(加速度计) + 3轴角速度(陀螺仪传感器)</p>
<p><code>9轴姿态传感器：</code>3轴加速度 + 3轴角速度 + 3轴磁场强度(磁力计)</p>
<p><code>10轴姿态传感器：</code>3轴加速度 + 3轴角速度 + 3轴磁场强度 + 1个气压强度(气压计)</p>
</blockquote>
<blockquote>
<p><code>一些术语：</code></p>
<p><code>加速度计：</code>简称为Accel或者Acc或A，X,Y,Z三轴都有一个测量加速度。<strong>上面第二幅图就是加速度计</strong>，实际上加速度就是一个就是一个测力计。</p>
<p>使用加速度计求角度的时候只能在物体静止的时候使用，当物体运动起来时，这个角度会受运动加速度的影响而变得不准确。</p>
<p><code>即特性：</code>加速度计具有静态稳定性，不具有动态稳定性</p>
<hr>
<p><code>陀螺仪传感器：</code>简称为Gyro或者G，可以测量三轴的角速度值，分别表示芯片绕X轴、Y轴、Z轴旋转的角速度，<strong>对应上面第三幅图，为陀螺仪的机械模型</strong>。该芯片只能测得角速度，而不能直接测得角度，通过对角速度积分可以得到角度</p>
<p>当物体静止时，角速度的值会因为噪声无法完全归零，经过积分的不断累积，小噪声就会导致计算出来的角度产生缓慢的漂移，角速度积分得到的角度经不起时间的考验，但角度无论是运动还是静止都是没问题的</p>
<p><code>特性：</code>陀螺仪具有动态稳定性，不具有静态稳定性</p>
<hr>
<p><code>姿态解算：</code></p>
<p>这两个传感器特性刚好互补，通过互补滤波就能融合得到静态和动态都稳定的姿态角了。</p>
<hr>
<p><code>了解姿态角/欧拉角:</code></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinolover/article/details/90671784">什么是欧拉角&#x2F;姿态角？_欧拉角和姿态角区别-CSDN博客</a></p>
</blockquote>
<h4 id="MPU6050参数"><a href="#MPU6050参数" class="headerlink" title="MPU6050参数"></a>MPU6050参数</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241207205112946-1752337644186-563.png" alt="image-20241207205112946"></p>
<blockquote>
<p><code>部分重要参数，具体参数清查看MPU6050手册</code></p>
<p>芯片输出的是一个随姿态变化而变化的电压，要想量化电压那么就需要AD转换器，芯片自带16位ADC，输出结果是有符号数</p>
<hr>
<p><code>满量程：</code>决定对应16位ADC值达到最大值时对应的物理参量，具有多个选择，根据具体物体运动的剧烈程度(实际情况)选择，避免超过满量程。</p>
<p>量程越小，分辨率越高，量程越大，范围越广</p>
<hr>
<p><code>低通滤波:</code>如果输出数据抖动很厉害，可以加一点低通滤波，这样就会更平缓</p>
<p><code>可配置时钟源和采样分频:</code>两个参数配合使用，时钟源通过采样分频为AD转换和内部其他电路提供时钟，控制分频系数就可以控制AD转换的快慢了</p>
<hr>
<p><code>对从机地址的处理</code>：</p>
<p>第一种从机地址：110 1000(0x68)</p>
<p>第二种从机地址(读写位)：1101 0000(0xD0)或者1101 0001(0xD1)</p>
<p>所以这两种从机地址说法都是正确的，一个是没带上读写位的从机地址，一个是带上从机位的地址。</p>
<p>实际发送一个字节时，只需要不带读写为的从机地址左移1位，再或上读写位即可</p>
<p>(0x68 &lt;&lt; 1 ) |   1&#x2F;0</p>
<p>也可以直接就写融入读写位的从机地址</p>
<p>0xD1&#x2F;0xD0</p>
</blockquote>
<h4 id="硬件电路-2"><a href="#硬件电路-2" class="headerlink" title="硬件电路"></a>硬件电路</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241207221537437-1752337644186-564.png" alt="image-20241207221537437"></p>
<blockquote>
<p><strong>最右边的是MPU6050的芯片</strong>：</p>
<p>芯片本身引脚非常多，包括I2C通信引脚，供电，帧同步等，很多引脚用不到，还有些引脚是芯片最小系统里的固定连接，一般手册中有</p>
<hr>
<p><strong>左下角是8针的排针</strong>：</p>
<ul>
<li><strong>VCC和GND</strong>：电源供电</li>
<li><strong>SCL和SDA</strong>：I2C通信引脚，可以看到外部电路已经内置两个4.7K上拉电阻了，直接接即可，不用再接上拉电阻了</li>
<li><strong>XCL、XDA</strong>：主机I2C引脚，设计是为了扩展芯片功能，6轴传感器不够时，这个XCL和XDL用于外接磁力计或者气压计扩展为9轴传感器等，接上后MPU6050主机接口可以直接访问这些扩展芯片的数据，将数据读入MPU6050,里面有DMP单元进行数据融合和姿态解算。</li>
</ul>
<p>如果不需要解算功能，可以直接把磁力计或气压计挂载到SCL和SDA上，因为I2C本来就可以挂载多设备</p>
<ul>
<li><strong>AD0</strong>：7位从机地址最低位，电路中可以看到默认若下拉到低电平所以悬空状态下为0。对应从机地址为1101 000，接VCC的话就是1101 001</li>
<li><strong>INT</strong>：中断输出引脚，可以配置芯片内部事件触发中断引脚输出，如：数据准备好了、I2C主机错误等，不使用可以不配置</li>
</ul>
<p>除此之外，芯片内部还内置了一些实用的小功能：自由落体监测、运动监测、零运动监测等，这些信号都可以触发INT引脚产生电平跳变，可以进行中断信号的配置</p>
<hr>
<p><strong>左上角是LDO，低压差线性稳压器</strong>：</p>
<p>这部分是供电的逻辑，手册中可以看到MPU6050的VDD供电为2.375~3.46V，属于3.3V供电设备，不能直接接5V，为了扩大供电范围，就加了个3.3V的稳压器，使输入端电压VCC_5V可以再3.3V到5V之间，经过3.3V的稳压器给芯片端供电。最后跟上的是一个电源知识灯，如果有点就会亮。</p>
<p>这一模块是否需要可以根据需求来，如果已经有稳定的3.3V的电源就不需要这部分了</p>
</blockquote>
<h4 id="MPU6050框图"><a href="#MPU6050框图" class="headerlink" title="MPU6050框图"></a>MPU6050框图</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241207225256921-1752337644186-565.png" alt="image-20241207225256921"></p>
<blockquote>
<p><strong>时钟部分</strong>：一般使用内部时钟，硬件电路上也是直接接地和没有引出</p>
<hr>
<p><strong>灰色部分</strong>：</p>
<p>是芯片内部传感器，包括XYZ轴的加速度计(X Accel等)，XYZ轴的角速度计(X Gyro等)</p>
<p>还内置了一个温度传感器(Temp Sensor)，也可用于测量温度。</p>
<p>这些传感器转换完成后，数据统一放在传感器寄存器(Sensor Register)中，读取该数据寄存器就能得到传感器测量的值。</p>
<p>芯片内部转换都是全自动进行(类似与AD连续转换+DMA转运)，每个ADC输出对应都是16位数据寄存器，不存在数据覆盖问题。需要数据直接读取即可</p>
<hr>
<p><strong>最左边Self test</strong>：</p>
<p>这是芯片的自测单元，当启动自测后，芯片内部会模拟一个外力施加在传感器上，这个外力导致传感器数据会比平时大一些。</p>
<p><strong>自测方法：先使能自测，读取数据，再失能自测，读取数据。两个数据相减得到的数据叫做自测响应，芯片手册中给出了一个范围，如果在这个范围内，代表芯片没问题。如果不在，就说明芯片可能坏了，使用的话就要小心点。</strong></p>
<p><code>手册找到自测范围如下：在这个范围内就代表芯片正常</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241207235118026-1752337644186-568.png" alt="image-20241207235118026"></p>
<hr>
<p><strong>最下方Charge Pump</strong>：电荷泵，进行升压操作</p>
<hr>
<p><strong>最右边是寄存器和通信接口部分：</strong></p>
<p>很多寄存器：配置寄存器等</p>
<p>通信接口：从机I2C和SPI接口，主机I2C接口用于扩展设备通信</p>
<p>里面有个Digital Motion Processor-数字运动处理器简称DMP，是芯片内部自带的一个姿态解算的硬件算法，配合官方DMP库可以进行姿态解算</p>
<hr>
<p><strong>右下角为供电部分</strong>：按照手册电压要求和参考电路接线即可</p>
</blockquote>
<h4 id="MPU6050产品手册"><a href="#MPU6050产品手册" class="headerlink" title="MPU6050产品手册"></a>MPU6050产品手册</h4><p>I2C通信，电气特性等知识均可查看</p>
<h4 id="MPU6050寄存器映像手册"><a href="#MPU6050寄存器映像手册" class="headerlink" title="MPU6050寄存器映像手册"></a>MPU6050寄存器映像手册</h4><p>所有的寄存器都在里面，但是不需要全部了解</p>
<p><strong>需要了解的如下：每个寄存器具体介绍在手册向下翻即可</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241207233440068-1752337644186-566.png" alt="image-20241207233440068"></p>
<blockquote>
<p><code>SMPLRT_DIV</code>：<strong>采样频率分频寄存器</strong>，配置采样寄存器的分频系数，分频越小，内部AD转换越快，数据刷新越快。</p>
<p>采样频率 &#x3D; (陀螺仪晶振)陀螺仪输出时钟频率&#x2F;(1+分频值)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241218223941780-1752337644186-567.png" alt="image-20241218223941780"></p>
<p>Bit7~Bit0：值越小，越快，根据实际需求来</p>
<p><strong>对应配置：0x09 (对应10分频)</strong></p>
<hr>
<p><code>CONFIG</code>：<strong>配置寄存器</strong>，分为外部同步设置和低通滤波器配置，外部同步这里不使用不看。低通滤波器可以使输出数据更平滑，选择值为0~7，数值越大，抖动越下，0代表不滤波</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241218224001365-1752337644186-569.png" alt="image-20241218224001365"></p>
<p>Bit7~6：无关位</p>
<p>Bit5~3：外部同步，不需要，给0即可</p>
<p>Bit2~0：数字低通滤波器，也是根据需求配置。我们给个110，比较平滑的配置</p>
<p><strong>对应配置为：0x06</strong></p>
<hr>
<p><code>GYRO_CONFIG</code>：<strong>陀螺仪配置寄存器</strong>，高3位是XYZ轴的自测使能位，中间两位是满量程选择位，最后三位没使用</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241218224017264-1752337644186-570.png" alt="image-20241218224017264"></p>
<p>Bit7~Bit5：自测使能位，不自测给0即可</p>
<p>Bit4~Bit3:	满量程选择，根据实际需求选择。我们给11为最大量程</p>
<p>Bit2~Bit0：无关位</p>
<p><strong>对应配置为：0x18</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241207235348661-1752337644186-571.png" alt="image-20241207235348661"></p>
<hr>
<p><code>ACCEL_CONFIG</code>：<strong>加速度计配置寄存器</strong>，高3位是XYZ轴的自测使能位，中间两位是满量程选择位，最后三位用于配置高通滤波器(内置小功能会用到)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241218224036938-1752337644186-572.png"></p>
<p>Bit7~Bit5：自测使能位，不自测给0即可</p>
<p>Bit4~Bit3:	满量程选择，根据实际需求选择。我们给11为最大量程</p>
<p>Bit2~Bit0：高通滤波器，不使用给00</p>
<p><strong>对应配置为：0x18</strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241207233637672-1752337644187-573.png" alt="image-20241207233637672"></p>
<blockquote>
<p><code>加速度计XYZ轴寄存器：</code>_L 表示低8位，_H表示高8位</p>
<p>ACCEL_XOUT_H ：</p>
<p>ACCEL_XOUT_L ：</p>
<p>ACCEL_YOUT_H ：</p>
<p>ACCEL_YOUT_L ：</p>
<p>ACCEL_ZOUT_H ：</p>
<p>ACCEL_ZOUT_L ：</p>
<p><code>加速度计XYZ轴寄存器：</code>_L 表示低8位，_H表示高8位</p>
<p>GYRO_XOUT_H： </p>
<p>GYRO_XOUT_L ：</p>
<p>GYRO_YOUT_H ：</p>
<p>GYRO_YOUT_L ：</p>
<p>GYRO_ZOUT_H ：</p>
<p>GYRO_ZOUT_L ：</p>
<p><code>温度传感器寄存器：</code></p>
<p>TEMP_OUT_H ：</p>
<p>TEMP_OUT_L ：</p>
<p><code>查看对应手册的寄存器讲解部分即可</code></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241207234205598-1752337644187-574.png" alt="image-20241207234205598"></p>
<blockquote>
<p><code>具体某位干什么查看手册对应寄存器功能</code></p>
<p><code>PWR_MGMT_1：电源管理寄存器1:</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241208000537943-1752337644187-575.png" alt="image-20241208000537943"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241218222543311-1752337644187-576.png" alt="image-20241218222543311"></p>
<p>Bit7(DEVICE)：设备复位，配置给0不复位</p>
<p>Bit6(SLEEP)：设备睡眠，配置时给0不睡眠</p>
<p>Bit5(CYCLE)：循环模式，配置给0不循环</p>
<p>Bit4(无关位)：配置给0即可</p>
<p>Bit3(温度传感器失能)：配置给0，不失能</p>
<p>Bit2~0(选择时钟)：000选择内部时钟，手册非常建议选择陀螺仪时钟，我们配置为001，选择X轴陀螺仪时钟</p>
<p><strong>对应配置为：0x01</strong></p>
<hr>
<p><code>PWR_MGMT_2：电源管理寄存器2:</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241218223451238-1752337644187-577.png" alt="image-20241218223451238"></p>
<p>Bit7~6：循环模式唤醒频率，给00，不需要</p>
<p>Bit5~0：后六位为每个轴的待机位，不需要待机，全部给0即可</p>
<p><strong>对应配置为：0x00</strong></p>
<hr>
<p><code>WHO_AM_I：器件ID号:</code>只读的，中间六位固定为110100</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241208000027373-1752337644187-578.png" alt="image-20241208000027373"></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241208000214450-1752337644187-579.png" alt="image-20241208000214450"></p>
<blockquote>
<p>注意这里写的是：所有寄存器上电后默认都是0x00，除了107号寄存器和117号寄存器</p>
<p><strong>107号</strong>：<strong>电源管理寄存器1</strong>，默认为0x40(01000000)，可以看到SLEEP位为1，及<strong>上电默认睡眠模式，使用时记得解除睡眠模式，否则操作其他寄存器是无效的</strong></p>
</blockquote>
<blockquote>
<p><strong>117号</strong>：器件ID寄存器配置初始化值为0x68</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241208000407336-1752337644187-580.png" alt="image-20241208000407336"></p>
</blockquote>
<h3 id="软件模拟I2C读写"><a href="#软件模拟I2C读写" class="headerlink" title="软件模拟I2C读写"></a>软件模拟I2C读写</h3><blockquote>
<p><strong>使用任意GPIO口模拟即可，步骤为：</strong></p>
<ol>
<li><strong>开启对应RCC时钟</strong></li>
<li><strong>配置GPIO口为开漏输出</strong></li>
<li><strong>配置SCL和SDA引脚默认高电平</strong></li>
</ol>
<p>这里都配置为开漏输出并不意味着只能<code>输出数据</code>，也可以<code>输入数据</code>，具有输入数据的功能，详细解释见另一个笔记<code>软件模拟I2C引脚问题</code></p>
</blockquote>
<h4 id="软件I2C代码实现"><a href="#软件I2C代码实现" class="headerlink" title="软件I2C代码实现"></a>软件I2C代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MyI2C.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYI2C_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYI2C_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元1：起始条件SCL高电平期间，SDA从高电平切换到低电平*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Start</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元1：结束条件SCL高电平期间，SDA从低电平切换到高电平*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Stop</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元2：发送一个字节，1位1位的发送，从最高位开始*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元2：接收一个字节，SCL低从机设置，SCL高主机读取*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_ReceiveByte</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元3：发送应答，逻辑和发送字节类似*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_SendAck</span><span class="params">(<span class="type">uint8_t</span> AckBit)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元3：接收应答，逻辑和接收字节类似*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_ReceiveAck</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>





<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MyI2C.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_W_SCL</span><span class="params">(<span class="type">uint8_t</span> BitVal)</span></span><br><span class="line">&#123;</span><br><span class="line">	 GPIO_WriteBit(GPIOA,GPIO_Pin_2,(BitAction)BitVal);</span><br><span class="line">	 Delay_ms(<span class="number">10</span>);<span class="comment">//延时用于控制每个时序步骤之间的时间，确保I2C时序的稳定性。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_W_SDA</span><span class="params">(<span class="type">uint8_t</span> BitVal)</span></span><br><span class="line">&#123;</span><br><span class="line">	 GPIO_WriteBit(GPIOA,GPIO_Pin_3,(BitAction)BitVal);</span><br><span class="line">	 Delay_ms(<span class="number">10</span>);<span class="comment">//延时用于控制每个时序步骤之间的时间，确保I2C时序的稳定性。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_R_SCL</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	 <span class="type">uint8_t</span> bitValue;</span><br><span class="line">   bitValue = GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_2);</span><br><span class="line">	 Delay_ms(<span class="number">10</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> bitValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_R_SDA</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	 <span class="type">uint8_t</span> bitValue;</span><br><span class="line">   bitValue = GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_3);</span><br><span class="line">	 Delay_ms(<span class="number">10</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> bitValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*通过前面几个函数的封装我们实现了函数名称、端口号的替换，需要替换端口或者移植时就只需要对前四个函数修改即可,这样编程很方便*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">		</span><br><span class="line">		GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_OD;</span><br><span class="line">	  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3;</span><br><span class="line">	  GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	  GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line">	</span><br><span class="line">	  GPIO_SetBits(GPIOA,GPIO_Pin_2 | GPIO_Pin_3);</span><br><span class="line">	 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元1：起始条件SCL高电平期间，SDA从高电平切换到低电平*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	 MyI2C_W_SDA(<span class="number">1</span>);<span class="comment">//保险起见，应该先拉高SDA，能够兼容重复起始条件Sr，避免SCL如果先被拉高电平，此时SDA为低，被拉高，就被误判为停止信号</span></span><br><span class="line">	 MyI2C_W_SCL(<span class="number">1</span>);</span><br><span class="line">	 </span><br><span class="line">	 MyI2C_W_SDA(<span class="number">0</span>);<span class="comment">//SDA产生下降沿</span></span><br><span class="line">	 MyI2C_W_SCL(<span class="number">0</span>);</span><br><span class="line">	 </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*基本单元1：结束条件SCL高电平期间，SDA从低电平切换到高电平*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Stop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">         <span class="comment">//MyI2C_W_SCL(0);// 这里可以省略，但是保险起见应该加上，一般在数据传输结束后，SCL都是低电平（因为最后一个bit或ACK/NACK后主控会拉低SCL)</span></span><br><span class="line">	 MyI2C_W_SDA(<span class="number">0</span>);<span class="comment">//SDA高低电平不确定，为了确保释放SDA时能产生上升沿，要先拉低SDA</span></span><br><span class="line">	</span><br><span class="line">	 MyI2C_W_SCL(<span class="number">1</span>);<span class="comment">//SCL先拉高</span></span><br><span class="line">	 MyI2C_W_SDA(<span class="number">1</span>);<span class="comment">//SDA产生上升沿</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元2：发送一个字节，1位1位的发送，从最高位开始*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">&#123; </span><br><span class="line">	</span><br><span class="line"><span class="comment">//	 /*发送最高位*/</span></span><br><span class="line"><span class="comment">//   进来时SCL为低电平</span></span><br><span class="line"><span class="comment">//	 MyI2C_W_SDA(Byte &amp; 0x80);//因为保证了SCL是低电平，所以此时直接放入数据即可</span></span><br><span class="line"><span class="comment">//	 MyI2C_W_SCL(1);//SCL先拉高后从机会立刻读取刚刚放入的数据</span></span><br><span class="line"><span class="comment">//	 MyI2C_W_SCL(0);//SCL拉低完成一个脉冲</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//	 /*发送次高位*/</span></span><br><span class="line"><span class="comment">//	 MyI2C_W_SDA(Byte &amp; 0x40);</span></span><br><span class="line"><span class="comment">//	 MyI2C_W_SCL(1);</span></span><br><span class="line"><span class="comment">//	 MyI2C_W_SCL(0);</span></span><br><span class="line"><span class="comment">//	 </span></span><br><span class="line"><span class="comment">//	 .......</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*这里使用循环直接实现8个字节的发送，SCL低主机设置，SCL高从机读取*/</span></span><br><span class="line">		 <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">		  MyI2C_W_SDA(Byte &amp; (<span class="number">0x80</span> &gt;&gt; i));</span><br><span class="line">			MyI2C_W_SCL(<span class="number">1</span>);</span><br><span class="line">			MyI2C_W_SCL(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元2：接收一个字节，SCL低从机设置，SCL高主机读取*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_ReceiveByte</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">		<span class="type">uint8_t</span> Byte = <span class="number">0x00</span>;</span><br><span class="line">	  </span><br><span class="line">		MyI2C_W_SDA(<span class="number">1</span>);<span class="comment">//主机在接受数据前需要将SDA释放让从机获取SDA控制权，使从机能够将数据放入SDA</span></span><br><span class="line">	  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			MyI2C_W_SCL(<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(MyI2C_R_SDA()==<span class="number">1</span>) <span class="comment">//从机发送的数据</span></span><br><span class="line">			&#123;</span><br><span class="line">				Byte |= (<span class="number">0x80</span> &gt;&gt; i); <span class="comment">// 设置第i位为1,否则为0</span></span><br><span class="line">			&#125;</span><br><span class="line">			MyI2C_W_SCL(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">return</span> Byte;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元3：发送应答，逻辑和发送字节类似*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_SendAck</span><span class="params">(<span class="type">uint8_t</span> AckBit)</span></span><br><span class="line">&#123; </span><br><span class="line">			<span class="comment">//进来时SCL为低电平</span></span><br><span class="line">			MyI2C_W_SDA(AckBit);<span class="comment">//主机发送ACK</span></span><br><span class="line">			MyI2C_W_SCL(<span class="number">1</span>);<span class="comment">//SCL为高，从机接收ACK</span></span><br><span class="line">			MyI2C_W_SCL(<span class="number">0</span>);<span class="comment">//结束一个脉冲</span></span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元3：接收应答，逻辑和接收字节类似*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_ReceiveAck</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">			<span class="type">uint8_t</span> AckBit = <span class="number">0x00</span>;</span><br><span class="line">	  </span><br><span class="line">	    <span class="comment">//进来时SCL为低电平</span></span><br><span class="line">			MyI2C_W_SDA(<span class="number">1</span>);<span class="comment">//释放SDA使从机能操控SDA线(使其具有能拉高或拉低SDA的能力)，在SCL置高电平之前，从机将ACK放到SDA线上</span></span><br><span class="line"></span><br><span class="line">			MyI2C_W_SCL(<span class="number">1</span>);</span><br><span class="line">			AckBit = MyI2C_R_SDA();<span class="comment">//读取ACK</span></span><br><span class="line">			MyI2C_W_SCL(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">			<span class="keyword">return</span> AckBit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyI2C.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	  UsartInit();</span><br><span class="line">	  MyI2C_Init();</span><br><span class="line">    </span><br><span class="line">	  MyI2C_Start();</span><br><span class="line">	  MyI2C_SendByte(<span class="number">0xD0</span>); <span class="comment">// 1101000 0 MPU6050地址+写位</span></span><br><span class="line">   <span class="comment">//  MyI2C_SendByte(0xB0); // 1101000 0 MPU6050地址+写位</span></span><br><span class="line">	  <span class="type">uint8_t</span> ack = MyI2C_ReceiveAck();</span><br><span class="line">	  MyI2C_Stop();</span><br><span class="line">	</span><br><span class="line">	 </span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;	</span><br><span class="line">			UsartSend(ack);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>测试是否能收到ACK，改变对应从机地址后是否应答</p>
</blockquote>
<h4 id="MPU6050-测试读写"><a href="#MPU6050-测试读写" class="headerlink" title="MPU6050-测试读写"></a>MPU6050-测试读写</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MPU6050.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MPU6050_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MPU6050_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址写对应时序*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress,<span class="type">uint8_t</span> Data)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址读对应时序，指定写+当前读*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_ReadReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MPU6050.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyI2C.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_ADDRESS 0xD0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">		MyI2C_Init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址写对应时序*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress,<span class="type">uint8_t</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">	  <span class="comment">/*1.起始，对应从机地址MPU6050，应答*/</span></span><br><span class="line">		MyI2C_Start();</span><br><span class="line">	  MyI2C_SendByte(MPU6050_ADDRESS);</span><br><span class="line">		MyI2C_ReceiveAck();<span class="comment">//可以对应答位判断是否收到从机数据进行处理，这里默认应答</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	  <span class="comment">/*2.发送要写入的寄存器地址，应答*/</span></span><br><span class="line">	  MyI2C_SendByte(RegAddress);</span><br><span class="line">		MyI2C_ReceiveAck();</span><br><span class="line">	</span><br><span class="line">	  <span class="comment">/*3.发送写入数据*/</span></span><br><span class="line">		MyI2C_SendByte(Data);</span><br><span class="line">		MyI2C_ReceiveAck(); <span class="comment">//这里只发送一个字节</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//	  for(int i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">//		&#123;</span></span><br><span class="line"><span class="comment">//			MyI2C_SendByte(Data);</span></span><br><span class="line"><span class="comment">//		  MyI2C_ReceiveAck();</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">	    <span class="comment">/*当要写入多个字节时，使用循环依次将数组的各个字节发送出去*/</span></span><br><span class="line">	  </span><br><span class="line">		<span class="comment">/*4.结束*/</span></span><br><span class="line">	  MyI2C_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址读对应时序，指定写+当前读*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_ReadReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress)</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="type">uint8_t</span> Data;</span><br><span class="line">	</span><br><span class="line">		MyI2C_Start();</span><br><span class="line">	  MyI2C_SendByte(MPU6050_ADDRESS);</span><br><span class="line">		MyI2C_ReceiveAck();</span><br><span class="line">		</span><br><span class="line">	  MyI2C_SendByte(RegAddress);</span><br><span class="line">		MyI2C_ReceiveAck();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*前一半为写的时序*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*后一半为读的时序*/</span></span><br><span class="line">	  MyI2C_Start();<span class="comment">//Sr</span></span><br><span class="line">	  MyI2C_SendByte(MPU6050_ADDRESS|<span class="number">0x01</span>);<span class="comment">//最后一位改成读</span></span><br><span class="line">		MyI2C_ReceiveAck();</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*接收从机数据*/</span></span><br><span class="line">	  Data = MyI2C_ReceiveByte();</span><br><span class="line">		MyI2C_SendAck(<span class="number">1</span>);<span class="comment">//想继续读数据给应答，这里只读一位，直接不应答了</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//	  for(int i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">//		&#123;</span></span><br><span class="line"><span class="comment">//		    Datas[i] = MyI2C_ReceiveByte();</span></span><br><span class="line"><span class="comment">//        if(i==7)</span></span><br><span class="line"><span class="comment">//				&#123;</span></span><br><span class="line"><span class="comment">//					MyI2C_SendAck(1);//最后一位读取后不应答</span></span><br><span class="line"><span class="comment">//					break;</span></span><br><span class="line"><span class="comment">//				&#125;</span></span><br><span class="line"><span class="comment">//				MyI2C_SendAck(0);//读取多个数据给应答</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		多个数据读取</span></span><br><span class="line">    </span><br><span class="line">	  MyI2C_Stop();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> Data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="读功能"><a href="#读功能" class="headerlink" title="读功能"></a>读功能</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MPU6050.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> Id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	 UsartInit();</span><br><span class="line">	 MPU6050_Init();</span><br><span class="line">    </span><br><span class="line">	  <span class="comment">/*读取寄存器*/</span></span><br><span class="line">    Id = MPU6050_ReadReg(<span class="number">0x75</span>);<span class="comment">//WHO_AM_I，ID寄存器</span></span><br><span class="line">	 </span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;	</span><br><span class="line">			UsartSend(Id);</span><br><span class="line">			Delay_ms(<span class="number">2000</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241218220447684-1752337644187-581.png" alt="image-20241218220447684"></p>
<blockquote>
<p>读读取0x75后，得到的结果是0x68，与手册对应代表一字节时序正确</p>
</blockquote>
<h5 id="写功能"><a href="#写功能" class="headerlink" title="写功能"></a>写功能</h5><p><code>在使用写功能是必须先接触睡眠模式，否则操控其他寄存器无效</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241218220917107-1752337644187-583.png" alt="image-20241218220917107"></p>
<blockquote>
<p>睡眠模式由该电源资源管理寄存器的SLEEP位控制，对应寄存器地址为0x6B，初始值为0x40(0100000)，SLEEP位为1</p>
<p><strong>只需要对该寄存器写入0x00即可</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MPU6050.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">	  <span class="type">uint8_t</span> Data = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">		LED_Init();</span><br><span class="line"></span><br><span class="line">	  UsartInit();</span><br><span class="line">	  MPU6050_Init();</span><br><span class="line">	  </span><br><span class="line">	  MPU6050_WriteReg(<span class="number">0x6B</span>,<span class="number">0x00</span>);<span class="comment">//电源资源管理寄存器，必选先接触睡眠模式</span></span><br><span class="line">	  </span><br><span class="line">	  MPU6050_WriteReg(<span class="number">0x19</span>,<span class="number">0xAA</span>);<span class="comment">//采样分频寄存器</span></span><br><span class="line">    </span><br><span class="line">	  Data = MPU6050_ReadReg(<span class="number">0x19</span>);</span><br><span class="line">	   </span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;	</span><br><span class="line">			UsartSend(Data);</span><br><span class="line">			Delay_ms(<span class="number">2000</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>测试发现对应寄存器值修改成功，串口显示AA</p>
</blockquote>
<h4 id="MPU6050-读取加速度-角速度"><a href="#MPU6050-读取加速度-角速度" class="headerlink" title="MPU6050-读取加速度&#x2F;角速度"></a>MPU6050-读取加速度&#x2F;角速度</h4><blockquote>
<p>当需要使用的寄存器宏定义比较多时，建议单独创建头文件管理。</p>
<p>该头文件为MPU6050部分寄存器，从MPU6050寄存器手册搬过来即可</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MPU6050_REG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MPU6050_REG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_SMPLRT_DIV		0x19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_CONFIG			0x1A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_GYRO_CONFIG		0x1B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_ACCEL_CONFIG	0x1C</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_ACCEL_XOUT_H	0x3B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_ACCEL_XOUT_L	0x3C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_ACCEL_YOUT_H	0x3D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_ACCEL_YOUT_L	0x3E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_ACCEL_ZOUT_H	0x3F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_ACCEL_ZOUT_L	0x40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_TEMP_OUT_H		0x41</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_TEMP_OUT_L		0x42</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_GYRO_XOUT_H		0x43</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_GYRO_XOUT_L		0x44</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_GYRO_YOUT_H		0x45</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_GYRO_YOUT_L		0x46</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_GYRO_ZOUT_H		0x47</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_GYRO_ZOUT_L		0x48</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_PWR_MGMT_1		0x6B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_PWR_MGMT_2		0x6C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_WHO_AM_I		0x75</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MPU6050.h*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MPU6050_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MPU6050_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">/*指定地址写对应时序*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress,<span class="type">uint8_t</span> Data)</span>;</span><br><span class="line"><span class="comment">/*指定地址读对应时序，指定写+当前读*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_ReadReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_GetData</span><span class="params">(<span class="type">int16_t</span> *AccX,<span class="type">int16_t</span> *AccY,<span class="type">int16_t</span> *AccZ, <span class="type">int16_t</span> *GyroX,<span class="type">int16_t</span> *GyroY,<span class="type">int16_t</span> *GyroZ)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_GetID</span><span class="params">()</span></span><br><span class="line"><span class="comment">/*读取对应MPU6050ID*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MPU6050.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyI2C.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MPU6050_Reg.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_ADDRESS 0xD0 <span class="comment">//1101000 0</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址写对应时序*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress,<span class="type">uint8_t</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">	  <span class="comment">/*1.起始，对应从机地址MPU6050，应答*/</span></span><br><span class="line">		MyI2C_Start();</span><br><span class="line">	  MyI2C_SendByte(MPU6050_ADDRESS);</span><br><span class="line">		MyI2C_ReceiveAck();<span class="comment">//可以对应答位判断是否收到从机数据进行处理，这里默认应答</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	  <span class="comment">/*2.发送要写入的寄存器地址，应答*/</span></span><br><span class="line">	  MyI2C_SendByte(RegAddress);</span><br><span class="line">		MyI2C_ReceiveAck();</span><br><span class="line">	</span><br><span class="line">	  <span class="comment">/*3.发送写入数据*/</span></span><br><span class="line">		MyI2C_SendByte(Data);</span><br><span class="line">		MyI2C_ReceiveAck(); <span class="comment">//这里只发送一个字节</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//	  for(int i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">//		&#123;</span></span><br><span class="line"><span class="comment">//			MyI2C_SendByte(Data);</span></span><br><span class="line"><span class="comment">//		  MyI2C_ReceiveAck();</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">	    <span class="comment">/*当要写入多个字节时，使用循环依次将数组的各个字节发送出去*/</span></span><br><span class="line">	  </span><br><span class="line">		<span class="comment">/*4.结束*/</span></span><br><span class="line">	  MyI2C_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址读对应时序，指定写+当前读*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_ReadReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress)</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="type">uint8_t</span> Data;</span><br><span class="line">	</span><br><span class="line">		MyI2C_Start();</span><br><span class="line">	  MyI2C_SendByte(MPU6050_ADDRESS);</span><br><span class="line">		MyI2C_ReceiveAck();</span><br><span class="line">		</span><br><span class="line">	  MyI2C_SendByte(RegAddress);</span><br><span class="line">		MyI2C_ReceiveAck();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*前一半为写的时序*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*后一半为读的时序*/</span></span><br><span class="line">	  MyI2C_Start();<span class="comment">//Sr</span></span><br><span class="line">	  MyI2C_SendByte(MPU6050_ADDRESS|<span class="number">0x01</span>);<span class="comment">//最后一位改成读</span></span><br><span class="line">		MyI2C_ReceiveAck();</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*接收从机数据*/</span></span><br><span class="line">	  Data = MyI2C_ReceiveByte();</span><br><span class="line">		MyI2C_SendAck(<span class="number">1</span>);<span class="comment">//想继续读数据给应答，这里只读一位，直接不应答了</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//	  for(int i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">//		&#123;</span></span><br><span class="line"><span class="comment">//		    Datas[i] = MyI2C_ReceiveByte();</span></span><br><span class="line"><span class="comment">//        if(i==7)</span></span><br><span class="line"><span class="comment">//				&#123;</span></span><br><span class="line"><span class="comment">//					MyI2C_SendAck(1);//最后一位读取后不应答</span></span><br><span class="line"><span class="comment">//					break;</span></span><br><span class="line"><span class="comment">//				&#125;</span></span><br><span class="line"><span class="comment">//				MyI2C_SendAck(0);//读取多个数据给应答</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		多个数据读取</span></span><br><span class="line">    </span><br><span class="line">	  MyI2C_Stop();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> Data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*主要修改如下*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">		MyI2C_Init();</span><br><span class="line">	  MPU6050_WriteReg(MPU6050_PWR_MGMT_1,<span class="number">0x01</span>);<span class="comment">//配置电源管理寄存器1,解除睡眠选择陀螺仪时钟</span></span><br><span class="line">	  MPU6050_WriteReg(MPU6050_PWR_MGMT_2,<span class="number">0x00</span>);<span class="comment">//配置电源管理寄存器2,6个轴均不待机</span></span><br><span class="line">	</span><br><span class="line">	  MPU6050_WriteReg(MPU6050_SMPLRT_DIV,<span class="number">0x09</span>);<span class="comment">//配置采样分频寄存器，选择10分频，滤波参数给最大</span></span><br><span class="line">		MPU6050_WriteReg(MPU6050_CONFIG	,<span class="number">0x06</span>);<span class="comment">//配置寄存器，滤波参数110</span></span><br><span class="line">	  MPU6050_WriteReg(MPU6050_GYRO_CONFIG	,<span class="number">0x18</span>);<span class="comment">//陀螺仪最大量程</span></span><br><span class="line">	  MPU6050_WriteReg(MPU6050_ACCEL_CONFIG,<span class="number">0x18</span>);<span class="comment">//加速度计最大量程</span></span><br><span class="line">	<span class="comment">/*这里配置完后，陀螺仪内部就在不停的转换了，对应数据存放在对应各轴数据寄存器中*/</span></span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*对应6轴的数据都是16位，分为高8位和低8位，分别读取高8位和低8位拼接后*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_GetData</span><span class="params">(<span class="type">int16_t</span> *AccX,<span class="type">int16_t</span> *AccY,<span class="type">int16_t</span> *AccZ,<span class="type">int16_t</span> *GyroX,<span class="type">int16_t</span> *GyroY,<span class="type">int16_t</span> *GyroZ)</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="type">uint16_t</span> DataH,DataL;</span><br><span class="line">	</span><br><span class="line">		DataH = MPU6050_ReadReg(MPU6050_ACCEL_XOUT_H);</span><br><span class="line">	  DataL =  MPU6050_ReadReg(MPU6050_ACCEL_XOUT_L);</span><br><span class="line">	  </span><br><span class="line">		*AccX =  (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line">	</span><br><span class="line">	  DataH = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_H);</span><br><span class="line">	  DataL =  MPU6050_ReadReg(MPU6050_ACCEL_YOUT_L);</span><br><span class="line">	</span><br><span class="line">	  *AccY =   (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line">	  </span><br><span class="line">	  DataH = MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_H);</span><br><span class="line">	  DataL =  MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_L);</span><br><span class="line">	</span><br><span class="line">	  *AccZ =    (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line">	</span><br><span class="line">	  DataH = MPU6050_ReadReg(MPU6050_GYRO_XOUT_H);</span><br><span class="line">	  DataL =  MPU6050_ReadReg(MPU6050_GYRO_XOUT_L);</span><br><span class="line">	</span><br><span class="line">	  *GyroX = 	(DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line">	</span><br><span class="line">	  </span><br><span class="line">		DataH = MPU6050_ReadReg(MPU6050_GYRO_YOUT_H);</span><br><span class="line">	  DataL =  MPU6050_ReadReg(MPU6050_GYRO_YOUT_L);</span><br><span class="line">		</span><br><span class="line">	  *GyroY =  (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line">	</span><br><span class="line">		DataH = MPU6050_ReadReg(MPU6050_GYRO_ZOUT_H);</span><br><span class="line">	  DataL =  MPU6050_ReadReg(MPU6050_GYRO_ZOUT_L);</span><br><span class="line">		</span><br><span class="line">	  *GyroZ =   (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*这里的读取分为12次，我们可以改进，使用连续读取的时序，大大提升效率*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_GetID</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	 <span class="keyword">return</span> MPU6050_ReadReg(MPU6050_WHO_AM_I);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MPU6050.h&quot;</span></span></span><br><span class="line"><span class="type">int16_t</span> AX=<span class="number">0</span>,AY=<span class="number">0</span>,AZ=<span class="number">0</span>,GX=<span class="number">0</span>,GY=<span class="number">0</span>,GZ=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">	  <span class="type">uint8_t</span> Data = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	  LED_Init();</span><br><span class="line">   </span><br><span class="line">	  UsartInit();</span><br><span class="line">	</span><br><span class="line">	  MPU6050_Init();</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;	</span><br><span class="line">			MPU6050_GetData(&amp;AX,&amp;AY,&amp;AZ,&amp;GX,&amp;GY,&amp;GZ);</span><br><span class="line">			UsartSend(AX);</span><br><span class="line">			UsartSend(AY);</span><br><span class="line">			UsartSend(AZ);</span><br><span class="line">			UsartSend(GX);</span><br><span class="line">			UsartSend(GY);</span><br><span class="line">			UsartSend(GZ);</span><br><span class="line">			Delay_ms(<span class="number">1000</span>);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>对应数据：</code></p>
<p>X轴加速度：水平基本没加速度</p>
<p>Y轴加速度：水平基本没加速度</p>
<p>Z轴加速度：平放在水面通过得到AZ，我们选择的是满量程16g(看手册上)</p>
<p>对应加速度计算公式为 AZ &#x2F; 32768 &#x3D;  x &#x2F; 16g ，解方程的得到的x为Z轴方向加速度，这个值理论上来说应该是重力加速度g</p>
<hr>
<p>X轴角速度：</p>
<p>Y轴角速度：</p>
<p>Z轴角速度：</p>
<hr>
<p><strong>上方所有数据计算的公式为：</strong></p>
<p><strong>（读取的数据）&#x2F;（32768） &#x3D; （x）  &#x2F;（ 满量程）</strong></p>
<p><strong>解出对应x的值即可</strong></p>
</blockquote>
<h3 id="I2C外设-硬件读写I2C"><a href="#I2C外设-硬件读写I2C" class="headerlink" title="I2C外设(硬件读写I2C)"></a>I2C外设(硬件读写I2C)</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241220151445355-1752337644187-586.png" alt="image-20241220151445355"></p>
<blockquote>
<p>由硬件电路自动实现引脚电平反转，软件只需要写入<strong>控制寄存器CR</strong>和<strong>数据寄存器DR</strong>即可。</p>
<p>为了监控时序状态，软件还得读取<strong>状态寄存器SR</strong>来了解当前的外设电路处于什么状态</p>
<p><strong>这就像开车一样：写入控制寄存器CR，就像是踩油门、打方向盘来控制汽车的运行，读取状态寄存器SR，就像是观看仪表盘，来了解汽车的运行状态。</strong></p>
<p>使用库函数封装后，有了I2C外设，硬件就可以自动实现时序，就可以减轻CPU的负担，节省软件资源</p>
<hr>
<p><strong>一主多从</strong>：一个主机多个从设备………</p>
<p><strong>多主机模式</strong>：分为固定多主机和可变多主机</p>
<ul>
<li>固定多主机：固定有几个主机，多个主机控制产生冲突时需要仲裁</li>
<li>可变多主机：总线上无固定主机和从机，任何设备可以在总线空闲时主动跳出作为主机与其他从机通信，通信完成后回归从机</li>
</ul>
<p><code>对于STM32使用的是可变多主机模型</code></p>
<hr>
<p><strong>地址模式</strong>：7&#x2F;10位</p>
<p>7位：一个字节中的前7位为设备地址，最后一位是读写位。</p>
<p>10位：使用两个字节，如果第二个字节也是寻址的话，第一个字节的前5位必须是11110<code>(10位地址标志位)</code>，第一个字节剩下2位和第二个字节的8位一共10位作为寻址</p>
<p>7位与10位区别：前5位是否为11110</p>
<hr>
<p><strong>通讯速度</strong>：</p>
<ul>
<li><p>标准速度：100KHz</p>
</li>
<li><p>快速速度：400KHz</p>
</li>
</ul>
<hr>
<p><strong>DMA</strong>：…..</p>
<hr>
<p><strong>兼容SMBus：System Management Bus-系统管理总线</strong></p>
<p>类似于I2C，是兼容的另一种总线</p>
</blockquote>
<p><strong>对应寄存器，标志位查看芯片参考手册的I2C接口模块阅读即可!!!</strong></p>
<h4 id="I2C框图"><a href="#I2C框图" class="headerlink" title="I2C框图"></a>I2C框图</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241221144132847-1752337644187-582.png" alt="image-20241221144132847"></p>
<blockquote>
<p><strong>对应使用时一般是GPIO口复用，查询对应引脚定义表即可，使用<code>硬件I2C时只能使用指定的引脚</code>，不能像<code>软件I2C那样引脚任意指定</code></strong></p>
<hr>
<p>由于I2C是半双工，只有<code>一组移位寄存器和数据寄存器</code>，接收和发送都是使用这组，而串口有两组</p>
<hr>
<p><code>比较器和地址寄存器：</code>从机模式使用，支持同时响应两个从机地址，在多主机模式下使用</p>
<hr>
<p><code>帧错误校验PEC计算</code>：CRC校验算法，数据有效性验证，对应数据错误标志位置位</p>
<hr>
<p><code>中断</code>：某个紧急事件发生后可以申请中断</p>
<hr>
<p><code>DMA</code>：配合提高效率</p>
</blockquote>
<blockquote>
<p>SMBALERT是SMBus相关，I2C使用时不用管它</p>
</blockquote>
<h4 id="I2C基本结构"><a href="#I2C基本结构" class="headerlink" title="I2C基本结构"></a>I2C基本结构</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241221150048169-1752337644187-584.png" alt="image-20241221150048169"></p>
<blockquote>
<p>图中是简化的一主多从结构，如果是多主机应该还有时钟输入</p>
<p>图中的两个GPIO：一个是复用输入，另一个是复用输出</p>
<hr>
<p><strong>移位寄存器和数据寄存器DR</strong>：</p>
<p><code>发送时数据先写入数据寄存器DR，如果移位寄存器没有数据，就会转到移位寄存器进行发送</code></p>
</blockquote>
<h4 id="主机发送流程"><a href="#主机发送流程" class="headerlink" title="主机发送流程"></a>主机发送流程</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241221162408618-1752337644187-585.png" alt="image-20241221162408618"></p>
<blockquote>
<p><code>EV事件</code> 是多个标志位的集合，所有标志位在手册中都可以找到</p>
<p>EV5,EV6,EV8….</p>
<p>流程简化下来就是：操作-等待-操作-等待……</p>
</blockquote>
<h4 id="主机接收流程"><a href="#主机接收流程" class="headerlink" title="主机接收流程"></a>主机接收流程</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241221162433975-1752337644187-587.png" alt="image-20241221162433975"></p>
<blockquote>
<p>图中给的时序是当前地址读的，想要指定地址读数据需要组合一下即可</p>
<p>具体的流程见下面的代码</p>
</blockquote>
<h4 id="从机发送接收"><a href="#从机发送接收" class="headerlink" title="从机发送接收"></a>从机发送接收</h4><p>见手册！！！</p>
<h4 id="库函数-8"><a href="#库函数-8" class="headerlink" title="库函数"></a>库函数</h4><p><code>初始化函数：</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C_DeInit</span><span class="params">(I2C_TypeDef* I2Cx)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Init</span><span class="params">(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_StructInit</span><span class="params">(I2C_InitTypeDef* I2C_InitStruct)</span>;</span><br></pre></td></tr></table></figure>

<p><code>起始条件和终止条件：</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C_GenerateSTART</span><span class="params">(I2C_TypeDef* I2Cx, FunctionalState NewState)</span>;<span class="comment">//调用该函数生成起始条件，对I2C_CR1寄存器中的START位置1</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_GenerateSTOP</span><span class="params">(I2C_TypeDef* I2Cx, FunctionalState NewState)</span>;<span class="comment">//调用该函数生成终止条件，对I2C_CR1寄存器中的STOP位置1</span></span><br></pre></td></tr></table></figure>

<p><code>应答ACK：</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C_AcknowledgeConfig</span><span class="params">(I2C_TypeDef* I2Cx, FunctionalState NewState)</span>;<span class="comment">//手动ACK配置，在收到一个字节后，是否给从机应答</span></span><br></pre></td></tr></table></figure>



<p><code>发送和接收数据：</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C_SendData</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint8_t</span> Data)</span>;<span class="comment">//写入数据到数据寄存器DR</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">I2C_ReceiveData</span><span class="params">(I2C_TypeDef* I2Cx)</span>;<span class="comment">//读取数据寄存器DR作为返回值，接收到下一个字节之前读出数据寄存器，防止数据覆盖，实现连续数据流</span></span><br></pre></td></tr></table></figure>



<p><code>发送地址专用函数:</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C_Send7bitAddress</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint8_t</span> Address, <span class="type">uint8_t</span> I2C_Direction)</span>;<span class="comment">//主要用于设置自动设置读写位</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个函数可以不使用，而是自己确定读写位的最后一位，直接使用SendData函数进行发送</p>
</blockquote>
<p><code>中断配置：</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C_ITConfig</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint16_t</span> I2C_IT, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure>



<p><code>DMA相关：</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C_DMACmd</span><span class="params">(I2C_TypeDef* I2Cx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_DMALastTransferCmd</span><span class="params">(I2C_TypeDef* I2Cx, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure>



<p><code>使能函数：</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C_Cmd</span><span class="params">(I2C_TypeDef* I2Cx, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure>



<p><code>标志位：</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FlagStatus <span class="title function_">I2C_GetFlagStatus</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_FLAG)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_ClearFlag</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_FLAG)</span>;</span><br><span class="line"><span class="comment">/*中断外使用*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ITStatus <span class="title function_">I2C_GetITStatus</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_IT)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_ClearITPendingBit</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_IT)</span>;</span><br><span class="line"><span class="comment">/*中断中使用*/</span></span><br></pre></td></tr></table></figure>





<p><code>状态监控：给了三种方法</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*第一种：基本状态监控，同时判断一个或多个标志位，来确定EV几EV几这个状态是否发生,对应发送接收流程*/</span></span><br><span class="line">ErrorStatus <span class="title function_">I2C_CheckEvent</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_EVENT)</span>;<span class="comment">//推荐使用！！！,第二个参数为监测的事件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*第二种：高级状态监控，实际上并不高级，对应库函数注释可以找到是将SR1和SR2这两个状态寄存器拼接成16位数据然后给你就完了*/</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">I2C_GetLastEvent</span><span class="params">(I2C_TypeDef* I2Cx)</span>;。<span class="comment">//一般不使用，了解即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*第三种：基于标志位的状态监控，我们一直使用的判断某个标志位方法*/</span></span><br><span class="line">FlagStatus <span class="title function_">I2C_GetFlagStatus</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_FLAG)</span>;</span><br></pre></td></tr></table></figure>



<h4 id="I2C外设配置"><a href="#I2C外设配置" class="headerlink" title="I2C外设配置"></a>I2C外设配置</h4><p><code>参考上方I2C框图和基本结构进行配置：</code></p>
<ol>
<li><strong>开启I2C外设和对应GPIO口的时钟</strong></li>
<li><strong>结构体配置对应GPIO口为复用开漏输出模式(区别：软件模拟I2C是直接开漏没有复用开漏)</strong></li>
<li><strong>结构体配置I2C</strong></li>
<li><strong>使能I2C，I2C_Cmd</strong></li>
</ol>
<h4 id="实验-硬件I2C读取MPU6050数据"><a href="#实验-硬件I2C读取MPU6050数据" class="headerlink" title="实验-硬件I2C读取MPU6050数据"></a>实验-硬件I2C读取MPU6050数据</h4><blockquote>
<p>部分与软件I2C相同，去掉了软件I2C最底层的部分，使用库函数代替</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MPU6050.h*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MPU6050_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MPU6050_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址写对应时序*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress,<span class="type">uint8_t</span> Data)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址读对应时序，指定写+当前读*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_ReadReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_GetData</span><span class="params">(<span class="type">int16_t</span> *AccX,<span class="type">int16_t</span> *AccY,<span class="type">int16_t</span> *AccZ,<span class="type">int16_t</span> *GyroX,<span class="type">int16_t</span> *GyroY,<span class="type">int16_t</span> *GyroZ)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &quot;MyI2C.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MPU6050_Reg.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_ADDRESS 0xD0 <span class="comment">//1101000 0</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WaitEvent</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_EVENT)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 程序中出现大量while等待的情况比较危险，容易发生卡死的现象，所以我们需要让它超时退出。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	不必使用定时器，我们只需要简单用一个计数值循环判断即可，该Timeout值根据实际情况更改大小，while循环正常不会执行到Timeout</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WaitEvent</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_EVENT)</span></span><br><span class="line">&#123;</span><br><span class="line">	 <span class="type">uint32_t</span> Timeout;</span><br><span class="line">	 Timeout = <span class="number">10000</span>;</span><br><span class="line">	 <span class="keyword">while</span>(I2C_CheckEvent(I2Cx,I2C_EVENT)!=SUCCESS)</span><br><span class="line">	 &#123;</span><br><span class="line">		 Timeout --;</span><br><span class="line">		 <span class="keyword">if</span>(Timeout ==<span class="number">0</span>)</span><br><span class="line">		 &#123;</span><br><span class="line">			 <span class="keyword">break</span>;</span><br><span class="line">		 &#125;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该函数为CheckEvent的封装</span></span><br><span class="line"><span class="comment"> * 下方没有替换，该函数使用时只需要将使用while循环的部分直接使用该函数全部替换即可</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址写对应时序*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress,<span class="type">uint8_t</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*软件I2C代码：*/</span></span><br><span class="line"><span class="comment">//	  /*1.起始，对应从机地址MPU6050，应答*/</span></span><br><span class="line"><span class="comment">//		MyI2C_Start();</span></span><br><span class="line"><span class="comment">//	  MyI2C_SendByte(MPU6050_ADDRESS);</span></span><br><span class="line"><span class="comment">//		MyI2C_ReceiveAck();//可以对应答位判断是否收到从机数据进行处理，这里默认应答</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//	  /*2.发送要写入的寄存器地址，应答*/</span></span><br><span class="line"><span class="comment">//	  MyI2C_SendByte(RegAddress);</span></span><br><span class="line"><span class="comment">//		MyI2C_ReceiveAck();</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//	  /*3.发送写入数据*/</span></span><br><span class="line"><span class="comment">//		MyI2C_SendByte(Data);</span></span><br><span class="line"><span class="comment">//		MyI2C_ReceiveAck(); //这里只发送一个字节</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">////	  for(int i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">////		&#123;</span></span><br><span class="line"><span class="comment">////			MyI2C_SendByte(Data);</span></span><br><span class="line"><span class="comment">////		  MyI2C_ReceiveAck();</span></span><br><span class="line"><span class="comment">////		&#125;</span></span><br><span class="line"><span class="comment">//	    /*当要写入多个字节时，使用循环依次将数组的各个字节发送出去*/</span></span><br><span class="line"><span class="comment">//	  </span></span><br><span class="line"><span class="comment">//		/*4.结束*/</span></span><br><span class="line"><span class="comment">//	  MyI2C_Stop();</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">	 <span class="comment">/*硬件I2C下使用的都是非阻塞的函数，需要等待标志位结束才能保证对应波形执行完成*/</span></span><br><span class="line">	 <span class="comment">/*对应等待的事件根据硬件I2C发送流程中来写*/</span></span><br><span class="line">	 </span><br><span class="line">	 I2C_GenerateSTART(I2C1,ENABLE);<span class="comment">//1.发送起始条件</span></span><br><span class="line">		<span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_MODE_SELECT)!=SUCCESS)</span><br><span class="line">		&#123;</span><br><span class="line">		&#125;<span class="comment">//等待EV5事件完成</span></span><br><span class="line">	 </span><br><span class="line">	 I2C_Send7bitAddress(I2C1,MPU6050_ADDRESS,I2C_Direction_Transmitter);<span class="comment">//2.发送从机地址，第三个参数自动置读写位,应答位会自动处理</span></span><br><span class="line">		<span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)!=SUCCESS)</span><br><span class="line">		&#123;</span><br><span class="line">		&#125;<span class="comment">//等待发送模式的EV6事件完成</span></span><br><span class="line">		 </span><br><span class="line">	 I2C_SendData(I2C1,RegAddress);<span class="comment">//3.发送指定寄存器地址</span></span><br><span class="line">		<span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_TRANSMITTING)!=SUCCESS)</span><br><span class="line">		&#123;</span><br><span class="line">		&#125;<span class="comment">//等待EV8事件</span></span><br><span class="line">		 </span><br><span class="line">	 <span class="comment">/*发送多个字节数据时，中间的数据发送完成后等待EV8事件，而最后一个字节变为等待EV8_2事件*/</span></span><br><span class="line">	 </span><br><span class="line">	 I2C_SendData(I2C1,Data);<span class="comment">//4.发送要写入的数据</span></span><br><span class="line">	 <span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_TRANSMITTED)!=SUCCESS)	</span><br><span class="line">		&#123;</span><br><span class="line">		&#125;<span class="comment">//发送最后一个字节完成后，等待EV8_2事件</span></span><br><span class="line">	 </span><br><span class="line">	 </span><br><span class="line">	 I2C_GenerateSTOP(I2C1,ENABLE);<span class="comment">//5.终止条件</span></span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址读对应时序，指定写+当前读*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_ReadReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress)</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="type">uint8_t</span> Data;</span><br><span class="line">	</span><br><span class="line">			<span class="comment">/*软件模拟I2C:*/</span></span><br><span class="line"><span class="comment">//		MyI2C_Start();</span></span><br><span class="line"><span class="comment">//	  MyI2C_SendByte(MPU6050_ADDRESS);</span></span><br><span class="line"><span class="comment">//		MyI2C_ReceiveAck();</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//	  MyI2C_SendByte(RegAddress);</span></span><br><span class="line"><span class="comment">//		MyI2C_ReceiveAck();</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//	/*前一半为写的时序*/</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//	/*后一半为读的时序*/</span></span><br><span class="line"><span class="comment">//	  MyI2C_Start();//Sr</span></span><br><span class="line"><span class="comment">//	  MyI2C_SendByte(MPU6050_ADDRESS|0x01);//最后一位改成读</span></span><br><span class="line"><span class="comment">//		MyI2C_ReceiveAck();</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">//	/*接收从机数据*/</span></span><br><span class="line"><span class="comment">//	  Data = MyI2C_ReceiveByte();</span></span><br><span class="line"><span class="comment">//		MyI2C_SendAck(1);//想继续读数据给应答，这里只读一位，直接不应答了</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">////	  for(int i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">////		&#123;</span></span><br><span class="line"><span class="comment">////		    Datas[i] = MyI2C_ReceiveByte();</span></span><br><span class="line"><span class="comment">////        if(i==7)</span></span><br><span class="line"><span class="comment">////				&#123;</span></span><br><span class="line"><span class="comment">////					MyI2C_SendAck(1);//最后一位读取后不应答</span></span><br><span class="line"><span class="comment">////					break;</span></span><br><span class="line"><span class="comment">////				&#125;</span></span><br><span class="line"><span class="comment">////				MyI2C_SendAck(0);//读取多个数据给应答</span></span><br><span class="line"><span class="comment">////		&#125;</span></span><br><span class="line"><span class="comment">////		多个数据读取</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">//	  MyI2C_Stop();</span></span><br><span class="line">		</span><br><span class="line">	 <span class="comment">/*硬件I2C:实现指定地址接收一个字节，使用的是复合形式*/</span>	</span><br><span class="line">	 I2C_GenerateSTART(I2C1,ENABLE);<span class="comment">//1.发送起始条件</span></span><br><span class="line">	 <span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_MODE_SELECT)!=SUCCESS);<span class="comment">//起始条件等待EV5事件完成</span></span><br><span class="line">	 </span><br><span class="line">	 I2C_Send7bitAddress(I2C1,MPU6050_ADDRESS,I2C_Direction_Transmitter);<span class="comment">//2.发送从机地址，第三个参数自动置读写位,应答位会自动处理</span></span><br><span class="line">	 <span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)!=SUCCESS)<span class="comment">//等待发送模式的EV6事件完成</span></span><br><span class="line">		 </span><br><span class="line">	 I2C_SendData(I2C1,RegAddress);<span class="comment">//3.发送指定寄存器地址</span></span><br><span class="line">	 <span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_TRANSMITTED)!=SUCCESS)<span class="comment">//这里因为是数据流最后一个字节所以变成了等待EV8_2事件</span></span><br><span class="line">		</span><br><span class="line">	 <span class="comment">/*前一半为写的时序*/</span></span><br><span class="line">	</span><br><span class="line">   <span class="comment">/*后一半为读的时序*/</span></span><br><span class="line">	 </span><br><span class="line">	 I2C_GenerateSTART(I2C1,ENABLE);<span class="comment">//4.重复起始条件。这个地方会等待上方字节发送完成后才会产生，所以上方用TRANSMITTING或TRANSMITTED都可以</span></span><br><span class="line">	 <span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_MODE_SELECT)!=SUCCESS);<span class="comment">//起始条件等待EV5事件完成</span></span><br><span class="line">		</span><br><span class="line">	 I2C_Send7bitAddress(I2C1,MPU6050_ADDRESS,I2C_Direction_Receiver);<span class="comment">//2.发送从机地址，这个地方应变成读的方向，第三个参数修改</span></span><br><span class="line">	 <span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED)!=SUCCESS)<span class="comment">//等待接收模式的EV6事件完成，与上方EV6事件不同</span></span><br><span class="line">		</span><br><span class="line">	 	 </span><br><span class="line">	 <span class="comment">//如果只需要读取一个字节，需要恰好在EV6之后，立刻把ACK置0，STOP置1，避免在本次ACK发送之后才去置0，这样时序会多一个字节</span></span><br><span class="line">		</span><br><span class="line">	 <span class="comment">//如果是需要读取多个字节，直接等待EV7事件，读取DR,就能收到数据，依次接收，直到最后一个字节之前也就是EV7_1事件(EV7_1不用等待)，提前把ACK置0，STOP置1</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	 	I2C_AcknowledgeConfig(I2C1, DISABLE);</span><br><span class="line">		I2C_GenerateSTOP(I2C1,ENABLE);<span class="comment">//STOP置1后该终止条件不会截断当前字节，会等当前字节接收完成后，再产生终止条件波形</span></span><br><span class="line">	 </span><br><span class="line">		<span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_RECEIVED)!=SUCCESS)<span class="comment">//等待EV7事件完成</span></span><br><span class="line">		Data = I2C_ReceiveData(I2C1);<span class="comment">//5.接收从机数据</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line"><span class="comment">//     for(int i=0;i&lt;N;i++)</span></span><br><span class="line"><span class="comment">//		&#123;</span></span><br><span class="line"><span class="comment">//			</span></span><br><span class="line"><span class="comment">//			if(i==N-1)</span></span><br><span class="line"><span class="comment">//			I2C_AcknowledgeConfig(I2C1, DISABLE);</span></span><br><span class="line"><span class="comment">//			I2C_GenerateSTOP(I2C1,ENABLE);//STOP置1后该终止条件不会截断当前字节，会等当前字节接收完成后，再产生终止条件波形</span></span><br><span class="line"><span class="comment">//		 </span></span><br><span class="line"><span class="comment">//			while(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_RECEIVED)!=SUCCESS)//等待EV7事件完成</span></span><br><span class="line"><span class="comment">//			Data = I2C_ReceiveData(I2C1);</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//   接收多个字节:使用循环处理，最后一个字节前执行一次ACK=0和STOP</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		I2C_AcknowledgeConfig(I2C1, ENABLE);<span class="comment">//最后再恢复默认ACK=1，方便收多个字节</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> Data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*软件I2C:*/</span></span><br><span class="line"><span class="comment">//		MyI2C_Init();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*硬件I2C:*/</span></span><br><span class="line">	  <span class="comment">/*第1步*/</span></span><br><span class="line">	  RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1,ENABLE);</span><br><span class="line">	  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">    </span><br><span class="line">	  <span class="comment">/*第2步*/</span></span><br><span class="line">	  GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">		GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_OD;</span><br><span class="line">	  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_2|GPIO_Pin_3;</span><br><span class="line">		GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	  GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line">	  </span><br><span class="line">		<span class="comment">/*第3步*/</span></span><br><span class="line">	  I2C_InitTypeDef I2C_InitStruct;</span><br><span class="line">		I2C_InitStruct.I2C_Mode = I2C_Mode_I2C ;</span><br><span class="line">		I2C_InitStruct.I2C_Ack = I2C_Ack_Enable;<span class="comment">//确认要发送应答位</span></span><br><span class="line">		I2C_InitStruct.I2C_ClockSpeed = <span class="number">100000</span>;<span class="comment">//最大为400KHZ，0~100KHZ为标准速度，100~400khz为快速</span></span><br><span class="line">	  I2C_InitStruct.I2C_DutyCycle = I2C_DutyCycle_2;<span class="comment">//时钟占空比参数，用与快速模式，只有当时钟频率大于100Khz才有效，小于100Khz是占空比固定为1：1</span></span><br><span class="line">		I2C_InitStruct.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;<span class="comment">//响应7或10位地址，stm32作为从机时才使用。作为主机随便给</span></span><br><span class="line">		I2C_InitStruct.I2C_OwnAddress1 = <span class="number">0x00</span>;	<span class="comment">//自身地址1，stm32作为从机才使用，方便别的主机呼叫，指定地址位数=上一个参数选择响应的位数。作为主机随便给</span></span><br><span class="line">	 </span><br><span class="line">	  <span class="comment">/*第4步*/</span></span><br><span class="line">	  I2C_Cmd(I2C1,ENABLE);</span><br><span class="line">  </span><br><span class="line">		MPU6050_WriteReg(MPU6050_PWR_MGMT_1,<span class="number">0x01</span>);<span class="comment">//配置电源管理寄存器1,解除睡眠选择陀螺仪时钟</span></span><br><span class="line">	  MPU6050_WriteReg(MPU6050_PWR_MGMT_2,<span class="number">0x00</span>);<span class="comment">//配置电源管理寄存器2,6个轴均不待机</span></span><br><span class="line">	</span><br><span class="line">	  MPU6050_WriteReg(MPU6050_SMPLRT_DIV,<span class="number">0x09</span>);<span class="comment">//配置采样分频寄存器，选择10分频，滤波参数给最大</span></span><br><span class="line">		MPU6050_WriteReg(MPU6050_CONFIG	,<span class="number">0x06</span>);<span class="comment">//配置寄存器，滤波参数110</span></span><br><span class="line">	  MPU6050_WriteReg(MPU6050_GYRO_CONFIG	,<span class="number">0x18</span>);<span class="comment">//陀螺仪最大量程</span></span><br><span class="line">	  MPU6050_WriteReg(MPU6050_ACCEL_CONFIG,<span class="number">0x18</span>);<span class="comment">//加速度计最大量程</span></span><br><span class="line">	<span class="comment">/*这里配置完后，陀螺仪内部就在不停的转换了，对应数据存放在对应各轴数据寄存器中*/</span></span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*对应6轴的数据都是16位，分为高8位和低8位，分别读取高8位和低8位拼接后*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_GetData</span><span class="params">(<span class="type">int16_t</span> *AccX,<span class="type">int16_t</span> *AccY,<span class="type">int16_t</span> *AccZ,</span></span><br><span class="line"><span class="params">										 <span class="type">int16_t</span> *GyroX,<span class="type">int16_t</span> *GyroY,<span class="type">int16_t</span> *GyroZ)</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="type">uint16_t</span> DataH,DataL;</span><br><span class="line">	</span><br><span class="line">		DataH =  MPU6050_ReadReg(MPU6050_ACCEL_XOUT_H);</span><br><span class="line">	  DataL =  MPU6050_ReadReg(MPU6050_ACCEL_XOUT_L);</span><br><span class="line">	  </span><br><span class="line">		*AccX =  (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line">	</span><br><span class="line">	  DataH = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_H);</span><br><span class="line">	  DataL = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_L);</span><br><span class="line">	</span><br><span class="line">	  *AccY =   (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line">	  </span><br><span class="line">	  DataH = MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_H);</span><br><span class="line">	  DataL =  MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_L);</span><br><span class="line">	</span><br><span class="line">	  *AccZ =    (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line">	</span><br><span class="line">	  DataH = MPU6050_ReadReg(MPU6050_GYRO_XOUT_H);</span><br><span class="line">	  DataL =  MPU6050_ReadReg(MPU6050_GYRO_XOUT_L);</span><br><span class="line">	</span><br><span class="line">	  *GyroX = 	(DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line">	</span><br><span class="line">	  </span><br><span class="line">		DataH = MPU6050_ReadReg(MPU6050_GYRO_YOUT_H);</span><br><span class="line">	  DataL =  MPU6050_ReadReg(MPU6050_GYRO_YOUT_L);</span><br><span class="line">		</span><br><span class="line">	  *GyroY =  (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line">	</span><br><span class="line">		DataH = MPU6050_ReadReg(MPU6050_GYRO_ZOUT_H);</span><br><span class="line">	  DataL =  MPU6050_ReadReg(MPU6050_GYRO_ZOUT_L);</span><br><span class="line">		</span><br><span class="line">	  *GyroZ =   (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*这里的读取分为12次，我们可以改进，使用连续读取的时序，大大提升效率*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_GetID</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	 <span class="keyword">return</span> MPU6050_ReadReg(MPU6050_WHO_AM_I);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>程序中出现大量while等待的情况比较危险，容易发生卡死的现象，所以我们需要让它超时退出。</p>
<p>不必使用定时器，我们只需要简单用一个计数值循环判断即可，该Timeout值根据实际情况更改大小，while循环正常不会执行到Timeout</p>
</blockquote>
<h3 id="软件和硬件I2C对比"><a href="#软件和硬件I2C对比" class="headerlink" title="软件和硬件I2C对比"></a>软件和硬件I2C对比</h3><p><code>波形对比：</code></p>
<p><strong>上方是软件波形，下方是硬件波形</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241221171144668-1752337644187-588.png"></p>
<blockquote>
<p><strong>从时钟线的规整程度上看：</strong></p>
<p>硬件I2C：SCL波形会更加规整，每个时钟的周期、占空比都非常一致</p>
<p>软件I2C：由于操作引脚后都加了延时，有时候加的多有时候加的少，所以软件时序的时钟周期、占空比可能不规整，但由于是同步时序不规整也不会影响通信</p>
<hr>
<p>在SCL低电平写，高电平读的时候，可以在整个电平的任意时候都可以读写，但是一般要求保证尽早原则，所以可以认为SCL下降沿写，上升沿读。</p>
<p>软件波形中，因为操作端口后有延时，所以都是等了一会在写的</p>
<p>硬件波形中，可以看到SCL下降沿的时候，SDA也立马切换数据。读写都是紧贴上下沿进行</p>
<hr>
<p><strong>应答结束时最为明显：</strong></p>
<p>从机在SCL下降沿立刻释放SDA，但是软件I2C由于有延时，所以在应答结束后主机等了一会才变换数据，所以在软件I2C中有一个短暂的高电平后才拉低SDA。</p>
<p>硬件I2C中应答结束后，从机在SCL下降沿立刻释放SDA，同时主机也立刻拉低SDA，所以就是直接一个小尖峰。</p>
</blockquote>
<blockquote>
<p><code>软件模拟I2C (Bit-Banging)：</code></p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>灵活性高</strong>：可以完全控制每个I2C数据位的发送和接收过程，适用于没有硬件I2C模块的STM32型号，或者需要多个I2C总线时，可以通过软件模拟多个I2C设备。</li>
<li><strong>成本低</strong>：不依赖硬件I2C外设，因此适合成本敏感的应用。</li>
<li><strong>可以在任意GPIO上运行</strong>：可以自定义SCL和SDA引脚，不需要专用的硬件I2C引脚。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>效率低</strong>：每个数据位的发送和接收都需要进行软件延时处理，导致比硬件I2C慢得多。对于高速通信，可能无法满足实时性要求。</li>
<li><strong>占用CPU资源</strong>：模拟I2C需要CPU不断参与数据的传输，可能影响系统其他任务的执行，尤其是当系统负载较高时。</li>
<li><strong>稳定性差</strong>：如果系统中有其他任务需要占用大量CPU时间，可能会导致I2C通信不稳定，或者丢失数据。</li>
</ul>
<hr>
<p><code>硬件I2C (利用硬件I2C模块)：</code></p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>高效</strong>：硬件I2C通过专用的I2C控制器进行数据传输，不需要CPU参与数据位的传送，速度快且稳定，通常能够提供更高的传输速率。</li>
<li><strong>节省CPU资源</strong>：硬件I2C控制器可以自动完成数据传输任务，释放CPU处理其他任务，特别适合多任务或实时系统。</li>
<li><strong>稳定性强</strong>：硬件I2C模块有专门的硬件实现，避免了由于软件延迟或CPU占用过高导致的通信不稳定问题。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>硬件资源有限</strong>：不同型号的STM32有不同数量的硬件I2C模块，因此可用的硬件I2C通道有限。如果需要多个I2C总线，可能无法满足需求。</li>
<li><strong>引脚固定</strong>：硬件I2C通常需要专用的引脚（SCL和SDA），不能任意选择GPIO。如果这些引脚已被占用或在项目设计中不方便，可能会限制设计的灵活性。</li>
<li><strong>复杂性较高</strong>：硬件I2C需要配置硬件相关的寄存器和管理中断等，比软件模拟I2C配置复杂一些。</li>
</ul>
<hr>
<p><strong>使用场景总结</strong>：</p>
<p>**软件模拟I2C：**灵活、成本低，但效率低、占用CPU资源。不受限制，引脚够基本上就是想开几路就是几路</p>
<p>硬件I2C不足时可以使用软件I2C</p>
<p>**硬件I2C：**效率高、稳定，节省CPU资源，但受硬件资源和引脚限制。</p>
<p>对性能指标要求比较高，实时性、多任务等时使用硬件I2C</p>
</blockquote>
<h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2><h3 id="SPI介绍"><a href="#SPI介绍" class="headerlink" title="SPI介绍"></a>SPI介绍</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250101153932297-1752337644187-589.png" alt="image-20250101153932297"></p>
<blockquote>
<p>图中的四种使用SPI通信的芯片：引脚名称可能不标注，可以查看对应手册了解</p>
<ol>
<li>W25QXX，FLASH存储芯片，作为从机，引脚写的DI和DO</li>
<li>OLED屏幕</li>
<li>2.4G无线通信模块，芯片型号为NRF24L01</li>
<li>Micro SD卡：官方通信协议为SDIO，但也支持SPI协议，可以对其进行读写操作</li>
</ol>
</blockquote>
<blockquote>
<p><strong>SPI特点：同步，全双工，四根通信线</strong></p>
<hr>
<p><code>SPI的四根线：</code></p>
<ol>
<li><strong>SCK(Serial Clock)</strong>：时钟线，也叫做SCLK、CLK、CK等</li>
<li><strong>MOSI(Master Output Slave Input)</strong>：主机输出从机输入线，也叫做DI(Data Output-对应从机输入)</li>
<li><strong>MISO(Master Output Slave Input)</strong>：主机输入从机输出线，也叫做DO(Data Input-对应从机输出))</li>
<li><strong>SS(Slave Select)</strong>：从机选择线，片选，也叫做NSS(Not Slave Select)、CS(Chip Select-片选)，有几个从机就用几条线。这样以后就不用像I2C那样先发送一个字节寻址、分配地址等操作</li>
</ol>
<p>注意：主机和从机不能同时配置为输入或输出</p>
<hr>
<p><strong>SPI没有应答位，SPI是不管你有没有收到信息的</strong></p>
<hr>
<p><code>SPI相对于I2C的优缺点：</code></p>
<ul>
<li><p><code>速度上：</code>SPI传输比I2C更快，SPI协议并没有严格规定最大传输速度，最大传输速度一般由芯片厂商的设计需求，如W25Q64存储器芯片，手册中写的是最大可达80MHz</p>
</li>
<li><p><code>设计上：</code>SPI设计比较简单粗暴，实现的功能没有I2C那么多，<strong>仅支持一主多从，因为没有仲裁机制，不支持多主机</strong></p>
</li>
<li><p><code>开销上：</code>SPI的硬件开销比较大，通信线的个数比较多，通信过程中经常会有资源浪费的情况</p>
</li>
</ul>
</blockquote>
<h3 id="硬件电路-3"><a href="#硬件电路-3" class="headerlink" title="硬件电路"></a>硬件电路</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250101165230579-1752337644187-590.png" alt="image-20250101165230579"></p>
<blockquote>
<p>主机一般是STM32，从机一般是存储器、显示屏、通信 模块、传感器等，对应有几个从设备就有几个SS线</p>
<hr>
<p><code>SCK：</code>时钟线完全由主机掌控，对于主机来说时钟线为输出，对于从机来说时钟线为输入</p>
<p><code>MOSI：</code>主机输出从机输入，左边主机对应MO，主机输出，右边从机SI，从机输入。数据从MOSI输出，所有从机从MOSI输入</p>
<p><code>MISO：</code>主机输入从机输入，与MOSI类似</p>
<p><code>SS：</code>从机选择线，低电平有效，主机初始化后所有的SS都输出高电平，代表都不指定，需要与谁通信，就将对应的SS线拉低即可，当对应从机通信完之后，对应SS线就重新置回高电平。同一时间只能选择一个从机(只能置一个为低电平)</p>
<hr>
<p><strong>输出引脚配置为推挽输出</strong>：高低电平均有很强驱动能力，使得SPI信号引脚上升沿和下降沿信号非常迅速，不像I2C那样下降沿迅速上升沿缓慢，所以SPI信号变化的快所以SPI具有更快的传输速度，一般的SPI信号都能轻松达到Mhz的速度级别。</p>
<p><code>输出引脚为：SCK、MOSI、SS</code></p>
<p><strong>输入引脚配置为浮空或上拉输入</strong></p>
<p><code>输入引脚为：MISO</code></p>
<p><code>SPI可能存在的冲突</code>：</p>
<p>​	对于SPI的从机MISO引脚，当某个从机的SS引脚被选择后，其他从机的SS引脚会被保持为高阻态，相当于断开不输出，这样可以防止一条线有多个输出而导致的电平冲突的问题</p>
</blockquote>
<h3 id="数据移位示意图"><a href="#数据移位示意图" class="headerlink" title="数据移位示意图"></a>数据移位示意图</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250101173950632-1752337644187-591.png" alt="image-20250101173950632"></p>
<blockquote>
<p><strong>SPI数据是高位先行，通信基础是<code>交换一个字节</code>，数据收发都是基于<code>字节交换</code>这个基本单元进行</strong>。主机要发送的数据跑到从机，从机要发送的数据跑到主机，这样就可以实现发送一个字节、接收一个字节、发送同时接收一个字节<code>三种功能</code></p>
<p><strong>对于只想接收数据时</strong>：我们会随便发送数据(一般统一为0x00或0xFF)，把数据置换过来即可</p>
<p><strong>对于只想发送数据时</strong>：只需要把数据发送过去，对方置换过来的数据不管即可</p>
<hr>
<p><strong>这里波特率发生器就是时钟</strong></p>
<p>主机移位寄存器左边出去的数据通过MOSI引脚，输入到从机移位寄存器的右边，从机移位寄存器左边移出去的数据通过MISO引脚，输入到主机移位寄存器的右边，形成一个环</p>
<p><strong>每当规定的时钟沿(上升沿&#x2F;下降沿)到来时，对应移位寄存器的最高位分别移动，分别放到MOSI和MISO的通信线上，然后对应的时钟沿(上升沿或下降沿)再次到来时，数据分别从MOSI和MISO线上，采样到从机和主机的最低位。这样就完成了一个时钟</strong></p>
<p>例：规定上升沿数据移动，下降沿数据采集。就是在上升沿时移位寄存器的最高位到对应的线上。下降沿时，会采样输入到对应的最低位。</p>
<hr>
</blockquote>
<h3 id="SPI时序基本单元"><a href="#SPI时序基本单元" class="headerlink" title="SPI时序基本单元"></a>SPI时序基本单元</h3><ul>
<li><code>起始条件和终止条件:</code></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250101174746261-1752337644187-592.png" alt="image-20250101174746261"></p>
<blockquote>
<p>起始条件：SS由高到低，代表选中从机通信开始</p>
<p>结束条件：SS由低到高，代表结束选中从机通信结束</p>
<p>所以SS低电平期间就代表正在通信</p>
</blockquote>
<hr>
<p>​	<strong>SPI中有两个可以配置的位，每一位可以配置为1或0，组合起来就有模式0、模式1、模式2、模式共四种模式，但功能实际都是一样的，任意选择一种使用即可。</strong></p>
<p><code>CPOL(Clock Polarity)：</code><strong>时钟极性</strong>，决定空闲时SCK的低电平，值为0或1</p>
<p><code>CPHA(Clock Phase)：</code><strong>时钟相位</strong>，决定第一个时钟采样移入还是第二时钟采样移入，并不是规定上升沿采样还是下降沿采样，值为0或1</p>
<hr>
<ul>
<li><code>模式0：使用最多重点掌握！！！</code></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250101175308487-1752337644187-593.png" alt="image-20250101175308487"></p>
<blockquote>
<p>CPOL &#x3D; 0：代表空闲状态SCK低电平</p>
<p>CPHA &#x3D; 0：SCK<code>第一个</code>边沿<code>移入数据</code>，<code>第二个</code>边沿<code>移出数据</code>。</p>
<p><strong>由于数据需要先移出来，才能移入，所以SCK第一个边沿之前就要提前开始移出数据了。</strong></p>
<p>​	这里把SS当作了时钟下降沿所以要移出数据，MOSI就提前移出数据，等SCK上升沿来到，两个数据B7分别移入到主机和从机。然后SCK到下降沿，两个B6数据就移出，上升沿的两个B6数据采样输入到主机和从机…….一直到B0最后一位，SS拉高，MOSI任意，MISO高阻态，这样一个字节的交换就完成。</p>
<p><strong>如果想要交换多个字节，只需要在B0最后继续紧跟第二个字节的B7重复前述过程即可</strong></p>
<hr>
<p><strong>总结交换字节步骤</strong>：</p>
<ol>
<li>SS拉低后，主机和从机立刻移出数据(主机移出它的数据最高位放到MOSI上，从机移出它的最高位数据放到MISO上)。从机的事主机不管，所以我们直接写MOSI即可</li>
<li>SCK上升沿，主机和从机同时移入数据(从机会自动把这位数据读走)，主机只需要读入MISO的数据位即可</li>
<li>SCK下降沿，主机和从机同时移出次高位数据，开始循环8次，共1字节8bit</li>
</ol>
</blockquote>
<ul>
<li><code>模式1：与上方的移位过程相同</code></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250101180327881-1752337644187-594.png" alt="image-20250101180327881"></p>
<blockquote>
<p><strong>模式1与模式0的区别：模式0把数据变化的实际提前了，而模式1没有</strong></p>
<hr>
<p>CPOL &#x3D; 0：代表空闲状态SCK低电平</p>
<p>CPHA &#x3D; 1：SCK<code>第一个</code>边沿<code>移出数据</code>，<code>第二个</code>边沿<code>移入数据</code>。</p>
<p>也能表述为：CPHA&#x3D;1表示SCK的第二个边沿进行数据采样，或SCK的偶数边沿进行数据采样</p>
<p>MOSI为主机发送的B7，B6…，默认状态下没有规定高低电平(均可)</p>
<p>MISO为从机发送的B7，B6…，默认状态下应为高阻态</p>
</blockquote>
<ul>
<li><code>模式2：</code></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250101183828210-1752337644187-595.png" alt="image-20250101183828210"></p>
<blockquote>
<p><strong>模式2与模式0区别：就把SCK极性取反即可</strong></p>
</blockquote>
<ul>
<li><code>模式3：</code></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250101183921953-1752337644187-596.png" alt="image-20250101183921953"></p>
<blockquote>
<p><strong>模式1与模式3区别：就把SCK极性取反即可</strong></p>
</blockquote>
<h3 id="SPI时序"><a href="#SPI时序" class="headerlink" title="SPI时序"></a>SPI时序</h3><p>​		SPI对字节流功能的规定与I2C不同，I2C是有效数据流第一个字节是寄存器地址，之后依次是读写的数据，<strong>使用的是读写寄存器的模型</strong>。</p>
<p>​		而在SPI中，通常<strong>采用指令码加读写数据的模型</strong>，即SPI第一个发送给从机的数据叫做指令码，在从机中对应的会定义一个指令集，只需要发送指令集中对应的数据即可指定想要完成的功能。</p>
<p>​		不同的指令，可以有不同的数据个数，有的指令只需要一个字节的指令码就可以完成，比如：W25Q64的写使能失能等。而写数据时，包含指令码+在哪里写+写的数据</p>
<p>​       <code>对应的指令集都会在SPI从机芯片手册中可以找到！！！！</code></p>
<p><strong>时序举例</strong>：</p>
<ul>
<li><code>写使能</code></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250101184358794-1752337644187-597.png" alt="image-20250101184358794"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250101185239046-1752337644187-598.png" alt="image-20250101185239046"></p>
<blockquote>
<p>在W25Q64中0x06代表写使能。</p>
<p><strong>这里使用SPI模式0，SS拉低后，立马准备移出数据，这里数据第一个Bit为0，所以没有变化，SCK第一个上升沿采样移入数据，从机采样输入(MOSI)得到0，主机采样输入(MISO)得到1。然后第一个下降沿移除数据……一直到最后一位交换完成一个字节。SS置回高电平结束</strong></p>
<p><code>结果：</code>主机用收到从机的0xFF，即从机输出不使用(0xFF为默认值)，从机收到主机的0x06，就会进行写使能</p>
<p><strong>由于使用软件模拟时序有延时，所以图中的MOSI数据变化有些延迟，没有紧贴SCK的下降沿是正常的</strong></p>
</blockquote>
<ul>
<li><code>指定地址写一个/多个字节</code></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250101191437487-1752337644187-599.png" alt="image-20250101191437487"></p>
<blockquote>
<p>由于W25Q64有8M的存储空间，一个字节的8位地址不够，所以这里的指定地址使用24位分成3个字节发送</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250101191742942-1752337644187-600.png" alt="image-20250101191742942">&#96;</p>
<blockquote>
<p><strong>在0x123456的地址下写入0x55数据</strong>：</p>
<p><code>指令码</code></p>
<p>第一个字节：主机先发送0x02指令代表写数据，收到从机数据为0xFF不使用</p>
<hr>
<p><code>指定地址</code></p>
<p>第二个字节：主机发送地址前8位(第23~16位)为0x12，收到从机数据0xFF</p>
<p>第三个字节：主机发送地址中8位(第15~8位)为0x34，收到从机数据0xFF</p>
<p>第四个字节：主机发送地址后8位(第7~0位)为0x56，收到从机数据0xFF</p>
<p><strong>从机收到的地址为0x123456</strong></p>
<hr>
<p><code>发送的数据</code></p>
<p>第五个字节：主机写入的数据0x55，收到从机数据0xFF</p>
<p>到这里便写入一个字节，没有应答位，一个接一个交换字节即可</p>
<hr>
<p><code>如果想指定地址，写入多个字节：</code></p>
<p>SPI中也有类似于I2C中的地址指针，每读写一个字节，地址指针自动+1，如果发送一个字节后不停止，继续发送的字节就会依次写入到后续的存储空间里，这样即实现多个字节写入</p>
</blockquote>
<ul>
<li><code>指定地址读一个/多个字节：</code></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250101193028026-1752337644188-601.png" alt="image-20250101193028026"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250101193633764-1752337644188-602.png" alt="image-20250101193633764"></p>
<blockquote>
<p><strong>和指定地址写时序差不多</strong></p>
<p>指令码：0x03</p>
<p>地址三个字节：0x123456</p>
<p>读取的数据：主机随便发送数据0xFF，交换数据后得到0x55。</p>
<p>这样就读取到了0x123456地址的数据为0x55</p>
<hr>
<p><code>实现读取指定地址的多个字节：</code></p>
<p>也是有地址指针，读取自动+1，实现连续读取即可</p>
<hr>
<p><strong>时序细节</strong>：</p>
<p>图中MISO是硬件控制波形，所以数据变化紧贴下降沿</p>
</blockquote>
<h3 id="W25Q64介绍"><a href="#W25Q64介绍" class="headerlink" title="W25Q64介绍"></a>W25Q64介绍</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250101193816880-1752337644188-603.png" alt="image-20250101193816880"></p>
<blockquote>
<p><code>容量：</code></p>
<p>该芯片存储为M级别，在手机可能很小，但是在嵌入式领域还是挺大的</p>
<p>还有的芯片是KB级别的，例如AT24C02芯片，使用的I2C通信的E2PROM芯片</p>
<hr>
<p><code>存储器分类：</code></p>
<p>分为非易失性存储器(FLASH、E2PROM)和易失性存储器(SRAM、DRAM)</p>
<p>该芯片是非易失性存储器，数据掉电不丢失，存储介质为Nor Flash</p>
<hr>
<p><code>通信协议：</code></p>
<p>使用SPI串行通信，SCK时钟线频率最大为80MHz，双重SPI模式等效频率为160Mhz，四重SPI模式等效的频率为320MHz</p>
<p>频率相对于stm32非常快</p>
<hr>
<p><code>应用：</code></p>
<p>数据存储：</p>
<p>字库存储：可以存放中文字库等，使用时读取数据后显示中文</p>
<hr>
<p><code>型号：</code></p>
<p><strong>芯片使用24位地址，3个字节</strong></p>
<p>2的24方 &#x3D; 16MB，所以24位地址的最大寻址空间为16MB，所W25Q40~W25Q128都是够用的，但是W25Q256是32MB的存储不够用</p>
<p>W25Q256分为3字节地址模式和4字节地址模式，使用3字节模式下只能读写到前16MB地址，而要想读写所有的地址进入4字节地址模式即可</p>
<p>更换芯片型号，硬件电路和底层驱动程序都不用更改</p>
</blockquote>
<h4 id="硬件电路-4"><a href="#硬件电路-4" class="headerlink" title="硬件电路"></a>硬件电路</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250101233710004-1752337644188-604.png" alt="image-20250101233710004"></p>
<blockquote>
<p>该芯片的供电VCC接3.3V</p>
<hr>
<p>WP：写保护，低电平不允许写，高电平可以写</p>
<p>HOLD：数据保持，低电平有效</p>
<p>作用：在正常读写时突然产生中断，然后想用SPI通信线去操控其他器件，此时如果把CS置回高电平，那时序就会终止，但如果不想终止总线又想操作其他器件，此时就可以将HOLD引脚置低电平，芯片释放总线，芯片的时序也不会终止，会记住当前的状态，操作完后可以回来HOLD置高电平，继续之前的时序。</p>
<p>相当于SPI总线进了一次中断</p>
<p><strong>HOLD和WP如果想用就接到GPIO引脚上，如果不想用就直接接VCC即可</strong></p>
<hr>
<p>IO1 、IO2与双重SPI和四重SPI有关</p>
</blockquote>
<h4 id="框图"><a href="#框图" class="headerlink" title="框图"></a>框图</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250102170255168-1752337644188-605.png" alt="image-20250102170255168"></p>
<blockquote>
<p><code>几个基本概念：块、扇区、页:</code></p>
<p><code>块大小：</code>64KB</p>
<p><code>扇区大小：</code>4KB</p>
<p><code>页大小：</code>256B</p>
<p>8MB的地址空间从0x000000到0x7FFFFF</p>
<p><strong>右边</strong>：以64KB为一个基本单元块划分为若干个块Block  8MB&#x2F;64KB &#x3D; 128块(块0~127)</p>
<p><strong>左上</strong>：以4KB为一个基本单元再将每个Block划分为若干个单元，每个单元叫做Sector-扇区 64KB&#x2F;4KB &#x3D; 16个扇区(扇区0~15)</p>
<p>我们在写入数据时其实还有一个划分叫做页，是对扇区进行的一个更细的划分，一页为256字节 4KB&#x2F;256 &#x3D; 16页(0~15页)</p>
<hr>
<p><strong>左下角：芯片的控制逻辑</strong></p>
<p>芯片内部的地址锁存、数据读写等操作都由控制逻辑自动完成</p>
<p>控制逻辑的左边连接的是SPI的引脚</p>
<p>控制逻辑上方是状态寄存器，可以知道芯片是否处于忙状态、是否写使能等</p>
<p>状态寄存器上方是写控制逻辑与WP引脚连接，实现硬件写保护</p>
<p>内部集成了高电压发生器(High Voltage Generators)，用于实现掉电不丢失</p>
<hr>
<p><strong>最下方：字节地址锁存&#x2F;计数器</strong></p>
<p>用于指定地址，SPI放过来3个字节的地址，前2个字节进到<strong>页地址锁存计数器</strong>，最后一个字节进入<strong>字节地址锁存计数器</strong>中</p>
<p>然后页地址锁存计数器通过写保护和行解码选择操作的哪一页</p>
<p>字节地址锁存计数器通过列解码和256字节页缓存来进行指定字节的读写操作</p>
<p>其中的计数器与地址指针自动+1有关</p>
<hr>
<p><strong>右下方：列解码和256Byte 页缓冲区</strong></p>
<p>实际上是个RAM缓冲区，写入数据时先放到这个RAM缓冲区，时序结束后，芯片对应状态BUSY会置1，芯片再将缓冲区的数据复制到对应的Flash中，此时不会响应新的写入</p>
<p><strong>缓冲区作用</strong>：SPI的写入频率是非常高的，而Flash的写入速度比较慢(掉电不丢失特性)，所以需要使用一个RAM页缓存区来存储写入的数据，从而可以跟得上SPI总线的速度。</p>
</blockquote>
<h4 id="Flash操作注意事项"><a href="#Flash操作注意事项" class="headerlink" title="Flash操作注意事项"></a>Flash操作注意事项</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250102173909328-1752337644188-606.png" alt="image-20250102173909328"></p>
<blockquote>
<p>第1条规定：直接使能即可</p>
<p>第2条规定：不擦除写入数据可能会与实际不符，实际值为(写入数据&amp;芯片内数据)</p>
<p><code>第3条规定：</code>是为了弥补第2条规定设立，保证每次写入数据不出错，由专门的擦除电路自动进行，我们只需要发送擦除的指令即可</p>
<p><code>一定要在每次写入前擦除数据!!!</code></p>
<p>第4条规定：擦除时只能选择整个芯片擦除、按块擦除、按扇区擦除，所以最小的擦除单元是一个扇区为4KB-4096字节。不能指定对某个字节擦除，如果想要擦除某一个字节，只能对该字节所在的扇区的4096个字节进行擦除</p>
<p>为了弥补这个缺点，我们需要在程序逻辑上进行一些优化：比如上电后先将Flash备份一份到RAM中</p>
<p>第5条规定：一次性不能写太多，一个写入时序最多写256字节(由缓冲区限制)</p>
<p>第6条规定：写入时序结束或者擦除芯片之后，芯片进入忙状态(BUSY位&#x3D;1)，当状态寄存器BUSY位为0后才会继续响应</p>
<p>第7条规定：读取时序基本没有限制，唯一就是不能在忙状态时读取</p>
<hr>
<p>由于Flash掉电不丢失的特性，成本低，存储量大，所以在操作的便携性上不是很友好，以及速度不是很快。但在非易失性存储器中速度却是很快的。</p>
<p>与RAM想在哪些就在哪写，想写多少就写多少不同，且可以覆盖写入区别较大</p>
</blockquote>
<h4 id="芯片手册"><a href="#芯片手册" class="headerlink" title="芯片手册"></a>芯片手册</h4><p>主要包含写保护配置表、状态寄存器、指令集，以及对每条指令的详细解释。还有芯片电器特性(供电电压范围等)</p>
<ul>
<li><code>状态寄存器:</code></li>
</ul>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250102191517893-1752337644188-607.png" alt="image-20250102191517893"></p>
<p><code>BUSY位：</code></p>
<p>当设备执行页编程（Page Program）、扇区擦除（Sector Erase）、块擦除（Block Erase）、芯片擦除（Chip Erase）或写状态寄存器指令时会被设置为1。在该位为1时，表示设备正在忙碌，不会响应其他指令，除了读取状态寄存器和进入&#x2F;擦除挂起操作的指令。程序、擦除或写状态寄存器操作完成后，“BUSY”位会清零，表明设备已准备好接收新的指令。</p>
<p><code>WEL位(写使能锁存位)：</code></p>
<p>WEL 是一个状态寄存器（Status Register）中的位，仅在执行了 Write Enable 指令后被设置为。在数据写入完成后，该位会被清零以禁用写操作。 当电源关闭或者执行以下任一指令时，WEL也会被禁用：Write Disable、Page Program(页编程)、Sector Erase（扇区擦除）、Block Erase（块擦除）、Chip Erase(芯片擦除) 和 <strong>Write Status Register(写入数据后会自动进行写使能)。</strong> </p>
<p>例子说明： 假设你有一块闪存芯片，在你想要向其写入数据之前，必须先发送 Write Enable 指令来激活WEL位。只有当这个位是激活状态（即值为1），才能对芯片进行编程或擦除操作。一旦这些操作完成或者直接通过发送特定指令显式地禁用它（比如Write Disable），WEL会回到未激活状态（即值为0），从而防止意外改变数据。</p>
<p><code>注意：一条写指令只能保证后续的一条写指令可以执行，所以每次写入都要进行写使能</code></p>
<hr>
<p><code>其他的位请自行查看手册！！</code></p>
</blockquote>
<ul>
<li><code>指令集(Instruction):</code></li>
</ul>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250102193355258-1752337644188-608.png" alt="image-20250102193355258"></p>
<p>厂商ID是：0xEF</p>
<p>设备ID：</p>
<p>0x16 (如果使用0xAB和0x90来读)</p>
<p>0x4017 (使用0x9F来读)</p>
<hr>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250102193817312-1752337644188-610.png" alt="image-20250102193817312"></p>
<p><code>Write Enable：</code>写使能，发送0x06</p>
<p><code>Write Disable：</code>写失能，发送0x04</p>
<hr>
<p><code>Read Status Register-1：</code>读取状态寄存器第1位，发送0x05，用于查看忙状态，S0是BUSY位，S1是WEL位</p>
<hr>
<p><code>Page Program：</code>页编程就是写数据，发送0x02，然后继续发送地址23-16位，15-8位，7-0位三个字节，然后发送写入的数据</p>
<p><strong>注意：该芯片不能跨页写入，在执行跨页写入时，多出来的数据会从页首的地方覆盖写入，一页为256B对应16进制为0x000000~0x0000FF。</strong></p>
<p><strong>若确实需要跨页写入，需要连续写入很大的数组，只能从软件上进行分批次写入，先计算数组要跨多少也，擦除对应区域,最后分批次一页一页写，最后封装成一个函数</strong></p>
<hr>
<p><code>Block Erase：</code>块擦除，包括按64KB的块擦除、32KB的块擦除、4KB的扇区擦除。发送0xD8&#x2F;0x62，再发送三个字节的地址即可</p>
<p><code>Sector Erase：</code>扇区擦除，包括4KB的扇区擦除。发送0x20，再发送三个字节的地址即可，对应一个扇区为0x000000~0x000FFF</p>
<p><code>Chip Erase：</code>发送0xC7或0x60h即可</p>
<hr>
<p><code>JEDEC ID：</code>读取ID指令，发送0x9F，然后连续交换三个字节数据，得到的第一个字节是厂商ID，后两个字节是设备ID</p>
</blockquote>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250102195113035-1752337644188-609.png" alt="image-20250102195113035"></p>
<p><code>Read Data：</code>读取数据，发送0x03，之后交换发送3个字节地址，接下来读取的就是该地址下的数据</p>
</blockquote>
<ul>
<li><code>执行所用时间：</code></li>
</ul>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250102200118784-1752337644188-612.png" alt="image-20250102200118784"></p>
<p>页编程以及各种擦除所用时间，基本都是ms级别</p>
</blockquote>
<ul>
<li><code>dummy数据：</code></li>
</ul>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250104225524682-1752337644188-611.png" alt="image-20250104225524682"></p>
<p><strong>手册中可以看到发送的数据为dummy，这个dummy就代表无用数据，发送0xFF即可此时发送和接收的数据都没有意义。</strong></p>
<p><strong>作用：可能是做一些延时</strong></p>
</blockquote>
<h3 id="软件SPI读写W25Q64"><a href="#软件SPI读写W25Q64" class="headerlink" title="软件SPI读写W25Q64"></a>软件SPI读写W25Q64</h3><h4 id="软件SPI底层代码"><a href="#软件SPI底层代码" class="headerlink" title="软件SPI底层代码"></a>软件SPI底层代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MySPI.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYSPI_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYSPI_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//void MySPI_W_SS(uint8_t BitVal);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void MySPI_W_SCK(uint8_t BitVal);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void MySPI_W_MOSI(uint8_t BitVal);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//uint8_t MySPI_W_MISO()；</span></span><br><span class="line"><span class="comment">/*上面四个函数只有MySPI.c中会使用，所以我们不用放在头文件中，保持模块的独立，封装！！！！！！*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Start</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Stop</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MySPI_SwapByte</span><span class="params">(<span class="type">uint8_t</span> ByteSend)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写SS</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_W_SS</span><span class="params">(<span class="type">uint8_t</span> BitVal)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	GPIO_WriteBit(GPIOA,GPIO_Pin_4,(BitAction)BitVal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//写SCK</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_W_SCK</span><span class="params">(<span class="type">uint8_t</span> BitVal)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	GPIO_WriteBit(GPIOA,GPIO_Pin_5,(BitAction)BitVal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写MOSI</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_W_MOSI</span><span class="params">(<span class="type">uint8_t</span> BitVal)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	GPIO_WriteBit(GPIOA,GPIO_Pin_7,(BitAction)BitVal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读MISO</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MySPI_R_MISO</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	 <span class="keyword">return</span> GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_6);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*由于SPI速度很快，操作引脚后就不用加延时了*/</span></span><br><span class="line"><span class="comment">/*上面这样单独对写入引脚的封装，有利于单片机移植或者添加延时*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	  <span class="comment">//1.开启对应引脚RCC</span></span><br><span class="line">		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	   </span><br><span class="line">	  <span class="comment">//2.配置GPIO</span></span><br><span class="line">	  <span class="comment">/*三个推挽输出引脚*/</span></span><br><span class="line">	  GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">	  GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_7;</span><br><span class="line">	  GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	  GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line">	  </span><br><span class="line">		<span class="comment">/*一个上拉/浮空输入引脚*/</span></span><br><span class="line">	  GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_6;</span><br><span class="line">	  GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">		GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//3.配置默认电平：初始化SS引脚为高电平，由于使用模式0，所以初始化SCK引脚为低电平</span></span><br><span class="line">	  MySPI_W_SS(<span class="number">1</span>);</span><br><span class="line">	  MySPI_W_SCK(<span class="number">0</span>);</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SPI起始条件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	MySPI_W_SS(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SPI终止条件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Stop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	 MySPI_W_SS(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//SPI字节交换,由于是交换1字节，所以需要有返回值得到从机发送的1字节</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MySPI_SwapByte</span><span class="params">(<span class="type">uint8_t</span> ByteSend)</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="type">uint8_t</span> ByteReceive = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">/*1.依次1位，1位操作*/</span></span><br><span class="line"><span class="comment">//		MySPI_W_MOSI(ByteSend &amp;= 0x80); //移出第一位数据</span></span><br><span class="line"><span class="comment">//	  MySPI_W_SCK(1);</span></span><br><span class="line"><span class="comment">//		if(MySPI_W_MISO() == 1)  //接收从机发送的第一位数据(最高位)</span></span><br><span class="line"><span class="comment">//		&#123;</span></span><br><span class="line"><span class="comment">//			ByteReceive |= 0x80;   </span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		MySPI_W_SCK(0);</span></span><br><span class="line"><span class="comment">//		/*一个时序的结束*/</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//		MySPI_W_MOSI(ByteSend &amp;= 0x40);//移出第二位数据</span></span><br><span class="line"><span class="comment">//		MySPI_W_SCK(1);</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//		if(MySPI_W_MISO() == 1)  //接收从机发送的第二位数据(次高位)</span></span><br><span class="line"><span class="comment">//		&#123;</span></span><br><span class="line"><span class="comment">//			ByteReceive |= 0x40;   </span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//		.....一位一位发送，可以简化为循环</span></span><br><span class="line">    </span><br><span class="line">		<span class="comment">/*2.通过掩码，依次挑出每一位进行操作*/</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			MySPI_W_MOSI(ByteSend &amp; (<span class="number">0x80</span> &gt;&gt; i)); <span class="comment">//移出第i位数据，每次只发送了1bit</span></span><br><span class="line">			MySPI_W_SCK(<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(MySPI_R_MISO() == <span class="number">1</span>)  <span class="comment">//接收从机发送的第i位数据(i=0时为最高位)，每次只接收了1bit</span></span><br><span class="line">			&#123;</span><br><span class="line">				ByteReceive |= (<span class="number">0x80</span> &gt;&gt; i);   </span><br><span class="line">			&#125;</span><br><span class="line">			MySPI_W_SCK(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*3.通过SPI中主机和从机移位寄存器交换字节的方式，更加契合SPI的移位模型讲解*/</span></span><br><span class="line"><span class="comment">//			for(int i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">//		&#123;</span></span><br><span class="line"><span class="comment">//			MySPI_W_MOSI(ByteSend &amp;= 0x80); //移出第i位数据，每次只发送了1bit</span></span><br><span class="line"><span class="comment">//			ByteSend &lt;&lt;= 1 ; //最高位发送后，左移1位后最低位为0，空出最低为</span></span><br><span class="line"><span class="comment">//			MySPI_W_SCK(1);</span></span><br><span class="line"><span class="comment">//			if(MySPI_W_MISO() == 1)  //接收从机发送的第i位数据(i=0时为最高位)，每次只接收了1bit</span></span><br><span class="line"><span class="comment">//			&#123;</span></span><br><span class="line"><span class="comment">//				ByteSend |= 0x01; //主机发送数据的移位寄存器最后1bit置为从机移位发送的1bit</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line"><span class="comment">//			MySPI_W_SCK(0);</span></span><br><span class="line"><span class="comment">//			</span></span><br><span class="line"><span class="comment">//			//最终得到的ByteSend就是移位交换后的数据，就可以不用定义ByteReceive,提高效率</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> ByteReceive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面演示的是SPI模式0的时序，如果需要修改模式，只需要对照时序图进行修改即可</p>
<p>比如修改为模式1，对照模式1的时序图只需要将for循环中的前两行代码交换顺序即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> <span class="title function_">MySPI_SwapByte</span><span class="params">(<span class="type">uint8_t</span> ByteSend)</span> </span><br><span class="line">&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">         MySPI_W_SCK(<span class="number">1</span>);</span><br><span class="line">         <span class="comment">/*这两行*/</span></span><br><span class="line">			MySPI_W_MOSI(ByteSend &amp;= (<span class="number">0x80</span> &gt;&gt; i)); </span><br><span class="line">			<span class="keyword">if</span>(MySPI_W_MISO() == <span class="number">1</span>)  </span><br><span class="line">			&#123;</span><br><span class="line">				ByteReceive |= (<span class="number">0x80</span> &gt;&gt; i);   </span><br><span class="line">			&#125;</span><br><span class="line">			MySPI_W_SCK(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>这里的模式0和模式1的时钟极性相同，如果改为模式2或模式3时，只需要将所有出现SCK的地方电平全部翻转一下即可</code></p>
</blockquote>
<h4 id="W25Q64测试代码"><a href="#W25Q64测试代码" class="headerlink" title="W25Q64测试代码"></a>W25Q64测试代码</h4><p><code>由于指令码直接书写不太美观，也不够清楚，所以我们可以对指令集进行宏定义。新建一个头文件，单独存放指令集的宏定义！！！</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*W25Q64_Ins*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __W25Q64_INS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __W25Q64_INS_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*根据W25Q64的手册将所有的指令码抄过来*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_WRITE_ENABLE							0x06</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_WRITE_DISABLE						0x04</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_READ_STATUS_REGISTER_1				0x05</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_READ_STATUS_REGISTER_2				0x35</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_WRITE_STATUS_REGISTER				0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_PAGE_PROGRAM							0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_QUAD_PAGE_PROGRAM					0x32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_BLOCK_ERASE_64KB						0xD8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_BLOCK_ERASE_32KB						0x52</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_SECTOR_ERASE_4KB						0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_CHIP_ERASE							0xC7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_ERASE_SUSPEND						0x75</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_ERASE_RESUME							0x7A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_POWER_DOWN							0xB9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_HIGH_PERFORMANCE_MODE				0xA3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_CONTINUOUS_READ_MODE_RESET			0xFF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_RELEASE_POWER_DOWN_HPM_DEVICE_ID		0xAB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_MANUFACTURER_DEVICE_ID				0x90</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_READ_UNIQUE_ID						0x4B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_JEDEC_ID								0x9F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_READ_DATA							0x03</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_FAST_READ							0x0B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_FAST_READ_DUAL_OUTPUT				0x3B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_FAST_READ_DUAL_IO					0xBB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_FAST_READ_QUAD_OUTPUT				0x6B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_FAST_READ_QUAD_IO					0xEB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_OCTAL_WORD_READ_QUAD_IO				0xE3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_DUMMY_BYTE							0xFF</span></span><br><span class="line"><span class="comment">//用于表示接受时交换过去的无用数据</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*W25Q64.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __W25Q64_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __W25Q64_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_ReadID</span><span class="params">(<span class="type">uint8_t</span>* mId,<span class="type">uint16_t</span>* dId)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*W25Q64.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MySPI.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	  MySPI_Init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*查看芯片手册对应指令集编写时序*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_ReadID</span><span class="params">(<span class="type">uint8_t</span>* mId,<span class="type">uint16_t</span>* dId)</span></span><br><span class="line">&#123;</span><br><span class="line">	    MySPI_Start();</span><br><span class="line">	</span><br><span class="line">		MySPI_SwapByte(<span class="number">0x9F</span>);<span class="comment">//发送读取厂商ID和设备ID的指令码</span></span><br><span class="line">	</span><br><span class="line">		*mId = MySPI_SwapByte(<span class="number">0xFF</span>);<span class="comment">//交换数据得到从机返回的第一个字节厂商ID，主机随便发送什么默认0xFF</span></span><br><span class="line">	</span><br><span class="line">		*dId = MySPI_SwapByte(<span class="number">0xFF</span>);<span class="comment">//交换数据得到从机返回的第二个字节设备ID(前8bit为存储器类型，后8bit为存储器大小)，主机随便发送什么默认0xFF</span></span><br><span class="line">		*dId &lt;&lt;= <span class="number">8</span>; <span class="comment">//设置16bit高8位</span></span><br><span class="line">	</span><br><span class="line">		*dId |= MySPI_SwapByte(<span class="number">0xFF</span>);<span class="comment">//设置16bit低8位，不能直接等于，否则高八位会被置0</span></span><br><span class="line">		</span><br><span class="line">	  MySPI_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>测试代码：先使用该读取ID的代码测试是否能使用SPI</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c业务代码*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;W25Q64.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="type">uint8_t</span> mid=<span class="number">0x00</span>;</span><br><span class="line">		<span class="type">uint16_t</span> did=<span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">	  	UsartInit();</span><br><span class="line"></span><br><span class="line">		W25Q64_Init();</span><br><span class="line"></span><br><span class="line">		W25Q64_ReadID(&amp;mid,&amp;did);</span><br><span class="line">	  	UsartSendNum(mid,<span class="number">2</span>);</span><br><span class="line">	  	UsartSendNum(did,<span class="number">4</span>);</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;	</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们读取的指令码为0x9F，对应手册上收到的应该是</p>
<p>厂商ID：0xEF</p>
<p>设备ID：0x4017</p>
<p>将OLED上显示或者串口发送的结果对比发现正确</p>
</blockquote>
<h4 id="W25Q64完整代码"><a href="#W25Q64完整代码" class="headerlink" title="W25Q64完整代码"></a>W25Q64完整代码</h4><blockquote>
<p><strong>由于每次操作需要我们判断是否芯片是否处于BUSY，所有我们可以在每次写操作的时候进行等待BUSY位。等待分为事前等待和事后等待</strong></p>
<p><code>事前等待</code>：在写操作开始前调用W25Q64_WaitBusy等待BUSY位置0</p>
<p><code>事后等待</code>：在写操作结束后需要调用W25Q64_WaitBusy</p>
<p><strong>两者区别：</strong></p>
<ol>
<li><p><strong>事后等待比事前等待更保险，事后等待可以保证在进行写操作之外的地方芯片肯定不处于BUSY状态，保证安全。</strong></p>
</li>
<li><p><strong>事前等待效率比事后等待效率高，可以在执行完写操作后执行其他代码，刚好可以利用这段代码来消耗等待时间</strong></p>
</li>
<li><p><strong>事前等待需要在读取和写入前都要调用。因为读的时候也需要在BUSY位不为1的时候。而事后等待只需要在写入后调用</strong></p>
</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*W25Q64.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __W25Q64_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __W25Q64_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_ReadID</span><span class="params">(<span class="type">uint8_t</span>* mId,<span class="type">uint16_t</span>* dId)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_PageProgram</span><span class="params">(<span class="type">uint32_t</span> Address,<span class="type">uint8_t</span>* DataArray,<span class="type">uint16_t</span> count)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_SectorErase</span><span class="params">(<span class="type">uint32_t</span> Address)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_ReadData</span><span class="params">(<span class="type">uint32_t</span> Address,<span class="type">uint8_t</span>* DataArray,<span class="type">uint32_t</span> count)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//void W25Q64_WriteEnble();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void W25Q64_WaitBusy();</span></span><br><span class="line"><span class="comment">/*这两个函数为了模块化，不用外部调用了*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*W25Q64.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MySPI.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;W25Q64_Ins.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	  MySPI_Init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*查看芯片手册对应指令集编写时序！！！*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_ReadID</span><span class="params">(<span class="type">uint8_t</span>* mId,<span class="type">uint16_t</span>* dId)</span></span><br><span class="line">&#123;</span><br><span class="line">	  MySPI_Start();</span><br><span class="line">	</span><br><span class="line">		MySPI_SwapByte(W25Q64_JEDEC_ID);<span class="comment">//发送读取厂商ID和设备ID的指令码</span></span><br><span class="line">	</span><br><span class="line">		*mId = MySPI_SwapByte(W25Q64_DUMMY_BYTE);<span class="comment">//交换数据得到从机返回的第一个字节厂商ID，主机随便发送什么默认0xFF</span></span><br><span class="line">	</span><br><span class="line">		*dId = MySPI_SwapByte(W25Q64_DUMMY_BYTE);<span class="comment">//交换数据得到从机返回的第二个字节设备ID(前8bit为存储器类型，后8bit为存储器大小)，主机随便发送什么默认0xFF</span></span><br><span class="line">		*dId &lt;&lt;= <span class="number">8</span>; <span class="comment">//设置16bit高8位</span></span><br><span class="line">	</span><br><span class="line">		*dId |= MySPI_SwapByte(W25Q64_DUMMY_BYTE);<span class="comment">//设置16bit低8位，不能直接等于，否则高八位会被置0</span></span><br><span class="line">		</span><br><span class="line">	  MySPI_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每次写之前都要写使能</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_WriteEnble</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">		MySPI_Start();</span><br><span class="line">		</span><br><span class="line">		MySPI_SwapByte(W25Q64_WRITE_ENABLE);</span><br><span class="line">		</span><br><span class="line">		MySPI_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待状态寄存器BUSY位</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_WaitBusy</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="type">uint32_t</span> Timeout=<span class="number">100000</span>;</span><br><span class="line">		MySPI_Start();</span><br><span class="line">	</span><br><span class="line">		MySPI_SwapByte(W25Q64_READ_STATUS_REGISTER_1);</span><br><span class="line">		<span class="keyword">while</span>((MySPI_SwapByte(W25Q64_DUMMY_BYTE) &amp; <span class="number">0x01</span>) == <span class="number">0x01</span>) <span class="comment">//状态寄存器有8位，最低位代表BUSY位，读取判断BUSY位若为1就一直等待</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/*状态寄存器可以被连续读取，如果不停止就会一直发送状态寄存器当前的值*/</span></span><br><span class="line">			Timeout--;</span><br><span class="line">			<span class="keyword">if</span>(Timeout == <span class="number">0</span>)<span class="comment">//超时退出避免程序卡死</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		MySPI_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//页编程，也就是写入数据到W25Q64。需要先写使能！！</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_PageProgram</span><span class="params">(<span class="type">uint32_t</span> Address,<span class="type">uint8_t</span>* DataArray,<span class="type">uint16_t</span> count)</span><span class="comment">//读取最大值count为256，所以要定义为uint16，uint8=255</span></span><br><span class="line">&#123;</span><br><span class="line">		W25Q64_WriteEnble();<span class="comment">//每次写入数据前都要进行写使能！！！，在这里可以方便我们避免每次都要手动写使能</span></span><br><span class="line">		MySPI_Start();</span><br><span class="line">		MySPI_SwapByte(W25Q64_PAGE_PROGRAM);</span><br><span class="line">	  MySPI_SwapByte(Address &gt;&gt; <span class="number">16</span>);<span class="comment">//取高8位</span></span><br><span class="line">		MySPI_SwapByte(Address &gt;&gt; <span class="number">8</span>); <span class="comment">//取中8位该函数只会发送8bit数据，高位会舍弃</span></span><br><span class="line">		MySPI_SwapByte(Address);<span class="comment">//取低8位发送</span></span><br><span class="line">	</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;count;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			MySPI_SwapByte(DataArray[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		MySPI_Stop();</span><br><span class="line">		</span><br><span class="line">		W25Q64_WaitBusy();<span class="comment">//写操作进行事后等待</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扇区擦除，其他擦除同理,Address为指定擦拭的4个字节，也就是1个扇区。需要先写使能！！</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_SectorErase</span><span class="params">(<span class="type">uint32_t</span> Address)</span></span><br><span class="line">&#123;</span><br><span class="line">	  W25Q64_WriteEnble(); <span class="comment">//每次写入数据前都要进行写使能！！！，在这里可以方便我们避免每次都要手动写使能</span></span><br><span class="line">		MySPI_Start();</span><br><span class="line">		MySPI_SwapByte(W25Q64_SECTOR_ERASE_4KB);</span><br><span class="line">	  MySPI_SwapByte(Address &gt;&gt; <span class="number">16</span>);<span class="comment">//取高8位</span></span><br><span class="line">		MySPI_SwapByte(Address &gt;&gt; <span class="number">8</span>); <span class="comment">//取中8位该函数只会发送8bit数据，高位会舍弃</span></span><br><span class="line">		MySPI_SwapByte(Address);<span class="comment">//取低8位发送</span></span><br><span class="line">		MySPI_Stop();</span><br><span class="line">	</span><br><span class="line">		W25Q64_WaitBusy();<span class="comment">//写操作进行事后等待</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_ReadData</span><span class="params">(<span class="type">uint32_t</span> Address,<span class="type">uint8_t</span>* DataArray,<span class="type">uint32_t</span> count)</span><span class="comment">//读取时数量没有限制</span></span><br><span class="line">&#123;</span><br><span class="line">		MySPI_Start();</span><br><span class="line">	  </span><br><span class="line">	  <span class="comment">//1.发送读取数据指令码</span></span><br><span class="line">		MySPI_SwapByte(W25Q64_READ_DATA);</span><br><span class="line">	  </span><br><span class="line">		<span class="comment">//2.发送读取的24位地址</span></span><br><span class="line">		MySPI_SwapByte(Address &gt;&gt; <span class="number">16</span>);<span class="comment">//取高8位</span></span><br><span class="line">		MySPI_SwapByte(Address &gt;&gt; <span class="number">8</span>); <span class="comment">//取中8位该函数只会发送8bit数据，高位会舍弃</span></span><br><span class="line">		MySPI_SwapByte(Address);<span class="comment">//取低8位发送</span></span><br><span class="line">	  </span><br><span class="line">		<span class="comment">//3.置换得到数据</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;count;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			DataArray[i]= MySPI_SwapByte(W25Q64_DUMMY_BYTE);<span class="comment">//发送0xFF将数据置换过来</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		MySPI_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;W25Q64.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="type">uint8_t</span> mid=<span class="number">0x00</span>;</span><br><span class="line">		<span class="type">uint16_t</span> did=<span class="number">0x00</span>;</span><br><span class="line">	</span><br><span class="line">	  	<span class="type">uint8_t</span> ArrayWrite[] = &#123;<span class="number">0xA1</span>,<span class="number">0xB2</span>,<span class="number">0xC3</span>,<span class="number">0xD4</span>&#125;;</span><br><span class="line">		<span class="type">uint8_t</span> ArrayRead[<span class="number">4</span>]; </span><br><span class="line"></span><br><span class="line">		W25Q64_Init();</span><br><span class="line">	  </span><br><span class="line">		W25Q64_ReadID(&amp;mid,&amp;did);</span><br><span class="line">	   </span><br><span class="line">		W25Q64_SectorErase(<span class="number">0x000000</span>);<span class="comment">//指定擦除扇区起始地址，后3位代表一个扇区内地址，6位代表块地址</span></span><br><span class="line">		W25Q64_PageProgram(<span class="number">0x000000</span>,ArrayWrite,<span class="number">4</span>);</span><br><span class="line">		</span><br><span class="line">		W25Q64_ReadData(<span class="number">0x000000</span>,ArrayRead,<span class="number">4</span>);</span><br><span class="line">		</span><br><span class="line"><span class="comment">//			OLED_ShowHexNum(2,3,ArrayWrite[0],2);</span></span><br><span class="line"><span class="comment">//			OLED_ShowHexNum(2,3,ArrayWrite[0],2);</span></span><br><span class="line"><span class="comment">//			OLED_ShowHexNum(2,3,ArrayWrite[0],2);</span></span><br><span class="line"><span class="comment">//			OLED_ShowHexNum(2,3,ArrayWrite[0],2);</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//			OLED_ShowHexNum(3,3,ArrayRead[0],2);</span></span><br><span class="line"><span class="comment">//			OLED_ShowHexNum(3,3,ArrayRead[0],2);</span></span><br><span class="line"><span class="comment">//			OLED_ShowHexNum(3,3,ArrayRead[0],2);</span></span><br><span class="line"><span class="comment">//			OLED_ShowHexNum(3,3,ArrayRead[0],2);</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;	</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>1.每次写入数据前要先写使能!!!</code></p>
<p><code>2.每次写入前一定要记得擦除!!!</code></p>
<p><strong>最终OLED上显示发送和读取的数据相同，断电后不写入直接读取数据也不变</strong></p>
</blockquote>
<h3 id="硬件SPI外设-硬件读写"><a href="#硬件SPI外设-硬件读写" class="headerlink" title="硬件SPI外设(硬件读写)"></a>硬件SPI外设(硬件读写)</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250105141343897-1752337644188-613.png" alt="image-20250105141343897"></p>
<blockquote>
<p>SPI最常用配置就是8位数据帧，高位先行。16位和低位先行用的很少</p>
<hr>
<p><code>时钟频率：</code><strong>SPI的时钟由PCLK(外设时钟)分频得来</strong>，可以2~256分频，时钟频率越快，对应传输速率越快。</p>
<p>频率不能任意指定，也就是说SPI的时钟频率只能是对面8种分频后对应的时钟频率，且对于SPI1和SPI2来说，PCLK也不相同，SPI1挂载在APB2，PCLK是72MHz，SPI2挂载在APB1，PCLK是36MHz</p>
<hr>
<p><code>多主机模型：</code>使用较少，可以看手册学习</p>
<p><code>主机或从机：</code>通常作为主机</p>
<hr>
<p><code>精简为半双工/单工通信：</code></p>
<p>可以节省一条数据线，半双工或单工通信。一般不适用</p>
<hr>
<p><code>DMA:</code>大量数据传输时使用</p>
<hr>
<p><code>兼容I2S协议：</code>数字音频传输专用协议，与SPI有一些共同特征</p>
<hr>
<p><code>以上所有内容都可以查看参考手册进行学习！！！</code></p>
</blockquote>
<h4 id="SPI框图"><a href="#SPI框图" class="headerlink" title="SPI框图"></a>SPI框图</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250108114540986-1752337644188-614.png" alt="image-20250108114540986"></p>
<blockquote>
<p>与对应寄存器描述结合理解</p>
<hr>
<p><code>左上角：</code>通过LSBFIRST控制位控制低位先行还是高位先行，移位寄存器通过MOSI和MISO，分别移动和接收一位位数据。SPI发送和接收可以同时进行</p>
<p>接收缓冲区：就是RDR寄存器</p>
<p>发送缓冲区：就是TDR寄存器</p>
<p>TDR和RDR占用同一个地址，统一叫作DR，写入经过RDR，发送数据经过TDR，对应也是TXE(发送寄存器空)和RXNE(接收寄存器非空)两个标志位</p>
<p><strong>移位寄存器配合数据寄存器实现连续数据流</strong>：</p>
<p>发送数据先写入TDR，再转到移位寄存器发送，发送的同时接收数据，接收的同时转到RDR，我们再从RDR读取数据</p>
<hr>
<p><code>左下角：</code></p>
<p>波特率发生器：内部有一个分频器，输入时钟为PCLK，72M或36M，经过分频器后输出到SCK，生成时钟与移位寄存器同步</p>
<hr>
<p><code>右下角:</code></p>
<p>LSBFIRST：用于控制高位先行还是低位先行</p>
<p>SPE：SPI使能位</p>
<p>BR2，BR1，BR0：用于控制分频系数</p>
<p>MSTR：配置主从模式</p>
<p>CPOL和CPHA：选择SPI四种模式</p>
<hr>
<p><code>右上角：</code></p>
<p>一些使能位与控制位，重要的是TXE和RXNE</p>
<hr>
<p><code>NSS引脚：</code>与多主机有关</p>
</blockquote>
<p><code>SPI外设基本结构:</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250108122752353-1752337644188-615.png" alt="image-20250108122752353"></p>
<blockquote>
<p><strong>TDR整体转入移位寄存器的时刻，置TXE标志位为1</strong></p>
<p><strong>移位寄存器数据整体转入RDR的时刻，置RXNE标志位为1</strong></p>
<hr>
<p><strong>图中没画出SS引脚，我们使用普通的GPIO口来模拟</strong></p>
</blockquote>
<h4 id="主模式全双工连续传输"><a href="#主模式全双工连续传输" class="headerlink" title="主模式全双工连续传输"></a>主模式全双工连续传输</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250108172721631-1752337644188-616.png" alt="image-20250108172721631"></p>
<blockquote>
<p>这里演示的是模式3，低位先行的模式：</p>
<p><strong>首先等待TXE&#x3D;1后就软件写入数据到SPI_DR(TDR)，TXE也就变为0，转入完成后，立马将数据再移动到移位寄存器，转入到移位寄存器瞬间把TXE置为1，表示发送寄存器空，波形产生开始传输，但此时又要立马把下个数据写入到TDR中</strong></p>
<hr>
<p>流程简述下来就是：</p>
<p>发送数据1、发送数据2– 接收数据1 –发送数据3 – 接收数据2 - 发送数据4 – 接收数据3</p>
<p>数据交换的流程是交叉的，要求很严格，对程序设计不太友好</p>
<p><strong>如果对效率要求很高，就可以研究这个</strong></p>
</blockquote>
<h4 id="非连续传输"><a href="#非连续传输" class="headerlink" title="非连续传输"></a>非连续传输</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250108174720946-1752337644188-617.png" alt="image-20250108174720946"></p>
<blockquote>
<p>这里演示的是模式3，低位先行的模式：</p>
<p><strong>接收时序与发送时序是同步的，具体见连续传输的图，因为是主机和从机交换字节发送所以发送的同时也在接收。但是必须先发送才会产生时序，然后才会有接收！！！</strong></p>
<p>首先等待TXE&#x3D;1后就软件写入数据到SPI_DR(TDR)，TXE也就变为0，转入完成后，立马将数据再移动到移位寄存器，转入到移位寄存器瞬间把TXE置为1，表示发送寄存器空，一旦移位寄存器有数据了，<strong>时序波形会自动产生</strong>，开始交换数据</p>
<p><strong>此时不立马将下个数据写入TDR，而是等待第一个字节时序结束，意味着接收第一个字节也结束了，RXNE置1，先把第一个接收到的数据读出来，之后再写入数据2</strong></p>
<p><strong>流程即：四行代码完成任务</strong></p>
<p>第1步：等待TXE为1</p>
<p>第2步：写入发送的数据至TDR</p>
<p>第3步：等待RXNE为1</p>
<p>第4步：读取RDR接收的数据</p>
<p>然后重复第2、3、….字节</p>
<p>所以我们只需要将这四步封装到一个函数中就可以实现字节的交换，与软件SPI的流程基本上是一样的。</p>
<hr>
<p><code>非连续与连续传输的区别：</code>没有及时将数据送入TDR寄存器，等到第一个字节时序完成后，第二个字节还没有送过来，数据传输就会等候，所以时钟和数据的时序在字节与字节之间产生了间隙，拖慢了整体数据传输的速度。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250108175801926-1752337644188-618.png" alt="image-20250108175801926"></p>
<p>间隙在SCK频率低时影响不大，但在非常高时就非常严重</p>
<p>频率在2分频下的波形：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250108181920148-1752337644188-619.png" alt="image-20250108181920148"></p>
<p>可以看到等待时间都远大于数据交换时间了</p>
<p><code>所以我们要在想在极限频率下，进一步提高数据传输速率，我们需要使用连续传输模式，或者使用DMA</code></p>
</blockquote>
<h4 id="TXE和RXNE标志位清除问题"><a href="#TXE和RXNE标志位清除问题" class="headerlink" title="TXE和RXNE标志位清除问题"></a>TXE和RXNE标志位清除问题</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250108211408772-1752337644188-620.png" alt="image-20250108211408772"></p>
<blockquote>
<p><strong>手册上的描述，TXE和RXNE会在写入DR和读DR的时候由硬件清除</strong></p>
<p><strong>所以我们不需要手动调用ClearFlag清除标志位</strong></p>
</blockquote>
<h4 id="连续和非连续的优缺点"><a href="#连续和非连续的优缺点" class="headerlink" title="连续和非连续的优缺点"></a>连续和非连续的优缺点</h4><blockquote>
<p><code>非连续传输：</code></p>
<p>好处：容易封装，好理解，好用</p>
<p>缺点：会损失一点点性能</p>
<hr>
<p><code>连续传输:对传输效率有要求的话可以使用</code></p>
<p>好处：传输更快</p>
<p>缺点：操作起来相对复杂，对软件的需求较高，每个标志位产生后数据都要及时处理</p>
</blockquote>
<h4 id="软件硬件波形对比"><a href="#软件硬件波形对比" class="headerlink" title="软件硬件波形对比"></a>软件硬件波形对比</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250108182601125-1752337644188-621.png" alt="image-20250108182601125"></p>
<blockquote>
<p><code>区别：</code></p>
<p>下降沿和低电平期间，都可以作为数据变化的时刻，只是硬件波形一般会紧贴边沿，软件波形，一般只能在电平期间，无论哪种方式都不会影响数据传输。</p>
<p>对于软件波形，尽量要贴近边沿，否则等待太久贴近下一个边沿了数据也会容易出错</p>
</blockquote>
<h4 id="SPI库函数"><a href="#SPI库函数" class="headerlink" title="SPI库函数"></a>SPI库函数</h4><p><strong>标准库函数中包含的SPI很多名称中带有I2S相关的函数，因为I2S与SPI共用一套电路。直接使用即可</strong></p>
<ul>
<li><code>初始化：</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_I2S_DeInit</span><span class="params">(SPI_TypeDef* SPIx)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">I2S_Init</span><span class="params">(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">I2S_StructInit</span><span class="params">(I2S_InitTypeDef* I2S_InitStruct)</span>;</span><br><span class="line"><span class="comment">/*-----------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SPI_Init</span><span class="params">(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SPI_StructInit</span><span class="params">(SPI_InitTypeDef* SPI_InitStruct)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>外设使能：</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_Cmd</span><span class="params">(SPI_TypeDef* SPIx, FunctionalState NewState)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2S_Cmd</span><span class="params">(SPI_TypeDef* SPIx, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>中断配置：</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_I2S_ITConfig</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint8_t</span> SPI_I2S_IT, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>DMA：</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_I2S_DMACmd</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint16_t</span> SPI_I2S_DMAReq, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>发送和接收数据：</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_I2S_SendData</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint16_t</span> Data)</span>;</span><br><span class="line"><span class="comment">//数据到DR</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">SPI_I2S_ReceiveData</span><span class="params">(SPI_TypeDef* SPIx)</span>;</span><br><span class="line"><span class="comment">//从DR读数据</span></span><br></pre></td></tr></table></figure>

<hr>
<p><code>不常用函数：</code></p>
<ul>
<li><code>NSS引脚配置：</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_NSSInternalSoftwareConfig</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint16_t</span> SPI_NSSInternalSoft)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SPI_SSOutputCmd</span><span class="params">(SPI_TypeDef* SPIx, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>数据帧位数配置：</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_DataSizeConfig</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint16_t</span> SPI_DataSize)</span>;</span><br><span class="line"><span class="comment">//8位或16为数据帧配置</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>CRC校验配置：</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_TransmitCRC</span><span class="params">(SPI_TypeDef* SPIx)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SPI_CalculateCRC</span><span class="params">(SPI_TypeDef* SPIx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">SPI_GetCRC</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint8_t</span> SPI_CRC)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">SPI_GetCRCPolynomial</span><span class="params">(SPI_TypeDef* SPIx)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>半双工时双向线的方向配置：</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_BiDirectionalLineConfig</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint16_t</span> SPI_Direction)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>标志位：</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FlagStatus <span class="title function_">SPI_I2S_GetFlagStatus</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint16_t</span> SPI_I2S_FLAG)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SPI_I2S_ClearFlag</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint16_t</span> SPI_I2S_FLAG)</span>;</span><br><span class="line">ITStatus <span class="title function_">SPI_I2S_GetITStatus</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint8_t</span> SPI_I2S_IT)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SPI_I2S_ClearITPendingBit</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint8_t</span> SPI_I2S_IT)</span>;</span><br></pre></td></tr></table></figure>









<h4 id="硬件SPI初始化流程"><a href="#硬件SPI初始化流程" class="headerlink" title="硬件SPI初始化流程"></a>硬件SPI初始化流程</h4><blockquote>
<p>根据SPI框图：</p>
<ol>
<li>开启RCC对应SPI和GPIO口的时钟</li>
<li>初始化GPIO口，SCK和MOSI是硬件控制输出的信号，配置为<strong>复用推挽输出</strong>。MISO是，是硬件外设配置的输入信号，配置为<strong>上拉输入</strong>。还有一个SS引脚，使用软件模拟控制的输出信号，配置为<strong>通用推挽输出</strong>即可</li>
<li>配置SPI外设，调用SPI_Init配置各参数即可</li>
<li>使能，开关控制，调用SPI_Cmd即可</li>
<li>默认SS为高电平，不使用从机</li>
</ol>
</blockquote>
<h4 id="硬件SPI读写W25Q64"><a href="#硬件SPI读写W25Q64" class="headerlink" title="硬件SPI读写W25Q64"></a>硬件SPI读写W25Q64</h4><blockquote>
<p>对于W25Q64Q驱动层的代码我们不需要修改，我们只需要修改底层SPI代码即可</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MySPI.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYSPI_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYSPI_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Start</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Stop</span><span class="params">()</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MySPI_SwapByte</span><span class="params">(<span class="type">uint8_t</span> ByteSend)</span>;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MySPI.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写SS</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_W_SS</span><span class="params">(<span class="type">uint8_t</span> BitVal)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	GPIO_WriteBit(GPIOA,GPIO_Pin_4,(BitAction)BitVal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	  <span class="comment">//1.开启对应引脚RCC</span></span><br><span class="line">		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	  <span class="comment">//2.配置GPIO</span></span><br><span class="line">		<span class="comment">/*SCK和MOSI复用推挽输出引脚*/</span></span><br><span class="line">	  GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">	  GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">	  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_7;</span><br><span class="line">	  GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	  GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line">	  </span><br><span class="line">	  <span class="comment">/*使用软件模拟SS，SS通用推挽输出引脚*/</span>  </span><br><span class="line">	  GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_4;</span><br><span class="line">	  GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	  GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line">	</span><br><span class="line">		<span class="comment">/*MISO上拉输入引脚*/</span></span><br><span class="line">	  GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_6;</span><br><span class="line">	  GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">		GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line">	  </span><br><span class="line">		<span class="comment">//3.配置SPI</span></span><br><span class="line">	  SPI_InitTypeDef SPI_InitStruct;</span><br><span class="line">	  SPI_InitStruct.SPI_Mode = SPI_Mode_Master;<span class="comment">//选择主机</span></span><br><span class="line">	  SPI_InitStruct.SPI_Direction = SPI_Direction_2Lines_FullDuplex;<span class="comment">//选择全双工</span></span><br><span class="line">	  SPI_InitStruct.SPI_DataSize = SPI_DataSize_8b;</span><br><span class="line">	  SPI_InitStruct.SPI_FirstBit = SPI_FirstBit_MSB;<span class="comment">//8位先行</span></span><br><span class="line">	  SPI_InitStruct.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_128;<span class="comment">//频率为72Mhz/128 = 500多khz</span></span><br><span class="line">	  SPI_InitStruct.SPI_CPHA = SPI_CPHA_1Edge;</span><br><span class="line">	  SPI_InitStruct.SPI_CPOL = SPI_CPOL_Low;</span><br><span class="line">	  SPI_InitStruct.SPI_NSS = SPI_NSS_Soft;<span class="comment">//我们使用的GPIO引脚模拟，使用软件NSS</span></span><br><span class="line">	  SPI_InitStruct.SPI_CRCPolynomial = <span class="number">7</span>;<span class="comment">//我们不使用CRC校验，只需要随便给个值即可</span></span><br><span class="line">	  SPI_Init(SPI1,&amp;SPI_InitStruct);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//4.使能</span></span><br><span class="line">	  SPI_Cmd(SPI1,ENABLE);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//5.默认不选中从机</span></span><br><span class="line">	  MySPI_W_SS(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SPI起始条件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	MySPI_W_SS(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SPI终止条件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Stop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	 MySPI_W_SS(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//SPI字节交换，硬件自动控制SCK、MOSI、MISO引脚</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MySPI_SwapByte</span><span class="params">(<span class="type">uint8_t</span> ByteSend)</span></span><br><span class="line">&#123;   </span><br><span class="line">	<span class="comment">/*对应非连续传输的四个步骤*/</span></span><br><span class="line">		<span class="comment">//1.等待TXE为1，代表发送数据寄存器为空，可以写入数据了</span></span><br><span class="line">		<span class="keyword">while</span>(SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_TXE) != SET)</span><br><span class="line">		&#123;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2.写入发送数据到TDR(发送数据寄存器)，同时自动清除TXE</span></span><br><span class="line">		SPI_I2S_SendData(SPI1,ByteSend);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//3.等待RXNE为1，接收数据寄存器非空，代表接收完成</span></span><br><span class="line">		<span class="keyword">while</span>(SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_RXNE) != SET)</span><br><span class="line">		&#123;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//4.从RDR(接收数据寄存器)读取接收到的数据，同时自动清除RXNE</span></span><br><span class="line">		<span class="keyword">return</span> SPI_I2S_ReceiveData(SPI1);</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="RTC"><a href="#RTC" class="headerlink" title="RTC"></a>RTC</h1><h2 id="常识"><a href="#常识" class="headerlink" title="常识"></a>常识</h2><h3 id="Unix时间戳"><a href="#Unix时间戳" class="headerlink" title="Unix时间戳"></a>Unix时间戳</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250109131815285-1752337644188-622.png" alt="image-20250109131815285"></p>
<blockquote>
<p><code>时间戳：</code>1970年1月1日0时0分0秒开始所经过的秒数，没有进位，不同时区通过对秒计数器添加偏移就可以得到当地时间</p>
<p>计算机底层使用时间戳会很方便，只需要一个很大的寄存器存储秒数即可</p>
<p>给人类观看的时候，只需要将时间戳转换为对应的日期即可</p>
<p>但是，时间戳比较占用软件资源，在每次进行秒计数器和日期时间转换时，软件都需要经过比较复杂的运算</p>
</blockquote>
<h3 id="RTC-GMT"><a href="#RTC-GMT" class="headerlink" title="RTC&#x2F;GMT"></a>RTC&#x2F;GMT</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250109133115489-1752337644188-623.png" alt="image-20250109133115489"></p>
<blockquote>
<p><code>闰秒：</code>由于地球自转会越转越慢，地球自转一周的时间会变化，当地球自转一周的时间与原子钟计时一天的时间相差超过0.9s时，UTC就会执行闰秒操作，即多走1s来等等地球，1分钟可能会出现61s。、</p>
<p>现在世界使用的就是UTC</p>
</blockquote>
<h3 id="时间戳转换"><a href="#时间戳转换" class="headerlink" title="时间戳转换"></a>时间戳转换</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250109134112560-1752337644188-624.png" alt="image-20250109134112560"></p>
<blockquote>
<p>localtime是在gmtime的基础上，加一个时区偏移得到</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250109134249030-1752337644188-625.png" alt="image-20250109134249030"></p>
<h2 id="BKP简介"><a href="#BKP简介" class="headerlink" title="BKP简介"></a>BKP简介</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250109135916881-1752337644188-626.png" alt="image-20250109135916881"></p>
<blockquote>
<p>BKP其实就是一个存储器，只有当VDD和VBAT都断电了数据才会清零</p>
<hr>
<p>TAMPER引脚：侵入事件将所有备份寄存器内容清除，用于安全等</p>
<hr>
<p>RTC引脚：输出RTC校准时钟，或输出RTC闹钟脉冲</p>
<hr>
<p>BKP20字节：中容量和小容量</p>
<p>BKP84字节：大容量和互联型</p>
</blockquote>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250109142941243-1752337644188-627.png" alt="image-20250109142941243"></p>
<blockquote>
<p>橙色部分叫后备区域，BKP处于后备区域，但后备区域不只有BKP，还有RTC相关电路</p>
<p><code>后备区域特性：</code>当VDD主电源掉电时，后备区域仍可以由VBAT的备用电池供电，当VDD主电源上电时，后备区域供电会由VBAT切换到VDD，也就是在主电源有电时，VBAT不会用到，这样可以节省电池电量。</p>
<p>每个数据寄存器空间为2个字节</p>
<hr>
<p><code>BKP的几个功能：</code></p>
<ul>
<li><strong>侵入检测</strong>：可以从PC13位置的TAMPER引脚引入一个检测信号，当TAMPER产生上升沿或者下降沿时，清除BKP所有的内容，以保证安全</li>
<li><strong>时钟输出</strong>：可以从PC13位置的RTC引脚输出出去，供外部使用，其中输出RTC校准时钟时配合校准寄存器可以对RTC的误差进行校准</li>
</ul>
</blockquote>
<h3 id="BKP库函数"><a href="#BKP库函数" class="headerlink" title="BKP库函数"></a>BKP库函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BKP_DeInit</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//手动清空bkp所有寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BKP_TamperPinLevelConfig</span><span class="params">(<span class="type">uint16_t</span> BKP_TamperPinLevel)</span>;</span><br><span class="line"><span class="comment">//配置tamper引脚有效电平</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BKP_TamperPinCmd</span><span class="params">(FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">//是否开启侵入检测功能</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BKP_ITConfig</span><span class="params">(FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">//BKP中断配置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BKP_RTCOutputConfig</span><span class="params">(<span class="type">uint16_t</span> BKP_RTCOutputSource)</span>;</span><br><span class="line"><span class="comment">//BKP时钟输出配置，可选择输入RTC校准时钟，RTC闹钟脉冲或秒脉冲</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BKP_SetRTCCalibrationValue</span><span class="params">(<span class="type">uint8_t</span> CalibrationValue)</span>;</span><br><span class="line"><span class="comment">//设置RTC校准值，写入RTC校准寄存器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BKP_WriteBackupRegister</span><span class="params">(<span class="type">uint16_t</span> BKP_DR, <span class="type">uint16_t</span> Data)</span>;</span><br><span class="line"><span class="comment">//写备份寄存器</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">BKP_ReadBackupRegister</span><span class="params">(<span class="type">uint16_t</span> BKP_DR)</span>;</span><br><span class="line"><span class="comment">//读备份寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*标志位相关函数*/</span></span><br><span class="line">FlagStatus <span class="title function_">BKP_GetFlagStatus</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BKP_ClearFlag</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">ITStatus <span class="title function_">BKP_GetITStatus</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BKP_ClearITPendingBit</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>



<h3 id="读写BKP"><a href="#读写BKP" class="headerlink" title="读写BKP"></a>读写BKP</h3><blockquote>
<ul>
<li><code>使用BKP或RTC必须先执行前两步：</code></li>
</ul>
<ol>
<li>开启PWR和BKP时钟</li>
<li>设置PWR，使能BKP和RTC的访问</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;W25Q64.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> test = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//1.开启对应BKP和PWR时钟</span></span><br><span class="line">	  		RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR|RCC_APB1Periph_BKP,ENABLE);</span><br><span class="line">		<span class="comment">//2.使能PWR，使能BKP和RTC的访问</span></span><br><span class="line">	  PWR_BackupAccessCmd(ENABLE);</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//3.写bkp寄存器</span></span><br><span class="line">	  BKP_WriteBackupRegister(BKP_DR1,<span class="number">0x1234</span>);<span class="comment">//写入DR1寄存器，uint16_t</span></span><br><span class="line">    </span><br><span class="line">	    <span class="comment">//4.读bkp寄存器</span></span><br><span class="line">	  test = BKP_ReadBackupRegister(BKP_DR1);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;	</span><br><span class="line">				 </span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="RTC外设"><a href="#RTC外设" class="headerlink" title="RTC外设"></a>RTC外设</h2><h3 id="RTC简介"><a href="#RTC简介" class="headerlink" title="RTC简介"></a>RTC简介</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250109144513674-1752337644188-628.png" alt="image-20250109144513674"></p>
<blockquote>
<p>其中计数都是用一个秒计数器，对应Unix的时间戳，使用c库中的time.h库中localtime函数可以得到年月日时分秒信息了。</p>
<hr>
<p>RTC可选三种时钟源输入：HSE、LSE、LSI</p>
<p><strong>一般都使用LSE：32.768KHz 提供给RTC时钟</strong></p>
<p>特殊情况下，HSE和LSI为备选时钟</p>
<p><code>选择LSE原因：</code><strong>HSE和LSI都有自己的用途，而LSE是专用，同时只有LSE时钟可以通过VBAT备用电池供电，HSE和LSI在主电源掉电后是停止运行的。</strong></p>
<p><code>所以要想实现RTC主电源掉电继续走时的功能，必须选择RTC专用时钟LSE</code></p>
<hr>
<p><code>BKP和RTC内容都可以在参考手册中查看！！！</code></p>
</blockquote>
<h3 id="RTC框图"><a href="#RTC框图" class="headerlink" title="RTC框图"></a>RTC框图</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250109145649841-1752337644188-629.png" alt="image-20250109145649841"></p>
<blockquote>
<p><strong>图中灰色部分都处于后备区域，主电源掉电后，可以使用备用电池供电</strong></p>
<p><code>左边：核心的分频和计数计时部分</code></p>
<p><strong>RTCCLK</strong>：为时钟来源在RCC配置，主要选择LSE</p>
<p><strong>RTC预分频器</strong>：实际上就是一个计数器，计几个数就溢出1次就是几分频。由重装载寄存器RTC_PRL(相当于ARR)，和余数寄存器RTC_DIV(相当于CNT计数器，但是为自减计数器)。</p>
<p>若RTC_PRL&#x3D;32768，来一个输入时钟RTC_DIV自减一次，直到变为0，然后再来一个输入时钟就会产生一个溢出信号，同时DIV变回32767。也就是每来32768个输入脉冲计数器就溢出一次，产生一个输出脉冲，也就是产生了32768分频，分频后输出的时钟频率为1Hz，也就是1s提供给后续</p>
<p><strong>RTC_CNT</strong>：就是Unix时间戳的秒计数器</p>
<p><code>RTC_ALR：</code>闹钟寄存器RTC_ALR，32位值，可以在其写入一个秒数，设定闹钟，当RTC_CNT &#x3D;&#x3D; RTC_ALR，这时闹钟响了就会产生RTC_Alarm信号，通往右边的中断系统，执行对应操作，同时闹钟信号RTC_Alarm可以让STM32退出待机模式。</p>
<p><strong>可以实现定时唤醒待机芯片采集数据，完成后继续待机，以节省电源的作用</strong></p>
<hr>
<p><code>右边：中断使能和NVIC部分</code></p>
<p><strong>RTC_Second</strong>：秒信号，触发秒中断，每秒触发一次中断</p>
<p><strong>RTC_Overflow</strong>：溢出信号，触发溢出中断，计数值溢出触发一次中断，这个一般不会触发</p>
<p><strong>RTC_Alarm</strong>：闹钟信号，触发闹钟中断，可以设定闹钟或者唤醒待机设备</p>
<hr>
<p><code>上边：AP1总线相关部分</code></p>
<p>读写寄存器可以通过APB1总线完成，且RTC是APB1总线上的设备</p>
<hr>
<p><code>下边：PWR关联的部分</code></p>
</blockquote>
<h3 id="RTC基本结构"><a href="#RTC基本结构" class="headerlink" title="RTC基本结构"></a>RTC基本结构</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250109151703477-1752337644188-630.png" alt="image-20250109151703477"></p>
<h3 id="硬件电路-5"><a href="#硬件电路-5" class="headerlink" title="硬件电路"></a>硬件电路</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250109151911012-1752337644188-631.png" alt="image-20250109151911012"></p>
<blockquote>
<p>在最小系统的电路上需要额外添加两个部分：</p>
<ol>
<li><p>**备用电池电路：**根据数据手册得到简单连接，参考手册得到推荐连接</p>
<p>图右上角：使用3V纽扣电池充当备用电池，型号位CR2032&#x2F;CR1220等，有字的那面为正极</p>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250109152015914-1752337644188-632.png" alt="image-20250109152015914"></p>
<p><strong>画板子设计产品应该选择推荐连接方案更保险</strong></p>
<ol start="2">
<li>**外部低速晶振：**根据参考手册设计</li>
</ol>
<p>图右下角：黑色的为外部低速晶振32.768khz，白色的为外部高速8Mhz晶振</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250109152430959-1752337644188-633.png" alt="image-20250109152430959"></p>
</blockquote>
<h3 id="RTC操作注意事项"><a href="#RTC操作注意事项" class="headerlink" title="RTC操作注意事项"></a>RTC操作注意事项</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250109152914363-1752337644188-634.png" alt="image-20250109152914363"></p>
<blockquote>
<ul>
<li><code>使用BKP或RTC必须先执行前两步：</code></li>
</ul>
<ol>
<li>开启PWR和BKP时钟</li>
<li>设置PWR，使能BKP和RTC的访问</li>
</ol>
<hr>
<ul>
<li>由于APB1和RTC_CRL使用的是不同时钟，面临着同步问题，所以需要在初始化时，调用一个等待同步的函数</li>
</ul>
<hr>
<ul>
<li>RTC有一个进入配置模式的标志位，必须先将RTC中的RTC_CRL中的CNF标志位置1才能进入配置模式。</li>
</ul>
<p>当然，在每个写入寄存器的库函数中都自动加上了这个操作，我们可以不用写</p>
<hr>
<ul>
<li>每次写入操作，都需要等待RTC_CR中的RTOFF标志位，只有为1时才能写入RTC寄存器。也就是调用一个等待上一个任务函数</li>
</ul>
<p>原因：因为PCLK1和RTCCLK时钟频率不一样，使用PCLK1的频率写入后，这个值不能直接更新到RTC寄存器中，因为RTC是由RTCCLK驱动，所以PCLK1写完后需要等一下RTCCLK时钟，RTCCLK来一个上升沿使值更新到RTC寄存器中</p>
</blockquote>
<h3 id="RCC库函数"><a href="#RCC库函数" class="headerlink" title="RCC库函数"></a>RCC库函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RCC_LSEConfig</span><span class="params">(<span class="type">uint8_t</span> RCC_LSE)</span>;<span class="comment">//配置LSE外部低速时钟</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_LSICmd</span><span class="params">(FunctionalState NewState)</span>;<span class="comment">//配置LSI内部低速时钟</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_RTCCLKConfig</span><span class="params">(<span class="type">uint32_t</span> RCC_RTCCLKSource)</span>;<span class="comment">//RTCCLK配置，配置时钟源选择</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_RTCCLKCmd</span><span class="params">(FunctionalState NewState)</span>;<span class="comment">//在调用上面的RTCCLK配置函数后，需要再次调用该函数使能</span></span><br><span class="line"></span><br><span class="line">FlagStatus <span class="title function_">RCC_GetFlagStatus</span><span class="params">(<span class="type">uint8_t</span> RCC_FLAG)</span>;<span class="comment">//调用时钟启动函数后需要该函数等待LSERDY标志位置1，时钟才算启动完成稳定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_GetClocksFreq</span><span class="params">(RCC_ClocksTypeDef* RCC_Clocks)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_AHBPeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_AHBPeriph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB2PeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB2Periph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB1PeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB1Periph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB2PeriphResetCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB2Periph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB1PeriphResetCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB1Periph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_BackupResetCmd</span><span class="params">(FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_ClockSecuritySystemCmd</span><span class="params">(FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_MCOConfig</span><span class="params">(<span class="type">uint8_t</span> RCC_MCO)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_ClearFlag</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">ITStatus <span class="title function_">RCC_GetITStatus</span><span class="params">(<span class="type">uint8_t</span> RCC_IT)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_ClearITPendingBit</span><span class="params">(<span class="type">uint8_t</span> RCC_IT)</span>;</span><br></pre></td></tr></table></figure>



<h3 id="RTC库函数"><a href="#RTC库函数" class="headerlink" title="RTC库函数"></a>RTC库函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RTC_ITConfig</span><span class="params">(<span class="type">uint16_t</span> RTC_IT, FunctionalState NewState)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_EnterConfigMode</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//RTC进入配置模式</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_ExitConfigMode</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//RTC退出配置模式</span></span><br><span class="line"><span class="type">uint32_t</span>  <span class="title function_">RTC_GetCounter</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//RTC获取CNT计数器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_SetCounter</span><span class="params">(<span class="type">uint32_t</span> CounterValue)</span>;<span class="comment">//写入CNT</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_SetPrescaler</span><span class="params">(<span class="type">uint32_t</span> PrescalerValue)</span>;<span class="comment">//写入预分频器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_SetAlarm</span><span class="params">(<span class="type">uint32_t</span> AlarmValue)</span>;<span class="comment">//RTC写入闹钟值,该该寄存器是只写的不可读</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span>  <span class="title function_">RTC_GetDivider</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//读取预分频器种的DIV余数寄存器，</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*注意事项中的两个等待函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_WaitForLastTask</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//等待上次操作完成，循环直到RTOFF状态位为1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_WaitForSynchro</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//等待同步，等待RSF置1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*标志位相关函数*/</span></span><br><span class="line">FlagStatus <span class="title function_">RTC_GetFlagStatus</span><span class="params">(<span class="type">uint16_t</span> RTC_FLAG)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_ClearFlag</span><span class="params">(<span class="type">uint16_t</span> RTC_FLAG)</span>;</span><br><span class="line">ITStatus <span class="title function_">RTC_GetITStatus</span><span class="params">(<span class="type">uint16_t</span> RTC_IT)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_ClearITPendingBit</span><span class="params">(<span class="type">uint16_t</span> RTC_IT)</span>;</span><br></pre></td></tr></table></figure>





<h3 id="RTC配置"><a href="#RTC配置" class="headerlink" title="RTC配置"></a>RTC配置</h3><ol>
<li><strong>开启PWR和BKP时钟，设置PWR，使能BKP和RTC的访问</strong></li>
<li><strong>使用RCC开启LSE时钟(LSE不行的话换成40khz的LSI)，且使用RCC开启LSE时钟(LSE省电默认关闭)，且等待LSERDY标志位为1</strong></li>
<li><strong>配置RTCCLK时钟源，指定LSE为RTCCLK时钟源，并且调用RTCCLK_Cmd使能</strong></li>
<li><strong>调用两个等待函数，注意事项中的等待同步与等待上一次操作完成</strong></li>
<li><strong>配置预分频器，RTC_SetPrescaler，并且再调用等待上一次操作完成函数</strong></li>
<li><strong>配置CNT,并且再调用等待上一次操作完成函数</strong></li>
<li>如果有闹钟值则配置闹钟</li>
<li>如果有中断就配置中断</li>
</ol>
<blockquote>
<p>RTC没有结构体进行配置，且没有Cmd函数，开启时钟后就会运行</p>
</blockquote>
<h3 id="RTC显示当前时间"><a href="#RTC显示当前时间" class="headerlink" title="RTC显示当前时间"></a>RTC显示当前时间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MyRTC.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYRTC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYRTC_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint16_t</span> MyRTC_Time[];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_SetTime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_ReadTime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MyRTC.C*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;time.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyRTC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> MyRTC_Time[] = &#123;<span class="number">2025</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">00</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//1.开启BKP和PWR时钟,设置PWR，使能BKP和RTC的访问</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_BKP|RCC_APB1Periph_PWR,ENABLE);</span><br><span class="line">	PWR_BackupAccessCmd(ENABLE);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.使用RCC开启LSE时钟,等待LSERDY标志位为1</span></span><br><span class="line">	RCC_LSEConfig(RCC_LSE_ON);<span class="comment">//使用LSI修改处1：RCC_LSICmd(ENABLE);</span></span><br><span class="line">  <span class="keyword">while</span>(RCC_GetFlagStatus(RCC_FLAG_LSERDY)!= SET)<span class="comment">//使用LSI修改处2：RCC_FLAG_LSIRDY</span></span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3.配置RTCCLK数据选择器，指定LSE为RTCCLK，并且调用RTCCLK_Cmd使能</span></span><br><span class="line">	RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);<span class="comment">//使用LSI修改处3：RCC_FLAG_LSERDY</span></span><br><span class="line">	RCC_RTCCLKCmd(ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//4.调用两个等待函数，注意事项中的等待同步与等待上一次操作完成</span></span><br><span class="line">	RTC_WaitForSynchro();</span><br><span class="line">	RTC_WaitForLastTask();</span><br><span class="line">	<span class="comment">//这两行代码是安全保障措施，防止因为时钟不同步而出现bug</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//5.配置预分频器，RTC_SetPrescaler，并且再调用等待上一次操作完成函数</span></span><br><span class="line">	RTC_SetPrescaler(<span class="number">32768</span><span class="number">-1</span>);<span class="comment">//LSE频率为32768HZ，32768分频后可以使频率为1hz</span></span><br><span class="line">	<span class="comment">//使用LSI修改处4：40KHz对应40000-1分频得到1hz</span></span><br><span class="line">	RTC_WaitForLastTask();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//6.配置CNT,并且再调用等待上一次操作完成函数</span></span><br><span class="line">	RTC_SetCounter(<span class="number">1672588795</span>);</span><br><span class="line">	RTC_WaitForLastTask();</span><br><span class="line">   </span><br><span class="line">	MyRTC_SetTime();<span class="comment">//设置起始时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_SetTime</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="type">time_t</span> time_cnt;<span class="comment">//unsigned int类型数据</span></span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">time_date</span>;</span></span><br><span class="line">		<span class="comment">//1.数组指定时间填充到struct tm结构体中</span></span><br><span class="line">	  time_date.tm_year = MyRTC_Time[<span class="number">0</span>]<span class="number">-1900</span>;</span><br><span class="line">		time_date.tm_mon = MyRTC_Time[<span class="number">1</span>]<span class="number">-1</span>;</span><br><span class="line">		time_date.tm_mday = MyRTC_Time[<span class="number">2</span>];	</span><br><span class="line">		time_date.tm_hour = MyRTC_Time[<span class="number">3</span>];</span><br><span class="line">		time_date.tm_min = MyRTC_Time[<span class="number">4</span>];</span><br><span class="line">		time_date.tm_sec = MyRTC_Time[<span class="number">5</span>];</span><br><span class="line">	  </span><br><span class="line">	  <span class="comment">//2.使用mktime得到秒数</span></span><br><span class="line">		time_cnt = mktime(&amp;time_date) - <span class="number">8</span>*<span class="number">60</span>*<span class="number">60</span>;<span class="comment">//此处是北京时间转为伦敦时间，因为RTC中的秒数是以伦敦时间计算的，写入到CNT中也应该是伦敦时间</span></span><br><span class="line">		</span><br><span class="line">	  <span class="comment">//3.写入RTC的CNT中</span></span><br><span class="line">	  RTC_SetCounter(time_cnt);</span><br><span class="line">	  RTC_WaitForLastTask();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_ReadTime</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="type">time_t</span> time_cnt;<span class="comment">//unsigned int类型数据</span></span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">time_date</span>;</span></span><br><span class="line">		</span><br><span class="line">	  time_cnt = RTC_GetCounter()+ <span class="number">8</span>*<span class="number">60</span>*<span class="number">60</span>;<span class="comment">//此处是伦敦时间转换为北京时间，东8区，要多8个小时，对应8个小时的秒数</span></span><br><span class="line">    </span><br><span class="line">	  time_date = *localtime(&amp;time_cnt);</span><br><span class="line">	  </span><br><span class="line">	  	MyRTC_Time[<span class="number">0</span>] = time_date.tm_year+<span class="number">1900</span>;</span><br><span class="line">		MyRTC_Time[<span class="number">1</span>] = time_date.tm_mon+<span class="number">1</span>;</span><br><span class="line">		MyRTC_Time[<span class="number">2</span>] = time_date.tm_mday;</span><br><span class="line">		MyRTC_Time[<span class="number">3</span>] = time_date.tm_hour ;</span><br><span class="line">		MyRTC_Time[<span class="number">4</span>] = time_date.tm_min;</span><br><span class="line">		MyRTC_Time[<span class="number">5</span>] = time_date.tm_sec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>在程序中由于F103芯片等的BUG，可能使用LSE时不会起振，此时函数会卡死在初始化中，我们可以用示波器观察是否产生波形判断一下</strong></p>
<p><code>解决方案：</code></p>
<p><strong>此时我们可以使用LSI作为时钟源，但是就不能实现掉电时间不重置了因为LSI不像LSE一样可以由VBat备用电池供电</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyRTC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*模块初始化*/</span></span><br><span class="line">	OLED_Init();		<span class="comment">//OLED初始化</span></span><br><span class="line">	MyRTC_Init();		<span class="comment">//RTC初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*显示静态字符串*/</span></span><br><span class="line">	OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;Date:XXXX-XX-XX&quot;</span>);</span><br><span class="line">	OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;Time:XX:XX:XX&quot;</span>);</span><br><span class="line">	OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;CNT :&quot;</span>);</span><br><span class="line">	OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;DIV :&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		MyRTC_ReadTime();							<span class="comment">//RTC读取时间，最新的时间存储到MyRTC_Time数组中</span></span><br><span class="line">		</span><br><span class="line">		OLED_ShowNum(<span class="number">1</span>, <span class="number">6</span>, MyRTC_Time[<span class="number">0</span>], <span class="number">4</span>);		<span class="comment">//显示MyRTC_Time数组中的时间值，年</span></span><br><span class="line">		OLED_ShowNum(<span class="number">1</span>, <span class="number">11</span>, MyRTC_Time[<span class="number">1</span>], <span class="number">2</span>);		<span class="comment">//月</span></span><br><span class="line">		OLED_ShowNum(<span class="number">1</span>, <span class="number">14</span>, MyRTC_Time[<span class="number">2</span>], <span class="number">2</span>);		<span class="comment">//日</span></span><br><span class="line">		OLED_ShowNum(<span class="number">2</span>, <span class="number">6</span>, MyRTC_Time[<span class="number">3</span>], <span class="number">2</span>);		<span class="comment">//时</span></span><br><span class="line">		OLED_ShowNum(<span class="number">2</span>, <span class="number">9</span>, MyRTC_Time[<span class="number">4</span>], <span class="number">2</span>);		<span class="comment">//分</span></span><br><span class="line">		OLED_ShowNum(<span class="number">2</span>, <span class="number">12</span>, MyRTC_Time[<span class="number">5</span>], <span class="number">2</span>);		<span class="comment">//秒</span></span><br><span class="line">		</span><br><span class="line">		OLED_ShowNum(<span class="number">3</span>, <span class="number">6</span>, RTC_GetCounter(), <span class="number">10</span>);	<span class="comment">//显示32位的秒计数器</span></span><br><span class="line">		OLED_ShowNum(<span class="number">4</span>, <span class="number">6</span>, RTC_GetDivider(), <span class="number">10</span>);	<span class="comment">//显示余数寄存器</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="BKP寄存器解决掉电时间不丢失问题"><a href="#BKP寄存器解决掉电时间不丢失问题" class="headerlink" title="BKP寄存器解决掉电时间不丢失问题"></a>BKP寄存器解决掉电时间不丢失问题</h3><blockquote>
<p><strong>在对RTC的初始化中，我们要有判断的去执行</strong>：</p>
<ol>
<li><p>当系统完全断电了，备用电池也断电了，我们就执行初始化</p>
</li>
<li><p>当系统只是主电源断电，备用电池没断的话，LSE一直都在运行，就不用执行初始化</p>
</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*我们只需要修改MyRTC_Init()的代码即可，为其添加一个BKP寄存器自定义标志位的判断*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*开启时钟*/</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);		<span class="comment">//开启PWR的时钟</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_BKP, ENABLE);		<span class="comment">//开启BKP的时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*备份寄存器访问使能*/</span></span><br><span class="line">	PWR_BackupAccessCmd(ENABLE);							<span class="comment">//使用PWR开启对备份寄存器的访问</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (BKP_ReadBackupRegister(BKP_DR1) != <span class="number">0xAAAA</span>)			<span class="comment">//通过写入备份寄存器的标志位，判断RTC是否是第一次配置</span></span><br><span class="line">															<span class="comment">//if成立则执行第一次的RTC配置</span></span><br><span class="line">	&#123;</span><br><span class="line">		RCC_LSEConfig(RCC_LSE_ON);							<span class="comment">//开启LSE时钟</span></span><br><span class="line">		<span class="keyword">while</span> (RCC_GetFlagStatus(RCC_FLAG_LSERDY) != SET);	<span class="comment">//等待LSE准备就绪</span></span><br><span class="line">		</span><br><span class="line">		RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);				<span class="comment">//选择RTCCLK来源为LSE</span></span><br><span class="line">		RCC_RTCCLKCmd(ENABLE);								<span class="comment">//RTCCLK使能</span></span><br><span class="line">		</span><br><span class="line">		RTC_WaitForSynchro();								<span class="comment">//等待同步</span></span><br><span class="line">		RTC_WaitForLastTask();								<span class="comment">//等待上一次操作完成</span></span><br><span class="line">		</span><br><span class="line">		RTC_SetPrescaler(<span class="number">32768</span> - <span class="number">1</span>);						<span class="comment">//设置RTC预分频器，预分频后的计数频率为1Hz</span></span><br><span class="line">		RTC_WaitForLastTask();								<span class="comment">//等待上一次操作完成</span></span><br><span class="line">		</span><br><span class="line">		MyRTC_SetTime();									<span class="comment">//设置时间，调用此函数，全局数组里时间值刷新到RTC硬件电路</span></span><br><span class="line">		</span><br><span class="line">		BKP_WriteBackupRegister(BKP_DR1, <span class="number">0xAAAA</span>);			<span class="comment">//在备份寄存器写入自己规定的标志位，用于判断RTC是不是第一次执行配置</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>													<span class="comment">//RTC不是第一次配置</span></span><br><span class="line">	&#123;</span><br><span class="line">		RTC_WaitForSynchro();								<span class="comment">//等待同步</span></span><br><span class="line">		RTC_WaitForLastTask();								<span class="comment">//等待上一次操作完成</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>如果LSE无法起振导致程序卡死在初始化函数中,可将初始化函数替换为下述代码，使用LSI当作RTCCLK</strong></p>
<p><code>LSI无法由备用电源供电，故主电源掉电时，RTC走时会暂停</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);</span><br><span class="line">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_BKP, ENABLE);</span><br><span class="line">    </span><br><span class="line">    PWR_BackupAccessCmd(ENABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (BKP_ReadBackupRegister(BKP_DR1) != <span class="number">0xA5A5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       RCC_LSICmd(ENABLE);</span><br><span class="line">       <span class="keyword">while</span> (RCC_GetFlagStatus(RCC_FLAG_LSIRDY) != SET);</span><br><span class="line">       </span><br><span class="line">       RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI);</span><br><span class="line">       RCC_RTCCLKCmd(ENABLE);</span><br><span class="line">       </span><br><span class="line">       RTC_WaitForSynchro();</span><br><span class="line">       RTC_WaitForLastTask();</span><br><span class="line">       </span><br><span class="line">       RTC_SetPrescaler(<span class="number">40000</span> - <span class="number">1</span>);</span><br><span class="line">       RTC_WaitForLastTask();</span><br><span class="line">       </span><br><span class="line">       MyRTC_SetTime();</span><br><span class="line">       </span><br><span class="line">       BKP_WriteBackupRegister(BKP_DR1, <span class="number">0xA5A5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       RCC_LSICmd(ENABLE);             <span class="comment">//即使不是第一次配置，也需要再次开启LSI时钟</span></span><br><span class="line">       <span class="keyword">while</span> (RCC_GetFlagStatus(RCC_FLAG_LSIRDY) != SET);</span><br><span class="line">       </span><br><span class="line">       RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI);</span><br><span class="line">       RCC_RTCCLKCmd(ENABLE);</span><br><span class="line">       </span><br><span class="line">       RTC_WaitForSynchro();</span><br><span class="line">       RTC_WaitForLastTask();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="PWR电源控制"><a href="#PWR电源控制" class="headerlink" title="PWR电源控制"></a>PWR电源控制</h1><h2 id="PWR简介"><a href="#PWR简介" class="headerlink" title="PWR简介"></a>PWR简介</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250110170201038-1752337644188-635.png" alt="image-20250110170201038"></p>
<blockquote>
<p>实现<code>可编程电压检测器</code>和<code>低功耗模式</code></p>
<p>**可编程电压检测器PVD：**监视VDD电压，在供电电压下降到PVD阀值以下时或上升到PVD阈值以上时，产生一个中断，通知软件做紧急处理</p>
<p>**低功耗模式：**睡眠模式Sleep、停机模式stop、待机模式standby。在空闲状态时关闭不必要的硬件，比如把CPU断电或关闭时钟，但需要保留必要的唤醒电路</p>
</blockquote>
<p><code>所有知识在手册上可以找到</code></p>
<h2 id="电源框图"><a href="#电源框图" class="headerlink" title="电源框图"></a>电源框图</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250110170713455-1752337644189-637.png" alt="image-20250110170713455"></p>
<blockquote>
<p>STM32内部供电方案图可分为三个部分：</p>
<p><code>模拟部分供电：</code>VDDA(VDD Analog)</p>
<p>包括A&#x2F;D转换器、温度传感器、复位模块、PLL</p>
<p>供电正极为：VDDA</p>
<p>供电负极为：VSSA</p>
<p>其中还有两个参考电压供电脚：VREF- 和VREF+</p>
<p>在该芯片中直接接入了VSSA和VDDA，也可能会单独引出去</p>
<hr>
<p><code>数字部分供电：</code>VDD供电区域和1.8V供电区域</p>
<p><strong>VDD供电区域</strong>：I&#x2F;O电路、待机电路、电压调节器(为1.8V区域供电)</p>
<p><strong>1.8V供电区域</strong>：CPU、存储器、外设</p>
<p>我们可以看到CPU、存储器和外设都是以1.8V的低电压运行的，当需要与外界交流时，才会通过I&#x2F;O电路转换为3.3V</p>
<hr>
<p><code>后备供电区域：</code>VBAT为以下供电</p>
<p>LSE 32K晶体振荡器后备寄存器</p>
<p>RCC BDCR寄存器，即备份域控制寄存器</p>
<p>RTC</p>
<p>低电压检测器：控制开关，VDD有电时由VDD供电，VDD没电时由VBAT供电</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250110171925509-1752337644189-636.png" alt="image-20250110171925509"></p>
</blockquote>
<h2 id="上电复位和掉电复位-POR-PDR"><a href="#上电复位和掉电复位-POR-PDR" class="headerlink" title="上电复位和掉电复位(POR&#x2F;PDR)"></a>上电复位和掉电复位(POR&#x2F;PDR)</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250110181242741-1752337644189-638.png" alt="image-20250110181242741"></p>
<blockquote>
<p>设置了阈值电压：40mV迟滞避免电压来回波动，造成输出也来回抖动</p>
<p>Reset：低电平有效</p>
<p>对应滞后时间在stm32数据手册可以找到</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250110181444794-1752337644189-639.png" alt="image-20250110181444794"></p>
</blockquote>
<h2 id="可编程电压检测器PVD"><a href="#可编程电压检测器PVD" class="headerlink" title="可编程电压检测器PVD"></a>可编程电压检测器PVD</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250110181535199-1752337644189-640.png" alt="image-20250110181535199"></p>
<blockquote>
<p><strong>PVD-(Programmable Votage Detector)作用</strong>：</p>
<p>监视VDD电压，在供电电压下降到PVD阀值以下时或上升到PVD阈值以上时，产生一个中断，通知软件做紧急处理。</p>
<p>PVD在电压过低时为1，正常时输出0</p>
<p>PVD在上升沿或下降沿时触发中断，通过<strong>外部中断</strong>实现，提醒用户处理。</p>
<hr>
<p>PVD的阈值电压可以使用程序指定，配置PLS寄存器3位，迟滞电压上限为100mV</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250110181653488-1752337644189-643.png" alt="image-20250110181653488"></p>
</blockquote>
<h2 id="低功耗模式介绍"><a href="#低功耗模式介绍" class="headerlink" title="低功耗模式介绍"></a>低功耗模式介绍</h2><p><code>手册中的低功耗模式介绍：</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250110182653384-1752337644189-641.png" alt="image-20250110182653384"></p>
<blockquote>
<p>三种模式从上到下：<code>睡眠</code>、<code>停机(止)</code>、<code>待机</code></p>
<ol>
<li>关闭的电路越来越多</li>
<li>越来越省电</li>
<li>越来越难唤醒</li>
</ol>
<p>图中可以知道关闭电路通常由两个做法：<code>关闭时钟</code>或<code>关闭电源</code></p>
<p><strong>关闭时钟</strong>：所有的运算和涉及时序的操作都会暂停，寄存器和存储器保存的数据可以维持不会消失</p>
<p><strong>关闭电源</strong>：电路直接断电，电路操作和寄存器数据都丢失，比关闭时钟更省电</p>
<hr>
<p><code>睡眠模式：一般省电</code></p>
<p>**WFI(wait for interrupt)：**等待中断，对应唤醒条件为<code>中断唤醒</code>，意思就是处于睡眠状态，如果有中断发生再叫我起来。</p>
<p>调用WFI进入的睡眠模式，<strong>任何外设发生任何中断时</strong>，芯片都会立刻醒来，进入中断处理程序</p>
<p>**WFE(wait for event)：**等待事件，对应唤醒条件为<code>唤醒事件</code>，可以是外部中断配置为事件模式，也可以是使能了中断但没有配置NVIC</p>
<p>调用WFE进入的睡眠模式，产生唤醒事件时，会立刻醒来。一般不需要进中断函数</p>
<p><code>对电路影响：</code>只关闭了CPU时钟，其他电路没有影响。<strong>看上图中描述</strong></p>
<hr>
<p><code>停机模式：非常省电</code></p>
<p><strong>SLEEPDEEP位</strong>：置1进入深度睡眠</p>
<p><strong>PDDS位</strong>：区分停机和待机。PDDS&#x3D;0，进入停机模式，PDDS&#x3D;1，进入待机模式</p>
<p><strong>LPDS位</strong>：<strong>设置电压调节器</strong>，开启或进入低功耗模式。LPDS&#x3D;0,电压调节器开启LPDS&#x3D;1，电压调节器进入低功耗(更省电但唤醒延迟更高)。</p>
<p><strong>设置流程：SLEEPDEEP&#x3D;1，PDDS&#x3D;0，LPDS&#x3D;0&#x2F;1，再调用WFI或WFE，芯片就可以进入停止模式了</strong></p>
<p><strong>唤醒条件</strong>：只有任一的外部中断能唤醒，其他中断不能唤醒</p>
<p>WFI用外部中断中断模式唤醒，WFE用外部中断事件唤醒</p>
<p><code>对电路影响：</code>关闭所有1.8V区域的时钟(CPU、AD、外设)，以及HSI和HSE振荡器，但不会关闭LSI和LSE，电压调节器开启(1.8V区域电源仍开启)。<strong>看上图中描述</strong></p>
<hr>
<p><code>待机模式:极为省电</code></p>
<p><strong>设置流程：SLEEPDEEP&#x3D;1，PDDS&#x3D;1，再调用WFI或WFE，芯片就可以进入停止模式了</strong></p>
<p>**唤醒条件：**普通外设中断或外部中断都无法唤醒待机模式，只能由以下四个信号唤醒</p>
<ol>
<li>WKUP引脚上升沿(如PA0-Wakeup，即PA0)</li>
<li>RTC闹钟事件</li>
<li>NRST引脚的外部复位(Reset一下)</li>
<li>IWDG复位</li>
</ol>
<p><code>对电路影响：</code>关闭所有1.8V区域的时钟(CPU、AD、外设)，两个高速时钟关闭，两个低速时钟不会关闭，电压调节器关闭(即1.8V区域电源关闭)。<strong>看上图中描述</strong></p>
</blockquote>
<h2 id="模式选择的图"><a href="#模式选择的图" class="headerlink" title="模式选择的图"></a>模式选择的图</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250110195522341-1752337644189-642.png" alt="image-20250110195522341"></p>
<blockquote>
<p>配置其他寄存器在执行WFI或WFE之前。</p>
<p>图中最左边是执行WFI&#x2F;WFE后，根据各个寄存器判断启动什么模式的流程</p>
</blockquote>
<h2 id="三种模式特性及注意事项"><a href="#三种模式特性及注意事项" class="headerlink" title="三种模式特性及注意事项"></a>三种模式特性及注意事项</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250110211426203-1752337644189-644.png" alt="image-20250110211426203"></p>
<blockquote>
<p><strong>GPIO高低电平保持睡眠前运行时的状态，唤醒后程序从暂停的地方继续运行</strong></p>
<p>手册对事件唤醒描述：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250110211647415-1752337644189-645.png" alt="image-20250110211647415"></p>
<p>比较麻烦所以还是使用中断唤醒吧</p>
</blockquote>
<hr>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250110211742039-1752337644189-646.png" alt="image-20250110211742039"></p>
<blockquote>
<p><strong>GPIO高低电平保持睡眠前运行时的状态，唤醒后程序从暂停的地方继续运行</strong></p>
<p><strong>注意：</strong></p>
<p>停止模式唤醒时，因为HSI被选为了系统时钟，所以变成了8MHz的主频，<code>所以我们在停止模式唤醒后第一时间应该重新启动HSE，配置主频为72MHz(调用SystemInit即可)</code></p>
</blockquote>
<hr>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250110212325583-1752337644189-648.png" alt="image-20250110212325583"></p>
<blockquote>
<p><strong>待机模式下，GPIO输出引脚变为高阻态(浮空输入)，唤醒后程序从头开始运行</strong></p>
<p>仅备份寄存器和待机电路供电</p>
<p>仅四种方式退出待机模式</p>
</blockquote>
<h2 id="节电方法"><a href="#节电方法" class="headerlink" title="节电方法"></a>节电方法</h2><p>在数据手册工作条件的供电电流特性测试电流部分可以得到省电方法</p>
<ol>
<li><strong>关闭不需要的外设对应时钟</strong></li>
<li><strong>降低主频，耗电电流下降，对于省电也挺划算的。设备需要连续运行，但是对于主频和性能没这么高要求的话，就可以选择降低主频</strong></li>
</ol>
<blockquote>
<p>产品使用电池的话低功耗模式也是很必要使用的</p>
</blockquote>
<h2 id="SLEEPDEEP和SLEEPONEXIT位配置"><a href="#SLEEPDEEP和SLEEPONEXIT位配置" class="headerlink" title="SLEEPDEEP和SLEEPONEXIT位配置"></a>SLEEPDEEP和SLEEPONEXIT位配置</h2><blockquote>
<p>这两个位位于内核系统控制块，没有提供什么简单的配置方法，只能通过操作寄存器来配置，默认值为0</p>
<p>我们需要打开Cortex-M3编程手册，第4章内核外设的系统控制块SCB中找到寄存器介绍</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250111155405959-1752337644189-647.png" alt="image-20250111155405959"></p>
<p>对应SCB-&gt;SCR寄存器等按照配置编程手册上的位配置即可</p>
</blockquote>
<h2 id="修改主频"><a href="#修改主频" class="headerlink" title="修改主频"></a>修改主频</h2><p>在system_stm32f10x.c文件中可以看到的描述是有两个函数和一个变量与系统主频有关</p>
<p>在system_stm32f10x.h文件中也可以找到</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">uint32_t</span> SystemCoreClock;<span class="comment">//系统时钟</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">SystemInit</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//系统时钟初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">SystemCoreClockUpdate</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//系统时钟更新</span></span><br></pre></td></tr></table></figure>



<p>在system_stm32f10x.c文件中，对应部分找到自己的型号然后进行修改主频即可</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250111152640885-1752337644189-649.png" alt="image-20250111152640885"></p>
<blockquote>
<p>修改主频后，使用主频的地方需要修改，比如Delay函数</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250111152842134-1752337644189-650.png" alt="image-20250111152842134"></p>
<p>在72Mhz下是正确延时指定时间，但是变为36Mhz后，就会变为原来的1&#x2F;2。所以最好将SystemCoreClock变量带入计算中做自适应</p>
<hr>
<p><code>所以一般条件下不推荐修改主频，除非有需求</code></p>
</blockquote>
<h2 id="睡眠模式实例"><a href="#睡眠模式实例" class="headerlink" title="睡眠模式实例"></a>睡眠模式实例</h2><p>睡眠模式使用寄存器都是内核中的，与PWR没什么关系，所以没使用PWR库函数</p>
<h3 id="串口收发"><a href="#串口收发" class="headerlink" title="串口收发"></a>串口收发</h3><blockquote>
<p><strong>对于这种靠任意中断触发，没中断就没什么事的，平时主循环会耗电</strong></p>
<p><strong>我们就可以给它加入低功耗模式</strong></p>
<p><code>根据分析，这种情况下串口只能使用睡眠模式</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Serial.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> RxData;			<span class="comment">//定义用于接收串口数据的变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	OLED_Init();		<span class="comment">//OLED初始化</span></span><br><span class="line">	OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;RxData:&quot;</span>);	<span class="comment">//显示静态字符串</span></span><br><span class="line">	</span><br><span class="line">	Serial_Init();		<span class="comment">//串口初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (Serial_GetRxFlag() == <span class="number">1</span>)			<span class="comment">//检查串口接收数据的标志位</span></span><br><span class="line">		&#123;</span><br><span class="line">			RxData = Serial_GetRxData();		<span class="comment">//获取串口接收的数据</span></span><br><span class="line">			Serial_SendByte(RxData);			<span class="comment">//串口将收到的数据回传回去，用于测试</span></span><br><span class="line">			OLED_ShowHexNum(<span class="number">1</span>, <span class="number">8</span>, RxData, <span class="number">2</span>);	<span class="comment">//显示串口接收的数据</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;Running&quot;</span>);		<span class="comment">//OLED闪烁Running，指示当前主循环正在运行</span></span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">		OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;       &quot;</span>);</span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">		</span><br><span class="line">		__WFI();								<span class="comment">//执行WFI指令，CPU睡眠，并等待中断唤醒</span></span><br><span class="line">        <span class="comment">//__WFE();WFE,事件唤醒</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>对于睡眠模式我们在while循环中加入WFI或WFE即可实现睡眠模式，唤醒后继续执行上一次执行的操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__WFI();<span class="comment">//执行WFI指令，CPU睡眠，并等待中断唤醒</span></span><br><span class="line">__WFE();<span class="comment">//WFE,事件唤醒</span></span><br></pre></td></tr></table></figure>

<p><code>现象：</code></p>
<p>OLED上不再持续显示Running，此时用串口助手发送信息，每发送一次，Running闪烁显示一次，说明只有接收中断后才会唤醒工作一次，然后立马睡眠</p>
</blockquote>
<h2 id="停机模式实例"><a href="#停机模式实例" class="headerlink" title="停机模式实例"></a>停机模式实例</h2><h3 id="库函数-9"><a href="#库函数-9" class="headerlink" title="库函数"></a>库函数</h3><p>停机模式涉及内核外的电路操作，需要使用库函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PWR_DeInit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PWR_BackupAccessCmd</span><span class="params">(FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">//使能后备区域的访问，在RTC初始化时需要使用</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWR_PVDCmd</span><span class="params">(FunctionalState NewState)</span>;<span class="comment">//PVD使能</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWR_PVDLevelConfig</span><span class="params">(<span class="type">uint32_t</span> PWR_PVDLevel)</span>;<span class="comment">//PVD阈值电压配置</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWR_WakeUpPinCmd</span><span class="params">(FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">//WKUP引脚唤醒功能使用需要调用此函数开启</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWR_EnterSTOPMode</span><span class="params">(<span class="type">uint32_t</span> PWR_Regulator, <span class="type">uint8_t</span> PWR_STOPEntry)</span>;</span><br><span class="line"><span class="comment">//停机模式：调用该函数就可以进入停止模式了</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWR_EnterSTANDBYMode</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//待机模式：调用该函数就可以进入待机模式了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//PWR标志位相关函数</span></span><br><span class="line">FlagStatus <span class="title function_">PWR_GetFlagStatus</span><span class="params">(<span class="type">uint32_t</span> PWR_FLAG)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PWR_ClearFlag</span><span class="params">(<span class="type">uint32_t</span> PWR_FLAG)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="对射式红外传感器外部中断-停机模式"><a href="#对射式红外传感器外部中断-停机模式" class="headerlink" title="对射式红外传感器外部中断(停机模式)"></a>对射式红外传感器外部中断(停机模式)</h3><blockquote>
<p>使用<strong>外部中断触发</strong>的可以考虑使用<strong>更省电的停机模式</strong></p>
<p>虽然停机模式关闭了外设时钟，但是外部中断使用不需要时钟就能工作</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CountSensor.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*模块初始化*/</span></span><br><span class="line">	OLED_Init();			<span class="comment">//OLED初始化</span></span><br><span class="line">	CountSensor_Init();		<span class="comment">//红外计数传感器初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*开启时钟*/</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);		<span class="comment">//开启PWR的时钟！！！</span></span><br><span class="line">															<span class="comment">//停止模式和待机模式一定要记得开启</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*显示静态字符串*/</span></span><br><span class="line">	OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;Count:&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		OLED_ShowNum(<span class="number">1</span>, <span class="number">7</span>, CountSensor_Get(), <span class="number">5</span>);			<span class="comment">//OLED不断刷新显示CountSensor_Get的返回值</span></span><br><span class="line">		</span><br><span class="line">		OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;Running&quot;</span>);					<span class="comment">//OLED闪烁Running，指示当前主循环正在运行</span></span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">		OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;       &quot;</span>);</span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">		</span><br><span class="line">		PWR_EnterSTOPMode(PWR_Regulator_ON, PWR_STOPEntry_WFI);	<span class="comment">//STM32WFI指令进入停止模式，并等待中断唤醒</span></span><br><span class="line">        </span><br><span class="line">		SystemInit();											<span class="comment">//唤醒后，要重新配置时钟</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>PWR_EnterSTOPMode(PWR_Regulator_ON, PWR_STOPEntry_WFI):</code></p>
<p>该函数最后调用了WFI或WFE指令之后就进入了静止模式</p>
<hr>
<p><code>SystemInit()：</code>唤醒后时钟变为了HSI的8M，需要我们重新启动HSE，配置72M的主频，调用该函数即可</p>
</blockquote>
<blockquote>
<p><code>现象：</code>红外传感器计数一次，Running闪烁一次，确实进入了停机模式</p>
</blockquote>
<h2 id="待机模式实例"><a href="#待机模式实例" class="headerlink" title="待机模式实例"></a>待机模式实例</h2><h3 id="RTC闹钟-待机模式"><a href="#RTC闹钟-待机模式" class="headerlink" title="RTC闹钟(待机模式)"></a>RTC闹钟(待机模式)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyRTC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*模块初始化*/</span></span><br><span class="line">	OLED_Init();		<span class="comment">//OLED初始化</span></span><br><span class="line">	MyRTC_Init();		<span class="comment">//RTC初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*开启时钟*/</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);		<span class="comment">//开启PWR的时钟</span></span><br><span class="line">															<span class="comment">//停止模式和待机模式一定要记得开启时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*显示静态字符串*/</span></span><br><span class="line">	OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;CNT :&quot;</span>);</span><br><span class="line">	OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;ALR :&quot;</span>);</span><br><span class="line">	OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;ALRF:&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*使能WKUP引脚*/</span></span><br><span class="line">	PWR_WakeUpPinCmd(ENABLE);						<span class="comment">//使能位于PA0的WKUP引脚，WKUP引脚上升沿唤醒待机模式,接上VCC即可唤醒</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*设定闹钟：由于该寄存器是只写的不可读，所以我们使用变量显示*/</span></span><br><span class="line">	<span class="type">uint32_t</span> Alarm = RTC_GetCounter() + <span class="number">10</span>;			<span class="comment">//闹钟为唤醒后当前时间的后10s</span></span><br><span class="line">	RTC_SetAlarm(Alarm);							<span class="comment">//写入闹钟值到RTC的ALR寄存器</span></span><br><span class="line">	OLED_ShowNum(<span class="number">2</span>, <span class="number">6</span>, Alarm, <span class="number">10</span>);					<span class="comment">//显示闹钟值</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		OLED_ShowNum(<span class="number">1</span>, <span class="number">6</span>, RTC_GetCounter(), <span class="number">10</span>);	<span class="comment">//显示32位的秒计数器</span></span><br><span class="line">		OLED_ShowNum(<span class="number">3</span>, <span class="number">6</span>, RTC_GetFlagStatus(RTC_FLAG_ALR), <span class="number">1</span>);		<span class="comment">//显示闹钟标志位</span></span><br><span class="line">		</span><br><span class="line">		OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;Running&quot;</span>);			<span class="comment">//OLED闪烁Running，指示当前主循环正在运行</span></span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">		OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;       &quot;</span>);</span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">		</span><br><span class="line">		OLED_ShowString(<span class="number">4</span>, <span class="number">9</span>, <span class="string">&quot;STANDBY&quot;</span>);			<span class="comment">//OLED闪烁STANDBY，指示即将进入待机模式</span></span><br><span class="line">		Delay_ms(<span class="number">1000</span>);</span><br><span class="line">		OLED_ShowString(<span class="number">4</span>, <span class="number">9</span>, <span class="string">&quot;       &quot;</span>);</span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">		</span><br><span class="line">		OLED_Clear();								<span class="comment">//OLED清屏，模拟关闭外部所有的耗电设备，以达到极度省电</span></span><br><span class="line">		</span><br><span class="line">		PWR_EnterSTANDBYMode();						<span class="comment">//STM32进入停止模式，并等待指定的唤醒事件（WKUP上升沿或RTC闹钟）</span></span><br><span class="line">		<span class="comment">/*待机模式唤醒后，程序会重头开始运行*/</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p><code>PWR_EnterSTANDBYMode():</code></p>
<p>该函数最后统一调用WFI指令进入待机模式</p>
<hr>
<p><strong>待机模式下只有这四种可以唤醒</strong>：</p>
<ol>
<li>WKUP引脚上升沿(如PA0-Wakeup，即PA0)：手册中对应描述不需要GPIO初始化，被强制下拉，只需要接VCC即可唤醒</li>
<li>RTC闹钟事件</li>
<li>NRST引脚的外部复位(Reset一下)</li>
<li>IWDG复位</li>
</ol>
</blockquote>
<blockquote>
<p><code>现象：</code>等待10s后，Running闪烁一下后消失，CNT和ALR的值都更新，说明待机模式下唤醒后，程序从头开始运行，所以我们不用重新调用SystemInit了。</p>
</blockquote>
<p><code>最大化省电：</code><strong>进入待机模式前把外接的模块能关的全关，需要精心设计电路。否则待机模式无法做到真正的极度省电！！！</strong></p>
<h1 id="看门狗WDG"><a href="#看门狗WDG" class="headerlink" title="看门狗WDG"></a>看门狗WDG</h1><h2 id="看门狗简介"><a href="#看门狗简介" class="headerlink" title="看门狗简介"></a>看门狗简介</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250111173313542-1752337644189-651.png" alt="image-20250111173313542"></p>
<blockquote>
<p><code>看门狗</code>：由于程序出现漏洞、硬件故障、电磁干扰等原因出现卡死或跑飞现象时可以及时复位程序。</p>
<p>本质是一个<strong>定时器</strong>，在指定时间范围内，程序没有执行<strong>喂狗</strong>(手动重装计数器)操作时，看门狗硬件电路就自动产生复位信号。</p>
<p><code>作用：</code>提高系统的可靠性和健壮性，避免程序陷入长时间罢工状态</p>
<p>可以预料的漏洞应该尽量解决，开门狗只是一个复位的作用，可能会出现复位也不能解决的问题</p>
<hr>
<p>STM32内置两个看门狗：独立看门狗(IWDG)和窗口看门狗(WWDG)</p>
<p><strong>独立看门狗(IWDG)</strong>：使用专门的LSI时钟，即使主时钟出现问题，独立看门狗也能正常工作，这就是<strong>独立的命名</strong>。对时间精度要求较低，只有一个喂狗最晚界限。</p>
<p><strong>窗口看门狗(WWDG)</strong>：使用APB1时钟，要求看门狗在精确的计时窗口作用，有喂狗最早界限和最晚界限，必须在这个界限窗口内喂狗，这就是窗口的命名。喂早和喂晚都会发生复位</p>
<p><code>对应更多内容请查看参考手册!!!</code></p>
</blockquote>
<h2 id="独立看门狗IWDG"><a href="#独立看门狗IWDG" class="headerlink" title="独立看门狗IWDG"></a>独立看门狗IWDG</h2><h3 id="IWDG框图"><a href="#IWDG框图" class="headerlink" title="IWDG框图"></a>IWDG框图</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250112155237497-1752337644189-652.png" alt="image-20250112155237497"></p>
<blockquote>
<p>IWDG_PR：其实就是定时器中的预分频Prescaler缩写，8位，最大为256</p>
<p>IWDG_RLR：就是定时器中的ARR&#x3D;Auto Reloader，RLR &#x3D; Reloader，12位最大为4096</p>
<p>IWDG_SR：状态寄存器</p>
<p><strong>工作流程</strong>：计数器为递减计数器，自减到0之前执行喂狗操作，重置计数器为4096-1，当计数器自减到0时，就会进行复位</p>
<hr>
<p>上面寄存器处于1.8V供电区，而下面的电路处于VDD供电区，所以在停机和待机模式下只会关闭1.8V时钟，所以可以在停机和待机模式下可以运行。</p>
<p>待机模式下的唤醒条件之一就包含看门狗</p>
</blockquote>
<h3 id="IWDG键寄存器"><a href="#IWDG键寄存器" class="headerlink" title="IWDG键寄存器"></a>IWDG键寄存器</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250112160401346-1752337644189-653.png" alt="image-20250112160401346"></p>
<blockquote>
<p><strong>在多个位确定代替一位的情况下，该寄存器就算值变化，也很难恰巧出现以上的值，这样就更保险。</strong></p>
<p>同时对IWDG_PR、IWDG_RLR设计了写保护，只有写入键寄存器的值为0x5555时才会解除写保护，其他情况下都不允许写入</p>
<p>IWDG_SR由于是只读的就不用管</p>
</blockquote>
<h3 id="IWDG超时时间"><a href="#IWDG超时时间" class="headerlink" title="IWDG超时时间"></a>IWDG超时时间</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250112160724383-1752337644189-654.png" alt="image-20250112160724383"></p>
<blockquote>
<p>就是定时器溢出时间，和定时器溢出时间相同</p>
<p>最大值只能是</p>
<p>PR[2:0]：写入0~7，固定上面几个分频系数</p>
</blockquote>
<h2 id="窗口看门狗WWDG"><a href="#窗口看门狗WWDG" class="headerlink" title="窗口看门狗WWDG"></a>窗口看门狗WWDG</h2><h3 id="WWDG框图"><a href="#WWDG框图" class="headerlink" title="WWDG框图"></a>WWDG框图</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250112161153418-1752337644189-655.png" alt="image-20250112161153418"></p>
<blockquote>
<p>**时钟源：**PCK1 &#x3D; 36M，进入预分频器前还进行了4096分频，图中没画出</p>
<p>**看门狗的预分频器WDGTB：**与独立看门狗PR和定时器的PSC都是一样的道理</p>
<hr>
<p>**看门狗控制寄存器(WWDG_CR)：<strong>包</strong>WDGA(看门狗使能位)**和计数器，与计数器合二为一了。</p>
<p>**6&#x2F;7位递减计数器CNT：**CNT的有效位为T0~T5，T6位用于判断是否溢出。<strong>启动时必须将此位写入1，值为1代表计数器没有溢出，值为0代表计数器溢出，产生看门狗复位</strong>。位于控制寄存器CR中，计数器和控制寄存器合二为一。</p>
<p>窗口看门狗没有重装寄存器，直接向CNT写数据。</p>
<p><strong>当T6~T0位为1 0 0 0 0 0 0 (<code>0x40</code>)，第1位为标志位T6为1，6位计数器的值为000000。再减一次后T6位变为0，计数器溢出，T6通过图中线路产生复位信号</strong>。</p>
<ul>
<li><p><strong>如果把T0~T5看成计数器，就是6位计数器，那么就是自减到0时溢出</strong></p>
</li>
<li><p><strong>如果把T0~T6为看成计数器，就是7位计数器，那么就是自减小于0x40时溢出</strong></p>
</li>
</ul>
<p><code>喂狗操作：</code>写入WWDG_CR寄存器，也就是写入CNT</p>
</blockquote>
<blockquote>
<hr>
<p><strong>看门狗配置寄存器WWDG_CFR：</strong></p>
<p>用于设置喂狗的<code>窗口值的最早界限</code>，写入W6~W0，7位数据，固定不变</p>
<hr>
<p>最左边是比较器逻辑，什么时候产生复位操作的逻辑</p>
<hr>
<p><code>工作流程：</code></p>
<p>首先时钟从PCLK1(36M时钟进入)，然后经过预分频器分频，驱动计数器进行计数，每来一个时钟自减一次。最终比较进行复位</p>
</blockquote>
<h3 id="WWDG工作特性"><a href="#WWDG工作特性" class="headerlink" title="WWDG工作特性"></a>WWDG工作特性</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250112163354916-17366708495051-1752337644189-656.png" alt="image-20250112163354916"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250112182947095-1752337644189-657.png" alt="image-20250112182947095"></p>
<blockquote>
<p>定期写入WWDG_CR寄存器喂狗，避免WWDG复位</p>
<p><strong>W[6:0]</strong>：喂狗的最早界限，对应<code>窗口时间</code></p>
<p><strong>T[6:0]：</strong> 喂狗的计数器值，对应<code>超时时间</code></p>
<p><strong>0x3F</strong>：喂狗的最晚界限，由0x40-1得到，对应<code>超时时间的最大值</code></p>
<p><code>窗口时间~超时时间:</code>之间喂狗才不会复位</p>
<hr>
<p>递减计数器T[6:0] &#x3D; 0X40 产生早期唤醒中断EWI</p>
</blockquote>
<h3 id="WWDG超时时间"><a href="#WWDG超时时间" class="headerlink" title="WWDG超时时间"></a>WWDG超时时间</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250112164040798-1752337644189-658.png" alt="image-20250112164040798"></p>
<h2 id="IWDG和WWDG对比"><a href="#IWDG和WWDG对比" class="headerlink" title="IWDG和WWDG对比"></a>IWDG和WWDG对比</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250112164553712-1752337644189-659.png" alt="image-20250112164553712"></p>
<blockquote>
<p><strong>窗口看门狗的精度比独立看门狗高</strong></p>
</blockquote>
<h2 id="独立看门狗代码"><a href="#独立看门狗代码" class="headerlink" title="独立看门狗代码"></a>独立看门狗代码</h2><h3 id="相关库函数"><a href="#相关库函数" class="headerlink" title="相关库函数"></a>相关库函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*stm32f10x_iwdg.h*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IWDG_WriteAccessCmd</span><span class="params">(<span class="type">uint16_t</span> IWDG_WriteAccess)</span>;</span><br><span class="line"><span class="comment">//写使能控制，键寄存器写入ENABLE就是0x5555，Disable就是0x0000</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IWDG_SetPrescaler</span><span class="params">(<span class="type">uint8_t</span> IWDG_Prescaler)</span>;</span><br><span class="line"><span class="comment">//设置预分频</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IWDG_SetReload</span><span class="params">(<span class="type">uint16_t</span> Reload)</span>;</span><br><span class="line"><span class="comment">//设置重装载值</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IWDG_ReloadCounter</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//喂狗操作：重新装载寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IWDG_Enable</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//启用独立看门狗，键寄存器写入0xCCCC</span></span><br><span class="line"></span><br><span class="line">FlagStatus <span class="title function_">IWDG_GetFlagStatus</span><span class="params">(<span class="type">uint16_t</span> IWDG_FLAG)</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*RCC库函数，stm32f10x_rcc.c*/</span></span><br><span class="line">FlagStatus <span class="title function_">RCC_GetFlagStatus</span><span class="params">(<span class="type">uint8_t</span> RCC_FLAG)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_ClearFlag</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* *   For @b other_STM32_devices, this parameter can be one of the following values:        </span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_HSERDY: HSE oscillator clock ready</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_PLLRDY: PLL clock ready</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_LSERDY: LSE oscillator clock ready</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_PINRST: Pin reset</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_PORRST: POR/PDR reset</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_SFTRST: Software reset</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_IWDGRST: Independent Watchdog reset</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_WWDGRST: Window Watchdog reset</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_LPWRRST: Low Power reset</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">     </span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用RCC中的获取标志位函数可以根据可选参数得到是什么造成的复位，这里用于判断复位是否由看门狗完成</p>
<p><code>同时我们的看门狗标志位必须手动清除，因为及时按下复位键也不会手动清0。如果不清零下次即使是复位键复位也会判断为看门狗复位</code></p>
</blockquote>
<h3 id="配置流程-1"><a href="#配置流程-1" class="headerlink" title="配置流程"></a>配置流程</h3><ol>
<li>开启时钟LSI**(不需要我们写代码，开启看门狗时会自动强制开启LSI)**</li>
</ol>
<blockquote>
<p><strong>在手册的看门狗时钟部分可以看到，开启独立看门狗后LSI会被强制打开，等LSI稳定后，就可以自动为独立看门狗提供时钟</strong></p>
</blockquote>
<ol start="2">
<li><p>写入键寄存器0x5555关闭写保护，再写入预分频值和重装值**(直接调用库函数，不需要我们寄存器操作)**</p>
</li>
<li><p>写入键寄存器0xCCCC启动看门狗**(直接调用库函数IWDG_Enable)**</p>
</li>
<li><p><strong>主循环执行喂狗操作</strong></p>
</li>
</ol>
<h3 id="按键触发独立看门狗"><a href="#按键触发独立看门狗" class="headerlink" title="按键触发独立看门狗"></a>按键触发独立看门狗</h3><blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250112171912193-1752337644189-660.png" alt="image-20250112171912193"></p>
<p><code>设置1000ms超时：</code><strong>图中可以看到前两个分频系数最大超时时间&lt;1000ms不满足,所以选下面的,优先选择预分频系数小的最大化利用计数器值</strong></p>
<p><strong>LSI时钟</strong>：40kHz -&gt; 0.025ms</p>
<p><strong>计算预分频系数PR</strong>：16</p>
<p><strong>计算重载寄存器RL</strong>： 1000&#x2F;(0.025*16) &#x3D; 2499+1</p>
<p>重载寄存器RL值：2499</p>
<p>0.025ms * 16 * (2499+1) &#x3D; 1000ms </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*模块初始化*/</span></span><br><span class="line">	OLED_Init();						<span class="comment">//OLED初始化</span></span><br><span class="line">	Key_Init();							<span class="comment">//按键初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*显示静态字符串*/</span></span><br><span class="line">	OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;IWDG TEST&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*判断复位信号来源*/</span></span><br><span class="line">	<span class="keyword">if</span> (RCC_GetFlagStatus(RCC_FLAG_IWDGRST) == SET)	<span class="comment">//如果是独立看门狗复位</span></span><br><span class="line">	&#123;</span><br><span class="line">		OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;IWDGRST&quot;</span>);			<span class="comment">//OLED闪烁IWDGRST字符串</span></span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;       &quot;</span>);</span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">		</span><br><span class="line">		RCC_ClearFlag();							<span class="comment">//清除标志位!!!</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>											<span class="comment">//否则，即为其他复位</span></span><br><span class="line">	&#123;</span><br><span class="line">		OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;RST&quot;</span>);				<span class="comment">//OLED闪烁RST字符串</span></span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;   &quot;</span>);</span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*IWDG初始化*/</span></span><br><span class="line">	IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);	<span class="comment">//1.独立看门狗写使能</span></span><br><span class="line">	IWDG_SetPrescaler(IWDG_Prescaler_16);			<span class="comment">//2.设置预分频为上面计算的16,</span></span><br><span class="line">	IWDG_SetReload(<span class="number">2499</span>);							<span class="comment">//2.设置重装值为双面计算的2499，独立看门狗的超时时间为1000ms</span></span><br><span class="line">	IWDG_ReloadCounter();							<span class="comment">//3.重装计数器，喂狗，这样更严谨一点使下个周期为1000ms</span></span><br><span class="line">	IWDG_Enable();									<span class="comment">//4.独立看门狗使能</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Key_GetNum();								<span class="comment">//调用阻塞式的按键扫描函数，模拟主循环卡死</span></span><br><span class="line">		</span><br><span class="line">		IWDG_ReloadCounter();						<span class="comment">//重装计数器，喂狗，避免复位</span></span><br><span class="line">		</span><br><span class="line">		OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;FEED&quot;</span>);				<span class="comment">//OLED闪烁FEED字符串</span></span><br><span class="line">		Delay_ms(<span class="number">200</span>);								<span class="comment">//喂狗间隔为200+600=800ms,没到1000ms不会重装</span></span><br><span class="line">		OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;    &quot;</span>);</span><br><span class="line">		Delay_ms(<span class="number">600</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Delay_ms(1010);//模拟超时喂狗，多留一点冗余时间</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>按键使用的是阻塞式消抖，其中包含while循环，一直按着不松就会卡死在while循环，这样就会造成超时主循环阻塞没喂狗，触发看门狗复位</p>
</blockquote>
<blockquote>
<p>现象：正常情况下屏幕间断显示FEED</p>
<p>正常按下Reset按键，屏幕显示”RST”复位。</p>
<p>按下按键不松手，屏幕显示”IWDGRST”</p>
</blockquote>
<h2 id="窗口看门狗代码"><a href="#窗口看门狗代码" class="headerlink" title="窗口看门狗代码"></a>窗口看门狗代码</h2><h3 id="库函数-10"><a href="#库函数-10" class="headerlink" title="库函数"></a>库函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">WWDG_DeInit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">WWDG_SetPrescaler</span><span class="params">(<span class="type">uint32_t</span> WWDG_Prescaler)</span>;<span class="comment">//写入预分频器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">WWDG_SetWindowValue</span><span class="params">(<span class="type">uint8_t</span> WindowValue)</span>;<span class="comment">//设置窗口最早界限</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">WWDG_EnableIT</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//使能EWI中断</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">WWDG_SetCounter</span><span class="params">(<span class="type">uint8_t</span> Counter)</span>;<span class="comment">//喂狗操作</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">WWDG_Enable</span><span class="params">(<span class="type">uint8_t</span> Counter)</span>;<span class="comment">//使能看门狗,手册上说明了计数器时刻自减，所以可能是任何值，所以需要使能的时候喂一下狗</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FlagStatus <span class="title function_">WWDG_GetFlagStatus</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">WWDG_ClearFlag</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>



<h3 id="配置流程-2"><a href="#配置流程-2" class="headerlink" title="配置流程"></a>配置流程</h3><ol>
<li><p><strong>RCC开启APB1总线上的WWDG时钟。</strong></p>
</li>
<li><p><strong>设置预分频值，窗口值</strong></p>
</li>
<li><p><strong>使能看门狗(带有喂狗值，需要使能的时候喂一下狗)</strong></p>
</li>
<li><p><strong>主循环在窗口时间~超时时间内喂狗</strong></p>
</li>
</ol>
<h3 id="按键触发窗口看门狗"><a href="#按键触发窗口看门狗" class="headerlink" title="按键触发窗口看门狗"></a>按键触发窗口看门狗</h3><blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250112174602385-1752337644189-661.png" alt="image-20250112174602385"></p>
<p><code>设定超时时间50ms</code>：图中看到只能选择最后一个分频系数</p>
<p>PCLK1的T：1&#x2F;36M </p>
<p>4096是进入预分频前对PCLK1的一个分频</p>
<p>**计算预分频系数：**2的3次方 &#x3D; 8</p>
<p><strong>计算T[5:0]写入计数器的值：</strong> 50ms &#x2F;[(1&#x2F;36M)*4096 *8] &#x3D; 54.931640625  &#x3D; 55(取整) &#x3D; 54+1</p>
<p><code>喂狗值：</code>54</p>
<p><strong>超时时间</strong> &#x3D; 1&#x2F;36M * 4096 * 8 * (54+1) &#x3D; 约为50ms</p>
<hr>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250112180841188-1752337644189-663.png" alt="image-20250112180841188"></p>
<p><code>设定窗口时间为30ms:</code></p>
<p>PCLK1的T：1&#x2F;36M </p>
<p>4096是进入预分频前对PCLK1的一个分频</p>
<p>计算窗口值W[5:0]：54 - 30ms &#x2F;[(1&#x2F;36M)*4096 *8] &#x3D; 54 - 33(取整) &#x3D; 21</p>
<p><code>窗口值：</code> 21</p>
<p><strong>窗口时间</strong> &#x3D; 1&#x2F;36M * 4096 * 8 * (54-33) &#x3D; 约为30ms</p>
<hr>
<p><code>最终我们主循环的喂狗周期为：</code><strong>30ms ~ 50ms</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*模块初始化*/</span></span><br><span class="line">	OLED_Init();						<span class="comment">//OLED初始化</span></span><br><span class="line">	Key_Init();							<span class="comment">//按键初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*显示静态字符串*/</span></span><br><span class="line">	OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;WWDG TEST&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*判断复位信号来源*/</span></span><br><span class="line">	<span class="keyword">if</span> (RCC_GetFlagStatus(RCC_FLAG_WWDGRST) == SET)	<span class="comment">//如果是窗口看门狗复位</span></span><br><span class="line">	&#123;</span><br><span class="line">		OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;WWDGRST&quot;</span>);			<span class="comment">//OLED闪烁WWDGRST字符串</span></span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;       &quot;</span>);</span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">		</span><br><span class="line">		RCC_ClearFlag();							<span class="comment">//清除标志位！！！</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>											<span class="comment">//否则，即为其他复位</span></span><br><span class="line">	&#123;</span><br><span class="line">		OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;RST&quot;</span>);				<span class="comment">//OLED闪烁RST字符串</span></span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;   &quot;</span>);</span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*1.开启时钟*/</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, ENABLE);	<span class="comment">//开启WWDG的时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*WWDG初始化*/</span></span><br><span class="line">	WWDG_SetPrescaler(WWDG_Prescaler_8);			<span class="comment">//设置预分频为8</span></span><br><span class="line">	WWDG_SetWindowValue(<span class="number">21</span> | <span class="number">0x40</span>);					<span class="comment">//设置窗口值，窗口时间为30ms</span></span><br><span class="line">	WWDG_Enable(<span class="number">54</span> | <span class="number">0x40</span>);							<span class="comment">//使能并第一次喂狗，超时时间为50ms</span></span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Key_GetNum();								<span class="comment">//调用阻塞式的按键扫描函数，模拟主循环卡死</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">/*如果把喂狗放在这里的话程序会一直触发看门狗复位，因为距离第一次喂狗时间&lt;30ms，就会触发看门狗复位*/</span></span><br><span class="line">        </span><br><span class="line">		OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;FEED&quot;</span>);				<span class="comment">//OLED闪烁FEED字符串</span></span><br><span class="line">		Delay_ms(<span class="number">20</span>);								<span class="comment">//喂狗间隔为20+20=40ms</span></span><br><span class="line">		OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;    &quot;</span>);</span><br><span class="line">		Delay_ms(<span class="number">20</span>);</span><br><span class="line">		</span><br><span class="line">		WWDG_SetCounter(<span class="number">54</span> | <span class="number">0x40</span>);					<span class="comment">//重装计数器，喂狗</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>代码中的或上0x40操作：</code></p>
<p>每次喂狗或上0x40是对计数器的T6位设置为1，避免每次喂狗后立即产生一个复位</p>
<p>而设置窗口时的或上0x40是为了使W6位也为1，这样才能将该窗口值与喂狗值比较，否则窗口值一直小于喂狗值</p>
</blockquote>
<h1 id="FLASH-闪存"><a href="#FLASH-闪存" class="headerlink" title="FLASH 闪存"></a>FLASH 闪存</h1><h2 id="FLASH简介"><a href="#FLASH简介" class="headerlink" title="FLASH简介"></a>FLASH简介</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250112184103510-1752337644189-662.png" alt="image-20250112184103510"></p>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250113122739972-1752337644189-664.png" alt="image-20250113122739972"></p>
<p><code>FLASH：</code>程序存储器、系统存储器、选项字节三部分。</p>
<p>通过<code>闪存存储器接口(外设)：</code><strong>可以对程序存储器和选项字节进行擦除和编程</strong></p>
<hr>
<p><code>读写FLASH的用途：</code></p>
<ol>
<li><strong>利用程序存储器Flash的剩余空间来保存掉电不丢失的用户数据</strong></li>
<li><strong>通过在程序中编程IAP，实现程序的自我更新</strong></li>
</ol>
<hr>
<p><code>在线编程</code>(In-Circuit Programming-ICP)：用于更新程序存储器的全部内容，它通过JTAG、SWD协议或系统加载程序(Bootloader)下载程序</p>
<p><code>在程序中编程</code>(In-Application Programming-lAP)： 可以使用微制器支持的任一种通信接口下载程序</p>
<hr>
<p><code>下图各个流程都是闪存编程参考手册中的内容，可以观看闪存编程手册编程!!!</code></p>
</blockquote>
<blockquote>
<p>当有些参数数据需要掉电不丢失的时候，我们可以将其写入内部FLASH中，这样不用外挂存储器芯片，节省了资源</p>
</blockquote>
<h2 id="闪存模块组织"><a href="#闪存模块组织" class="headerlink" title="闪存模块组织"></a>闪存模块组织</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250113123459899-1752337644189-666.png" alt="image-20250113123459899"></p>
<blockquote>
<p><code>闪存三部分：</code></p>
<p><strong>主存储器</strong>对应：<code>1.程序存储器Flash</code>，起始地址0x0800 0000。也是我们平时说的闪存容量的部分，另外两部分也属于闪存，但不统计进入容量内。</p>
<p><strong>信息块</strong>：</p>
<ul>
<li><p><strong>启动程序代码</strong>对应：<code>2.系统存储器</code>，存放bootloader。起始地址0x1FFF F000</p>
</li>
<li><p><strong>用户选择字节</strong>对应：<code>3.选项字节</code>，起始地址0x1FFF F800</p>
</li>
</ul>
<p><strong>闪存存储器接口寄存器(外设)</strong>：从地址来看就是普通的外设寄存器，SRAM的内容</p>
<hr>
<p>与W25Q64分为块、扇区、页不同</p>
<p><strong>内部Flash只有页为基本单位，每页大小为</strong><code>1K</code></p>
<p>以000、400、800、C00结尾的都一定是页的起始地址。</p>
<hr>
<p><code>对于不同容量产品，闪存的分配方式有些区别，参考单独的闪存编程参考手册！！！</code></p>
</blockquote>
<h2 id="FLASH基本结构"><a href="#FLASH基本结构" class="headerlink" title="FLASH基本结构"></a>FLASH基本结构</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250113143613020-1752337644189-668.png" alt="image-20250113143613020"></p>
<blockquote>
<ol>
<li><p><strong>闪存存储器接口也叫闪存编程和擦除控制器FPEC</strong>。可以对程序存储器擦除和编程、选项字节擦除和编程</p>
</li>
<li><p>选项字节可以配置程序存储器的读写保护</p>
</li>
</ol>
</blockquote>
<h2 id="FLASH解锁"><a href="#FLASH解锁" class="headerlink" title="FLASH解锁"></a>FLASH解锁</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250113143920049-1752337644189-665.png" alt="image-20250113143920049"></p>
<blockquote>
<p><code>FPEC：</code>闪存存储器接口&#x2F;闪存编程和擦除控制器，其中的键寄存器有三个键值</p>
<p><strong>通过向键寄存器写入指定值可以解锁FLASH的写操作，对于读操作不用执行解锁操作</strong></p>
<p><code>解锁方式：</code></p>
<ol>
<li>先向FLASH_KEYR写入KEY1</li>
<li>再向FLASH_KEYR写入KEY2</li>
</ol>
<p>保护机制：一旦没有先写入KEY1，再写入KEY2就会锁死，除非复位</p>
<p><code>加锁方式：</code></p>
<ol>
<li>设置FLASH_CR中给的LOCK位锁住FPEC和FLASH_CR</li>
</ol>
<p><code>操作闪存方式：</code>先解锁，操作完后，再加锁即可</p>
</blockquote>
<h2 id="使用指针访问存储器-指针写入操作"><a href="#使用指针访问存储器-指针写入操作" class="headerlink" title="使用指针访问存储器(指针写入操作)"></a>使用指针访问存储器(指针写入操作)</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250113144515473-1752337644189-667.png" alt="image-20250113144515473"></p>
<blockquote>
<p>想以什么形式的方式读出数据，就把uint16_t* 改为对应类型即可，比如想以8位读取，将uint16_t*改为uint8_t*即可</p>
</blockquote>
<blockquote>
<p><code>使用 __IO原因：</code></p>
<p>当单片机通过指针访问外部硬件设备的寄存器时，<strong>由于这些寄存器的值可能会由硬件自动更新</strong>（例如，一个定时器寄存器的值会随时间变化），因此应该将这些寄存器对应的变量声明为volatile。 这样，每次访问这些变量时，都会直接从硬件寄存器中读取值，而不是使用可能已过时的缓存值。</p>
</blockquote>
<h2 id="程序存储器FLASH的擦除和编程"><a href="#程序存储器FLASH的擦除和编程" class="headerlink" title="程序存储器FLASH的擦除和编程"></a>程序存储器FLASH的擦除和编程</h2><p>以下内容对应stm32闪存编写手册的2.3.4节和2.3.3节</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250113151653732-1752337644189-670.png" alt="image-20250113151653732"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250113151600875-1752337644189-671.png" alt="image-20250113151600875"></p>
<h3 id="程序存储器FLASH的全擦除"><a href="#程序存储器FLASH的全擦除" class="headerlink" title="程序存储器FLASH的全擦除"></a>程序存储器FLASH的全擦除</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250113145605786-1752337644189-669.png" alt="image-20250113145605786"></p>
<blockquote>
<p><strong>程序的全擦除在库函数中使用了一个函数，我们可以直接使用，以下就是函数的底层寄存器操作步骤</strong></p>
<p><code>步骤如下：</code></p>
<ol>
<li>读取FLASH_CR的<code>LOCK位</code>，如果锁住了需要先解锁(库函数都是直接解锁)</li>
<li>置FLASH_CR的<code>MER = 1</code> (MER表示执行的是全擦除)，置FLASH_CR的<code>STRT = 1</code> (STRT为触发条件，置1后芯片开始干活)</li>
<li>检测FLASH_SR的<code>BSY位是否为1</code>，为1就一直等待，直到BSY位置0后全擦除结束</li>
</ol>
<p>读出并验证被擦除页的数据我们可以不管</p>
</blockquote>
<h3 id="程序存储器FLASH的页擦除"><a href="#程序存储器FLASH的页擦除" class="headerlink" title="程序存储器FLASH的页擦除"></a>程序存储器FLASH的页擦除</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250113172548064-1752337644189-673.png" alt="image-20250113172548064"></p>
<blockquote>
<p><strong>程序的页擦除在库函数中使用了一个函数，我们可以直接使用，以下就是函数的底层寄存器操作步骤</strong></p>
<p><code>步骤如下：</code></p>
<ol>
<li><p>读取FLASH_CR的<code>LOCK位</code>，如果锁住了需要先解锁(库函数都是直接解锁)</p>
</li>
<li><p>置FLASH_CR的<code>PER = 1</code> (PER表示执行的是页擦除)，</p>
<p>然后在FLASH_AR中选择要擦除的页，此地址提前写入</p>
<p>最后置FLASH_CR的<code>STRT = 1</code> (STRT为触发条件，置1后芯片开始干活)</p>
</li>
<li><p>检测FLASH_SR的<code>BSY位是否为1</code>，为1就一直等待，直到BSY位置0后全擦除结束</p>
</li>
</ol>
<p>读出并验证被擦除页的数据我们可以不管</p>
</blockquote>
<h3 id="程序存储器FLASH编程"><a href="#程序存储器FLASH编程" class="headerlink" title="程序存储器FLASH编程"></a>程序存储器FLASH编程</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250113145516235-1752337644189-672.png" alt="image-20250113145516235"></p>
<blockquote>
<p><code>注：STM32的闪存会在写入前检查指定地址有没有擦除，如果没有擦除，STM32不执行写入操作，除非写入的全为0!!!</code></p>
<p><strong>程序的全擦除在库函数中使用了一个函数，我们可以直接使用，以下就是函数的底层寄存器操作步骤</strong></p>
<p><code>步骤如下：</code></p>
<ol>
<li>读取FLASH_CR的<code>LOCK位</code>，如果锁住了需要先解锁(库函数都是直接解锁)</li>
<li>置FLASH_CR的<code>PG = 1</code> (PG表示执行的是编程操作)</li>
<li>在指定地址写入半字(16位)，只能以半字写入16位(使用指针写入操作)</li>
<li>检测FLASH_SR的<code>BSY位是否为1</code>，为1就一直等待，直到BSY位置0后全擦除结束</li>
</ol>
<p><code>每次流程只能写入半字，如果想要写入很多字节，只需循环调用上面的步骤即可</code></p>
<hr>
<p><code>字、半字、字节：</code></p>
<p>Word(字)：32位数据</p>
<p>HalfWord(半字)：16位数据</p>
<p>Byte(字节)：8位数据</p>
</blockquote>
<h2 id="选项字节"><a href="#选项字节" class="headerlink" title="选项字节"></a>选项字节</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250113151106010-1752337644189-674.png" alt="image-20250113151106010"></p>
<blockquote>
<p><code>选项字节：</code>存放独立于程序代码的配置参数</p>
</blockquote>
<p><strong>内容对应闪存编程手册2.5节</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250113151906094-1752337644190-675.png" alt="image-20250113151906094"></p>
<h3 id="选项字节擦除"><a href="#选项字节擦除" class="headerlink" title="选项字节擦除"></a>选项字节擦除</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250113151712143-1752337644190-676.png" alt="image-20250113151712143"></p>
<blockquote>
<ol>
<li><p>先解锁闪存</p>
</li>
<li><p>检查FLASH SR的BSY位，以确认没有其他正在进行的闪存操作</p>
</li>
<li><p>解锁FLASH_CR的OPTWRE(Option Write Enable)位，即：对FLASH_OPTKEY写入类似对FLASH_KEYR解锁的两个KEY操作</p>
</li>
<li><p>设置FLASH CR的OPTER位为1，设置FLASH CR的STRT位为1</p>
</li>
<li><p>等待BSY位变为0，即擦除结束</p>
</li>
<li><p>读出被擦除的选择字节并做验证(不必要操作)</p>
</li>
</ol>
</blockquote>
<h3 id="选项字节的编程"><a href="#选项字节的编程" class="headerlink" title="选项字节的编程"></a>选项字节的编程</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250113151403201-1752337644190-677.png" alt="image-20250113151403201"></p>
<blockquote>
<ol>
<li><p>先解锁闪存</p>
</li>
<li><p>检查FLASH SR的BSY位，以确认没有其他正在进行的闪存操作</p>
</li>
<li><p>解锁FLASH_CR的OPTWRE(Option Write Enable)位，即：对FLASH_OPTKEY写入类似对FLASH_KEYR解锁的两个KEY操作</p>
</li>
<li><p>设置FLASH CR的OPTPG位为1</p>
</li>
<li><p>写入要编程的半字到指定地址</p>
</li>
<li><p>等待BSY位变为0，即写入结束</p>
</li>
<li><p>读出被擦除的选择字节并做验证(不必要操作)</p>
</li>
</ol>
</blockquote>
<h2 id="器件电子签名"><a href="#器件电子签名" class="headerlink" title="器件电子签名"></a>器件电子签名</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250113152633326-1752337644190-678.png" alt="image-20250113152633326"></p>
<blockquote>
<p><code>器件电子签名相关内容对应参考手册第28章的内容!!!</code></p>
<p><strong>电子签名其实就是芯片ID号</strong></p>
<p>**存放在系统存储器区域：**包含BootLoader和几个字节的电子签名</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250113152728389-1752337644190-679.png" alt="image-20250113152728389"></p>
</blockquote>
<h2 id="FLASH-库函数"><a href="#FLASH-库函数" class="headerlink" title="FLASH 库函数"></a>FLASH 库函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*stm32f10x_flash.h*/</span></span><br><span class="line"><span class="comment">/*------------ Functions used for all STM32F10x devices -----*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_SetLatency</span><span class="params">(<span class="type">uint32_t</span> FLASH_Latency)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_HalfCycleAccessCmd</span><span class="params">(<span class="type">uint32_t</span> FLASH_HalfCycleAccess)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_PrefetchBufferCmd</span><span class="params">(<span class="type">uint32_t</span> FLASH_PrefetchBuffer)</span>;</span><br><span class="line">FlagStatus <span class="title function_">FLASH_GetPrefetchBufferStatus</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">/*内核运行代码相关，我们不需要使用*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*加锁解锁：*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_Unlock</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_Lock</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//芯片的加锁和解锁，KEY1,KEY2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*芯片擦除：*/</span></span><br><span class="line">FLASH_Status <span class="title function_">FLASH_ErasePage</span><span class="params">(<span class="type">uint32_t</span> Page_Address)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_EraseAllPages</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_EraseOptionBytes</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//分别是页擦除、全擦除、选项字节擦除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*芯片写入(编程):*/</span></span><br><span class="line">FLASH_Status <span class="title function_">FLASH_ProgramWord</span><span class="params">(<span class="type">uint32_t</span> Address, <span class="type">uint32_t</span> Data)</span>;<span class="comment">//指定地址写入字</span></span><br><span class="line">FLASH_Status <span class="title function_">FLASH_ProgramHalfWord</span><span class="params">(<span class="type">uint32_t</span> Address, <span class="type">uint16_t</span> Data)</span>;<span class="comment">////指定地址写入半字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*选项字节读写相关:*/</span></span><br><span class="line">FLASH_Status <span class="title function_">FLASH_ProgramOptionByteData</span><span class="params">(<span class="type">uint32_t</span> Address, <span class="type">uint8_t</span> Data)</span>;<span class="comment">//选项字节写入Data</span></span><br><span class="line">FLASH_Status <span class="title function_">FLASH_EnableWriteProtection</span><span class="params">(<span class="type">uint32_t</span> FLASH_Pages)</span>;<span class="comment">//选项字节写保护使能</span></span><br><span class="line">FLASH_Status <span class="title function_">FLASH_ReadOutProtection</span><span class="params">(FunctionalState NewState)</span>;<span class="comment">//选项字节都保护</span></span><br><span class="line">FLASH_Status <span class="title function_">FLASH_UserOptionByteConfig</span><span class="params">(<span class="type">uint16_t</span> OB_IWDG, <span class="type">uint16_t</span> OB_STOP, <span class="type">uint16_t</span> OB_STDBY)</span>;<span class="comment">//用户选项的三个配置位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*选项字节状态获取：*/</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">FLASH_GetUserOptionByte</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">FLASH_GetWriteProtectionOptionByte</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">FlagStatus <span class="title function_">FLASH_GetReadOutProtectionStatus</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*标志位相关*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_ITConfig</span><span class="params">(<span class="type">uint32_t</span> FLASH_IT, FunctionalState NewState)</span>;</span><br><span class="line">FlagStatus <span class="title function_">FLASH_GetFlagStatus</span><span class="params">(<span class="type">uint32_t</span> FLASH_FLAG)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_ClearFlag</span><span class="params">(<span class="type">uint32_t</span> FLASH_FLAG)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_GetStatus</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">FLASH_Status <span class="title function_">FLASH_WaitForLastOperation</span><span class="params">(<span class="type">uint32_t</span> Timeout)</span>;<span class="comment">//等待上一次操作，也就是等待BSY为0，在上面读写擦除的库函数内部已经调用了，我们不需要调用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--我们这里用不到下面的函数</span><br><span class="line"><span class="comment">/*------------ New function used for all STM32F10x devices -----*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_UnlockBank1</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_LockBank1</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_EraseAllBank1Pages</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_GetBank1Status</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_WaitForLastBank1Operation</span><span class="params">(<span class="type">uint32_t</span> Timeout)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> STM32F10X_XL</span></span><br><span class="line"><span class="comment">/*---- New Functions used only with STM32F10x_XL density devices -----*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_UnlockBank2</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_LockBank2</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_EraseAllBank2Pages</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_GetBank2Status</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_WaitForLastBank2Operation</span><span class="params">(<span class="type">uint32_t</span> Timeout)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_BootConfig</span><span class="params">(<span class="type">uint16_t</span> FLASH_BOOT)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面三个库函数分为部分：<strong>通用函数、新加的通用函数、新加的只能被大容量XL系列使用的函数</strong></p>
<p>图中的Bank2是后面新推出加大容量XL系列新加的一块Flash</p>
</blockquote>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="简单读写FLASH-FLASH底层代码实现"><a href="#简单读写FLASH-FLASH底层代码实现" class="headerlink" title="简单读写FLASH(FLASH底层代码实现)"></a>简单读写FLASH(FLASH底层代码实现)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取一个字32bit</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">MyFlash_ReadWord</span><span class="params">(<span class="type">uint32_t</span> Address)</span></span><br><span class="line">&#123;</span><br><span class="line">	 <span class="keyword">return</span>  *((__IO <span class="type">uint32_t</span>*)(Address));<span class="comment">////使用指针访问指定地址下的数据并返回</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取半字16bit</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">MyFlash_ReadHalfWord</span><span class="params">(<span class="type">uint32_t</span> Address)</span></span><br><span class="line">&#123;</span><br><span class="line">	 <span class="keyword">return</span>  *((__IO <span class="type">uint16_t</span>*)(Address));<span class="comment">//使用指针访问指定地址下的数据并返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将32位地址强转为指向uint16_t数据的指针，Address值也就是该指针不会变，仅仅将这个指针(地址)指向的数据变为了uint16_t</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取字节8bit</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyFlash_ReadByte</span><span class="params">(<span class="type">uint32_t</span> Address)</span></span><br><span class="line">&#123;</span><br><span class="line">	 <span class="keyword">return</span>  *((__IO <span class="type">uint8_t</span>*)(Address));<span class="comment">//使用指针访问指定地址下的数据并返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全擦除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFlash_EraseAllPages</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">		FLASH_Unlock();<span class="comment">//解锁</span></span><br><span class="line">		FLASH_EraseAllPages();<span class="comment">//全擦除</span></span><br><span class="line">		FLASH_Lock();<span class="comment">//加锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//页擦除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFlash_ErasePage</span><span class="params">(<span class="type">uint32_t</span> Page_Address)</span></span><br><span class="line">&#123;</span><br><span class="line">		FLASH_Unlock();<span class="comment">//解锁</span></span><br><span class="line">		FLASH_ErasePage(Page_Address);<span class="comment">//全擦除</span></span><br><span class="line">		FLASH_Lock();<span class="comment">//加锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//选项字节擦除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFLash_EraseOptionBytes</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">		FLASH_Unlock();<span class="comment">//解锁</span></span><br><span class="line">		FLASH_EraseOptionBytes();<span class="comment">//全擦除</span></span><br><span class="line">	  FLASH_Lock();<span class="comment">//加锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入字32bit</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFlash_ProgramWord</span><span class="params">(<span class="type">uint32_t</span> Address, <span class="type">uint32_t</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">	FLASH_Unlock();							<span class="comment">//解锁</span></span><br><span class="line">	FLASH_ProgramWord(Address, Data);		<span class="comment">//编程字</span></span><br><span class="line">	FLASH_Lock();							<span class="comment">//加锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入半字16bit</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFlash_ProgramHalfWord</span><span class="params">(<span class="type">uint32_t</span> Address, <span class="type">uint16_t</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">	FLASH_Unlock();							<span class="comment">//解锁</span></span><br><span class="line">	FLASH_ProgramHalfWord(Address, Data);	<span class="comment">//编程半字</span></span><br><span class="line">	FLASH_Lock();							<span class="comment">//加锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MyFlash.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYFLASH_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYFLASH_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">MyFlash_ReadWord</span><span class="params">(<span class="type">uint32_t</span> Address)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">MyFlash_ReadHalfWord</span><span class="params">(<span class="type">uint32_t</span> Address)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyFlash_ReadByte</span><span class="params">(<span class="type">uint32_t</span> Address)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFlash_EraseAllPages</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFlash_ErasePage</span><span class="params">(<span class="type">uint32_t</span> Page_Address)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFLash_EraseOptionBytes</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFlash_ProgramWord</span><span class="params">(<span class="type">uint32_t</span> Address, <span class="type">uint32_t</span> Data)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFlash_ProgramHalfWord</span><span class="params">(<span class="type">uint32_t</span> Address, <span class="type">uint16_t</span> Data)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyFlash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> data1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint16_t</span> data2 = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> data3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">		</span><br><span class="line">			</span><br><span class="line">		MyFlash_ErasePage(<span class="number">0x0800FC00</span>);<span class="comment">//写入前要先擦除，写入区域</span></span><br><span class="line">				</span><br><span class="line">				MyFlash_ProgramWord(<span class="number">0x0800FC00</span>,<span class="number">0x12345678</span>);<span class="comment">//写入Flash最后的区域一个字,数据为0x12345678</span></span><br><span class="line">	      MyFlash_ProgramHalfWord(<span class="number">0x0800FC10</span>,<span class="number">0xABCD</span>);<span class="comment">//写入半个字，数据为0xABCD</span></span><br><span class="line">	      </span><br><span class="line">	    data1 = MyFlash_ReadWord(<span class="number">0x0800FC00</span>);</span><br><span class="line">		data2 = MyFlash_ReadHalfWord(<span class="number">0x0800FC00</span>);</span><br><span class="line">	      </span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;	</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>最终读取的结果如下keil变量的值，以及内存中的值如图</p>
<p><strong>我们也可以使用STM32 ST-LINK Utility软件直接观察</strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250113194907167-1752337644190-680.png" alt="image-20250113194907167"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250113194929798-1752337644190-681.png" alt="image-20250113194929798"></p>
<h3 id="在SRAM中定义数组和标志位对FLASH数据存储"><a href="#在SRAM中定义数组和标志位对FLASH数据存储" class="headerlink" title="在SRAM中定义数组和标志位对FLASH数据存储"></a>在SRAM中定义数组和标志位对FLASH数据存储</h3><blockquote>
<p><strong>在SRAM定义数组写入数据到FLASH，并且实现上电FLASH数据读取到SRAM操作</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*store.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STORE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STORE_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint16_t</span> Store_Data[]; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Store_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Store_Save</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Store_Clear</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*store.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyFLASH.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*对于这种在很多地方出现，对应不同芯片有不同值得数据我们使用宏定义，提高程序的复用*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STORE_START_ADDRESS		0x0800FC00		<span class="comment">//存储的起始地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STORE_COUNT				512				<span class="comment">//存储数据的个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> Store_Data[STORE_COUNT];				<span class="comment">//定义SRAM数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：参数存储模块初始化</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Store_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*地址的第一个半字存储标志位以此判断是不是第一次使用,*/</span></span><br><span class="line">	<span class="keyword">if</span> (MyFLASH_ReadHalfWord(STORE_START_ADDRESS) != <span class="number">0xA5A5</span>)	<span class="comment">//读取第一个半字的标志位，if成立，则执行第一次使用的初始化</span></span><br><span class="line">	&#123;</span><br><span class="line">		MyFLASH_ErasePage(STORE_START_ADDRESS);					<span class="comment">//擦除指定页</span></span><br><span class="line">		MyFLASH_ProgramHalfWord(STORE_START_ADDRESS, <span class="number">0xA5A5</span>);	<span class="comment">//在第一个半字写入自己规定的标志位，用于判断是不是第一次使用</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">uint16_t</span> i = <span class="number">1</span>; i &lt; STORE_COUNT; i ++)				<span class="comment">//循环STORE_COUNT次，除了第一个标志位</span></span><br><span class="line">		&#123;</span><br><span class="line">			MyFLASH_ProgramHalfWord(STORE_START_ADDRESS + i * <span class="number">2</span>, <span class="number">0x0000</span>);		<span class="comment">//除了标志位的有效数据全部清0</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*上电时，将闪存数据加载回SRAM数组，实现SRAM数组的掉电不丢失*/</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">uint16_t</span> i = <span class="number">0</span>; i &lt; STORE_COUNT; i ++)					<span class="comment">//循环STORE_COUNT次，包括第一个标志位</span></span><br><span class="line">	&#123;</span><br><span class="line">		Store_Data[i] = MyFLASH_ReadHalfWord(STORE_START_ADDRESS + i * <span class="number">2</span>);		<span class="comment">//将闪存的数据加载回SRAM数组</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：参数存储模块保存数据到闪存</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Store_Save</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	MyFLASH_ErasePage(STORE_START_ADDRESS);				<span class="comment">//擦除指定页</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">uint16_t</span> i = <span class="number">0</span>; i &lt; STORE_COUNT; i ++)			<span class="comment">//循环STORE_COUNT次，包括第一个标志位</span></span><br><span class="line">	&#123;</span><br><span class="line">		MyFLASH_ProgramHalfWord(STORE_START_ADDRESS + i * <span class="number">2</span>, Store_Data[i]);	<span class="comment">//将SRAM数组的数据备份保存到闪存</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：参数存储模块将所有有效数据清0</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Store_Clear</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">uint16_t</span> i = <span class="number">1</span>; i &lt; STORE_COUNT; i ++)			<span class="comment">//循环STORE_COUNT次，除了第一个标志位</span></span><br><span class="line">	&#123;</span><br><span class="line">		Store_Data[i] = <span class="number">0x0000</span>;							<span class="comment">//SRAM数组有效数据清0</span></span><br><span class="line">	&#125;</span><br><span class="line">	Store_Save();										<span class="comment">//保存数据到闪存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Store.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> KeyNum;					<span class="comment">//定义用于接收按键键码的变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*模块初始化*/</span></span><br><span class="line">	OLED_Init();				<span class="comment">//OLED初始化</span></span><br><span class="line">	Key_Init();					<span class="comment">//按键初始化</span></span><br><span class="line">	Store_Init();				<span class="comment">//参数存储模块初始化，在上电的时候将闪存的数据加载回Store_Data，实现掉电不丢失</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*显示静态字符串*/</span></span><br><span class="line">	OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;Flag:&quot;</span>);</span><br><span class="line">	OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;Data:&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		KeyNum = Key_GetNum();		<span class="comment">//获取按键键码</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (KeyNum == <span class="number">1</span>)			<span class="comment">//按键1按下</span></span><br><span class="line">		&#123;</span><br><span class="line">			Store_Data[<span class="number">1</span>] ++;		<span class="comment">//变换测试数据</span></span><br><span class="line">			Store_Data[<span class="number">2</span>] += <span class="number">2</span>;</span><br><span class="line">			Store_Data[<span class="number">3</span>] += <span class="number">3</span>;</span><br><span class="line">			Store_Data[<span class="number">4</span>] += <span class="number">4</span>;</span><br><span class="line">			Store_Save();			<span class="comment">//将Store_Data的数据备份保存到闪存，实现掉电不丢失</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (KeyNum == <span class="number">2</span>)			<span class="comment">//按键2按下</span></span><br><span class="line">		&#123;</span><br><span class="line">			Store_Clear();			<span class="comment">//将Store_Data的数据全部清0</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		OLED_ShowHexNum(<span class="number">1</span>, <span class="number">6</span>, Store_Data[<span class="number">0</span>], <span class="number">4</span>);	<span class="comment">//显示Store_Data的第一位标志位</span></span><br><span class="line">		OLED_ShowHexNum(<span class="number">3</span>, <span class="number">1</span>, Store_Data[<span class="number">1</span>], <span class="number">4</span>);	<span class="comment">//显示Store_Data的有效存储数据</span></span><br><span class="line">		OLED_ShowHexNum(<span class="number">3</span>, <span class="number">6</span>, Store_Data[<span class="number">2</span>], <span class="number">4</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">4</span>, <span class="number">1</span>, Store_Data[<span class="number">3</span>], <span class="number">4</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">4</span>, <span class="number">6</span>, Store_Data[<span class="number">4</span>], <span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>实现按键1按下存入FLASH中，按键2按下清除数据</p>
</blockquote>
<h3 id="读取芯片ID-使用指针直接访问读取"><a href="#读取芯片ID-使用指针直接访问读取" class="headerlink" title="读取芯片ID(使用指针直接访问读取)"></a>读取芯片ID(使用指针直接访问读取)</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250113152633326-1752337644190-678.png" alt="image-20250113152633326"></p>
<p><code>对应手册28章内容：</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250113204952775-1752337644190-682.png" alt="image-20250113204952775"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250113205028352-1752337644190-683.png" alt="image-20250113205028352"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	OLED_Init();						<span class="comment">//OLED初始化</span></span><br><span class="line">	</span><br><span class="line">	OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;F_SIZE:&quot;</span>);	<span class="comment">//显示静态字符串</span></span><br><span class="line">	OLED_ShowHexNum(<span class="number">1</span>, <span class="number">8</span>, *((__IO <span class="type">uint16_t</span> *)(<span class="number">0x1FFFF7E0</span>)), <span class="number">4</span>);		<span class="comment">//使用指针读取指定地址下的闪存容量寄存器</span></span><br><span class="line">	</span><br><span class="line">	OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;U_ID:&quot;</span>);		<span class="comment">//显示静态字符串</span></span><br><span class="line">	OLED_ShowHexNum(<span class="number">2</span>, <span class="number">6</span>, *((__IO <span class="type">uint16_t</span> *)(<span class="number">0x1FFFF7E8</span>)), <span class="number">4</span>);		<span class="comment">//使用指针读取指定地址下的产品唯一身份标识寄存器</span></span><br><span class="line">	OLED_ShowHexNum(<span class="number">2</span>, <span class="number">11</span>, *((__IO <span class="type">uint16_t</span> *)(<span class="number">0x1FFFF7E8</span> + <span class="number">0x02</span>)), <span class="number">4</span>);</span><br><span class="line">	OLED_ShowHexNum(<span class="number">3</span>, <span class="number">1</span>, *((__IO <span class="type">uint32_t</span> *)(<span class="number">0x1FFFF7E8</span> + <span class="number">0x04</span>)), <span class="number">8</span>);</span><br><span class="line">	OLED_ShowHexNum(<span class="number">4</span>, <span class="number">1</span>, *((__IO <span class="type">uint32_t</span> *)(<span class="number">0x1FFFF7E8</span> + <span class="number">0x08</span>)), <span class="number">8</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>**闪存容量寄存器：**使用半字读取</p>
<p>**产品唯一身份标识寄存器：**2个半字和2个字读取</p>
<p>全部显示到OLED上去</p>
</blockquote>
<h2 id="存在的BUG-当程序很大时覆盖用户存储参数区"><a href="#存在的BUG-当程序很大时覆盖用户存储参数区" class="headerlink" title="存在的BUG-当程序很大时覆盖用户存储参数区"></a>存在的BUG-当程序很大时覆盖用户存储参数区</h2><p><code>问题描述：</code></p>
<p><strong>我们上面由于程序较小，程序存储在Flash的靠前区域，我们使用最后一页存储用户数据，但是如果程序很大的时候，可能就会到最后一页，造成程序和用户数据存储的位置冲突。</strong></p>
<p><code>解决方法：</code>给程序文件限定一个存储范围，不让它分配到后面我们的用户数据空间来。</p>
<ol>
<li><strong>打开工程管理</strong></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250113203529438-1752337644190-684.png" alt="image-20250113203529438"></p>
<ol start="2">
<li><strong>目前使用的是起始地址为0x80000000，Size大小为0x10000(64KB)，刚好使用完了程序存储区</strong></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250113203606973-1752337644190-685.png" alt="image-20250113203606973"></p>
<ol start="3">
<li><strong>如果我们想把程序区的最后自己使用，修改Size为0xFC00，这样到FC00之前就是程序存储的地方，后面地址我们可以自己存放用户参数</strong></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250113203950691-1752337644190-686.png" alt="image-20250113203950691"></p>
<blockquote>
<p>注意修改size大小不能太小，太小了也会报错</p>
</blockquote>
<h2 id="Flash写入之前的擦除必要性"><a href="#Flash写入之前的擦除必要性" class="headerlink" title="Flash写入之前的擦除必要性"></a>Flash写入之前的擦除必要性</h2><p><strong>1.Flash 默认状态是“全 1”</strong>：</p>
<ul>
<li>Flash 存储器在擦除之前的默认值是“1”，即每个字节的每一位都设为 1。当你想要写入数据时，必须将目标区域从“1”改为“0”。但是 Flash 存储器并不支持直接将 “0” 恢复为 “1”，只能将其设置为“0”。</li>
</ul>
<p><strong>2.擦除是将区域复位为“全 1”</strong>：</p>
<ul>
<li>擦除操作是将整个存储单元（如页面或扇区）恢复为“全 1”状态，为后续的写入做好准备。只有当区域恢复为全 1 后，才能写入新的数据。</li>
</ul>
<p><strong>3.Flash 的写入操作是“增量”</strong>：</p>
<ul>
<li>你可以在一个已擦除区域中写入数据，但不能直接覆盖其中的</li>
</ul>
<h2 id="STM32-ST-LINK-Utility"><a href="#STM32-ST-LINK-Utility" class="headerlink" title="STM32 ST-LINK Utility"></a>STM32 ST-LINK Utility</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250113171621586-1752337644190-687.png" alt="image-20250113171621586"></p>
<blockquote>
<p>我们可以使用STM32 ST-LINK Utility这个软件直接查看和修改我们芯片内部的各个地址的内容。</p>
<p>关于上方的内部FLASH和选项字节模块对应都可以查看和修改</p>
<p>使用代码配置读写保护时如果造成了芯片自锁，但程序里没有预留解除写保护的代码，造成没法下载程序了，我们可以使用这个这个软件直接去掉读写保护就可以解除芯片的自锁。</p>
</blockquote>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://i.postimg.cc/fbN6bFqP/20220206101541-14a48.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://i.postimg.cc/fbN6bFqP/20220206101541-14a48.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">THEDI</div><div class="post-copyright__author_desc">我想睡到12点!</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://www.thekqd.top/2025/01/13/STM32%E6%A0%87%E5%87%86%E5%BA%93/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://www.thekqd.top/2025/01/13/STM32%E6%A0%87%E5%87%86%E5%BA%93/')">STM32(标准库)</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/null" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/null" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://www.thekqd.top/2025/01/13/STM32%E6%A0%87%E5%87%86%E5%BA%93/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=STM32(标准库)&amp;url=https://www.thekqd.top/2025/01/13/STM32%E6%A0%87%E5%87%86%E5%BA%93/&amp;pic=/assets/14.webp" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.thekqd.top" target="_blank">THEDI的仓库</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>嵌入式<span class="tagsPageCount">2</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="/assets/213.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/02/21/C++-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/25.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++学习笔记</div></div></a></div><div class="next-post pull-right"><a href="/2025/05/23/PCB-Layout/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/36.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">PCB Layout</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2023/04/02/STM32HAL%E5%BA%93/" title="STM32(HAL库)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/3.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-02</div><div class="title">STM32(HAL库)</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://i.postimg.cc/fbN6bFqP/20220206101541-14a48.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">THEDI</h1><div class="author-info__desc">我想睡到12点!</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="/assets/QRCode.jpg" target="_blank" title="微信"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-weixin"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/" target="_blank" title="B站"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg></a><a class="social-icon faa-parent animated-hover" href="mailto:1244381125@qq.com" target="_blank" title="QQ邮箱"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxiang"></use></svg></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">不要偷看我的博客!</div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(null) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#keil%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%8A%AF%E7%89%87%E5%8C%85%E4%B8%8B%E8%BD%BD"><span class="toc-number">1.</span> <span class="toc-text">keil配置与芯片包下载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BA%E4%BB%B6%E5%BA%93%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.</span> <span class="toc-text">固件库文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#keil%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">keil新建工程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">1.3.</span> <span class="toc-text">启动文件的选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stm32f10x-h"><span class="toc-number">1.4.</span> <span class="toc-text">stm32f10x.h</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%E6%AD%A5%E9%AA%A4%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.</span> <span class="toc-text">新建工程步骤总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">模块化编程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#STM32%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text">STM32启动文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GPIO"><span class="toc-number">4.</span> <span class="toc-text">GPIO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RCC%E5%BC%80%E5%90%AF%E6%97%B6%E9%92%9F"><span class="toc-number">4.1.</span> <span class="toc-text">RCC开启时钟</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GPIO%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.</span> <span class="toc-text">GPIO标准库函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">4.3.</span> <span class="toc-text">具体流程代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-LED%E6%B5%81%E6%B0%B4%E7%81%AF"><span class="toc-number">4.4.</span> <span class="toc-text">实验-LED流水灯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.5.</span> <span class="toc-text">输入模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GPIO%E7%9B%B8%E5%85%B3%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">4.6.</span> <span class="toc-text">GPIO相关寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E8%84%9A%E9%87%8D%E6%98%A0%E5%B0%84-%E5%A4%8D%E7%94%A8%E5%8A%9F%E8%83%BD%E9%87%8D%E6%98%A0%E5%83%8F"><span class="toc-number">4.7.</span> <span class="toc-text">引脚重映射(复用功能重映像)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#EXTI-%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD"><span class="toc-number">5.</span> <span class="toc-text">EXTI(外部中断)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.</span> <span class="toc-text">库函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B"><span class="toc-number">5.3.</span> <span class="toc-text">初始化配置流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%87%BD%E6%95%B0"><span class="toc-number">5.4.</span> <span class="toc-text">中断函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E6%97%8B%E8%BD%AC%E7%BC%96%E7%A0%81%E5%99%A8%E8%AE%A1%E6%95%B0"><span class="toc-number">5.5.</span> <span class="toc-text">实验- 旋转编码器计数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E5%AF%B9%E5%B0%84%E5%BC%8F%E7%BA%A2%E5%A4%96%E4%BC%A0%E6%84%9F%E5%99%A8%E8%AE%A1%E6%AC%A1"><span class="toc-number">5.6.</span> <span class="toc-text">实验-对射式红外传感器计次</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%AD%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">5.7.</span> <span class="toc-text">使用中断注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E7%94%A8%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E7%BA%BF%E9%97%AE%E9%A2%98"><span class="toc-number">5.8.</span> <span class="toc-text">共用外部中断线问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TIM-%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">6.</span> <span class="toc-text">TIM(定时器)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">6.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.2.</span> <span class="toc-text">计数器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E5%9F%BA%E5%8D%95%E5%85%83"><span class="toc-number">6.3.</span> <span class="toc-text">时基单元</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E6%BA%90"><span class="toc-number">6.4.</span> <span class="toc-text">时钟源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0-1"><span class="toc-number">6.5.</span> <span class="toc-text">库函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD-%E5%AE%9A%E6%97%B6%E6%88%96%E8%AE%A1%E6%95%B0%E5%8A%9F%E8%83%BD"><span class="toc-number">6.6.</span> <span class="toc-text">定时器中断(定时或计数功能)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TIM%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B"><span class="toc-number">6.6.1.</span> <span class="toc-text">TIM配置流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E4%BD%BF%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E6%AF%8F%E7%A7%92%E8%AE%A1%E6%95%B0-%E5%86%85%E9%83%A8%E6%97%B6%E9%92%9F"><span class="toc-number">6.6.2.</span> <span class="toc-text">实验-使用定时器每秒计数(内部时钟)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E5%AF%B9%E5%B0%84%E5%BC%8F%E7%BA%A2%E5%A4%96%E4%BC%A0%E6%84%9F%E5%99%A8-%E5%A4%96%E9%83%A8%E6%97%B6%E9%92%9F%E6%A8%A1%E5%BC%8F2"><span class="toc-number">6.6.3.</span> <span class="toc-text">实验-对射式红外传感器(外部时钟模式2)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E5%BE%AA%E8%BF%B9%E6%A8%A1%E5%9D%97%E6%B5%8B%E9%87%8F%E5%95%86%E5%93%81%E6%95%B0%E9%87%8F-%E5%A4%96%E9%83%A8%E6%97%B6%E9%92%9F%E6%A8%A1%E5%BC%8F2"><span class="toc-number">6.6.4.</span> <span class="toc-text">实验-循迹模块测量商品数量(外部时钟模式2)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%AF%94%E8%BE%83%E5%8A%9F%E8%83%BD-OC"><span class="toc-number">6.7.</span> <span class="toc-text">输出比较功能(OC)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OC%E7%AE%80%E4%BB%8B"><span class="toc-number">6.7.1.</span> <span class="toc-text">OC简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PWM%E8%BE%93%E5%87%BA%E7%AE%80%E4%BB%8B"><span class="toc-number">6.7.2.</span> <span class="toc-text">PWM输出简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%88%B5%E6%9C%BA%E7%AE%80%E4%BB%8B"><span class="toc-number">6.7.3.</span> <span class="toc-text">舵机简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA%E5%8F%8A%E9%A9%B1%E5%8A%A8%E7%AE%80%E4%BB%8B"><span class="toc-number">6.7.4.</span> <span class="toc-text">直流电机及驱动简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0-2"><span class="toc-number">6.7.5.</span> <span class="toc-text">库函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%AF%94%E8%BE%83%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B"><span class="toc-number">6.7.6.</span> <span class="toc-text">输出比较配置流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-PWM%E5%91%BC%E5%90%B8%E7%81%AF"><span class="toc-number">6.7.7.</span> <span class="toc-text">实验-PWM呼吸灯</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B"><span class="toc-number">6.7.7.1.</span> <span class="toc-text">配置流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-PWM%E9%A9%B1%E5%8A%A8%E8%88%B5%E6%9C%BA"><span class="toc-number">6.7.8.</span> <span class="toc-text">实验-PWM驱动舵机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-PWM%E9%A9%B1%E5%8A%A8DRV8833%E7%94%B5%E6%9C%BA"><span class="toc-number">6.7.9.</span> <span class="toc-text">实验-PWM驱动DRV8833电机</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E5%8A%9F%E8%83%BD-IC"><span class="toc-number">6.8.</span> <span class="toc-text">输入捕获功能(IC)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IC%E7%AE%80%E4%BB%8B"><span class="toc-number">6.8.1.</span> <span class="toc-text">IC简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%91%E7%8E%87%E6%B5%8B%E9%87%8F"><span class="toc-number">6.8.2.</span> <span class="toc-text">频率测量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E9%80%9A%E9%81%93"><span class="toc-number">6.8.3.</span> <span class="toc-text">输入捕获通道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E8%A7%A6%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.8.4.</span> <span class="toc-text">主从触发模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E6%A8%A1%E5%BC%8F%E5%92%8CPWM%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F-PWMI-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">6.8.5.</span> <span class="toc-text">输入捕获模式和PWM输入模式(PWMI)基本结构图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0-3"><span class="toc-number">6.8.6.</span> <span class="toc-text">库函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B"><span class="toc-number">6.8.7.</span> <span class="toc-text">输入捕获配置流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E6%A8%A1%E5%BC%8F%E6%B5%8B%E9%A2%91%E7%8E%87-%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E7%9B%B4%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.8.8.</span> <span class="toc-text">实验-输入捕获模式测频率(输入捕获直接模式)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-PWMI%E6%A8%A1%E5%BC%8F%E6%B5%8B%E9%A2%91%E7%8E%87%E5%92%8C%E5%8D%A0%E7%A9%BA%E6%AF%94-%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E4%BA%A4%E5%8F%89-%E9%97%B4%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.8.9.</span> <span class="toc-text">实验-PWMI模式测频率和占空比(输入捕获交叉&#x2F;间接模式)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.9.</span> <span class="toc-text">编码器接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%99%A8%E6%8E%A5%E5%8F%A3%E7%AE%80%E4%BB%8B"><span class="toc-number">6.9.1.</span> <span class="toc-text">编码器接口简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E4%BA%A4%E7%BC%96%E7%A0%81%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="toc-number">6.9.2.</span> <span class="toc-text">正交编码器介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">6.9.3.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%99%A8%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">6.9.4.</span> <span class="toc-text">编码器接口基本结构图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0-4"><span class="toc-number">6.9.5.</span> <span class="toc-text">库函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%99%A8%E6%8E%A5%E5%8F%A3%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B"><span class="toc-number">6.9.6.</span> <span class="toc-text">编码器接口配置流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E6%AD%A3%E4%BA%A4%E7%BC%96%E7%A0%81%E5%99%A8%E6%B5%8B%E9%80%9F"><span class="toc-number">6.9.7.</span> <span class="toc-text">实验-正交编码器测速</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ADC"><span class="toc-number">7.</span> <span class="toc-text">ADC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ADC%E7%AE%80%E4%BB%8B"><span class="toc-number">7.1.</span> <span class="toc-text">ADC简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ADC%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">7.2.</span> <span class="toc-text">ADC内部结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ADC%E8%BE%93%E5%85%A5%E9%80%9A%E9%81%93"><span class="toc-number">7.3.</span> <span class="toc-text">ADC输入通道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ADC%E8%BD%AC%E6%8D%A2%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.4.</span> <span class="toc-text">ADC转换模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ADC%E8%A7%A6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">7.5.</span> <span class="toc-text">ADC触发控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ADC%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90"><span class="toc-number">7.6.</span> <span class="toc-text">ADC数据对齐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ADC%E8%BD%AC%E6%8D%A2%E6%97%B6%E9%97%B4"><span class="toc-number">7.7.</span> <span class="toc-text">ADC转换时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ADC%E6%A0%A1%E5%87%86"><span class="toc-number">7.8.</span> <span class="toc-text">ADC校准</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF"><span class="toc-number">7.9.</span> <span class="toc-text">硬件电路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ADC%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">7.10.</span> <span class="toc-text">ADC基本结构图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0-5"><span class="toc-number">7.11.</span> <span class="toc-text">库函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ADC%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B"><span class="toc-number">7.12.</span> <span class="toc-text">ADC配置流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-ADC%E8%AF%BB%E5%8F%96%E7%94%B5%E4%BD%8D%E5%99%A8%E7%94%B5%E5%8E%8B-ADC%E5%8D%95%E9%80%9A%E9%81%93"><span class="toc-number">7.13.</span> <span class="toc-text">实验-ADC读取电位器电压(ADC单通道)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-ADC%E5%A4%9A%E9%80%9A%E9%81%93%E9%87%87%E9%9B%86"><span class="toc-number">7.14.</span> <span class="toc-text">实验- ADC多通道采集</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DMA"><span class="toc-number">8.</span> <span class="toc-text">DMA</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DMA%E7%AE%80%E4%BB%8B"><span class="toc-number">8.1.</span> <span class="toc-text">DMA简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STM32%E5%AD%98%E5%82%A8%E5%99%A8%E6%98%A0%E5%83%8F"><span class="toc-number">8.2.</span> <span class="toc-text">STM32存储器映像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DMA%E6%A1%86%E5%9B%BE"><span class="toc-number">8.3.</span> <span class="toc-text">DMA框图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DMA-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">8.4.</span> <span class="toc-text">DMA 基本结构图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DMA%E8%AF%B7%E6%B1%82%E6%98%A0%E5%83%8F"><span class="toc-number">8.5.</span> <span class="toc-text">DMA请求映像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AE%BD%E5%BA%A6%E4%B8%8E%E5%AF%B9%E9%BD%90"><span class="toc-number">8.6.</span> <span class="toc-text">数据宽度与对齐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">8.7.</span> <span class="toc-text">例子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BD%AC%E8%BF%90-DMA-%E5%AD%98%E5%82%A8%E5%99%A8%E5%88%B0%E5%AD%98%E5%82%A8%E5%99%A8%E8%BD%AC%E8%BF%90"><span class="toc-number">8.7.1.</span> <span class="toc-text">数据转运+DMA(存储器到存储器转运)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ADC%E6%89%AB%E6%8F%8F%E6%A8%A1%E5%BC%8F-DMA-%E5%A4%96%E8%AE%BE%E5%88%B0%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">8.7.2.</span> <span class="toc-text">ADC扫描模式+DMA(外设到存储器)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0-6"><span class="toc-number">8.8.</span> <span class="toc-text">库函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DMA%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B"><span class="toc-number">8.9.</span> <span class="toc-text">DMA配置流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-DMA%E6%95%B0%E6%8D%AE%E8%BD%AC%E8%BF%90-%E5%AD%98%E5%82%A8%E5%99%A8%E5%88%B0%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">8.10.</span> <span class="toc-text">实验-DMA数据转运(存储器到存储器)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-DMA-ADC%E5%A4%9A%E9%80%9A%E9%81%93%E9%87%87%E9%9B%86"><span class="toc-number">8.11.</span> <span class="toc-text">实验-DMA+ADC多通道采集</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.</span> <span class="toc-text">通信接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%AE%80%E4%BB%8B"><span class="toc-number">9.1.</span> <span class="toc-text">接口简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1"><span class="toc-number">9.2.</span> <span class="toc-text">串口通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">9.2.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CH340%E4%B8%B2%E5%8F%A3%E9%A9%B1%E5%8A%A8"><span class="toc-number">9.2.2.</span> <span class="toc-text">CH340串口驱动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF-1"><span class="toc-number">9.2.3.</span> <span class="toc-text">硬件电路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B5%E5%B9%B3%E6%A0%87%E5%87%86"><span class="toc-number">9.2.4.</span> <span class="toc-text">电平标准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E5%8F%82%E6%95%B0%E5%8F%8A%E6%97%B6%E5%BA%8F"><span class="toc-number">9.2.5.</span> <span class="toc-text">串口参数及时序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#USART%E7%AE%80%E4%BB%8B"><span class="toc-number">9.2.6.</span> <span class="toc-text">USART简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#USART%E6%A1%86%E5%9B%BE"><span class="toc-number">9.2.7.</span> <span class="toc-text">USART框图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#USART%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">9.2.8.</span> <span class="toc-text">USART基本结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%B8%A7"><span class="toc-number">9.2.9.</span> <span class="toc-text">数据帧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%B7%E5%A7%8B%E4%BD%8D%E4%BE%A6%E6%B5%8B"><span class="toc-number">9.2.10.</span> <span class="toc-text">起始位侦测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%87%87%E6%A0%B7"><span class="toc-number">9.2.11.</span> <span class="toc-text">数据采样</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A2%E7%89%B9%E7%8E%87%E5%8F%91%E7%94%9F%E5%99%A8"><span class="toc-number">9.2.12.</span> <span class="toc-text">波特率发生器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.2.13.</span> <span class="toc-text">数据模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0-7"><span class="toc-number">9.2.14.</span> <span class="toc-text">库函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#USART%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B"><span class="toc-number">9.2.15.</span> <span class="toc-text">USART配置流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-%E4%B8%B2%E5%8F%A3%E5%8F%91%E9%80%81%E5%92%8C%E4%B8%B2%E5%8F%A3%E6%8E%A5%E6%94%B6"><span class="toc-number">9.2.16.</span> <span class="toc-text">测试-串口发送和串口接收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E4%B8%B2%E5%8F%A3%E6%8E%A5%E6%94%B6%E5%8D%95%E5%AD%97%E8%8A%82-%E8%BD%AE%E8%AF%A2-%E4%B8%AD%E6%96%AD"><span class="toc-number">9.2.17.</span> <span class="toc-text">实验-串口接收单字节(轮询+中断)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-USART%E4%B8%B2%E5%8F%A3%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-number">9.2.18.</span> <span class="toc-text">实验-USART串口数据包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-printf%E5%87%BD%E6%95%B0%E7%9A%84%E7%A7%BB%E6%A4%8D"><span class="toc-number">9.2.19.</span> <span class="toc-text">实验-printf函数的移植</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-number">9.2.20.</span> <span class="toc-text">数据包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8C%85%E4%BB%8B%E7%BB%8D"><span class="toc-number">9.2.20.1.</span> <span class="toc-text">数据包介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6"><span class="toc-number">9.2.20.2.</span> <span class="toc-text">数据包的发送和接收</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E4%B8%B2%E5%8F%A3%E6%94%B6%E5%8F%91HEX%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-number">9.2.21.</span> <span class="toc-text">实验-串口收发HEX数据包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E4%B8%B2%E5%8F%A3%E6%94%B6%E5%8F%91%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-number">9.2.22.</span> <span class="toc-text">实验-串口收发文本数据包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I2C"><span class="toc-number">9.3.</span> <span class="toc-text">I2C</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I2C%E4%BB%8B%E7%BB%8D"><span class="toc-number">9.3.1.</span> <span class="toc-text">I2C介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF%E4%B8%8E%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">9.3.2.</span> <span class="toc-text">硬件电路与优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I2C%E6%97%B6%E5%BA%8F%E5%9F%BA%E6%9C%AC%E5%8D%95%E5%85%83"><span class="toc-number">9.3.3.</span> <span class="toc-text">I2C时序基本单元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I2C%E4%BB%8E%E6%9C%BA%E5%9C%B0%E5%9D%80"><span class="toc-number">9.3.4.</span> <span class="toc-text">I2C从机地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I2C%E6%97%B6%E5%BA%8F"><span class="toc-number">9.3.5.</span> <span class="toc-text">I2C时序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MPU6050"><span class="toc-number">9.3.6.</span> <span class="toc-text">MPU6050</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MPU6050%E7%AE%80%E4%BB%8B"><span class="toc-number">9.3.6.1.</span> <span class="toc-text">MPU6050简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MPU6050%E5%8F%82%E6%95%B0"><span class="toc-number">9.3.6.2.</span> <span class="toc-text">MPU6050参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF-2"><span class="toc-number">9.3.6.3.</span> <span class="toc-text">硬件电路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MPU6050%E6%A1%86%E5%9B%BE"><span class="toc-number">9.3.6.4.</span> <span class="toc-text">MPU6050框图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MPU6050%E4%BA%A7%E5%93%81%E6%89%8B%E5%86%8C"><span class="toc-number">9.3.6.5.</span> <span class="toc-text">MPU6050产品手册</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MPU6050%E5%AF%84%E5%AD%98%E5%99%A8%E6%98%A0%E5%83%8F%E6%89%8B%E5%86%8C"><span class="toc-number">9.3.6.6.</span> <span class="toc-text">MPU6050寄存器映像手册</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%A8%A1%E6%8B%9FI2C%E8%AF%BB%E5%86%99"><span class="toc-number">9.3.7.</span> <span class="toc-text">软件模拟I2C读写</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6I2C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.3.7.1.</span> <span class="toc-text">软件I2C代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MPU6050-%E6%B5%8B%E8%AF%95%E8%AF%BB%E5%86%99"><span class="toc-number">9.3.7.2.</span> <span class="toc-text">MPU6050-测试读写</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%8A%9F%E8%83%BD"><span class="toc-number">9.3.7.2.1.</span> <span class="toc-text">读功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%99%E5%8A%9F%E8%83%BD"><span class="toc-number">9.3.7.2.2.</span> <span class="toc-text">写功能</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MPU6050-%E8%AF%BB%E5%8F%96%E5%8A%A0%E9%80%9F%E5%BA%A6-%E8%A7%92%E9%80%9F%E5%BA%A6"><span class="toc-number">9.3.7.3.</span> <span class="toc-text">MPU6050-读取加速度&#x2F;角速度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I2C%E5%A4%96%E8%AE%BE-%E7%A1%AC%E4%BB%B6%E8%AF%BB%E5%86%99I2C"><span class="toc-number">9.3.8.</span> <span class="toc-text">I2C外设(硬件读写I2C)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#I2C%E6%A1%86%E5%9B%BE"><span class="toc-number">9.3.8.1.</span> <span class="toc-text">I2C框图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I2C%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">9.3.8.2.</span> <span class="toc-text">I2C基本结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E6%9C%BA%E5%8F%91%E9%80%81%E6%B5%81%E7%A8%8B"><span class="toc-number">9.3.8.3.</span> <span class="toc-text">主机发送流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E6%9C%BA%E6%8E%A5%E6%94%B6%E6%B5%81%E7%A8%8B"><span class="toc-number">9.3.8.4.</span> <span class="toc-text">主机接收流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E6%9C%BA%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6"><span class="toc-number">9.3.8.5.</span> <span class="toc-text">从机发送接收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0-8"><span class="toc-number">9.3.8.6.</span> <span class="toc-text">库函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I2C%E5%A4%96%E8%AE%BE%E9%85%8D%E7%BD%AE"><span class="toc-number">9.3.8.7.</span> <span class="toc-text">I2C外设配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E7%A1%AC%E4%BB%B6I2C%E8%AF%BB%E5%8F%96MPU6050%E6%95%B0%E6%8D%AE"><span class="toc-number">9.3.8.8.</span> <span class="toc-text">实验-硬件I2C读取MPU6050数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%92%8C%E7%A1%AC%E4%BB%B6I2C%E5%AF%B9%E6%AF%94"><span class="toc-number">9.3.9.</span> <span class="toc-text">软件和硬件I2C对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPI"><span class="toc-number">9.4.</span> <span class="toc-text">SPI</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SPI%E4%BB%8B%E7%BB%8D"><span class="toc-number">9.4.1.</span> <span class="toc-text">SPI介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF-3"><span class="toc-number">9.4.2.</span> <span class="toc-text">硬件电路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%A7%BB%E4%BD%8D%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-number">9.4.3.</span> <span class="toc-text">数据移位示意图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SPI%E6%97%B6%E5%BA%8F%E5%9F%BA%E6%9C%AC%E5%8D%95%E5%85%83"><span class="toc-number">9.4.4.</span> <span class="toc-text">SPI时序基本单元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SPI%E6%97%B6%E5%BA%8F"><span class="toc-number">9.4.5.</span> <span class="toc-text">SPI时序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#W25Q64%E4%BB%8B%E7%BB%8D"><span class="toc-number">9.4.6.</span> <span class="toc-text">W25Q64介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF-4"><span class="toc-number">9.4.6.1.</span> <span class="toc-text">硬件电路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%86%E5%9B%BE"><span class="toc-number">9.4.6.2.</span> <span class="toc-text">框图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Flash%E6%93%8D%E4%BD%9C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">9.4.6.3.</span> <span class="toc-text">Flash操作注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%AF%E7%89%87%E6%89%8B%E5%86%8C"><span class="toc-number">9.4.6.4.</span> <span class="toc-text">芯片手册</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6SPI%E8%AF%BB%E5%86%99W25Q64"><span class="toc-number">9.4.7.</span> <span class="toc-text">软件SPI读写W25Q64</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6SPI%E5%BA%95%E5%B1%82%E4%BB%A3%E7%A0%81"><span class="toc-number">9.4.7.1.</span> <span class="toc-text">软件SPI底层代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#W25Q64%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="toc-number">9.4.7.2.</span> <span class="toc-text">W25Q64测试代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#W25Q64%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-number">9.4.7.3.</span> <span class="toc-text">W25Q64完整代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6SPI%E5%A4%96%E8%AE%BE-%E7%A1%AC%E4%BB%B6%E8%AF%BB%E5%86%99"><span class="toc-number">9.4.8.</span> <span class="toc-text">硬件SPI外设(硬件读写)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SPI%E6%A1%86%E5%9B%BE"><span class="toc-number">9.4.8.1.</span> <span class="toc-text">SPI框图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E6%A8%A1%E5%BC%8F%E5%85%A8%E5%8F%8C%E5%B7%A5%E8%BF%9E%E7%BB%AD%E4%BC%A0%E8%BE%93"><span class="toc-number">9.4.8.2.</span> <span class="toc-text">主模式全双工连续传输</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E8%BF%9E%E7%BB%AD%E4%BC%A0%E8%BE%93"><span class="toc-number">9.4.8.3.</span> <span class="toc-text">非连续传输</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TXE%E5%92%8CRXNE%E6%A0%87%E5%BF%97%E4%BD%8D%E6%B8%85%E9%99%A4%E9%97%AE%E9%A2%98"><span class="toc-number">9.4.8.4.</span> <span class="toc-text">TXE和RXNE标志位清除问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%92%8C%E9%9D%9E%E8%BF%9E%E7%BB%AD%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">9.4.8.5.</span> <span class="toc-text">连续和非连续的优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%A1%AC%E4%BB%B6%E6%B3%A2%E5%BD%A2%E5%AF%B9%E6%AF%94"><span class="toc-number">9.4.8.6.</span> <span class="toc-text">软件硬件波形对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SPI%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-number">9.4.8.7.</span> <span class="toc-text">SPI库函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6SPI%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="toc-number">9.4.8.8.</span> <span class="toc-text">硬件SPI初始化流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6SPI%E8%AF%BB%E5%86%99W25Q64"><span class="toc-number">9.4.8.9.</span> <span class="toc-text">硬件SPI读写W25Q64</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RTC"><span class="toc-number">10.</span> <span class="toc-text">RTC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%AF%86"><span class="toc-number">10.1.</span> <span class="toc-text">常识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Unix%E6%97%B6%E9%97%B4%E6%88%B3"><span class="toc-number">10.1.1.</span> <span class="toc-text">Unix时间戳</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RTC-GMT"><span class="toc-number">10.1.2.</span> <span class="toc-text">RTC&#x2F;GMT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E6%8D%A2"><span class="toc-number">10.1.3.</span> <span class="toc-text">时间戳转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BKP%E7%AE%80%E4%BB%8B"><span class="toc-number">10.2.</span> <span class="toc-text">BKP简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">10.2.1.</span> <span class="toc-text">基本结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BKP%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-number">10.2.2.</span> <span class="toc-text">BKP库函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99BKP"><span class="toc-number">10.2.3.</span> <span class="toc-text">读写BKP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RTC%E5%A4%96%E8%AE%BE"><span class="toc-number">10.3.</span> <span class="toc-text">RTC外设</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RTC%E7%AE%80%E4%BB%8B"><span class="toc-number">10.3.1.</span> <span class="toc-text">RTC简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RTC%E6%A1%86%E5%9B%BE"><span class="toc-number">10.3.2.</span> <span class="toc-text">RTC框图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RTC%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">10.3.3.</span> <span class="toc-text">RTC基本结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF-5"><span class="toc-number">10.3.4.</span> <span class="toc-text">硬件电路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RTC%E6%93%8D%E4%BD%9C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">10.3.5.</span> <span class="toc-text">RTC操作注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RCC%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-number">10.3.6.</span> <span class="toc-text">RCC库函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RTC%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-number">10.3.7.</span> <span class="toc-text">RTC库函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RTC%E9%85%8D%E7%BD%AE"><span class="toc-number">10.3.8.</span> <span class="toc-text">RTC配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RTC%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4"><span class="toc-number">10.3.9.</span> <span class="toc-text">RTC显示当前时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BKP%E5%AF%84%E5%AD%98%E5%99%A8%E8%A7%A3%E5%86%B3%E6%8E%89%E7%94%B5%E6%97%B6%E9%97%B4%E4%B8%8D%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98"><span class="toc-number">10.3.10.</span> <span class="toc-text">BKP寄存器解决掉电时间不丢失问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PWR%E7%94%B5%E6%BA%90%E6%8E%A7%E5%88%B6"><span class="toc-number">11.</span> <span class="toc-text">PWR电源控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#PWR%E7%AE%80%E4%BB%8B"><span class="toc-number">11.1.</span> <span class="toc-text">PWR简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%B5%E6%BA%90%E6%A1%86%E5%9B%BE"><span class="toc-number">11.2.</span> <span class="toc-text">电源框图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E7%94%B5%E5%A4%8D%E4%BD%8D%E5%92%8C%E6%8E%89%E7%94%B5%E5%A4%8D%E4%BD%8D-POR-PDR"><span class="toc-number">11.3.</span> <span class="toc-text">上电复位和掉电复位(POR&#x2F;PDR)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E7%BC%96%E7%A8%8B%E7%94%B5%E5%8E%8B%E6%A3%80%E6%B5%8B%E5%99%A8PVD"><span class="toc-number">11.4.</span> <span class="toc-text">可编程电压检测器PVD</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8E%E5%8A%9F%E8%80%97%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D"><span class="toc-number">11.5.</span> <span class="toc-text">低功耗模式介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E9%80%89%E6%8B%A9%E7%9A%84%E5%9B%BE"><span class="toc-number">11.6.</span> <span class="toc-text">模式选择的图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F%E7%89%B9%E6%80%A7%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">11.7.</span> <span class="toc-text">三种模式特性及注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%82%E7%94%B5%E6%96%B9%E6%B3%95"><span class="toc-number">11.8.</span> <span class="toc-text">节电方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SLEEPDEEP%E5%92%8CSLEEPONEXIT%E4%BD%8D%E9%85%8D%E7%BD%AE"><span class="toc-number">11.9.</span> <span class="toc-text">SLEEPDEEP和SLEEPONEXIT位配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E4%B8%BB%E9%A2%91"><span class="toc-number">11.10.</span> <span class="toc-text">修改主频</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9D%A1%E7%9C%A0%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B"><span class="toc-number">11.11.</span> <span class="toc-text">睡眠模式实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E6%94%B6%E5%8F%91"><span class="toc-number">11.11.1.</span> <span class="toc-text">串口收发</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%9C%E6%9C%BA%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B"><span class="toc-number">11.12.</span> <span class="toc-text">停机模式实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0-9"><span class="toc-number">11.12.1.</span> <span class="toc-text">库函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E5%B0%84%E5%BC%8F%E7%BA%A2%E5%A4%96%E4%BC%A0%E6%84%9F%E5%99%A8%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD-%E5%81%9C%E6%9C%BA%E6%A8%A1%E5%BC%8F"><span class="toc-number">11.12.2.</span> <span class="toc-text">对射式红外传感器外部中断(停机模式)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%85%E6%9C%BA%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B"><span class="toc-number">11.13.</span> <span class="toc-text">待机模式实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RTC%E9%97%B9%E9%92%9F-%E5%BE%85%E6%9C%BA%E6%A8%A1%E5%BC%8F"><span class="toc-number">11.13.1.</span> <span class="toc-text">RTC闹钟(待机模式)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9C%8B%E9%97%A8%E7%8B%97WDG"><span class="toc-number">12.</span> <span class="toc-text">看门狗WDG</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%8B%E9%97%A8%E7%8B%97%E7%AE%80%E4%BB%8B"><span class="toc-number">12.1.</span> <span class="toc-text">看门狗简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E7%9C%8B%E9%97%A8%E7%8B%97IWDG"><span class="toc-number">12.2.</span> <span class="toc-text">独立看门狗IWDG</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IWDG%E6%A1%86%E5%9B%BE"><span class="toc-number">12.2.1.</span> <span class="toc-text">IWDG框图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IWDG%E9%94%AE%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">12.2.2.</span> <span class="toc-text">IWDG键寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IWDG%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4"><span class="toc-number">12.2.3.</span> <span class="toc-text">IWDG超时时间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E7%9C%8B%E9%97%A8%E7%8B%97WWDG"><span class="toc-number">12.3.</span> <span class="toc-text">窗口看门狗WWDG</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#WWDG%E6%A1%86%E5%9B%BE"><span class="toc-number">12.3.1.</span> <span class="toc-text">WWDG框图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WWDG%E5%B7%A5%E4%BD%9C%E7%89%B9%E6%80%A7"><span class="toc-number">12.3.2.</span> <span class="toc-text">WWDG工作特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WWDG%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4"><span class="toc-number">12.3.3.</span> <span class="toc-text">WWDG超时时间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IWDG%E5%92%8CWWDG%E5%AF%B9%E6%AF%94"><span class="toc-number">12.4.</span> <span class="toc-text">IWDG和WWDG对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E7%9C%8B%E9%97%A8%E7%8B%97%E4%BB%A3%E7%A0%81"><span class="toc-number">12.5.</span> <span class="toc-text">独立看门狗代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-number">12.5.1.</span> <span class="toc-text">相关库函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B-1"><span class="toc-number">12.5.2.</span> <span class="toc-text">配置流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E9%94%AE%E8%A7%A6%E5%8F%91%E7%8B%AC%E7%AB%8B%E7%9C%8B%E9%97%A8%E7%8B%97"><span class="toc-number">12.5.3.</span> <span class="toc-text">按键触发独立看门狗</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E7%9C%8B%E9%97%A8%E7%8B%97%E4%BB%A3%E7%A0%81"><span class="toc-number">12.6.</span> <span class="toc-text">窗口看门狗代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0-10"><span class="toc-number">12.6.1.</span> <span class="toc-text">库函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B-2"><span class="toc-number">12.6.2.</span> <span class="toc-text">配置流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E9%94%AE%E8%A7%A6%E5%8F%91%E7%AA%97%E5%8F%A3%E7%9C%8B%E9%97%A8%E7%8B%97"><span class="toc-number">12.6.3.</span> <span class="toc-text">按键触发窗口看门狗</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#FLASH-%E9%97%AA%E5%AD%98"><span class="toc-number">13.</span> <span class="toc-text">FLASH 闪存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#FLASH%E7%AE%80%E4%BB%8B"><span class="toc-number">13.1.</span> <span class="toc-text">FLASH简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AA%E5%AD%98%E6%A8%A1%E5%9D%97%E7%BB%84%E7%BB%87"><span class="toc-number">13.2.</span> <span class="toc-text">闪存模块组织</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FLASH%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">13.3.</span> <span class="toc-text">FLASH基本结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FLASH%E8%A7%A3%E9%94%81"><span class="toc-number">13.4.</span> <span class="toc-text">FLASH解锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AD%98%E5%82%A8%E5%99%A8-%E6%8C%87%E9%92%88%E5%86%99%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">13.5.</span> <span class="toc-text">使用指针访问存储器(指针写入操作)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%AD%98%E5%82%A8%E5%99%A8FLASH%E7%9A%84%E6%93%A6%E9%99%A4%E5%92%8C%E7%BC%96%E7%A8%8B"><span class="toc-number">13.6.</span> <span class="toc-text">程序存储器FLASH的擦除和编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%AD%98%E5%82%A8%E5%99%A8FLASH%E7%9A%84%E5%85%A8%E6%93%A6%E9%99%A4"><span class="toc-number">13.6.1.</span> <span class="toc-text">程序存储器FLASH的全擦除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%AD%98%E5%82%A8%E5%99%A8FLASH%E7%9A%84%E9%A1%B5%E6%93%A6%E9%99%A4"><span class="toc-number">13.6.2.</span> <span class="toc-text">程序存储器FLASH的页擦除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%AD%98%E5%82%A8%E5%99%A8FLASH%E7%BC%96%E7%A8%8B"><span class="toc-number">13.6.3.</span> <span class="toc-text">程序存储器FLASH编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E9%A1%B9%E5%AD%97%E8%8A%82"><span class="toc-number">13.7.</span> <span class="toc-text">选项字节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E9%A1%B9%E5%AD%97%E8%8A%82%E6%93%A6%E9%99%A4"><span class="toc-number">13.7.1.</span> <span class="toc-text">选项字节擦除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E9%A1%B9%E5%AD%97%E8%8A%82%E7%9A%84%E7%BC%96%E7%A8%8B"><span class="toc-number">13.7.2.</span> <span class="toc-text">选项字节的编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%99%A8%E4%BB%B6%E7%94%B5%E5%AD%90%E7%AD%BE%E5%90%8D"><span class="toc-number">13.8.</span> <span class="toc-text">器件电子签名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FLASH-%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-number">13.9.</span> <span class="toc-text">FLASH 库函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C"><span class="toc-number">13.10.</span> <span class="toc-text">实验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%BB%E5%86%99FLASH-FLASH%E5%BA%95%E5%B1%82%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">13.10.1.</span> <span class="toc-text">简单读写FLASH(FLASH底层代码实现)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8SRAM%E4%B8%AD%E5%AE%9A%E4%B9%89%E6%95%B0%E7%BB%84%E5%92%8C%E6%A0%87%E5%BF%97%E4%BD%8D%E5%AF%B9FLASH%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="toc-number">13.10.2.</span> <span class="toc-text">在SRAM中定义数组和标志位对FLASH数据存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E8%8A%AF%E7%89%87ID-%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E8%AF%BB%E5%8F%96"><span class="toc-number">13.10.3.</span> <span class="toc-text">读取芯片ID(使用指针直接访问读取)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E7%9A%84BUG-%E5%BD%93%E7%A8%8B%E5%BA%8F%E5%BE%88%E5%A4%A7%E6%97%B6%E8%A6%86%E7%9B%96%E7%94%A8%E6%88%B7%E5%AD%98%E5%82%A8%E5%8F%82%E6%95%B0%E5%8C%BA"><span class="toc-number">13.11.</span> <span class="toc-text">存在的BUG-当程序很大时覆盖用户存储参数区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Flash%E5%86%99%E5%85%A5%E4%B9%8B%E5%89%8D%E7%9A%84%E6%93%A6%E9%99%A4%E5%BF%85%E8%A6%81%E6%80%A7"><span class="toc-number">13.12.</span> <span class="toc-text">Flash写入之前的擦除必要性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STM32-ST-LINK-Utility"><span class="toc-number">13.13.</span> <span class="toc-text">STM32 ST-LINK Utility</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/08/30/MQTT%E8%BF%9E%E6%8E%A5AWS-IoT/" title="MQTT连接AWS IoT"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/213.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MQTT连接AWS IoT"/></a><div class="content"><a class="title" href="/2025/08/30/MQTT%E8%BF%9E%E6%8E%A5AWS-IoT/" title="MQTT连接AWS IoT">MQTT连接AWS IoT</a><time datetime="2025-08-29T16:33:21.000Z" title="发表于 2025-08-30 00:33:21">2025-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/30/TLS%E4%BC%A0%E8%BE%93%E5%B1%82%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/" title="TLS传输层安全协议"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/33.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TLS传输层安全协议"/></a><div class="content"><a class="title" href="/2025/08/30/TLS%E4%BC%A0%E8%BE%93%E5%B1%82%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/" title="TLS传输层安全协议">TLS传输层安全协议</a><time datetime="2025-08-29T16:31:07.000Z" title="发表于 2025-08-30 00:31:07">2025-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/30/AWS%E4%BB%8B%E7%BB%8D/" title="AWS介绍"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/28.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AWS介绍"/></a><div class="content"><a class="title" href="/2025/08/30/AWS%E4%BB%8B%E7%BB%8D/" title="AWS介绍">AWS介绍</a><time datetime="2025-08-29T16:28:11.000Z" title="发表于 2025-08-30 00:28:11">2025-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/30/PCB%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E4%BA%8E%E7%AB%8B%E5%88%9BEDA/" title="PCB设计(基于立创EDA)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/26.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="PCB设计(基于立创EDA)"/></a><div class="content"><a class="title" href="/2025/08/30/PCB%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E4%BA%8E%E7%AB%8B%E5%88%9BEDA/" title="PCB设计(基于立创EDA)">PCB设计(基于立创EDA)</a><time datetime="2025-08-29T16:20:05.000Z" title="发表于 2025-08-30 00:20:05">2025-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/30/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/" title="加密算法"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/5.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="加密算法"/></a><div class="content"><a class="title" href="/2025/08/30/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/" title="加密算法">加密算法</a><time datetime="2025-08-29T16:12:06.000Z" title="发表于 2025-08-30 00:12:06">2025-08-30</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="workboard"><img class="workSituationImg boardsign" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-上班摸鱼中.svg" alt="距离月入25k也就还差一个大佬带我~" title="距离月入25k也就还差一个大佬带我~"/><div id="runtimeTextTip"></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://blog.anheyu.com/" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"/></a><a class="github-badge" target="_blank" href="https://www.dogecloud.com/" style="margin-inline:5px" data-title="本站使用多吉云为静态资源提供CDN加速" title="本站使用多吉云为静态资源提供CDN加速"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/CDN-多吉云-3693F3.svg" alt="本站使用多吉云为静态资源提供CDN加速"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"/></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2022 - 2025 By <a class="footer-bar-link" href="/" title="THEDI" target="_blank">THEDI</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">63</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">8</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="安知鱼的博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="安知鱼的博客"/><span class="back-menu-item-text">安知鱼的博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/keqiudi/keqiudi.github.io" title="我的博客仓库"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="我的博客仓库"/><span class="back-menu-item-text">我的博客仓库</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AWS/" style="font-size: 0.88rem;">AWS<sup>2</sup></a><a href="/tags/C/" style="font-size: 0.88rem;">C++<sup>2</sup></a><a href="/tags/CLion/" style="font-size: 0.88rem;">CLion<sup>2</sup></a><a href="/tags/CMake/" style="font-size: 0.88rem;">CMake<sup>1</sup></a><a href="/tags/ESP32/" style="font-size: 0.88rem;">ESP32<sup>1</sup></a><a href="/tags/FreeRTOS/" style="font-size: 0.88rem;">FreeRTOS<sup>5</sup></a><a href="/tags/Git/" style="font-size: 0.88rem;">Git<sup>1</sup></a><a href="/tags/LCD/" style="font-size: 0.88rem;">LCD<sup>2</sup></a><a href="/tags/LVGL/" style="font-size: 0.88rem;">LVGL<sup>7</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem;">Linux<sup>8</sup></a><a href="/tags/MySQL/" style="font-size: 0.88rem;">MySQL<sup>2</sup></a><a href="/tags/PCB/" style="font-size: 0.88rem;">PCB<sup>2</sup></a><a href="/tags/QT/" style="font-size: 0.88rem;">QT<sup>1</sup></a><a href="/tags/keil/" style="font-size: 0.88rem;">keil<sup>1</sup></a><a href="/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1/" style="font-size: 0.88rem;">云服务<sup>3</sup></a><a href="/tags/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" style="font-size: 0.88rem;">启动流程<sup>2</sup></a><a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/" style="font-size: 0.88rem;">嵌入式<sup>2</sup></a><a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%89%E5%85%A8/" style="font-size: 0.88rem;">嵌入式安全<sup>3</sup></a><a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 0.88rem;">架构<sup>2</sup></a><a href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" style="font-size: 0.88rem;">环境配置<sup>4</sup></a><a href="/tags/%E7%A1%AC%E4%BB%B6/" style="font-size: 0.88rem;">硬件<sup>5</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>3</sup></a><a href="/tags/%E8%B0%83%E8%AF%95/" style="font-size: 0.88rem;">调试<sup>5</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.cbd.int/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("12/01/2022 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2022 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 THEDI 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("12/01/2022 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-下班啦.svg";
        img.title = "下班了就该开开心心的玩耍，嘿嘿~";
        img.alt = "下班了就该开开心心的玩耍，嘿嘿~";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><script src="https://cdn.cbd.int/algoliasearch@4.18.0/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.cbd.int/instantsearch.js@4.60.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script async src="//at.alicdn.com/t/c/font_4169545_k8d3mxnig4s.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>