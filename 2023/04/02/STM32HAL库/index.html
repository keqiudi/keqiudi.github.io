<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>STM32(HAL库) | THEDI的仓库</title><meta name="keywords" content="STM32"><meta name="author" content="THEDI"><meta name="copyright" content="THEDI"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="STM32(HAL库)"><meta name="application-name" content="STM32(HAL库)"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="STM32(HAL库)"><meta property="og:url" content="https://www.thekqd.top/2023/04/02/STM32HAL%E5%BA%93/index.html"><meta property="og:site_name" content="THEDI的仓库"><meta property="og:description" content="STM32单片机开发"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://www.thekqd.top/assets/43.webp"><meta property="article:author" content="THEDI"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.thekqd.top/assets/43.webp"><meta name="description" content="STM32单片机开发"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://www.thekqd.top/2023/04/02/STM32HAL%E5%BA%93/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="manifest" href="/manifest.json"/><meta name="msapplication-TileColor" content="var(--anzhiyu-main)"/><link rel="mask-icon" href="/img/siteicon/apple-icon-180.png" color="#5bbad5"/><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/apple-icon-180.png"/><link rel="apple-touch-icon-precomposed" sizes="180x180" href="/img/siteicon/apple-icon-180.png"/><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/16.png"/><link rel="bookmark" href="/img/siteicon/apple-icon-180.png"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2048-2732.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2732-2048.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1668-2388.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2388-1668.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1536-2048.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2048-1536.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1668-2224.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2224-1668.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1620-2160.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2160-1620.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1290-2796.jpg" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2796-1290.jpg" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1179-2556.jpg" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2556-1179.jpg" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1284-2778.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2778-1284.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1170-2532.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2532-1170.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1125-2436.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2436-1125.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1242-2688.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2688-1242.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-828-1792.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1792-828.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1242-2208.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2208-1242.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-750-1334.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1334-750.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-640-1136.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1136-640.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css#fontawesome_animation 如果有就会加载，示例值：https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: {"enable":true,"title":"与大家一起进步","addFriendPlaceholder":"昵称（请勿包含博客等字样）：\n网站地址（要求博客地址，请勿提交个人主页）：\n头像图片url（请提供尽可能清晰的图片，我会上传到我自己的图床）：\n描述：\n站点截图（可选）：\n"},
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"该回来学习啦！","backTitle":"w(ﾟДﾟ)w快认真学习！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🏠 智能家居小能手"]},
  algolia: {"appId":"PW49GHYJ6T","apiKey":"42b04be58e36cfebeb6ac1989c6e8009","indexName":"hexo","hits":{"per_page":6},"languages":{"input_placeholder":"输入关键词后按下回车查找","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: THEDI","link":"链接: ","source":"来源: THEDI的仓库","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'THEDI的仓库',
  title: 'STM32(HAL库)',
  postAI: '',
  pageFillDescription: '实验和一些好用的工具, 讲解视频, GPIO, GPIO介绍, GPIO工作模式, 点灯, STM32启动流程, 启动文件, RCC, RCC介绍, 复位, 时钟, 时钟源, 系统时钟SYSCLK, 配置时钟树, SysTick, 介绍, 寄存器介绍, uwTick, uwTick的工作原理, uwTick的使用场景, 如何配置和使用 uwTick, 初始化, 读取 uwTick, 获取系统启动后的时间, 处理溢出问题, HAL_Delay, 自定义延时函数, 注意事项, uwTick与硬件定时器外设区别, uwTick, 硬件定时器外设, 使用场景分析, 使用 uwTick 的场景, 使用硬件定时器外设的场景, 总结对比表, RCC与SysTick, Timebase Souce, 时基介绍, 常用配置, 中断和异常, 中断优先级, 优先级分组, NVIC, EXTI, 实验, 外部按键中断控制LED亮灭, 按键消抖, 轮询按键控制LED亮灭(延时消抖), 外部中断+定时器消抖(推荐), 按键状态机+定时器消抖, 使用场景, 中断相关的-volatile关键字, 通讯概念, 通讯方式, 通讯速率, USART, 概念, 功能, 串口接受与发送, USART中断, 实验, USART1普通中断回显实验, USART2控制LED灯, 串口接收不定长数据, 实验, HAL库函数的一些调用流程, TIM(定时器), 概念, 基于定时器的LED闪烁, CubeMX配置, 函数和业务代码, RTC, RTC时钟选择, RTC中断, CubeMX配置, 库函数, 实验-实时时间OLED显示, RTC掉电重置, BKP寄存器, 解决掉电重置代码, 定时器外部时钟与循迹模块, 循迹模块, 抖动脉冲, 输入滤波器, PWM, 概念, 相关函数, 实验-PWM控制LED亮度实现呼吸灯, CubeMX配置, 业务代码(轮询修改占空比), 业务代码(定时器修改占空比), 实验-PWM控制无源蜂鸣器, 原理, CubeMX配置, 业务代码, 实验-PWM控制直流电机, DRV8833电机驱动模块, 原理, CubeMX配置, 业务代码, 驱动库, 输入捕获, 概念, 捕获寄存器, 相关函数, 输入捕获单通道测频率, 业务代码, 超声波测距介绍, 业务代码, 旋转编码器, 增量型旋转编码器, 原理, 实现思路, 实验-使用增量型旋转编码器控制小灯亮度, CubeMX配置, 函数, 业务代码, 舵机(SERVO), 原理(PWM), 实验-使用旋转编码器控制舵机(SG90)旋转, CubeMX配置, 业务代码, 看门狗, 介绍, 独立看门狗, CubeMX配置, 相关函数, 窗口看门狗, 中断, 配置, 相关函数, 实验, 传感器模块, ADC, 概述, 参数配置, 相关函数, 实验-轮询读取ADC的值, CubeMX配置, 业务代码, 实验-使用ADC读取电位器电压(单通道), 电位器介绍, CubeMX配置, 业务代码, 实验-使用NTC热敏传感器测量温度(单通道), NTC-热敏电阻介绍, 原理, CubeMX配置, 业务代码, DMA, 概念, DMA传输方式, 串口DMA模式与收发不定长数据, DMA模式, 收发不定长数据-Idle, DMA传输过半中断, 蓝牙模块与简易数据包解析, 蓝牙模块介绍, 协议, 实验(蓝牙发送数据控制LED-UART), 简易数据包解析, 蓝牙发送数据控制LED开关, IIC, 介绍, 分类, 特点, 物理层与协议层, 主从, IIC相关函数, IIC读写, IIC中断, 实验-读写EEPROM(AT24C02), EEPROM介绍, 设备地址, 写读数据, CubeMX配置, 代码, 实验-使用AHT20温湿度传感器(轮询), CubeMX配置：, 传感器读取流程, 代码, IIC中断与DMA以及状态机编程, 相关函数, 状态机编程, 实验-使用AHT20温湿度传感器(状态机), SPI, 介绍, 主从模式, 信号线, 数据发送和接收, 工作模式, W25Q128 FLASH芯片, 实验读写FLASH(W25Q128), CubeMX配置, 代码, 函数, OLED, 介绍, 原理, 驱动函数, 取模(图模+字模), CubeMX配置, 移植实验和一些好用的工具欢迎来到波特律动波特律动串口调试助手蓝牙调试助手波特律动串口助手驱动库图片字体取模波特律动字模生成器讲解视频工作第集串口模式与收发不定长数据的教程哔哩哔哩介绍是通用输入输出端口的英文简写是所有的微控制器必不可少的外设之一可以由直接驱动从而实现与外部设备通信控制以及采集和捕获的功能单片机的被分为很多组每组有个引脚不同型号的的个数是不同的比如只有以及个别引脚而拥有的全部个引脚所有的都有基本的输入输出功能同时还可以作为其它的外设功能引脚作为最基本的外设最基本的输出功能是由控制引脚输出高低电平比如可以把接灯来控制其亮灭也可以接继电器或者三极管通过继电器或三极管来控制外部大功率电路的通断工作模式输入模式浮空输入上拉输入内部上拉和外部上拉下拉输入模拟输入输出模式推挽输出高低电平均有驱动能力一般使用开漏输出高电平相当于高阻态没有驱动能力低电平有驱动能力特殊使用开漏复用输出推挽复用输出表示电路的意思即接入电路的电压表示器件的意思即器件内部的工作电压表示公共连接的意思通常指电路公共接地端电压基础入门详解采集信号博客介绍博客点灯启动流程启动文件汇编文件文件具体工作介绍上的外设是复位和时钟控制的英文缩写简单理解为心跳负责配置和管理整个芯片的时钟系统包括主时钟源选择等各级时钟分频系统时钟外设时钟等各外设包括等时钟使能关闭系统复位管理的主要用途配置系统主频和各外设时钟影响定时器总线速度以及延时函数的精度程序启动时必须先配置好否则外设定时器都不能正常工作复位可见参考手册系统复位电源复位后备域复位原理图上有复位电路时钟系统时钟详解超详细超全面时钟博客时钟源中能够主动发出时钟信号的元器件可以用作时钟源中有四个时钟源还有一个辅助时钟源生成倍频时钟信号的器件锁相环高速内部时钟时钟信号由内部震荡电路提供时钟频率为但是这个时钟频率会随着温度产生漂移很不稳定所以一般不使用此时钟信号高速外部时钟时钟信号由外部晶振提供时钟频率一般在是经常会用到的时钟源这里的外部晶振可以是有源晶振也可以是无源晶振它们的区别在于与的连接方式以及需不需要谐振电容低速内部时钟时钟信号由内部振荡电路提供时钟频率一般为这个信号一般用于独立看门狗时钟低速外部时钟时钟信号由外部晶振提供时钟频率一般为这个信号一般用于实时时钟锁相环倍频时钟锁相环是辅助产生时钟信号的器件并不是自己产生的时钟源而是通过倍频得到的时钟将时钟信号输入锁相环锁相环可以将这个时钟信号的频率按照指定倍率提高倍频之后再输出与锁相环具有相反作用的是分频器分频器可以将输入时钟信号分率按照指定倍率降低之后再输出简单理解分频就是做除法系统时钟系统时钟可来源于三个时钟源振荡器时钟振荡器时钟时钟配置时钟树一般填入指定最大即可但对上的时钟具体怎么配置根据需求决定时钟频率选取越高功耗也会越高所以实际情况中考虑芯片的工作条件根据芯片运行的工作条件选取时钟频率相关总线上的时钟工作条件可以在数据手册的通用工作条件模块可以查看到满足的条件介绍系统定时器又叫系统滴答定时器是属于内核中的一个外设内嵌在中系统定时器是一个计数宽度的向下递减的计数器计数器每计数一次的时间为一般我们设置系统时钟等于当重装载数值寄存器的值递减到的时候系统定时器就产生一次中断以此循环往复因为是属于内核的外设所以所有基于内核的单片机都具有这个系统定时器使得软件在单片机中可以很容易的移植计数宽度来储存数据向下递减计数器的工作模式计数器的工作周期每的时间为常用功能系统定时器一般用于操作系统用于产生时基维持操作系统的心跳最常用的功能是计数比如用来进行微秒毫秒的延时以此产生特定时序我们需要实现级延时就是使用寄存器介绍第课定时器中断系统定时器寄存器博客库中是基于来实现使用时基源是中用于存储系统运行时间的变量它在库中与滴答定时器一起使用通常用于实现毫秒级的计时是一个全局变量保存了从系统启动开始经过的毫秒数通常用于延时超时管理或作为定时器的时间基准的工作原理由系统的滴答定时器自动递增每当定时器触发中断时的值增加表示已经过去了毫秒函数会初始化并确保定时器按照指定的时钟频率通常是定期递增的使用场景延时函数可用于在没有的情况下实现毫秒级的延时函数定时任务可以使用来实现周期性定时任务超时管理可以通过计算超时进行时间监控如何配置和使用在系列中是由库自动管理的因此你不需要手动操作它只需配置好定时器并让它触发的更新初始化在调用时会被自动调用确保滴答定时器已启用并正确地递增读取你可以直接读取来获取从系统启动以来的毫秒数例如等待指定的毫秒数该函数可以实现一个简单的延时功能利用的递增特性来实现时间等待获取系统启动后的时间保存了系统从启动以来经过的毫秒数如果你需要获取系统的运行时间可以直接读取例如获取系统启动后的运行时间返回从启动以来的毫秒数处理溢出问题是一个位无符号整数因此当它达到最大值时会溢出回一般情况下你不需要担心溢出问题因为的更新是连续的你可以通过以下方式避免溢出导致的问题自动处理溢出通过这种方式你可以计算当前和之前记录的时间差无论它是否经历了溢出函数就是使用系统滴答定时器实现的自定义延时函数除了使用你也可以编写自定义延时函数例如可以放置其他任务或者空闲等待注意事项定时精度的精度依赖于系统时钟频率如果系统时钟较低延时精度可能不如高精度时钟溢出是一个位计数器每天会溢出一次大部分应用场景中不需要特别处理溢出问题除非你需要精确计时更长时间段与如果使用如可以作为内部定时器的基础进行任务调度和延时处理与硬件定时器外设区别来源是由定时器系统定时器更新的全局变量通常用于提供一个基于毫秒的系统时基它是由的内核提供通常用于时间管理和简单的延时精度的精度取决于系统时钟频率通常是毫秒对于很多应用场景这种精度足够了功能只是一个软件计数器它每毫秒递增并通过中断如果启用更新它通常用于延时操作比如定时任务超时控制简单的时间基准比如计算系统运行时间优点简单易用尤其是没有时它可以作为一个基本的定时机制使用非常灵活可以通过实现延时超时周期性任务等功能缺点只能提供低精度的时间基准通常为毫秒不能直接处理复杂的定时器任务如生成特定频率的信号或者需要高精度计时的应用硬件定时器外设来源硬件定时器是提供的专用硬件模块它们可以用来精确地生成定时中断输出计数器等通常具有多个定时器外设如等精度硬件定时器的精度非常高通常由定时器的计数时钟频率通常是系统时钟或时钟的一部分决定可以达到微秒级别的精度硬件定时器可以配置为不同的分频因子以适应不同的应用需求功能硬件定时器可以用于生成高精度的定时中断生成波形输出实现高精度延时时间测量和计数用于编码器频率测量信号发生等优点提供高精度定时不需要依赖系统时钟或软件轮询硬件定时器直接生成中断效率较高可以配置为多种不同模式如脉冲计数输入捕获等缺点配置较复杂尤其是在需要多种不同定时器功能时配置工作量较大受限于硬件资源每个芯片上有固定数量的定时器使用场景分析使用的场景主要适用于以下场景简单的定时器应用如延时超时控制周期性任务等如果你的系统不需要极高的定时精度并且不需要复杂的定时任务管理是一个非常便捷的选择例如延时功能你可以用实现简单的延时操作如延时秒秒等超时检测在没有的情况下可以用检测外部事件是否超时如等待串口数据等待传感器响应等周期性任务比如每毫秒执行一次某些任务使用来检测时间是否满足周期要求低精度任务当任务不依赖于极高的定时精度时足够满足需求比如一些简单的闪烁定时任务等使用硬件定时器外设的场景硬件定时器外设适用于以下场景高精度定时任务如精确的时间测量频率产生等硬件定时器可以提供比更高精度的定时通常是微秒级别例如生成当你需要控制电机灯光等硬件时通常需要高精度的信号这时就需要硬件定时器频率计数通过硬件定时器的输入捕获功能可以精确地测量信号的频率精确延时对于一些要求非常精确延时的场景如通信协议中的时序控制硬件定时器可以提供更高的精度复杂的定时功能如果你需要多个定时器同步运行或者需要定时器在某个特定事件如输入信号时产生中断硬件定时器会是一个更合适的选择应用在环境中硬件定时器通常用于管理任务的时间片或者作为周期性任务的时基硬件事件捕捉硬件定时器支持的输入捕获模式使得它可以捕捉外部信号的事件如测量脉冲宽度时间间隔等总结对比表与主要负责配置我们的时钟源和系统主频以及各总线的时钟频率等就是一个外设类似于但是是内核外设在时钟树中我们可以看到的时钟来源是系统时钟主频时基介绍时基源是库下系统时基源的设置决定哪个硬件定时器为库提供系统节拍时基主要的作用用于库的时间相关功能如用于如的任务调度节拍决定系统中到底是谁来精确定义常用配置时基源的配置可以在和中选择默认使用内核自带的定时器用某个通用定时器如等作为源逻辑开发时库通常在中配置时基源为当时基源设置为后空闲就可自定义用途中断负责系统中断和异常中断概念中断是指计算机运行过程中出现某些意外情况需主机干预时机器能自动停止正在运行的程序并转入处理新情况的程序处理完毕后又返回原被暂停的程序继续执行中断触发后流程触发中断中断向量表存放中断服务函数地址偏移入口地址中断可以分为内部中断和外部中断外部中断说的中断一般指这个外部中断发生在处理器外部连接的设备或外部信号例如按键按下外部传感器信号变化等外部中断用于响应外部事件并及时处理相关任务异常内部中断异常和中断概念相近异常可以说是内核活动处理器内部产生比如执行未定义指令除零运算等发生在内部的意外事件这些异常的发生会引起运行相应的异常处理程序因为发生在处理器内部故叫做内部中断注中断一般指连接到内核的外部器件外设产生使用一般不严格区分中断和异常但无论是异常还是中断都会引起程序执行偏离正常的流程转而去执行异常中断的处理函数中断优先级中断优先级分为两种可编程不可编程的中断优先级决定着内核优先响应谁的中断请求中断优先级数值越小优先级越大中断会被优先响应中断优先级按照优先级分组配置在的芯片参考手册中可以找到中断向量表里面可找到优先级数值等信息优先级分组在优先级分组中存在抢占优先级和子优先级分组个数和各优先级数值图片入门篇中断的初步认识及其优先级和分组中断优先级和分组博客通过优先级分组我们可以管理中断的响应顺序只有抢占优先级才具有抢占中断的权限打断了就发生了中断嵌套中断嵌套中断嵌套是指中断系统正在执行一个中断服务时有另一个抢占优先级更高的中断提出这时会暂时终止当前正在执行的级别较低的的去处理级别更高的中断源待处理完毕再返回到被中断了的的过程例如中断正在执行突然发生了中断但是中断的抢占优先级数值更小比的更小数值更小抢占优先级更高中断则抢过中断的使用权响应的中断服务函数中断执行完毕后再交回继续执行如果中断抢占优先级相同将不会发生抢占行为只能乖乖的排队等待这就叫做中断挂起如果多个在挂起状态的中断具有相同的抢占优先级则子优先级高的先响应如果子优先级也相同则由编号中断编号小的响应一些中断编号的定义一般在芯片头文件中找到下列为总结抢占优先级子优先级编号可编程的优先级可以通过嵌套向量中断控制器实现嵌套向量中断控制器是系列微控制器中的中断控制器模块其主要功能如下中断优先级管理中断使能和禁止中断嵌套中断状态控制中断向量表管理通常在中开启各线的中断有关和的介绍的中断系统详解嵌入式学习中断嵌套博客是的外部中断事件控制器是的外设用于处理外部引脚的中断请求模块与紧密合作使得处理器能够响应外部事件并执行相应的中断处理程序通过线捕获线事件并且去生成中断在中断回调函数中翻转状态并且清除中断标志中断标志要清除不然就会一直产生中断使用外部中断模块特性对于来说想要获取的信号是外部的很快的突发信号由外部驱动只能被动读取实验外部按键中断控制亮灭测试时发现灯的行为有一些奇怪比如闪烁不完全亮等情况会发生所以需要按键消抖按键消抖当用户按下一个物理按键时由于按键使用的是机械式弹簧片的结构通常会导致按键在接通和断开状态之间快速切换造成一系列的开关状态变化这种短暂的状态变化称为按键抖动按键抖动可能会导致系统误以为用户进行了多次按键操作从而引发意外行为或错误抖动时间的长短由按键的机械特性决定一般为这是一个很重要的时间参数在很多场合都要用到按键稳定闭合时间的长短则是由操作人员的按键动作决定的一般为零点几秒至数秒为确保对键的一次闭合仅作一次处理必须去除键抖动在键闭合稳定时读取键的状态并且必须判别到键释放稳定后再作处理按键消抖分为硬件消抖和软件消抖硬件消抖一般是添加滤波电容软件消抖延时函数按键消抖或者定时器按键消抖或状态机消抖消抖时间设置为即可首先一定要在中的按键引脚设置为上拉状态不要设置为浮空输入做了按键消抖却失效的原因按键消抖的有效性通常取决于按键引脚的电气特性尤其是在没有上拉或下拉电阻的情况下没有上拉电阻时处于浮空输入状态按键引脚可能会更容易受到电气噪声和抖动等外部环境的影响从而使消抖无法正常工作轮询按键控制亮灭延时消抖按下检测延时消抖再次确认是否按下松手检测其他颜色的灯同理优点代码简单缺点会使空等浪费时间外部中断定时器消抖推荐消抖时间设置为即可一般设置为优点并没有浪费时间缺点会浪费一个定时器注意在配置时注意上升沿触发还是下降沿触发可能效果会不同一般都是设置下降沿触发按下开关为低电平注意别在中断回调函数中使用延时函数可能会出现神奇的严重会导致死机按键状态机定时器消抖配置选择内部时钟源配置对应的定时器溢出时间为消抖时长业务代码状态机判断状态按键状态短按标志长按标志按下持续时间启动定时器中断空闲态别忘了消抖态定时器消抖确认按下进入释放释放态检测每增加代表按下时间增加可以将变为枚举变量如下图所以比上面增加一种按下的状态使用场景中断相关的关键字关键字作用避免编译器优化编译器优化会可以去除无用的繁杂代码降低代码空间提升运行效率但优化后编译器在某些地方可能会弄巧成拙例空循环延时编译器就会觉得没什么用浪费时间会直接给你优化掉例中断方式下如果需要访问全局变量最好把全局变量使用来进行修饰避免编译器对该变量进行优化具体参考主函数和中断处理函数相当于两个线程因为编译器的优化在一个线程中改变一个全局变量的值另外一个线程读取到的可能是没有改变前的值因此需要用来标识这个变量让编译器不优化这个变量的存储这个变量的值可能因为编译器的优化在寄存器中进行改变而不是在真正的内存区间这个问题书上在中断这部分也说明了通讯概念通讯方式通讯方式分类串行通讯和并行通讯按数据传送的方式通讯可分为串行通讯与并行通讯串行通讯是指设备之间通过少量数据信号线一般是根以下地线以及控制信号线按数据位形式一位一位地传输数据的通讯方式并行通讯一般是指使用及根或更多的数据线进行传输的通讯方式并行通讯就像多个车道的公路可以同时传输多个数据位的数据而串行通讯而串行通讯就像单个车道的公路同一时刻只能传输一个数据位的数据一般情况下串行通讯成本更低节省数据线且通讯距离抗干扰能力较强但传输速率较慢全双工通讯半双工单工通讯全双工在同一时刻两个设备之间可以同时收发数据半双工在同一时刻两个设备之间可以收发数据但不能在同一时刻进行单工在任何时刻都只能进行一个方向的通讯即一个固定为发送设备另一个固定为接收设备同步通讯和异步通讯根据通讯的数据同步方式又分为同步和异步两种可以根据通讯过程中是否有使用到时钟信号进行简单的区分使用时钟信号的叫同步通讯未使用时钟信号则叫异步通讯在同步通讯中收发设备双方会使用一根信号线表示时钟信号在时钟信号的驱动下双方进行协调同步数据通讯中通常双方会统一规定在时钟信号的上升沿或下降沿对数据线进行采样通讯速率衡量通讯性能的一个非常重要的参数就是通讯速率通常以比特率来表示即每秒钟传输的二进制位数单位为比特每秒容易与比特率混淆的概念是波特率它表示每秒钟传输了多少个码元而码元是通讯信号调制的概念通讯中常用时间间隔相同的符号来表示一个二进制数字这样的信号称为码元如常见的通讯传输中用表示数字表示数字那么一个码元可以表示两种状态和所以一个码元等于一个二进制比特位此时波特率的大小与比特率一致如果在通讯传输中有以及分别表示二进制数那么每个码元可以表示四种状态即两个二进制比特位所以码元数是二进制比特位数的一半这个时候的波特率为比特率的一半因为很多常见的通讯中一个码元都是表示两种状态人们常常直接以波特率来表示比特率虽然严格来说没什么错误但不能混淆串口通讯详解串口通讯的原理流程图博客库教程四串口通信详解博客是什么芯片是干嘛的博客转博客概念通用同步异步收发器是一个全双工通用同步异步串行收发模块该接口是一个高度灵活的串行通信设备中的外设可以实现同步传输功能所以命名为比多了一个即同步器件主要用来产生相关接口的协议信号如串口等串行接口标准规范和总线的标准规范要使用传输数据的这些接口就要按照接口规定的协议信号发送数据所以期间广泛应用于串口通信中扮演者传输者的角色功能的串口通常用于与其他设备进行通信它可以用于与计算机其他微控制器传感器显示屏或其他外围设备进行数据传输串口通常用于发送和接收数据可以是文本二进制数据或其他格式常见的应用通过串口进行调试控制外部设备传感器数据采集和与外部设备进行通信等串口通常是嵌入式系统中基本且常用的通信接口之一串口接受与发送在中包含声明串口重定向函数在中重写和函数函数功能重定向库函数到输入参数无返回值无说明无函数功能重定向库函数到输入参数无返回值无说明无该函数在轮询中会堵塞执行的别名如别名就是需要发送的数据发送的字节数最大发送时间发送数据超过该时间退出发送在函数中使用等从串口获取单个字符中断轮询状态下的串口接收数据会使效率一直查看是否有数据干不了其他事情使程序堵塞效率低下但如果使用中断发送和接收比较高效需要处理时会被叫回处理其他时间可以干其他事情不会长期占用时间轮询模式是阻塞模式程序会等到所有数据发送接收完成后才会着向下执行而中断和是非阻塞模式他们将任务交给外设后就会接着向下执行不会等待数据发送接收完成主要有三个函数串口中断处理函数功能对接收到的数据进行判断和处理判断是发送中断还是接收中断然后进行数据的发送和接收在中断服务函数中使用中断接收数据该函数启动后只能触发一次中断进入一次中断回调函数如果需要多次触发需要在中断回调函数中重新启用中断发送数据串口接收中断回调函数再次开启串口接收代表完成代表接收完成后触发中断回调注意别忘了在中断回调函数中重新启动接收空闲中断对应回调函数代表扩展参数代表接收的数据长度实验普通中断回显实验主要的函数函数功能用于启用串口的接收中断并指定接收数据存放位置每当接收到数据时将触发一个中断然后调用相应的中断回调函数处理接收数据输入参数一共三个串口别名数据存放地址字节数返回值无说明无参数的别名如别名就是接收到的数据存放地址一次接收的字节数函数功能串口接收中断回调函数由用户自己编写当接收到一个或多个字符后会被调用在这个函数中处理接收到的数据比如回显到终端或者储存到缓冲区中输入参数无返回值无说明无开启串口接收中断数据溢出开启串口中断每次中断接收一个字节的数据数据量大会频繁触发中断可以改进为一次接收个字节的数据控制灯请操作小灯只有小灯亮只有小灯亮两个小灯同时亮两个小灯同时熄灭开启串口接收中断在串口调试助手时发送在单片机上可以看到明显的现象串口接收不定长数据如果用库一次性接收大量数据如果通过判断标志位每次只接受一个字节会消耗大量资源去频繁处理中断如果一次性接收多个字节可能会导致数据无法对齐如果一次接收大量字节中断回调函数无法执行像这样一次接收一个字节如果数据量大会频繁进入中断这样一次接收多个字节会导致接收数据错误这样接收大量数据会直接进不了中断回调此时就需要我们的标志位能解决一次性接收大量数据的问题也就是使用空闲串口中断收发不定长数据主要依靠串口空闲中断所谓串口空闲中断就是中断触发条件与接收的字节数无关串口无数据接收时不会触发必须要从接收到第一个数据开售当引脚上无后续数据进入串口接收从忙碌转为空闲时才会触发可以认为空闲中断发生时就是一帧的数据包接收完成了此时对数据进行分析处理即可一般用于接收大量数据串口接收数据阻塞中断代表扩展代表空闲中断以为例参数不变参数并不是想要接收的长度而是一次接收的最大长度空闲中断对应回调函数代表扩展代表空闲中断参数代表接收的数据长度使用相关函数时不再调用回调而是使用了进行回调实验库函数的一些调用流程外设名该函数一般会调用函数实际操作寄存器初始化外设功能由库实现外设名该函数是外设外围相关功能的初始化比如引脚特殊功能比如时钟使能等等由用户自己实现以初始化来举例定义一个结构体句柄通过函数来实现串口外设的底层初始化要做的功能使能外设时钟配置使用的引脚模式如果要使用中断就配置中断如果要用就配置通过前面定义的结构体具备来配置串口的波特率数据字长停止位奇偶校验位如果要使用异步模式则通过调用函数来将串口配置为异步模式定时器概念中的定时器是一种内置的硬件模块用于生成精确的时间延迟执行周期性任务捕获外部事件等定时器通常用于需要精确时间控制的应用比如实时操作系统通信协议脉冲宽度调制生成等以下常见的几种定时器高级定时器通用定时器基本定时器定时器的常见作用计时器模式定时器可以作为简单的计时器用于生成一段时间延迟你可以设置定时器的计数值和时钟频率来控制延迟的精度定时器中断定时器可以配置为在计数器达到特定值时生成中断请求这对于周期性任务执行或时间精确控制非常有用输出定时器可以用来生成信号用于控制电机速度亮度音频输出等捕获模式定时器可以捕获外部事件的时间戳比如测量输入脉冲的周期或脉宽计数器级联一些系列的芯片支持多个定时器级联可以扩展定时器的计数范围或增加功能还有一些相关知识例如定时器的主从模式定时器相关寄存器可以查看参考手册数据手册等还有一些相关知识定时器的主从模式等以下为定时器详细介绍定时器详解定时器博客基于定时器的闪烁配置确定时钟输入这里我们需要一个稳定的时钟输入以精确的进行定时因此可以选择内部时钟源这里以为例在中将选择为使用内部时钟源那么这个内部时钟源是哪来的呢参考芯片手册找到时钟源输入频率即在中配置为内部时钟源确定预分频值预分频值就是指时钟信号输入之后会在这里被分频也就是降低了输入频率假设这里的值设定为则最终信号会变成也就是计数器每秒会加次很显然这个速度对我们来说还是太大了为了便于计算我这里更倾向于让输出的时钟频率变成这样每定时器就加确定重装载值当我们在上面分完频后就很容易计算这里的值应该为多少了显然要使定时器触发一次这里的这个值应该为最后别忘了才是准确的值从开始别忘了使能自动重装载使能定时器中断在中开启中断主要涉及三个概念预分频值内部有一个预分频器简单来说就是分频值时钟信号被分频后的频率自动重装载值内部有一个自动重装载寄存器简单来说就是设置计数值上限最大为计数器内部有一个计数器自增会与自动重装在寄存器比较当计数值等于自动重装载值时将会触发更新中断或更新事件同时清零计数器定时器溢出时间注意和的值配置时都要因为从开始数举个例子假设时钟源频率为我们设置为那么得到分频后的时钟频率为每秒计数次要使定时器溢出一次那么次库教程六定时器中断博客函数和业务代码主要函数定时器中断处理函数定时器溢出中断回调函数在中可以找到里面调用了这个溢出中断回调函数使能定时器中断使用之前别忘了在中使能定时器中断业务代码定时器中断使能微控制器中的实时时钟模块是一个低功耗的独立计时器用于提供精确的时间和日期信息模块设计为即使在主电源关闭的情况下也能继续运行从而确保时间信息不会丢失这通常是通过一个备用电池或超级电容来实现的它能够为供电即便主电源断开以下是关于中的一些关键点功能提供实时时间可以作为系统时钟提供准确的小时分钟秒等日历功能除了时间还可以提供年月日等日期信息闹钟功能可以设置特定时间触发中断用于定时唤醒或其他用途定时任务可用于执行定期的任务或事件硬件特性低功耗设计在低功耗模式下也能工作适合于电池供电的应用备用电源通过引脚连接备用电源保证在主电源断开后仍能维持时间信息时钟源可以选择多种时钟源如低速外部晶振通常为低速内部振荡器或高速外部晶振经过分频后的信号时钟选择设备因为其独特的运行方式即掉电依旧运行使用分频时钟或者的时候在主电源掉电的情况下这两个时钟来源都会受到影响资源消耗太大小小的纽扣电池根本吃不消所以一般都时钟低速外部时钟频率为实时时钟模块中常用的因为分频容易实现所以被广泛应用到模块在主电源有效的情况下待机还可以配置闹钟事件使退出待机模式故使用时记得使能的外部晶振配置时钟树时选择中断秒中断这里时钟自带一个秒中断每当计数加一的时候就会触发一次秒中断注意这里所说的秒中断并非一定是一秒的时间它是由时钟源和分频值决定的秒的时间当然也是可以做到秒钟中断一次我们通过往秒中断里写更新时间的函数来达到时间同步的效果闹钟中断闹钟中断就是设置一个预设定的值计数每自加多少次触发一次闹钟中断配置激活时钟源激活日历这两个都要使能作用也很明显先是使能时钟源再使能日历第一个参数是否使能引脚作为校正的秒脉冲输出第二个参数是否使能引脚作为入侵检测校验功能剩下的就是时间配置库函数设置系统时间读取系统时间设置系统日期读取系统日期启动报警功能设置报警中断报警时间回调函数写入备份储存器读取备份储存器参数句柄结构体参数参数获取时间的结构体参数获取时间的格式使用进制使用进制实验实时时间显示获取日期结构体获取时间结构体分别从获取时间结构体和日期结构体掉电重置寄存器是在嵌入式系统如微控制器中用于在系统掉电或复位时保存数据的特殊寄存器它们通常用于需要在掉电或复位后保留的重要数据这些数据在重新上电或复位时能够被恢复即使系统复位或电源复位备份寄存器的内容会保留不变直到手动修改或在特定条件下被重置寄存器可以在芯片手册中找到解决掉电重置代码新增代码处读取备份寄存器检查是否已经初始化过新增代码处设置完成后将标志位写入备份寄存器标记已初始化下次开机后将不再初始化检查寄存器值在部分通过函数读取备份寄存器的值我们约定用值来表示已经被初始化该值自己约定即可初始化和时间设置如果读取到的值不是说明未初始化接着会进行的时间和日期设置否则跳过初始化保留当前时间保存初始化标志设置完时间后通过将写入标记已经完成初始化以便下次重启时检测在中备份寄存器可以使用到多个寄存器上面的例子使用的是你可以根据需要选择其他备份寄存器定时器外部时钟与循迹模块循迹模块作用为传送带测速测距计算流水线上的货物数量等动画讲解定时器外部时钟实战传送带测速装置哔哩哔哩抖动脉冲输入滤波器概念脉冲宽度调制是英文的缩写简称脉宽调制其实是在利用微控制器的定时器模块来生成一种特定频率和占空比的脉冲信号调整脉冲的宽度从而影响功率等信号是一种周期性的脉冲信号通过调整脉冲的宽度高电平时间可以模拟模拟信号控制电机速度亮度蜂鸣器响度等无非就是一定的频率周期输出不断交替的高低电平信号占空比高电平在一个周期中占用时间的比重叫做占空比占空比越大其在宏观上表现的电压也就越大成线性关系通用或者高级定时器具有输出比较模式可以通过不断比较计数器与比较寄存器的值相关函数启动定时器输出第一个参数为指向定时器句柄的指针第二个参数为启动的通道一个有共四个例函数返回一个类型的值表示操作的状态常见的返回值包括操作成功操作失败启动输出并启动比较中断修改占空比或前两个参数不变第三个参数为用户占空比占空比上下两种都可以它是库中的一个宏用于快速设置定时器的比较寄存器的值直接修改比较寄存器的值也可以访问定时器相关寄存器修改或的值修改预分频值寄存器修改自动重装载值寄存器实验控制亮度实现呼吸灯库教程七输出呼吸灯博客配置第一步配置时钟树第二步选用定时器这里用选择内部时钟源四个独立通道任选一个选择模式代表通道对应引脚将自动配置为复用模式就是设置定时器通道的功能输入捕获输出比较输出单脉冲模式第三步选择宽度占空比先选择不使能通道极性配置为选择可以使占空比变为低电平占整个周期的比例和区别在于一个是向上计数一个是向下计数以及频率和占空比是否固定上等的选择上当占空比为时如果选择那么高电平占选择那么低电平占但一般情况下占空比都是指高电平所占周期的比例第四步设置预分频值和重装载值以及占空比我设置得到的定时溢出频率即的频率故占空比为高电平所占时间与整个周期比例是定时器的比较捕获寄存器可以修改其值来调整占空比第五步生成项目业务代码轮询修改占空比按键控制呼吸灯开关此时占空比为代表全为低电平这里的延迟可以使到达最暗或者最亮之后可以持续一会以便于灯的变化更加顺畅注意切换模式要卸载消抖里面否则可能会出现关不上灯的情况如果感觉灯到达最亮或者最暗的时间比较慢可以调整一次循环中加或减的值使亮度变化更平滑如果感觉灯到达最亮或者最暗之后的维持的一段时间比较慢快可以修改每一次大循环的延迟比较合适每一次加或减之后有一个在每次循环迭代中产生一个较小的延迟因为每一次循环都是很快的的速度远远小于一个输出周期的时间如果删除它那么占空比将会很快到达我们肉眼观察就是瞬间亮了又瞬间灭了而不会产生亮度慢慢变化的结果一般设置为即可提问每一个周期不应是有高电平和低电平吗为什么观察到的不是灯一闪一闪的到达最亮或最暗呢那么我们平时见到的灯当它的频率大于的时候人眼就会产生视觉暂留效果基本就看不到闪烁了而是一个常亮的灯你在秒内高电平秒低电平秒频率如此反复那么你看到的电灯就会闪烁但是如果是毫秒内毫秒打开毫秒关闭频率这时候灯光的亮灭速度赶不上开关速度灯还没完全亮就又熄灭了由于视觉暂留作用人眼不感觉电灯在闪烁而是感觉灯的亮度少了然后占空比在不断变化所以才会感觉在慢慢变亮和慢慢变暗业务代码定时器修改占空比另外启用了一个定时器修改占空比数秒内让占空比从假定内那么增加一占空比所以通道的呼吸效果通道的呼吸效果通道的呼吸效果实验控制无源蜂鸣器通过改变频率可以输出不同频率的方波信号用这个信号驱动无源蜂鸣器便能播放不同频率的声音原理学习板上的蜂鸣器型号为电磁式无源蜂鸣器蜂鸣器内部有一个电磁线圈能够驱动振动膜片发出声音通过给蜂鸣器提供不同频率的信号即可发出不同频率的声音实际操作中除了控制频率还需要控制占空比以使膜片振动趋近于正弦波从而发出清脆明亮的声音在学习板上使用占空比可以有较好的响度和音质配置配置打开外部晶振配置时钟树配置对应按键输入模式上拉等找到蜂鸣器对应的引脚和通道勾选对应内部时钟对应通道选择生成模式参数按照要求或随意业务代码按下输出声波设置占空比为按下输出声波设置占空比为否则关闭声波输出实验控制直流电机直流电机一端通正极一端通负极就可以旋转电压越大旋转也就越快正负极反过来还可以实现反转电机驱动模块我们控制的是单相电机一个正极一个负极分别接入通常驱动一个小电机需要几百毫安的电流但单片机上的口只能支持几毫安的电流直接接上可能会损坏单片机所有我们需要一个电机驱动芯片常见的有等一共个口个口其中与一组与一组我们可以通过单片机输出到来控制的输出来控制电机同理也就是说电机芯片可以驱动两个电机引脚可以让芯片暂停工作实现低功耗的脚可以在出现控制错误时提醒单片机和脚用于给芯片和电机供电原理停止旋转时向输入高电平向输入低电平时输出高电平输出低电平使电机正转向输入低电平向输入高电平时输出低电平输出高电平电机反转旋转时都输入高电平与都输出低电平相当于将电机的两根线短路由于电机内的转子由很多线圈组成相当于电感产生反电动势阻碍电流变化因此电流在整个回路中是缓慢变小消失这种情况称为电流慢衰减反电动势产生的磁场与定子产生的磁场相互作用会使电机转子很快的刹停叫刹车都输入低电平会将与都输出高电平使得转子电流瞬间释放这种情况称为电流快衰减相当于将电机的两根线断路无回路不能形成磁场此时会随着摩擦力慢慢停下来叫滑行原理正转输入低电平正转滑行快衰减电机一会处于正转一会处于滑行占空比越高正转时间越长宏观上来看也就是电机转速也就越快高电平输入正转刹车慢衰减电机一会处于正转一会处于刹车占空比越低正转时间越长宏观上来看也就是电机转速也就越快滑行和刹车区别都可以实现控制电机转速区别就在于占空比一个高越快一个低越快应用场景快衰减能够迅速降低电流故常用于需要快速变化的高动态响应场景慢衰减电流变化比较平稳因而比较适合用于平稳运行降低噪音的场景中对于小电机来说其实感受不到什么区别反转低电平输入反转滑行输入高电平反转刹车注意占空比过低时电机可能无法启动配置配置打开外部晶振配置时钟树查看对应引脚对应的通道切换到配置选择内部时钟源将对应通道设置为生成模式一个通道正转一个通道反转参数配置频率变为其他配置生成代码业务代码停止转动电机转速由计算而来使用旋转编码器控制电机转速启动两个通道设置编码器初始值为停止转动控制编码器在之间代表反转代表正转离中点越远转速越快最快反转最快正转保持反转最快保持正转最快控制的值在之间通过控制使映射在之间反转滑行通过控制使映射在之间正转滑行最好将该模块拆分为单独的实现驱动的编写驱动库电机驱动波特律动字模生成器可以参照别人写的驱动自己编写代码输入捕获动画讲解输入捕获并实现超声波测距哔哩哔哩概念输入捕获当定时器输入通道上检测到上升沿或者下降沿时立刻将此时计数器的值记录到捕获寄存器中等待程序稍后读取并且可以借用另一个输入通道的捕获寄存器进行输入捕获此种方法不会受到软件运行时间的干扰更加准确捕获寄存器对于通用定时器和高级定时器来说每个输入通道都有它自己的捕获寄存器假设我们启动了输入通道的输入捕获模式并且设定为上升沿捕获定时器启动计数后若输入到输入通道的信号出现了一个上升沿边沿检测器立即检测到就会通过传递到捕获寄存器捕获寄存器便立刻将此时计数器的值复制到自身如果对此输入捕获开启了中断就还会触发输入捕获中断通知程序尽快读取捕获寄存器中的数值这样就获取到了上升沿出现时定时器的时刻当我们再获取下降沿出现时定时器的时刻就可以获得到高电平持续时间但一个输入通道的输入捕获只能进行上升沿捕获或者下降沿捕获不能设置为双边沿捕获所以又从上引出了一条线连接到了捕获寄存器上这条线就是输入捕获的直接模式和间接模式信号从引入在自己的捕获寄存器上进行输入捕获就叫做输入捕获的直接模式而借用捕获寄存器进行输入捕获则叫做输入捕获的间接模式和是一对可以相互借用和是一对可以相互借用相关函数输入捕获函数启动就是输入捕获的意思输入捕获中断当下降沿来临时说明高电平结束我们需要获取两个输入捕获寄存器的值进行计算因此需要在通道捕获完成后中断通知我们读取捕获寄存器数值读取对应通道的捕获寄存器值输入捕获中断回调在输入捕获完成后将会进入该函数定时器计数值设置参数为对应定时器句柄参数为设置的值输入捕获单通道测频率配置只需要开启对应时钟配置对应引脚的对应通道为输入捕获直接模式的值要尽可能的大避免在测量时溢出的也需要设置一些值避免标准频率过快在很小时计数很快也容易溢出业务代码输入捕获中断用外设进行分频后的时钟计算频率使用测周法未配置从模式所以需要手动清零注意对于每次读取之后都是一个新的周期开始如果没有配置从模式触发复位那么我们需要在读取手动将复位避免溢出超声波测距介绍超声波测距模块是各种需要测距的产品中常用的一类传感器测距原理首先发送一定频率的超声波超声波遇见被测物体后就会被反射回来当模块接收到反射回来的超声波后只要将超声波从发送到接收的时间差乘以声速再除以就可以得到超声波测距模块和被测物体的距离了发送时刻接受时刻声速距离注意若被测物体和超声波测距模块之间有障碍物则测得的是障碍物的距离因而某些场景不适合但倒车雷达等需要对一个范围内进行测距的便非常合适超声波测距模块以为例共有四个引脚控制端用于触发模块进行测距输出端用于测量模块输出的高电平持续时间原理当需要超声波测距时只需要通过口向引脚发送一个脉冲信号超声波模块接收到脉冲信号就会向外发送一段超声波然后模块会将拉高当模块接收到反射回来的超声波后会被拉低那么高电平持续时间也就是超声波在往返路途中消耗的时间向引脚发送脉冲信号启动超声波测距先将口拉高等待一会后再将口拉低即可等待的时间可以查看超声波模块手册级别测量上高电平持续时间得到超声波往返时间使用定时器上的输入捕获通过两个输入捕获寄存器的差可以得到高电平持续时间配置配置先启动开启外部晶振配置时钟树使用屏幕显示测距所以打开查看手册找到控制端和输出端对应引脚配置为配置为并打好对应然后转到选择内部时钟源配置的为输入捕获直接模式配置为输入捕获间接模式转到参数设置设置为计数器频率变为每计数值设置上升沿检测输入捕获直接模式捕获寄存器前的分频设置为不分频滤波为因为没什么抖动所以不用滤波置下降沿检测输入捕获间接模式捕获寄存器前的分频设置为不分频滤波为因为需要使用中断模式最后使能捕获比较中断业务代码启动定时器启动上升沿输入捕获启动下降沿输入捕获此处中断启动因为得到捕获值后要计算引脚发送脉冲信号先拉高引脚等待一段时间后再拉低用于启动超声波测距重置计数器的值避免下降沿捕获数值小于上升沿捕获数值使用显示器距离缓慢发送在中可以发现每次进入中断回调函数前都会被重新赋值以表示当前处理的是哪个通道注意和之前的是不同的分别通过两个捕获寄存器得到上升沿对应计数和下降沿对应计数分频后为即一次声速影响条件较多这里取即最后单位为启动超声波测距引脚发送脉冲信号先拉高引脚等待一段时间后再拉低用于启动超声波测距重置计数器的值避免下降沿捕获数值小于上升沿捕获数值计算高电平持续时间和被测物体距离在中可以发现每次进入中断回调函数前都会被重新赋值以表示当前处理的是哪个通道注意和之前的是不同的分频后为即一次声速影响条件较多这里取即最后单位为旋转编码器概念用来测量位置速度或旋转方向的传感器当期旋转轴旋转时其输出端可以输出与旋转速度和方向对应的方波信号读取方波信号的频率和相位信息可以得知旋转轴的速度和方向常见的有增量型旋转编码器绝对型编码器等教程扭扭扭转转转轻松掌握编码器哔哩哔哩增量型旋转编码器原理增量型旋转编码器一般有两相输出信号当旋转编码器没有旋转时两相均没有电平变化稳定输出高电平或者低电平当旋转编码器被顺时针旋转时相会输出一个方波相此时也会输出一个方波但是相方波领先相度也就是相先产生上升沿下降沿稍后相再产生上升沿下降沿也可以说相上升沿时相为高电平相为下降沿时相为低电平当逆时针旋转时情况相反相方波落后相度相上升沿时相为低电平相为上升沿时相为高电平这样我们可以通过计算相或者相上升沿或者下降沿的数量来获取旋转编码器的角度可以通过相边沿时相电平的情况得知当前的旋转方向注意不同旋转方向下相到底谁在前谁在后也可能根据具体元器件的不同而反过来查阅旋转编码器的手册中可以看到即每读输出个脉冲也就是每个脉冲为所以用脉冲数量乘以就能得到真实的旋转角度旋转角度脉冲数量每个脉冲对应的角度当然对于旋钮这种用户输入我们一般只需要知道用户向哪个方向旋转了多大程度就好不必计算真实角度实现思路思路中断将相信号接入到口后将相的口设置为上升沿或者下降沿触发中断然后再中断回调中读取相口的电平状态即可判断旋转方向同时根据旋转方向对计数值加或减来记录脉冲数量缺点处理单片机上转的慢的旋钮效果不错但是处理转的非常快的电机的旋转编码器时容易频繁触发中断导致工作效率低还有可能出现软件处理跟不上导致丢步问题思路定时器通用高级定时器为增量型编码器准备了专门的编码器接口只要将两相信号同时输入进去就可以实现正传时计数器自增反转时计数器自减那么我们将如何将相信号输入编码器呢编码器两个输入接口其实是早已了解过的和也就是说我们直接将相信号接入到定时器的通道和通道就可以接入到编码器接口让编码器可以根据相的信号控制计数器进行增加和减少而且还可以利用这两个通道的滤波器与边沿检测器对相信号初步处理编码器接口对上下边沿都很敏感对于相上的一组脉冲会计数两次例如相下降沿时相为低电平计数器相上升沿时相为高电平计数器又反向时同理一句话来说就是一个脉冲上下降沿都会被计数一共两次实验使用增量型旋转编码器控制小灯亮度配置配置打开外部晶振配置时钟树查阅原理图找到相相按键找到对应引脚和该板为配置引脚和由于旋转编码器能自主产生两路信号故不用配置内部时钟源直接找到组合通道设置选择为编码器模式引脚自动被设置旋转编码器对应定时器参数配置默认为不分频由于编码器对上下沿都敏感此时编码器旋转一次计数为如果想要旋转一次计数器计数为的话设置二分频即可或者可以在代码中手动对值进行修改编码器对应定时器的计数器保持默认的或设置为想要的值即可是选择在哪个通道进行计数如果选择两个通道都计数的话一个脉冲将会被计数次通常配置为即可极性设置类似于有效电平机制设置下降沿有效会将此通道波形翻转如果与平时顺时针增加逆时针减少不符可以修改一个通道的极性即可输入捕获只能进行直接捕获走和预分频器分频比不进行预分频输入滤波可以设置为最大值不滤波其实也没为问题编码器可以按下当按键使用配置为输入模式或中断模式都可注意是否需要开启内部上拉为了实现亮度调节找到小灯对应的定时器设置这里为勾选内部时钟源将通道设置为生成模式为了使用打开函数编码器启动参数定时器对应结构体句柄参数对应通道对于只有一相信号的单相编码器来说填通道或若有两项以上的一般填所有通道其实也就是通道和获取定时器计数值内部库使用能够获取当前的计数器值编码器旋转时计数值会自增或自减业务代码启动编码器启动小灯的输出每次循环更新定时器的计数值上显示和进度条实现按下编码器切换小灯未作消抖处理舵机概念舵机由于经常用于控制航模船模的舵面而得名是一种比较简易的伺服电机系统原理以为例可以控制舵机从旋转到查看舵机手册可以得到分别对应着的高电平时长我们见到的多数舵机通常使用也就是周期为的信号进行控制因而对应的占空比为即输出占空比为时舵机旋转到输出占空比为舵机旋转到输出占空比为时舵机旋转到绝大多数舵机控制的占空比范围都是因为绝大多数的航模遥控器也是输出这个范围的信号实验使用旋转编码器控制舵机旋转配置配置打开外部晶振配置时钟树配置好旋转编码器默认设置为其余默认即可查看手册找到舵机对应打开内部时钟配置对应通道的生成模式使用的信号假设的内部时钟为配置为生成代码注意因为旋转编码器个脉冲对应的是也就是计数次而舵机只能旋转所以最大计数值应该设为业务代码占空比定时器最大值为计算占空比为对应的比较寄存器的值看门狗介绍微控制器中的看门狗外设是一种用于监视系统运行的外设它是一种硬件计时器用于检测系统是否正常运行其基本原理是周期性地重置系统以确保系统在正常情况下能够响应当系统出现异常情况如死循环软件错误等导致停止响应时看门狗定时器将超时并执行其预设的动作例如重置系统或触发中断从而使系统得以恢复或采取适当的措施在微控制器中看门狗外设主要分为两种类型独立看门狗和窗口看门狗独立看门狗独立看门狗特点独立看门狗是一种基本的看门狗类型本质是一个单独的定时器独立于主处理器即使主时钟发生故障仍然有效驱动时钟由专用的低速时钟驱动由于的时钟频率不精确故独立看门狗只适用于对时间精度要求比较低的场合用途独立看门狗主要用于监视整个系统的运行状态当系统出现故障死锁或其他异常情况时独立看门狗会在预设的超时时间内未收到系统的喂狗信号时触发重启操作以恢复系统的正常运行独立看门狗可以简单理解为一个位的递减计数器看门狗激活后如果计数器的重装载值递减到系统就会产生复位如果在计数器递减到之前刷新了计数器值那么系统就不会产生复位这个刷新计数器的过程我们称为喂狗配置时钟并不直接提供给计数器时钟而是通过一个位的预分频器寄存器分频后输入给计数器时钟具体见的参考手册寄存器章节配置预分频系数取值溢出时间单位是预分频系数而是的取值代表分频分频等是重装载寄存器的值位即为输入时钟频率是分频后的频率的倒数即周期再乘代表定时器溢出时间相关函数看门狗初始化函数喂狗函数举例看门狗喂狗窗口看门狗窗口看门狗特点窗口看门狗是一种高级的看门狗类型它具有两个阈值即看门狗窗口只有在这个窗口内喂狗信号才被视为有效超出窗口范围的喂狗信号会被视为异常驱动时钟由时钟如分频后得到时钟驱动通过可配置的时间窗口来检测应用程序非正常的过迟或过早操作窗口看门狗最适合那些要求看门狗在精确计时窗口起作用的程序用途窗口看门狗不仅可以监视系统的整体运行状态还可以检测特定时间段内的系统运行状态它可以帮助系统在特定的时间窗口内完成任务以确保系统的实时性和稳定性比如一个程序段正常运行的时间是在运行完这个段程序之后紧接着进行喂狗如果在规定的时间窗口内还没有喂狗那就说明我们监控的程序出故障了跑飞了那么就会产生系统复位让程序重新运行窗口看门狗跟独立看门狗一样也是一个递减计数器不断的往下递减计数当减到一个固定值时还不喂狗的话产生复位这个值叫窗口的下限是固定的值不能改变窗口看门狗之所以称为窗口就是因为其喂狗时间限制在一个有上下限上下窗口的范围内计数器减到某个值计数器减到在这个范围内才可以喂狗可以通过设定相关寄存器设定其上限时间但是下限是固定的中断相比于独立看门狗窗口看门狗可以使能中断如果使能了提前唤醒中断系统出现问题喂狗函数没有生效那么在计数器由减到的时候便会先进入中断之后再递减一次才会复位当然你也可以在中断里面喂狗喂狗的操作必须要在主循环里而不能放在定时器中断里这是很多初学者容易犯的错误因为如果出现了主循环跑飞或者陷入某个死循环定时器中断可能还在正常运行定期进入中断喂狗则看门狗不能复位系统起不到监测系统正常运行的作用配置预分频系数选择上窗口值要求在和计数器值之间向下递减的计数器值如果不喂狗到会复位有位取值为使能提前唤醒中断并开启中断若时钟为选择分频计数器取最大值上窗口设置为分频后递减到上窗口的最短时间递减到下窗口的最长时间喂狗窗口期为超出这个时间没有喂狗那么就会复位相关函数看门狗初始化喂狗看门狗中断处理函数看门狗中断回调函数实验创建的中中断发生标志位清除该标志位等待下一次中断喂狗避免一直重复喂狗设置了一个中断进入标志位当主循环中检测到进入中断后则喂狗避免复位烧录到开发板后可以看到亮起之后熄灭没有再亮起代表没有复位实验成功注意最好不要在中断回调函数中喂狗库教程五看门狗独立看门狗窗口看门狗使用库程序跑飞博客传感器模块传感器元件光敏电阻热敏电阻红外接收管等的电阻会随外界的模拟量的变化而变化通过与定值电阻分压即可得到模拟电压输出再通过电压比较器进行二值化即可得到数字电压输出概述的缩写指模数转换器或者模拟数字转换器是指将连续变量的模拟信号转换为离散的数字信号的器件典型的模拟数字转换器将模拟信号转换为表示一定比例电压值的数字信号库教程九博客重要概念转换模式单次转换模式连续转换模式扫描模式间断模式等单多通道数据左右对齐电压输入范围输入通道注入通道和中断类似规则通道时钟外部触发转换定时器中断中断触发条件三个规则通道转换结束注入通道转换结束模拟看门狗状态位被设置触发只有和才可通常使用都开启参数配置中配置这里设置为独立模式独立模式模式下双不能同步每个接口独立工作所以如果不需要同步或者只是用了一个的时候应该设成独立模式多个同时使用时会有其他模式如双重同步模式两个同时采集一个或多个通道可以提高采样率数据对齐方式右对齐左对齐这个上方有讲解数据的左右对齐扫描模式如果只是用了一个通道的话就可以了也只能如果使用了多个通道的话会自动设置为就是是否开启扫描模式连续转换模式设置为即连续转换如果设置为则是单次转换两者的区别在于连续转换直到所有的数据转换完成后才停止转换而单次转换则只转换一次数据就停止要再次触发转换才可以进行转换间断模式因为我们只用到了个所以这个直接不使能即可规则通道设置启用常规转换模式使能否则无发进行下方配置转换通道数用到几个通道就设置为几多个通道自动使能扫描模式外部触发转换源设定的触发方式规则的软件触发调用函数触发即可外部引脚触发定时器通道输出触发需要设置相应的定时器设置转换顺序这个只修改通道采样时间即可设置为不同的采样时间会影响到的转换精度和转换速度较长的采样时间可以提供更稳定的转换结果适合高阻抗的信号源但会增加总的转换时间而较短的采样时间可以提高转换速度但可能会降低精度特别是在处理高阻抗信号时多个通道时会有多个可以设定每个通道的转换顺序总转换时间如下计算采样时间个周期当最大采样时间为周期最快时周期因此的最小采样时间时钟采样周期为周期下得到注入通道设置也就是注入通道的设置和转换通道没啥太大区别这里不再详解使能模拟看门狗中断本质也测量值就是超出测量范围或者低于最低范围启动看门狗转换结束中断配置的传输配置相关函数开启的种模式轮询模式中断模式模式轮询模式开启中断轮询模式开启模式开启关闭的种模式轮询模式中断模式模式读取转换值校准函数通常精度要求时使用一般添加在初始化之后注意系列不支持等待转换结束函数第一个参数为指定的第二个参数为最大等待时间中断回调函数转换完成后回调模式下传输完成后调用规则通道以及看门狗的配置配置规则组通道实验轮询读取的值配置开启对应通道选择不开启连续转换模式同时设置适当的采样时间业务代码启动校准启动转换等待转换完成实验使用读取电位器电压单通道电位器介绍电位器是一种三端的可调电阻器常用于调节电压电流或信号强度它通过转动或滑动一个机械部件如旋钮或滑杆来改变电阻值实现电路中的电压分配或控制在单片机上使用标注原理图中标注为可变电阻配置配置打开外部晶振配置时钟树为了转换结果的准确性配置时钟树时注意分频后的时钟信号最好不超过从原理图中找到对应引脚查看其对应通道然后在对应中勾选通道设为使转换持续进行不需要每次获取之前手动触发转换设为最长采样时间可以获得更稳定的转换结果采样时间越长转换结果越准确若有显示等配置即可生成项目业务代码启动连续转换读取原始值获取位精度的测量范围为进行电压计算该处电压范围可以在对应原理图上的找到实验使用热敏传感器测量温度单通道热敏电阻介绍是指负温度系数热敏电阻是一种随着温度升高电阻值下降的热敏电阻器件它的主要特点是电阻值与温度呈反比关系原理热敏电阻本身是一个单独的电阻在这个电路中通常会与一个已知电阻如串联以形成一个分压器这样可以通过测量电压来推算出的电阻值具体来说传感器的电阻值会随着温度变化而变化而通过这个分压器电路可以得到一个对应的电压信号单片机上的原理图如下电路工作原理与固定电阻串联电路中有一个热敏电阻和一个已知固定电阻串联电源整个电路连接到一个电源例如分压器在热敏电阻上得到的电压计算步骤通过位读取电压测量得到的值代表的是在热敏电阻上的电压由分压公式有将的值带入后简化得到的值计算公式为得到的值之后使用值公式计算出热敏电阻的阻值对应温度温度下通过计算得到的电阻单位为参考温度下的电阻值常温给出的值热敏电阻的材料常数单位常温配置配置打开外部晶振配置时钟树为了转换结果的准确性配置时钟树时注意分频后的时钟信号最好不超过从原理图中找到对应引脚查看其对应通道然后在对应中勾选通道设为使转换持续进行不需要每次获取之前手动触发转换设为最长采样时间可以获得更稳定的转换结果采样时间越长转换结果越准确若有显示等配置即可生成项目业务代码通过值计算电阻值参数转换的结果为串联电阻值大小返回值电阻值浮点数类型单位通过阻值计算温度语言中函数就是以为底数的函数即参数通过计算得到的电阻手册上给出的值常数串联电阻大小常温返回值温度类型单位摄氏度计算当前电阻语言中函数就是以为底数的函数即概念全称即直接存储器访问传输将数据从一个地址空间复制到另一个地址空间提供在外设和存储器之间或者存储器和存储器之间的高速数据传输无须的干预通过数据可以快速地移动这就节省了的资源来做其他操作的作用就是实现数据的直接传输而去掉了传统数据传输需要寄存器参与的环节一般在数据量大的时候频繁进入中断可能会出现问题此时采用搬运是的小助手库教程十一串口发送接收串口发送第一次成功博客传输方式方法正常模式当一次数据传输完后停止传送也就是只传输一次方法循环传输模式当传输结束时硬件自动会将传输数据量寄存器进行重装进行下一轮的数据传输也就是多次传输模式串口模式与收发不定长数据模式只需要将串口中断发送函数改为即可串口发送数据串口接收数据串口恢复函数使用方式时还是有中断参与其中函数同样是由中断触发只不过不是串口中断而是传输完成中断还有的就是传输过半中断收发不定长数据收发不定长数据主要依靠串口空闲中断所谓串口空闲中断就是中断触发条件与接收的字节数无关串口无数据接收时不会触发必须要从接收到第一个数据开售当引脚上无后续数据进入串口接收从忙碌转为空闲时才会触发可以认为空闲中断发生时就是一帧的数据包接收完成了此时对数据进行分析处理即可一般用于接收大量数据串口接收数据阻塞中断代表扩展代表空闲中断以为例参数不变参数并不是想要接收的长度而是一次接收的最大长度空闲中断对应回调函数代表扩展代表空闲中断参数代表接收的数据长度使用相关函数时不再调用回调而是使用了进行回调首先还是要以启动中断或模式再次开启串口或中断接收模式传输过半中断可以使用或方式启动空闲中断但是使用模式时除了串口的空闲中断外的传输过半中断也会触发回调函数即接收的数据量到达我们设置的最大值的一半时也会触发这个回调函数一般场景不适用但某些场景有用可以通过加大数组长度或关闭传输过半中断解决所以一般情况下要关闭传输过半中断关闭传输过半中断参数通道的指针地址上面是的通道参数需要关闭的中断就是传输过半中断每次方式启动时都需要关闭注意如果勾选了外设文件单独生成那么需要在中使用否则找不到定义关闭半传输中断再次关闭半传输中断蓝牙模块与简易数据包解析蓝牙模块介绍蓝牙通信是其常见的无线通信方式之一蓝牙模块可以帮助实现与其他设备如手机电脑其他蓝牙设备之间的无线通信蓝牙模块在系统中可以通过等接口与主控制器连接蓝牙主要分类是经典蓝牙和低功耗蓝牙简称经典蓝牙一般像耳机这种持续传输数据的低功耗蓝牙间歇性同步数据设备常用于嵌入式如手环协议实验蓝牙发送数据控制简易数据包解析首先三个小灯亮灭对应红灯绿灯蓝灯亮灭例如代表红灯熄灭蓝灯亮指令一般都会有包头表示一帧数据的开始这里规定包头为包头后往往有一位数据包长度指示此数据包一共多长最后一位为校验和为前面所有数据的和取字节进制最后两位当收到数据后自行计算出的结果与数据包中自带的校验位比较相同则用不同舍弃假定故校验位为当向蓝色发送数据为校验位代表包头长度红灯绿灯蓝灯都亮蓝牙发送数据控制开关的教程第集使用蓝牙模块与简易数据包解析哔哩哔哩使用模块实现蓝牙透传通信波特率设置为使用连接扩展库实现不定长数据快速传输不占用资源使用通道实现串口数据的快速传输不占用资源配置蓝牙蓝牙透传通信波特律动最后使用蓝牙调试助手蓝牙打开微信小程序大夏无线传输助手点击搜索找到连接后发送注意切换进制发送介绍总线是一种由原公司开发的两线式串行总线用于连接微控制器及其外围设备多用于主控制器和从器件间的主从通信在小数据量场合使用传输距离短主从模式下任意时刻只能有一个主机等特性可以有多个从机是一种低速的半双工同步的通信总线常用于连接微控制器与各种外围设备在中接口可以应用于以下几种场景传感器读取许多环境传感器如温度湿度加速度等使用作为通信方式通过的接口可以轻松地与这些传感器进行数据交换显示模块控制一些小型的或显示屏使用接口进行命令和数据传输可以用来驱动这些显示模块以显示信息或图像音频编解码器部分音频编解码芯片使用作为配置接口可以通过配置这些芯片的工作模式并接收或发送音频信号实时时钟模块某些模块也采用接口来同步时间和日期信息可以用作主控来更新或从获取时间这里要注意是为了与低速设备通信而发明的所以的传输速率比不上原理超详细讲解值得一看博客分类分为软件和硬件软件软件通信指的是用单片机的两个端口模拟出来的用软件控制管脚状态以模拟通信波形软件模拟寄存器的工作方式硬件一块硬件电路硬件对应芯片上的外设有相应驱动电路其所使用的管脚也是专用的硬件固件是直接调用内部寄存器进行配置硬件的效率要远高于软件的而软件由于不受管脚限制接口比较灵活特点一共有只有两个总线一条是双向的串行数据线一条是串行时钟线数据线同时间只能发送或接收数据故为半双工通信是数据线代表也就是数据也就是用来传输数据的是时钟线代表也就是时钟也就是控制数据发送的时序的所有接到总线设备上的串行数据都接到总线的上各设备的时钟线接到总线的上总线上的每个设备都自己一个唯一的地址来确保不同设备之间访问的准确性物理层与协议层物理层总线在物理连接上非常简单分别由串行数据线和串行时钟线及上拉电阻组成和都需要接上拉电阻大小由速度和容性负载决定一般在之间保证数据的稳定性减少干扰通信原理是通过对和线高低电平时序的控制来产生总线协议所需要的信号进行数据的传递在总线空闲状态时和被上拉电阻拉高使和线都保持高电平协议层总线在传送数据过程中共有三种类型信号它们分别是开始信号结束信号和应答信号开始信号为高电平时由高电平向低电平跳变开始传送数据结束信号为高电平时由低电平向高电平跳变结束传送数据应答信号每当主机向从机发送完一个字节的数据主机总是需要等待从机给出一个应答信号以确认从机是否成功接收到了数据应答信号主机拉高读取从机的电平为低电平表示产生应答应答信号为低电平时规定为有效应答位简称应答位表示接收器已经成功地接收了该字节应答信号为高电平时规定为非应答位一般表示接收器接收该字节没有成功每发送一个字节个在一个字节传输的个时钟后的第九个时钟期间接收器接收数据后必须回一个应答信号给发送器这样才能进行数据传输应答出现在每一次主机完成个数据位传输后紧跟着的时钟周期低电平表示应答表示非应答注意这些信号中起始信号是必需的结束信号和应答信号都可以不要时序图应答主从主机和从机的概念主机就是负责整个系统的任务协调与分配从机一般是通过接收主机的指令从而完成某些特定的任务主机和从机之间通过总线连接进行数据通讯发布主要命令的称为主机接受命令的称为从机是一种主从通信协议允许多个设备连接在同一条总线上每个从设备都有一个唯一的地址称为以便主设备能够与特定的从设备进行通信是由位或位组成的二进制数字在通信时主设备将此地址发送到总线上从设备根据地址进行识别当主设备想要与某个从设备通信时它会发送从设备的地址如果从设备检测到自己的地址匹配它将响应通信请求主设备可以发送读命令或写命令以此来从从设备获取数据或向其发送数据例如假设作为主设备而一个显示屏作为从设备的地址为或表示为位地址主设备通过发送的地址来选择并与这个显示屏通信相关函数读写写函数设置使用的是那个例写入的地址设置写入数据的地址例需要写入的数据要发送的字节数最大传输时间超过传输时间将自动退出传输函数读函数参数同上写数据函数第个参数为操作句柄第个参数为从机设备地址第个参数为从机寄存器地址第个参数为从机寄存器地址长度第个参数为发送的数据的起始地址第个参数为传输数据的大小第个参数为操作超时时间设备号指针设置使用的是那个例从设备地址从设备的地址例的设备地址从机寄存器地址每写入一个字节数据地址就会自动如果是的寄存器那么就是从机寄存器地址字节长度位或位写入数据的字节类型位还是位需要写入的的数据的起始地址传输数据的大小多少个字节最大读取时间超过时间将自动退出函数位读写位读写与上方写函数区别写多个数据该函数适用于外设里面还有子地址寄存器的设备比方说除了设备地址每个存储字节都有其对应的地址如果只往某个外设中写数据则用如果是外设里面还有子地址例如我们的有设备地址还有每个数据的寄存器存储地址则用是个地址只有从机地址中断中断和相关函数中断读写模式读写中断回调函数和模式下进入的回调函数相同都是下面的函数发送回调接收回调实验读写库教程十二读取博客介绍是一个的串行存储器掉电不丢失内部含有个字节在里面有一个字节的页写缓冲器可以通过存储的型号来计算芯片的存储容量是多大比如后面的表示的是可存储的数据转换为字节的存储量为那么后面的表示的是可存储的数据转换为字节的储存量为以此来类推其它型号的存储空间设备地址下图为芯片从地址可以看出对于不同大小的具有不同的从器件地址由于为容量也就是说只需要参考图中第一行的内容这些只需要查看对应的手册都能找到芯片的寻址设备地址为如下前四位固定为为由管脚电平模块电路图中中默认为接地所以默认为最后一位表示读写操作所以的读地址为写地址为电路图如图其中对应上图中的都是接地所以为也就是说如果是写的时候从器件地址为读的时候从器件地址为片内地址寻址芯片寻址可对内部中的任一个进行读写操作其寻址范围为共个寻址单位对应的修改三位数据即可写读数据注意在写数据的过程中每成功写入一个字节存储空间的地址就会自动加当加到后再写一个字节地址就会溢出又变成写数据的时候需要注意是先写到缓冲区然后再搬运到到掉电非易失区所以这个过程需要一定的时间这个过程是不超过所以当我们在写多个字节时写入一个字节之后再写入下一个字节之前必须延时才可以对应延时的来自芯片手册以下部分对应教程配置查看芯片手册打开对应外设参数全部默认即可启动对应的串口代码写数据的时候大于的延时同上如果要一次写一个字节写次用这里的代码使用块读出错因此采用此种方式逐个单字节写入此处延时必加与写时序有关注意事项的每次写之后要延时一段时间才能继续写每次写之后要左右不管硬件采用何种形式都要确保两次写入的间隔大于页写入只支持个所以需要分次写入这不是库的而是的限制其他的可以支持更多的写入当然你也可以每次写一个字节分成次写入也是可以的那就用注释了的代码即可读写函数最后一个超时调整为以上因为我们一次写个字节延时要久一点注意读取数据的时候延时也要久一点否则会造成读的数据不完整实验使用温湿度传感器轮询总线温湿度传感器波特律动入门教程第集通信与温湿度传感器哔哩哔哩配置打开外设参数全部默认即可启动对应的串口传感器读取流程打开温湿度传感器数据手册找到传感器读取流程读取流程这里按位与就是确定第位是否为不为就发送注意的优先级很低要加括号流程流程流程流程上图中蓝色为从机发送给主机的数据可得温度和湿度都是个字节需要将其拆开后拼接起来可得到温湿度数据使用位操作此时注意强制转换为避免移动时丢失数据最后计算就是拼接后的湿度就是拼接后的温度代码我们通常会为不同的模块单独建立驱动文件新建文件和在中进行获取温湿度并显示设备地址位但是发送时通常是位包括一位读写为故要左移一位即故设备地址为使用函数时会根据读或写自动帮我们确定最后一位为还是文件文件温度湿度函数可以拼接字符串需要包含文件发送到串口使用串口调试助手中断与以及状态机编程中断和使用方法和串口类似相关函数中断读写模式读写中断回调函数和模式下进入的回调函数相同都是下面的函数发送回调接收回调状态机编程在微控制器编程中状态机是一种常用的设计模式用来管理复杂系统的不同状态以及在状态之间进行的切换状态机编程有助于使代码结构清晰易于维护特别适用于处理嵌入式系统中的顺序逻辑通信协议控制流程等问题状态机编程通常是使用枚举设定状态例如该模块实验中可以设置如下状态初始状态发送测量命令发送中发送完成后进行读取读取中读取完成数据解析轮询中对应处理温度湿度实验使用温湿度传感器状态机文件初始状态发送测量命令发送中发送完成后进行读取读取中读取完成数据解析文件此处的为了避免该函数作用域结束后回收故设置为方便多次测量或者以中断模式启动都是非阻塞模式或者以中断模式启动都是非阻塞模式状态机枚举变量温度湿度介绍是英语的缩写顾名思义就是串行外围设备接口是摩托罗拉首先在其系列处理器上定义的是一种高速的全双工同步的通信总线并且在芯片的管脚上只占用四根线节约了芯片的管脚同时为的布局上节省空间提供方便主要应用在实时时钟转换器还有数字信号处理器和数字信号解码器之间是全双工且没有定义速度限制一般的实现通常能达到甚至超过学习资料原理超详细讲解值得一看博客库教程十四博客主从模式分为主从两种模式一个通讯系统需要包含一个且只能是一个主设备一个或多个从设备提供时钟的为主设备接收时钟的设备为从设备接口的读写操作都是由主设备发起当存在多个从设备时通过各自的片选信号进行管理信号线接口有四条信号线通信数据输入数据输出时钟片选主设备输入从设备输出引脚该引脚在从模式下发送数据在主模式下接收数据主设备输出从设备输入引脚该引脚在主模式下发送数据在从模式下接收数据串行时钟信号由主设备产生从设备片选信号由主设备控制它的功能是用来作为片选引脚也就是选择指定的从设备让主设备可以单独地与特定从设备通讯避免数据线上的冲突对应硬件上为根线一对一一对多数据发送和接收主机和从机都有一个串行移位寄存器位主机通过向它的串行寄存器写入一个字节来发起一次传输首先拉低对应信号线表示与该设备进行通信主机通过发送时钟信号来告诉从机写数据或者读数据这里要注意时钟信号可能是低电平有效也可能是高电平有效因为有四种模式这个我们在下面会介绍主机将要发送的数据写到发送数据缓存区缓存区经过移位寄存器串行移位寄存器通过信号线将字节一位一位的移出去传送给从机同时接口接收到的数据经过移位寄存器一位一位的移到接收缓存区从机也将自己的串行移位寄存器中的内容通过信号线返回给主机同时通过信号线接收主机发送的数据这样两个移位寄存器中的内容就被交换工作模式根据时钟极性及相位不同有四种工作模式时钟极性定义了时钟空闲状态电平为时钟空闲时为低电平为时钟空闲时为高电平时钟相位定义数据的采集时间在时钟的第一个跳变沿上升沿或下降沿进行数据采样在时钟的第二个跳变沿上升沿或下降沿进行数据采样对应组合四种模式为原理超详细讲解值得一看博客芯片是一款通信的芯片可以通过标准两线四线控制的大小为分为个块每个块大小为字节每个块又分为个扇区每个扇区个字节通过通信协议即可实现和之间的通信实现的控制需要通过协议发送相应的控制指令并满足一定的时序打开芯片手册可以找到对应的操作写使能阅读最后一段英文可知写入使能通过将驱动为低电平将指令代码在的上升沿时移至数据输入引脚然后驱动为高电平即向发送写使能命令即可开启写使能首先片选拉低控制写入字节函数写入命令片选拉高扇区擦除指令第二排可以看到必须先执行指令设备才会接受通过将引脚驱动为低电平来启动该指令再将指令代码为扇区地址在最后一个字节的第位被锁存后必须将引脚驱动为高电平如果未执行此操作则指令将不会被执行即扇区擦除指令数据写入前必须擦除对应的存储单元该指令先拉低引脚电平接着传输指令和要位要擦除扇区的地址读命令第一排读取可以一次读取一个或多个数据字节先拉低电平再传输接着通过管教传输为地址最终数据通过引脚引出每传输一个字节地址自动递增所以只要时钟继续传输就可以不断读取出储存器中的数据状态读取命令写入命令在对的写入数据的操作中一定要先擦出扇区在进行写入否则将会发生数据错误一次性最大写入只有个字节在进行写操作之前一定要开启写使能当只接收数据时不但能只检测状态必须同时向发送缓冲区发送数据才能驱动时钟跳变实验读写配置主要说配置页面为全双工半双工有主机模式全双工半双工从机模式全双工半双工只接收主机模式只接收从机模式只发送主机模式硬件片选信号片选分为软件片选和硬件片选有硬件片选信号可以选择使能也可以使用其他口接到芯片的上进行代替其中的片选其中的片选如果片选引脚没有连接或者则需要选择软件片选管脚及我们熟知的片选信号作为主设备管脚为高电平从设备管脚为低电平当管脚为低电平时该设备被选中可以和主设备进行通信在中每个控制器的信号引脚都具有两种功能即输入和输出所谓的输入就是管脚的信号给自己所谓的输出就是将的信号送出去给从机对于的输入又分为软件输入和硬件输入软件输入分为内部管脚和外部管脚通过设置寄存器的位和位都为可以设置管脚为软件输入模式且内部管脚提供的电平为高电平其中位为使能软件输入位位为设置内部管脚电平位同理通过设置和位和则此时的管脚为软件输入模式但内部管脚提供的电平为若从设备是一个其他的带有接口的芯片并不能选择管脚的方式则可以有两种办法将管脚直接接低电平通过主设备的任何一个口去输出低电平选中从设备硬件输入主机接高电平从机接低电平硬件片选信号直接配置即可下面说软件片选只需要对应软件片选引脚选择硬件片选对应引脚选择然后设置下备注即可芯片闪存芯片进行通信所以设置为主机全双工然后进行基本参数配置帧格式默认通信格式默认有高位在前和低位在前波特率分频值决定时钟参数上面设置分频后得到的传输速率时钟极性选择是高还是低电平时钟相位选择第几个跳变沿上升下降沿采样校验项提高通信可靠性选择软件片选或者硬件片选配置中设置数据长度为先输出分频为分频则波特率为其他为默认设置格式设置为设置为第一个边沿不开启检验为软件控制代码因为我们是软件使能片选定义片选引脚片选低电平为有效使能片选高电平不使能这里用两个宏定义来代替以为例使用野火官方提供的驱动即可函数从对应头文件可以看到对应轮询中断和三种方式发送接收数据函数发送数据选择比如需要发送的数据可以为数组发送数据的字节数就是发送一个字节数据超时时间就是执行发送函数最长的时间超过该时间自动退出发送函数接收数据中断函数中断启动当上接收出现了个字节的数据后中断函数会调用回调函数中断回调介绍所谓就是由一个个发光的二极管发光小灯组成每个小灯称为一个像素只要在屏幕上有选择的点亮一部分小灯就可以显示我们想要的图案而小灯排列的数目就是分辨率常见尺寸分辨率列行小灯此时如果再按照之前的方法一个引脚控制一个小灯的话消耗太大显然不可能所以我们需要屏幕驱动芯片有了屏幕驱动芯片我们只需要通过或者等通讯协议与屏幕驱动芯片进行通信就可以操控这些小灯的亮灭常见屏幕驱动芯片有等入门教程第集如何在屏幕上挥毫哔哩哔哩原理与的通信分为两类指令和数据以为例分辨率为将行划分为页每一个从到共行列数为不变从芯片数据手册可以查到的从地址为通常在对应芯片手册下面为芯片中可以找到地址如下图位为或第位为位故为指令通讯格式一字节指令为地址开头一字节指令是我们需要发送的设置页地址只分为一次例如想设置页地址为想设置页地址为设置列地址需要发送两次指令假设我们需要设置列地址为第一次发送将列地址低位设置为第二次发送将列地址高位设置为即低位高位数据通讯格式任意数量的数据为地址开头任意数量数据为我们发送的等芯片特性设置完一字节的个像素后列地址会自动这样下一个数据就可以写到本页的下一列里利用这特性我们只需要将页地址和列地址都设置为然后一次性发送个字节就可以直接完成一页屏幕的像素设置设置第页需要在循环中手动自增遍历设置第列自动自增发送显示数据共个驱动函数在使用之前需要初始化关闭显示设置列起始地址设置列结束地址设置起始行设置页地址设置对比度设置分段重映射从右到左正向显示多路复用率设置启动电荷泵启动设置泵电压设置输出扫描方向到设置显示偏移设置内部时钟频率设置放电预充电时间设置引脚布局设置电平开启显示该函数内容一般厂商会提供网上搜即可当然没有的话只有自己写了发送指令设置页设置列低四位设置列高四位发送指令设置页和列发送数据设置亮灭由于屏幕任意点亮灭是随机的启动时会花屏所以需要我们利用显存刷新一下定义显存将所有像素清空只需要对进行增加列由于特性会自增故不需要增加该函数作用是使指定坐标亮起描述屏幕时使用的是下坐标系第四象限为列坐标为行坐标清空显存画点显示显存你将会得到一个在屏幕上移动的点初始化通常前面跟一个延时启动比上电快可等待再初始化避免比启动更早取模图模字模配置正常启动配置由于有大量数据故只需要将模式标准模式切换为快速模式使用外部高速时钟即可移植为了便于使用驱动库可以直接移植波特律动字模生成器图模和字模的使用方法使用波特率动取模后将取模后的代码复制到文件最下方最后再调用或即可使用',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-08-30 16:48:37',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/sites.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://i.postimg.cc/fbN6bFqP/20220206101541-14a48.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="安知鱼的博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="安知鱼的博客"/><span class="back-menu-item-text">安知鱼的博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/keqiudi/keqiudi.github.io" title="我的博客仓库"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="我的博客仓库"/><span class="back-menu-item-text">我的博客仓库</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">THEDI的仓库</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/sites/"><span> 网站导航</span></a></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/null"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/null"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AWS/" style="font-size: 1.05rem;">AWS<sup>2</sup></a><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>2</sup></a><a href="/tags/CLion/" style="font-size: 1.05rem;">CLion<sup>2</sup></a><a href="/tags/CMake/" style="font-size: 1.05rem;">CMake<sup>1</sup></a><a href="/tags/ESP32/" style="font-size: 1.05rem;">ESP32<sup>1</sup></a><a href="/tags/FreeRTOS/" style="font-size: 1.05rem;">FreeRTOS<sup>5</sup></a><a href="/tags/Git/" style="font-size: 1.05rem;">Git<sup>1</sup></a><a href="/tags/LCD/" style="font-size: 1.05rem;">LCD<sup>2</sup></a><a href="/tags/LVGL/" style="font-size: 1.05rem;">LVGL<sup>7</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem;">Linux<sup>8</sup></a><a href="/tags/MySQL/" style="font-size: 1.05rem;">MySQL<sup>2</sup></a><a href="/tags/PCB/" style="font-size: 1.05rem;">PCB<sup>2</sup></a><a href="/tags/QT/" style="font-size: 1.05rem;">QT<sup>1</sup></a><a href="/tags/STM32/" style="font-size: 1.05rem;">STM32<sup>2</sup></a><a href="/tags/keil/" style="font-size: 1.05rem;">keil<sup>1</sup></a><a href="/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1/" style="font-size: 1.05rem;">云服务<sup>3</sup></a><a href="/tags/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" style="font-size: 1.05rem;">启动流程<sup>2</sup></a><a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%89%E5%85%A8/" style="font-size: 1.05rem;">嵌入式安全<sup>3</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.05rem;">数据结构<sup>3</sup></a><a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 1.05rem;">架构<sup>2</sup></a><a href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" style="font-size: 1.05rem;">环境配置<sup>4</sup></a><a href="/tags/%E7%A1%AC%E4%BB%B6/" style="font-size: 1.05rem;">硬件<sup>5</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>3</sup></a><a href="/tags/%E8%B0%83%E8%AF%95/" style="font-size: 1.05rem;">调试<sup>5</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/11/"><span class="card-archive-list-date">十一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/08/"><span class="card-archive-list-date">八月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">35</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/06/"><span class="card-archive-list-date">六月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/05/"><span class="card-archive-list-date">五月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/01/"><span class="card-archive-list-date">一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/02/"><span class="card-archive-list-date">二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6/" itemprop="url">嵌入式软件</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/STM32/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>STM32</span></a></span></div></div><h1 class="post-title" itemprop="name headline">STM32(HAL库)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-04-02T15:03:08.000Z" title="发表于 2023-04-02 23:03:08">2023-04-02</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-08-30T08:48:37.552Z" title="更新于 2025-08-30 16:48:37">2025-08-30</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">36.3k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>128分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="STM32(HAL库)"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为成都"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>成都</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="/assets/43.webp"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://www.thekqd.top/2023/04/02/STM32HAL%E5%BA%93/"><header><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6/" itemprop="url">嵌入式软件</a><a href="/tags/STM32/" tabindex="-1" itemprop="url">STM32</a><h1 id="CrawlerTitle" itemprop="name headline">STM32(HAL库)</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">THEDI</span><time itemprop="dateCreated datePublished" datetime="2023-04-02T15:03:08.000Z" title="发表于 2023-04-02 23:03:08">2023-04-02</time><time itemprop="dateCreated datePublished" datetime="2025-08-30T08:48:37.552Z" title="更新于 2025-08-30 16:48:37">2025-08-30</time></header><h1 id="实验和一些好用的工具"><a href="#实验和一些好用的工具" class="headerlink" title="实验和一些好用的工具"></a>实验和一些好用的工具</h1><p><a target="_blank" rel="noopener" href="https://docs.keysking.com/docs/stm32/intro">欢迎来到 波特律动 | 波特律动 (keysking.com)</a></p>
<p><strong>串口调试助手、蓝牙调试助手</strong>：</p>
<p><a target="_blank" rel="noopener" href="https://serial.keysking.com/">波特律动 串口助手 (keysking.com)</a></p>
<p><strong>OLED驱动库、图片字体取模</strong>：<a target="_blank" rel="noopener" href="https://led.baud-dance.com/">波特律动LED字模生成器 (baud-dance.com)</a></p>
<h1 id="讲解视频"><a href="#讲解视频" class="headerlink" title="讲解视频"></a>讲解视频</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1do4y1F7wt/?spm_id_from=333.788&vd_source=830e63bd86bd9268c1b7cd9ff383f386">【工作STM32】第10集 STM32串口DMA模式与收发不定长数据 | keysking的stm32教程_哔哩哔哩_bilibili</a></p>
<h1 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h1><h2 id="GPIO介绍"><a href="#GPIO介绍" class="headerlink" title="GPIO介绍"></a>GPIO介绍</h2><p>GPIO是<strong>通用输入输出端口</strong>（General-purpose input&#x2F;output）的英文简写，是所有的微控制器必不可少的外设之一，可以由STM32直接驱动从而实现与外部设备通信、控制以及采集和捕获的功能。STM32单片机的GPIO被分为很多组，每组有16个引脚，不同型号的MCU的GPIO个数是不同的，比如STM32F103C8T6只有PA、PB以及个别PC引脚而STM32F103ZET6拥有PA~PG的全部112个引脚。<strong>所有的GPIO都有基本的输入输出功能，同时GPIO还可以作为其它的外设功能引脚</strong>。</p>
<p>作为STM32最基本的外设，GPIO最基本的输出功能是由STM32控制 引脚输出高低电平，比如可以把GPIO接LED灯来控制其亮灭，也可以接继电器或者三极管，通过继电器或三极管来控制外部大功率电路的通断。</p>
<h2 id="GPIO工作模式"><a href="#GPIO工作模式" class="headerlink" title="GPIO工作模式"></a>GPIO工作模式</h2><ul>
<li>输入模式：<ul>
<li>浮空输入</li>
<li>上拉输入(内部上拉和外部上拉)</li>
<li>下拉输入</li>
<li>模拟输入</li>
</ul>
</li>
<li>输出模式：<ul>
<li>推挽输出(PP)：高低电平均有驱动能力(一般使用)</li>
<li>开漏输出(OD,open drain)：高电平相当于高阻态，没有驱动能力，低电平有驱动能力(特殊使用)</li>
<li>开漏复用输出</li>
<li>推挽复用输出</li>
</ul>
</li>
</ul>
<p><strong>VCC：C&#x3D;circuit，表示电路的意思，即接入电路的电压。</strong></p>
<p><strong>VDD：D&#x3D;device，表示器件的意思，即器件内部的工作电压。</strong></p>
<p><strong>VSS：S&#x3D;series，表示公共连接的意思，通常指电路公共接地端电压。</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_63094577/article/details/124489756?ops_request_misc=%7B%22request_id%22:%22171126819716800211573854%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171126819716800211573854&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-124489756-null-null.142%5Ev99%5Epc_search_result_base1&utm_term=stm32GPIO&spm=1018.2226.3001.4187">STM32基础入门——GPIO详解_stm32gpio采集0、1信号-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44016222/article/details/123206403?ops_request_misc=&request_id=&biz_id=102&utm_term=stm32GPIO&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-123206403.nonecase&spm=1018.2226.3001.4187">STM32-GPIO介绍_stm32 gpio-CSDN博客</a></p>
<h2 id="点灯"><a href="#点灯" class="headerlink" title="点灯"></a>点灯</h2><h1 id="STM32启动流程"><a href="#STM32启动流程" class="headerlink" title="STM32启动流程"></a>STM32启动流程</h1><h2 id="启动文件"><a href="#启动文件" class="headerlink" title="启动文件"></a>启动文件</h2><p>startup_stm32xxx.s(汇编文件)文件具体工作</p>
<h1 id="RCC"><a href="#RCC" class="headerlink" title="RCC"></a>RCC</h1><h2 id="RCC介绍"><a href="#RCC介绍" class="headerlink" title="RCC介绍"></a>RCC介绍</h2><p>stm32上的**RCC(Reset and Clock Control)**外设，是<code>复位和时钟控制</code>的英文缩写。简单理解为<code>心跳</code>，负责配置和管理整个芯片的时钟系统，包括：</p>
<ul>
<li>主时钟源选择（HSE、HSI、PLL等）</li>
<li>各级时钟分频（系统时钟HCLK、外设时钟PCLK1&#x2F;PCLK2等）</li>
<li>各外设（包括GPIO、USART、SPI、TIM等）时钟使能&#x2F;关闭</li>
<li>系统复位管理</li>
</ul>
<p>RCC的主要用途：</p>
<ul>
<li>配置<strong>系统主频</strong>和各外设时钟</li>
<li>影响定时器、SysTick、总线速度、以及延时函数的精度</li>
<li>程序启动时必须先配置好，否则外设&#x2F;定时器都不能正常工作</li>
</ul>
<h2 id="复位"><a href="#复位" class="headerlink" title="复位"></a>复位</h2><p> 可见<strong>参考手册</strong></p>
<ul>
<li>系统复位</li>
<li>电源复位</li>
<li>后备域复位</li>
</ul>
<p>原理图上有复位电路</p>
<h2 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/as480133937/article/details/98845509?ops_request_misc=%7B%22request_id%22:%22171266890916800182712783%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=171266890916800182712783&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-16-98845509-null-null.142%5Ev100%5Epc_search_result_base5&utm_term=rcc&spm=1018.2226.3001.4187">【STM32】系统时钟RCC详解(超详细，超全面)_rcc时钟-CSDN博客</a></p>
<h3 id="时钟源"><a href="#时钟源" class="headerlink" title="时钟源"></a>时钟源</h3><p>STM32中能够主动发出时钟信号的元器件，可以用作<strong>时钟源</strong>。STM32中有四个时钟源，还有一个辅助时钟源生成倍频时钟信号的器件锁相环。</p>
<ul>
<li><strong>HSI(高速内部时钟)</strong></li>
</ul>
<p>时钟信号由内部RC震荡电路提供，时钟频率为<strong>8MHz</strong>，但是这个时钟频率会随着温度产生漂移，<strong>很不稳定</strong>，所以一般不使用此时钟信号</p>
<ul>
<li><strong>HSE(高速外部时钟)</strong></li>
</ul>
<p>时钟信号由外部晶振提供，时钟频率一般在<strong>4-16MHz</strong>，是经常会用到的时钟源</p>
<blockquote>
<p>这里的外部晶振可以是有源晶振，也可以是无源晶振，它们的区别在于与<strong>STM32的 连接方式，以及需不需要谐振电容</strong></p>
</blockquote>
<ul>
<li><strong>LSI(低速内部时钟)</strong></li>
</ul>
<p>时钟信号由内部RC振荡电路提供，时钟频率一般为40KHz，这个信号<strong>一般用于独立看门狗时钟</strong></p>
<ul>
<li><strong>LSE(低速外部时钟)</strong></li>
</ul>
<p>时钟信号由外部晶振提供，时钟频率一般为32.768KHz，这个信号一般用于<strong>RTC实时时钟</strong></p>
<ul>
<li><strong>PLLCLK(锁相环倍频时钟)</strong></li>
</ul>
<p>PLL锁相环是辅助产生时钟信号的器件。PLL并不是自己产生的时钟源，而是通过倍频得到的时钟。将时钟信号输入锁相环，锁相环可以将这个时钟信号的频率按照<strong>指定倍率提高</strong>（倍频）之后，再输出。</p>
<blockquote>
<p>与锁相环具有相反作用的是分频器，分频器可以将输入时钟信号分率按照指定倍率降低之后，再输出。简单理解<strong>分频就是做除法</strong></p>
</blockquote>
<h3 id="系统时钟SYSCLK"><a href="#系统时钟SYSCLK" class="headerlink" title="系统时钟SYSCLK"></a>系统时钟SYSCLK</h3><p>系统时钟SYSCLK可<strong>来源于三个时钟源</strong>：</p>
<ul>
<li><strong>HSI振荡器时钟</strong></li>
<li><strong>HSE振荡器时钟</strong></li>
<li><strong>PLLCLK时钟</strong></li>
</ul>
<h2 id="配置时钟树"><a href="#配置时钟树" class="headerlink" title="配置时钟树"></a>配置时钟树</h2><p>STM32CubeMX一般填入指定最大即可</p>
<p>但对STM32上的时钟，具体怎么配置，根据需求决定。时钟频率选取越高，功耗也会越高。</p>
<p>所以实际情况中考虑芯片的工作条件，根据芯片运行的工作条件选取时钟频率</p>
<p>相关AHB、APB1、APB2总线上的时钟工作条件可以在STM32数据手册的通用工作条件模块可以查看到满足的条件</p>
<h1 id="SysTick"><a href="#SysTick" class="headerlink" title="SysTick"></a>SysTick</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>SysTick<code>系统定时器</code>(又叫系统滴答定时器)是属于 Cortex-M3 <strong>内核中的一个外设，内嵌在 NVIC中</strong>。系统定时器是一个计数宽度24bit的向下递减的计数器，计数器每计数一次的时间为 1&#x2F;SYSCLK，一般我们设置系统时钟 SYSCLK等于72M。<strong>当重装载数值寄存器的值递减到 0 的时候，系统定时器就产生一次中断，以此循环往复</strong>。</p>
<p>因为 SysTick 是属于 CM3 内核的外设，所以所有基于 Cortex-M 内核的单片机都具有这个系统定时器，使得软件在 CM3 单片机中可以很容易的移植。</p>
<ul>
<li>计数宽度：24bit来储存数据，2^24&#x3D;16,777,216</li>
<li>向下递减：计数器的工作模式</li>
<li>计数器的工作周期：1&#x2F;CLKSource，1&#x2F;72Mhz(每-1的时间为1&#x2F;72000000)</li>
</ul>
<p><strong>常用功能</strong>：</p>
<ul>
<li><p>系统定时器一般用于操作系统，用于产生时基，维持操作系统的心跳</p>
</li>
<li><p>最常用的功能是计数。比如用来进行微秒、毫秒的延时，以此产生特定时序(我们需要实现us级延时就是使用SysTick)</p>
</li>
</ul>
<h2 id="寄存器介绍"><a href="#寄存器介绍" class="headerlink" title="寄存器介绍"></a>寄存器介绍</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/PORKWOTONLEE/article/details/121154152?ops_request_misc=%7B%22request_id%22:%22171309432516800184129019%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=171309432516800184129019&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-121154152-null-null.142%5Ev100%5Epc_search_result_base2&utm_term=Systick%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AF%84%E5%AD%98%E5%99%A8%E4%BB%8B%E7%BB%8D&spm=1018.2226.3001.4187">第7课【SysTick定时器】中断 系统定时器 寄存器-CSDN博客</a></p>
<p><strong>HAL库中HAL_Delay是基于SysTick来实现，使用时基源SysTick</strong></p>
<h2 id="uwTick"><a href="#uwTick" class="headerlink" title="uwTick"></a>uwTick</h2><p><code>uwTick</code> 是 STM32 中用于存储系统运行时间的变量，它在 <code>HAL</code> 库中与滴答定时器（SysTick）一起使用，通常用于实现毫秒级的计时。<code>uwTick</code> 是一个全局变量，保存了从系统启动开始经过的毫秒数，通常用于延时、超时管理或作为定时器的时间基准。</p>
<h3 id="uwTick的工作原理"><a href="#uwTick的工作原理" class="headerlink" title="uwTick的工作原理"></a>uwTick的工作原理</h3><ul>
<li><code>uwTick</code> 由系统的滴答定时器（SysTick Timer）自动递增。每当 SysTick 定时器触发中断时，<code>uwTick</code> 的值增加 1，表示已经过去了 1 毫秒。</li>
<li><code>HAL_InitTick()</code> 函数会初始化 <code>uwTick</code>，并确保 SysTick 定时器按照指定的时钟频率（通常是 1ms）定期递增。</li>
</ul>
<h3 id="uwTick的使用场景"><a href="#uwTick的使用场景" class="headerlink" title="uwTick的使用场景"></a>uwTick的使用场景</h3><ul>
<li><strong>延时函数</strong>：<code>uwTick</code> 可用于在没有 RTOS 的情况下实现毫秒级的延时函数。</li>
<li><strong>定时任务</strong>：可以使用 <code>uwTick</code> 来实现周期性定时任务。</li>
<li><strong>超时管理</strong>：可以通过 <code>uwTick</code> 计算超时，进行时间监控。</li>
</ul>
<h3 id="如何配置和使用-uwTick"><a href="#如何配置和使用-uwTick" class="headerlink" title="如何配置和使用 uwTick"></a>如何配置和使用 uwTick</h3><p>在 STM32 系列中，<code>uwTick</code> 是由 <code>HAL</code> 库自动管理的，因此你不需要手动操作它，只需配置好 SysTick 定时器，并让它触发 <code>uwTick</code> 的更新。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>在调用 <code>HAL_Init()</code> 时，<code>HAL_InitTick()</code> 会被自动调用，确保滴答定时器已启用并正确地递增 <code>uwTick</code>。</p>
<h4 id="读取-uwTick"><a href="#读取-uwTick" class="headerlink" title="读取 uwTick"></a>读取 uwTick</h4><p>你可以直接读取 <code>uwTick</code> 来获取从系统启动以来的毫秒数。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f4xx_hal.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">uint32_t</span> ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> startTick = uwTick;</span><br><span class="line">    <span class="keyword">while</span> ((uwTick - startTick) &lt; ms)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 等待指定的毫秒数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数可以实现一个简单的延时功能，利用 <code>uwTick</code> 的递增特性来实现时间等待。</p>
<h4 id="获取系统启动后的时间"><a href="#获取系统启动后的时间" class="headerlink" title="获取系统启动后的时间"></a>获取系统启动后的时间</h4><p><code>uwTick</code> 保存了系统从启动以来经过的毫秒数。如果你需要获取系统的运行时间，可以直接读取 <code>uwTick</code>。</p>
<p>例如，获取系统启动后的运行时间：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">getSystemUptime</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> uwTick;  <span class="comment">// 返回从启动以来的毫秒数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="处理溢出问题"><a href="#处理溢出问题" class="headerlink" title="处理溢出问题"></a>处理溢出问题</h4><p><code>uwTick</code> 是一个 32 位无符号整数，因此当它达到最大值（0xFFFFFFFF）时会溢出回 0。一般情况下，你不需要担心溢出问题，因为 <code>uwTick</code> 的更新是连续的，你可以通过以下方式避免溢出导致的问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">getTickDiff</span><span class="params">(<span class="type">uint32_t</span> startTick)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (uwTick - startTick);  <span class="comment">// 自动处理溢出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方式，你可以计算当前 <code>uwTick</code> 和之前记录的时间差，无论它是否经历了溢出。</p>
<h3 id="HAL-Delay"><a href="#HAL-Delay" class="headerlink" title="HAL_Delay"></a>HAL_Delay</h3><p>HAL_Delay()函数就是使用系统滴答定时器Systick实现的。</p>
<h3 id="自定义延时函数"><a href="#自定义延时函数" class="headerlink" title="自定义延时函数"></a>自定义延时函数</h3><p>除了使用 <code>HAL_Delay()</code>，你也可以编写自定义延时函数。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delay_ms_custom</span><span class="params">(<span class="type">uint32_t</span> ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> start_tick = uwTick;</span><br><span class="line">    <span class="keyword">while</span> ((uwTick - start_tick) &lt; ms) &#123;</span><br><span class="line">        <span class="comment">// 可以放置其他任务或者空闲等待</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>定时精度</strong>：<code>uwTick</code> 的精度依赖于系统时钟频率，如果系统时钟较低，延时精度可能不如高精度时钟。</li>
<li><strong>溢出</strong>：<code>uwTick</code> 是一个 32 位计数器，每 49.7 天会溢出一次。大部分应用场景中不需要特别处理溢出问题，除非你需要精确计时更长时间段。</li>
<li><strong>RTOS 与 <code>uwTick</code></strong>：如果使用 RTOS（如 FreeRTOS），<code>uwTick</code> 可以作为 RTOS 内部定时器的基础，进行任务调度和延时处理。</li>
</ul>
<h2 id="uwTick与硬件定时器外设区别"><a href="#uwTick与硬件定时器外设区别" class="headerlink" title="uwTick与硬件定时器外设区别"></a>uwTick与硬件定时器外设区别</h2><h3 id="uwTick-1"><a href="#uwTick-1" class="headerlink" title="uwTick"></a>uwTick</h3><ul>
<li><strong>来源</strong>：<code>uwTick</code> 是由 <strong>SysTick 定时器</strong>（系统定时器）更新的全局变量，通常用于提供一个基于毫秒的系统时基。它是由 STM32 的 <strong>Cortex-M 内核</strong>提供，通常用于时间管理和简单的延时。</li>
<li><strong>精度</strong>：<code>uwTick</code> 的精度取决于系统时钟频率（通常是 1 毫秒）。对于很多应用场景，这种精度足够了。</li>
<li><strong>功能</strong>：<code>uwTick</code> 只是一个软件计数器，它每 1 毫秒递增，并通过 SysTick 中断（如果启用）更新。它通常用于：<ul>
<li>延时操作（比如定时任务、超时控制）。</li>
<li>简单的时间基准（比如计算系统运行时间）。</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li>简单易用，尤其是没有 RTOS 时，它可以作为一个基本的定时机制。</li>
<li>使用非常灵活，可以通过 <code>uwTick</code> 实现延时、超时、周期性任务等功能。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>只能提供低精度的时间基准（通常为 1 毫秒）。</li>
<li>不能直接处理复杂的定时器任务，如生成特定频率的 PWM 信号，或者需要高精度计时的应用。</li>
</ul>
</li>
</ul>
<h3 id="硬件定时器外设"><a href="#硬件定时器外设" class="headerlink" title="硬件定时器外设"></a>硬件定时器外设</h3><ul>
<li><strong>来源</strong>：硬件定时器是 STM32 提供的专用硬件模块，它们可以用来精确地生成定时中断、PWM 输出、计数器等。STM32 通常具有多个定时器外设（如 TIM1、TIM2 等）。</li>
<li><strong>精度</strong>：硬件定时器的精度非常高，通常由定时器的计数时钟频率（通常是系统时钟或 APB 时钟的一部分）决定，可以达到微秒级别的精度。硬件定时器可以配置为不同的分频因子，以适应不同的应用需求。</li>
<li><strong>功能</strong>：硬件定时器可以用于：<ul>
<li>生成高精度的定时中断。</li>
<li>生成 PWM 波形输出。</li>
<li>实现高精度延时、时间测量和计数。</li>
<li>用于编码器、频率测量、信号发生等。</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li>提供高精度定时。</li>
<li>不需要依赖系统时钟或软件轮询，硬件定时器直接生成中断，效率较高。</li>
<li>可以配置为多种不同模式，如 PWM、脉冲计数、输入捕获等。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>配置较复杂，尤其是在需要多种不同定时器功能时，配置工作量较大。</li>
<li>受限于硬件资源，每个 STM32 芯片上有固定数量的定时器。</li>
</ul>
</li>
</ul>
<h3 id="使用场景分析"><a href="#使用场景分析" class="headerlink" title="使用场景分析"></a>使用场景分析</h3><h4 id="使用-uwTick-的场景"><a href="#使用-uwTick-的场景" class="headerlink" title="使用 uwTick 的场景"></a>使用 uwTick 的场景</h4><p><code>uwTick</code> 主要适用于以下场景：</p>
<ul>
<li><p><strong>简单的定时器应用</strong>：如延时、超时控制、周期性任务等。如果你的系统不需要极高的定时精度，并且不需要复杂的定时任务管理，<code>uwTick</code> 是一个非常便捷的选择。</p>
<p>例如：</p>
<ul>
<li><strong>延时功能</strong>：你可以用 <code>uwTick</code> 实现简单的延时操作（如延时 1 秒、5 秒等）。</li>
<li><strong>超时检测</strong>：在没有 RTOS 的情况下，可以用 <code>uwTick</code> 检测外部事件是否超时（如等待串口数据、等待传感器响应等）。</li>
<li><strong>周期性任务</strong>：比如每 100 毫秒执行一次某些任务，使用 <code>uwTick</code> 来检测时间是否满足周期要求。</li>
</ul>
</li>
<li><p><strong>低精度任务</strong>：当任务不依赖于极高的定时精度时，<code>uwTick</code> 足够满足需求。比如一些简单的 LED 闪烁、定时任务等。</p>
</li>
</ul>
<h4 id="使用硬件定时器外设的场景"><a href="#使用硬件定时器外设的场景" class="headerlink" title="使用硬件定时器外设的场景"></a>使用硬件定时器外设的场景</h4><p>硬件定时器外设适用于以下场景：</p>
<ul>
<li><p><strong>高精度定时任务</strong>：如精确的时间测量、频率产生等。硬件定时器可以提供比 <code>uwTick</code> 更高精度的定时，通常是微秒级别。</p>
<p>例如：</p>
<ul>
<li><strong>PWM 生成</strong>：当你需要控制电机、灯光等硬件时，通常需要高精度的 PWM 信号，这时就需要硬件定时器。</li>
<li><strong>频率计数</strong>：通过硬件定时器的输入捕获功能，可以精确地测量信号的频率。</li>
<li><strong>精确延时</strong>：对于一些要求非常精确延时的场景，如通信协议中的时序控制，硬件定时器可以提供更高的精度。</li>
</ul>
</li>
<li><p><strong>复杂的定时功能</strong>：如果你需要多个定时器同步运行，或者需要定时器在某个特定事件（如输入信号）时产生中断，硬件定时器会是一个更合适的选择。</p>
</li>
<li><p><strong>RTOS 应用</strong>：在 RTOS 环境中，硬件定时器通常用于管理任务的时间片，或者作为周期性任务的时基。</p>
</li>
<li><p><strong>硬件事件捕捉</strong>：硬件定时器支持的输入捕获模式使得它可以捕捉外部信号的事件，如测量脉冲宽度、时间间隔等。</p>
</li>
</ul>
<h3 id="总结对比表"><a href="#总结对比表" class="headerlink" title="总结对比表"></a>总结对比表</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250117235719124-1752338032549-1.png" alt="image-20250117235719124"></p>
<h1 id="RCC与SysTick"><a href="#RCC与SysTick" class="headerlink" title="RCC与SysTick"></a>RCC与SysTick</h1><p>RCC：主要负责配置我们的时钟源和系统主频，以及各总线(AHB、APB)的时钟频率等</p>
<p>SysTick：就是一个外设，类似于TIM，但是是内核外设</p>
<p>在时钟树中我们可以看到SysTick的时钟来源是SYSCLK(系统时钟主频)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250710215446352.png" alt="image-20250710215446352"></p>
<h1 id="Timebase-Souce"><a href="#Timebase-Souce" class="headerlink" title="Timebase Souce"></a>Timebase Souce</h1><h2 id="时基介绍"><a href="#时基介绍" class="headerlink" title="时基介绍"></a>时基介绍</h2><p><code>Timebase Souce(时基源)</code>：是HAL库下系统时基源的设置，决定哪个硬件定时器为HAL库&#x2F;RTOS提供系统<code>节拍(Tick)</code></p>
<p><code>时基主要的作用</code>：</p>
<ul>
<li>用于HAL库的时间相关功能（如HAL_Delay、HAL_GetTick）</li>
<li>用于RTOS（如FreeRTOS）的任务调度节拍</li>
<li>决定系统中“1ms”到底是谁来精确定义</li>
</ul>
<h2 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h2><p>Timebase Source(时基源)的配置可以在SysTick和TIM中选择：</p>
<ul>
<li><strong>SysTick</strong>（默认）：使用Cortex-M内核自带的SysTick定时器</li>
<li><strong>TIMx</strong>：用某个通用定时器（如TIM1、TIM6等）作为tick源</li>
</ul>
<p>逻辑开发时：HAL库通常在HAL_Init()中配置时基源为SysTick</p>
<p>当<code>时基源</code>设置为<code>TIMx</code>后，SysTick空闲，就可自定义用途，TIMx中断负责系统tick</p>
<h1 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h1><p><strong>中断概念</strong>：中断是指计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续执行。</p>
<p><strong>STM32中断触发后流程</strong>：</p>
<p>触发中断-&gt;中断向量表(存放中断服务函数地址)-&gt;偏移：入口地址</p>
<p>中断可以分为<strong>内部中断</strong>和<strong>外部中断</strong>：</p>
<p><strong>外部中断</strong>：STM32说的中断一般指这个外部中断，发生在<strong>处理器外部</strong>连接的设备或外部信号，例如按键按下、外部传感器信号变化等。外部中断用于响应外部事件，并及时处理相关任务。</p>
<p><strong>异常(内部中断)</strong>：异常和中断概念相近，异常可以说是<strong>内核活动(处理器内部)产生</strong>，比如执行<strong>未定义指令、除零运算</strong>等发生在CPU内部的意外事件。这些异常的发生，会引起CPU运行相应的异常处理程序，因为发生在处理器内部，故叫做<strong>内部中断</strong>。</p>
<p><strong>注</strong>：中断一般指连接到内核的**外部器件(外设)**产生，。使用一般不严格区分中断和异常，但无论是异常还是中断，都会引起程序执行偏离正常的流程，转而去执行异常&#x2F;中断的处理函数。</p>
<h2 id="中断优先级"><a href="#中断优先级" class="headerlink" title="中断优先级"></a>中断优先级</h2><p><strong>中断优先级分为两种</strong>：</p>
<ol>
<li><p><strong>可编程</strong></p>
</li>
<li><p><strong>不可编程</strong></p>
</li>
</ol>
<p>STM32的中断优先级，决定着内核优先响应谁的中断请求:</p>
<ul>
<li><strong>中断优先级数值越小，优先级越大</strong>，中断会被优先响应</li>
<li>中断优先级按照<strong>优先级分组</strong>配置</li>
</ul>
<blockquote>
<p>在STM32的芯片参考手册中可以找到中断向量表，里面可找到优先级数值等信息</p>
</blockquote>
<h2 id="优先级分组"><a href="#优先级分组" class="headerlink" title="优先级分组"></a>优先级分组</h2><p>在优先级分组中存在<strong>抢占优先级</strong>和<strong>子优先级</strong></p>
<p>分组个数和各优先级数值图片：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41066277/article/details/88728661?ops_request_misc=%7B%22request_id%22:%22171275025416800215044240%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171275025416800215044240&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-88728661-null-null.142%5Ev100%5Epc_search_result_base5&utm_term=%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7%E5%88%86%E7%BB%84&spm=1018.2226.3001.4187">stm32入门篇–中断的初步认识及其优先级和分组_中断优先级和分组-CSDN博客</a></p>
<ol>
<li><p>通过优先级分组，我们可以管理中断的响应顺序</p>
</li>
<li><p>只有抢占优先级才具有抢占中断的权限，打断了就发生了<strong>中断嵌套</strong></p>
</li>
</ol>
<blockquote>
<p><strong>中断嵌套</strong>：中断嵌套是指中断系统正在执行一个中断服务时，有另一个抢占优先级更高的中断提出，这时会暂时终止当前正在执行的级别较低的的，去处理级别更高的中断源，待处理完毕，再返回到被中断了的的过程。</p>
<p>例如：B中断正在执行，突然发生了A中断，<strong>但是A中断的抢占优先级数值更小比B的更小(数值更小，	A抢占优先级更高)</strong>，A中断则抢过B中断的使用权，响应A的中断服务函数，A中断执行完毕后再交回B继续执行。</p>
</blockquote>
<ol start="3">
<li><p>如果中断抢占优先级相同，将不会发生抢占行为(只能乖乖的排队等待),这就叫做<strong>中断挂起</strong></p>
</li>
<li><p>如果多个在挂起状态的中断具有<strong>相同的抢占优先级</strong>，则<strong>子优先级高的先响应</strong>，如果<strong>子优先级也相同</strong>，则由<strong>IRQ编号(中断编号)小的响应</strong></p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*一些中断编号的定义，一般在芯片头文件中找到，下列为stm32f103xe.h*/</span> </span><br><span class="line">NonMaskableInt_IRQn         = <span class="number">-14</span>,    </span><br><span class="line"> HardFault_IRQn              = <span class="number">-13</span>,   </span><br><span class="line"> MemoryManagement_IRQn       = <span class="number">-12</span>,    </span><br><span class="line"> BusFault_IRQn               = <span class="number">-11</span>,    </span><br><span class="line"> UsageFault_IRQn             = <span class="number">-10</span>,   </span><br><span class="line"> SVCall_IRQn                 = <span class="number">-5</span>,    </span><br><span class="line"> DebugMonitor_IRQn           = <span class="number">-4</span>,    </span><br><span class="line"> PendSV_IRQn                 = <span class="number">-2</span>,     </span><br><span class="line"> SysTick_IRQn                = <span class="number">-1</span>, </span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>：抢占优先级&gt;子优先级&gt;IRQ编号。</p>
<ol start="5">
<li><strong>可编程的优先级</strong>，可以通过**嵌套向量中断控制器(NVIC)**实现</li>
</ol>
<h2 id="NVIC"><a href="#NVIC" class="headerlink" title="NVIC"></a>NVIC</h2><p>NVIC（Nested Vectored Interrupt Controller）-<strong>嵌套向量中断控制器</strong>，是STM32系列微控制器中的中断控制器模块，其主要功能如下：</p>
<ol>
<li>中断优先级管理</li>
<li>中断使能和禁止</li>
<li>中断嵌套</li>
<li>中断状态控制</li>
<li>中断向量表管理</li>
</ol>
<p><strong>通常在STM32CubeMX中开启各EXTI线的中断</strong></p>
<p>有关EXTI和NVIC的介绍：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_56694518/article/details/131260526?ops_request_misc=%7B%22request_id%22:%22171275275416800186516157%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171275275416800186516157&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-131260526-null-null.142%5Ev100%5Epc_search_result_base5&utm_term=stm32%E5%86%85%E9%83%A8%E4%B8%AD%E6%96%AD&spm=1018.2226.3001.4187">STM32的中断系统详解（嵌入式学习）_stm32中断嵌套-CSDN博客</a></p>
<h2 id="EXTI"><a href="#EXTI" class="headerlink" title="EXTI"></a>EXTI</h2><p>EXTI(External interrupt&#x2F;event controller)，是STM32的<strong>外部中断&#x2F;事件控制器</strong>，是STM32的外设，用于处理外部引脚的中断请求。EXTI模块与NVIC紧密合作，使得处理器能够响应外部事件并执行相应的中断处理程序。</p>
<p>通过EXTI线，捕获EXTI线事件，并且去生成中断，在中断回调函数中，翻转LED状态，并且<strong>清除EXTI中断标志</strong>(中断标志要清除不然就会一直产生中断)。</p>
<blockquote>
<p>使用外部中断模块特性：</p>
<p>对于STM32来说，想要获取的信号是外部的很快的突发信号。由外部驱动，STM32只能被动读取。</p>
</blockquote>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="外部按键中断控制LED亮灭"><a href="#外部按键中断控制LED亮灭" class="headerlink" title="外部按键中断控制LED亮灭"></a>外部按键中断控制LED亮灭</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gpio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span>	</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">						</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">if</span> (GPIO_Pin == KEY0_Pin) </span><br><span class="line">	&#123;</span><br><span class="line">		HAL_GPIO_TogglePin(LED2_GPIO_Port,LED2_Pin);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试时发现灯的行为有一些奇怪，比如闪烁，不完全亮等情况会发生，所以需要按键消抖。</p>
<h3 id="按键消抖"><a href="#按键消抖" class="headerlink" title="按键消抖:"></a>按键消抖:</h3><p>当用户按下一个物理按键时，由于<strong>按键使用的是机械式弹簧片的结构</strong>，通常会导致按键在接通和断开状态之间快速切换，造成一系列的开关状态变化。<strong>这种短暂的状态变化称为按键抖动</strong>。按键抖动可能会导致系统误以为用户进行了多次按键操作，从而引发意外行为或错误。</p>
<p>抖动时间的长短由按键的机械特性决定，<strong>一般为5ms～10ms</strong>。这是一个很重要的时间参数，在很多场合都要用到。按键稳定闭合时间的长短则是由操作人员的按键动作决定的，一般为零点几秒至数秒。为确保CPU对键的一次闭合仅作一次处理，必须去除键抖动。在键闭合稳定时读取键的状态，并且必须判别到键释放稳定后再作处理。</p>
<p><strong>按键消抖分为硬件消抖和软件消抖</strong>:</p>
<ul>
<li><p>硬件消抖：一般是添加RC滤波电容</p>
</li>
<li><p>软件消抖：延时函数按键消抖或者定时器按键消抖或状态机消抖，<strong>消抖时间设置为20ms-100ms即可</strong></p>
</li>
</ul>
<blockquote>
<p><strong>首先一定要在CubeMX中的按键引脚设置为上拉(pull up)状态，不要设置为浮空输入(no pull up and no pull down)。</strong></p>
<p><strong>做了按键消抖却失效的原因</strong>：</p>
<p>按键消抖的有效性通常取决于按键引脚的电气特性，尤其是在没有上拉或下拉电阻的情况下。<strong>没有上拉电阻时，处于浮空输入状态，按键引脚可能会更容易受到电气噪声和抖动等外部环境的影响，从而使消抖无法正常工作。</strong></p>
</blockquote>
<h4 id="轮询按键控制LED亮灭-延时消抖"><a href="#轮询按键控制LED亮灭-延时消抖" class="headerlink" title="轮询按键控制LED亮灭(延时消抖)"></a>轮询按键控制LED亮灭(延时消抖)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;gpio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(HAL_GPIO_ReadPin(KEY1_GPIO_Port, KEY1_Pin) == GPIO_PIN_RESET)<span class="comment">//按下检测!</span></span><br><span class="line">    &#123;</span><br><span class="line">        HAL_Delay(<span class="number">20</span>);<span class="comment">//延时消抖</span></span><br><span class="line">        <span class="keyword">if</span>(HAL_GPIO_ReadPin(KEY1_GPIO_Port, KEY1_Pin) == GPIO_PIN_RESET)<span class="comment">//再次确认是否按下</span></span><br><span class="line">        &#123;</span><br><span class="line">            HAL_GPIO_TogglePin(LED_BLUE_GPIO_Port,LED_BLUE_Pin);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(HAL_GPIO_ReadPin(KEY1_GPIO_Port, KEY1_Pin) == GPIO_PIN_RESET)&#123;&#125;;<span class="comment">//松手检测!</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>()<span class="comment">//其他颜色的灯同理...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>优点：代码简单</strong></p>
<p><strong>缺点：delay会使cpu空等浪费时间</strong></p>
</blockquote>
<h4 id="外部中断-定时器消抖-推荐"><a href="#外部中断-定时器消抖-推荐" class="headerlink" title="外部中断+定时器消抖(推荐)"></a>外部中断+定时器消抖(推荐)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*消抖时间设置为20ms-100ms即可,一般设置为20ms,Pre=7199,arr=199~500*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_GPIO_WritePin(LED_BLUE_GPIO_Port, LED_BLUE_Pin, GPIO_PIN_SET);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(GPIO_Pin == KEY1_Pin)</span><br><span class="line">  &#123;</span><br><span class="line">       HAL_TIM_Base_Start_IT(&amp;htim2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(htim == &amp;htim2)</span><br><span class="line">    &#123;</span><br><span class="line">        HAL_TIM_Base_Stop_IT(&amp;htim2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(HAL_GPIO_ReadPin(KEY1_GPIO_Port,KEY1_Pin) == GPIO_PIN_RESET)</span><br><span class="line">        &#123;</span><br><span class="line">            HAL_GPIO_TogglePin(LED_BLUE_GPIO_Port,LED_BLUE_Pin);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>优点</strong>：cpu并没有浪费时间</p>
<p><strong>缺点</strong>：会浪费一个定时器</p>
<p><strong>注意</strong>：在CubeMX配置时注意上升沿触发还是下降沿触发,可能效果会不同,一般都是<strong>设置下降沿触发</strong>，按下开关为低电平</p>
</blockquote>
<blockquote>
<p><strong>注意</strong>：</p>
<p><strong>别在中断回调函数中使用延时函数，可能会出现神奇的bug，严重会导致死机</strong></p>
</blockquote>
<h4 id="按键状态机-定时器消抖"><a href="#按键状态机-定时器消抖" class="headerlink" title="按键状态机+定时器消抖"></a>按键状态机+定时器消抖</h4><ol>
<li><strong>CubeMX配置</strong></li>
</ol>
<p><strong>选择内部时钟源，配置对应的定时器溢出时间为10ms(消抖时长)</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250405143801639.png" alt="image-20250405143801639"></p>
<ol start="2">
<li><strong>业务代码</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">uint8_t</span> judgeState; <span class="comment">//状态机判断状态</span></span><br><span class="line">  <span class="type">uint8_t</span> keyState; <span class="comment">//按键状态</span></span><br><span class="line">	<span class="type">uint8_t</span> shortPressFlag;<span class="comment">//短按标志</span></span><br><span class="line">	<span class="type">uint8_t</span> longPressFlag;<span class="comment">//长按标志</span></span><br><span class="line">	<span class="type">uint32_t</span> pressTime;<span class="comment">//按下持续时间</span></span><br><span class="line">&#125;Keys;</span><br><span class="line"></span><br><span class="line">Keys key[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	  HAL_TIM_Base_Start_IT(&amp;htim4);<span class="comment">//启动定时器中断	</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span>(htim == &amp;htim4)</span><br><span class="line">        &#123;</span><br><span class="line">           key[<span class="number">0</span>].keyState = HAL_GPIO_ReadPin(KEY1_GPIO_Port,KEY1_Pin);</span><br><span class="line">             key[<span class="number">1</span>].keyState = HAL_GPIO_ReadPin(KEY2_GPIO_Port,KEY2_Pin);</span><br><span class="line">             key[<span class="number">2</span>].keyState = HAL_GPIO_ReadPin(KEY3_GPIO_Port,KEY3_Pin);</span><br><span class="line">             key[<span class="number">3</span>].keyState = HAL_GPIO_ReadPin(KEY4_GPIO_Port,KEY4_Pin);</span><br><span class="line">            </span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="keyword">switch</span>(key[i].judgeState)</span><br><span class="line">                 &#123;</span><br><span class="line">                     <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//1.空闲态</span></span><br><span class="line">                              <span class="keyword">if</span>(key[i].keyState == <span class="number">0</span>)</span><br><span class="line">                                &#123;</span><br><span class="line">                                    key[i].judgeState = <span class="number">1</span>;</span><br><span class="line">                                &#125;                                    </span><br><span class="line">                              <span class="keyword">break</span>; <span class="comment">//别忘了break</span></span><br><span class="line">                                </span><br><span class="line">                     <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//消抖态(定时器10ms消抖)</span></span><br><span class="line">                                </span><br><span class="line">                                <span class="keyword">if</span>(key[i].keyState == <span class="number">0</span>) <span class="comment">//确认按下</span></span><br><span class="line">                                &#123;</span><br><span class="line">                                     key[i].judgeState = <span class="number">2</span>; <span class="comment">//进入释放</span></span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                &#123;</span><br><span class="line">                                     key[i].judgeState = <span class="number">0</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                                </span><br><span class="line">                     <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//释放态检测</span></span><br><span class="line">                                <span class="keyword">if</span>(key[i].keyState == <span class="number">1</span>)</span><br><span class="line">                                &#123;</span><br><span class="line">                                     <span class="keyword">if</span>(key[i].pressTime &lt; <span class="number">100</span>) <span class="comment">//100*10ms = 1s</span></span><br><span class="line">                                     &#123;</span><br><span class="line">                                         key[i].shortPressFlag = <span class="number">1</span>;</span><br><span class="line">                                     &#125;</span><br><span class="line">                                     <span class="keyword">else</span></span><br><span class="line">                                     &#123;</span><br><span class="line">                                         key[i].longPressFlag = <span class="number">1</span>;</span><br><span class="line">                                     &#125;</span><br><span class="line">                                     </span><br><span class="line">                                     key[i].judgeState = <span class="number">0</span>;</span><br><span class="line">                                     key[i].pressTime = <span class="number">0</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                &#123;</span><br><span class="line">                                      key[i].pressTime++; <span class="comment">//每增加1代表按下时间增加10ms</span></span><br><span class="line">                                &#125;</span><br><span class="line">                                </span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Task</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//key1</span></span><br><span class="line">	<span class="keyword">if</span>(key[<span class="number">0</span>].shortPressFlag)</span><br><span class="line">	&#123;</span><br><span class="line">		key[<span class="number">0</span>].shortPressFlag = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//key2</span></span><br><span class="line">	<span class="keyword">if</span>(key[<span class="number">1</span>].shortPressFlag)</span><br><span class="line">	&#123;</span><br><span class="line">		key[<span class="number">1</span>].shortPressFlag = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//key3</span></span><br><span class="line">	<span class="keyword">if</span>(key[<span class="number">2</span>].shortPressFlag)</span><br><span class="line">	&#123;</span><br><span class="line">		 key[<span class="number">2</span>].shortPressFlag = <span class="number">0</span>;			 </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//key4</span></span><br><span class="line">    <span class="keyword">if</span>(key[<span class="number">3</span>].shortPressFlag)</span><br><span class="line">	&#123;</span><br><span class="line">		 key[<span class="number">3</span>].shortPressFlag = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以将judgeState变为枚举变量，如下图所以，比上面增加一种按下的状态</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250424145843605.png" alt="image-20250424145843605"></p>
</blockquote>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250424145735918.png" alt="image-20250424145735918"></p>
<h1 id="中断相关的-volatile关键字"><a href="#中断相关的-volatile关键字" class="headerlink" title="中断相关的-volatile关键字"></a>中断相关的-volatile关键字</h1><p><code>volatile关键字作用：</code>避免编译器优化。编译器优化会可以去除无用的繁杂代码，降低代码空间，提升运行效率，但优化后编译器在某些地方可能会弄巧成拙。</p>
<p><code>例1：</code>空循环延时，编译器就会觉得没什么用浪费时间，会直接给你优化掉</p>
<p><code>例2：</code></p>
<p><strong>中断方式下，如果需要访问全局变量，最好把全局变量使用 volatile 来进行修饰，避免编译器对该 变量进行优化。</strong></p>
<p>具体参考  <a target="_blank" rel="noopener" href="https://blog.csdn.net/dengjin20104042056/article/details/107716564">https://blog.csdn.net/dengjin20104042056/article/details/107716564</a>  。</p>
<p>主函数和中断处理函数相当于两个线程，因为编译器的优化，在一个线程中改变一个全局变量的值，另外一个线程读取到的可能是没有改变前的值，因此需要用 volatile 来标识这个变量，让编译器不优化这个变量的存储（这个变量的值可能因为编译器的优化在寄存器中进行改变，而不是在真 正的内存区间）。这个问题书上在中断这部分也说明了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">uint8_t</span> A;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    A...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)</span><br><span class="line">&#123;</span><br><span class="line">    A....</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="通讯概念"><a href="#通讯概念" class="headerlink" title="通讯概念"></a>通讯概念</h1><h2 id="通讯方式"><a href="#通讯方式" class="headerlink" title="通讯方式"></a>通讯方式</h2><p>通讯方式分类：</p>
<ul>
<li><strong>串行通讯和并行通讯</strong></li>
</ul>
<p>按数据传送的方式，通讯可分为串行通讯与并行通讯，<strong>串行通讯是指设备之间通过少量数据信号线 (一般是 8 根以下)，地线以及控制信号线，按数据位形式一位一位地传输数据的通讯方式</strong>。<strong>并行通讯一般是指使用 8、16、32 及 64 根或更多的数据线进行传输的通讯方式，并行通讯就像多个车道的公路，可以同时传输多个数据位的数据</strong>。而串行通讯，而串行通讯就像单个车道的公路，同一时刻只能传输一个数据位的数据。</p>
<p><strong>一般情况下，串行通讯成本更低(节省数据线),且通讯距离、抗干扰能力较强，但传输速率较慢</strong></p>
<ul>
<li><p><strong>全双工通讯、半双工、单工通讯</strong></p>
<ul>
<li>全双工 ：在同一时刻，两个设备之间可以同时收发数据</li>
<li>半双工：在同一时刻，两个设备之间可以收发数据，但不能在同一时刻进行</li>
<li>单工 ：在任何时刻都只能进行一个方向的通讯，即一个固定为发送设备，另一个固定为接收设备</li>
</ul>
</li>
<li><p><strong>同步通讯和异步通讯</strong></p>
</li>
</ul>
<p>根据<strong>通讯的数据同步方式</strong>，又分为同步和异步两种，可以根据通讯过程中<strong>是否有使用到时钟信号</strong>进行简单的区分，<strong>使用时钟信号的叫同步通讯，未使用时钟信号则叫异步通讯</strong>。</p>
<p>在同步通讯中，收发设备双方会使用一根信号线表示时钟信号，在时钟信号的驱动下双方进行协调，同步数据，<strong>通讯中通常双方会统一规定在时钟信号的上升沿或下降沿对数据线进行采样</strong>。</p>
<h2 id="通讯速率"><a href="#通讯速率" class="headerlink" title="通讯速率"></a>通讯速率</h2><p>衡量通讯性能的一个非常重要的参数就是通讯速率，通常以<strong>比特率</strong> (Bitrate) 来表示，即<strong>每秒钟传输的二进制位数，单位为比特每秒 (bit&#x2F;s)</strong>。</p>
<p>容易与比特率混淆的概念是“<strong>波特率</strong>”(Baudrate)，它表示<strong>每秒钟传输了多少个码元</strong>。而码元是通讯信号调制的概念，通讯中常用时间间隔相同的符号来表示一个二进制数字，这样的信号称为<strong>码元</strong>。如常见的通讯传输中，用 0V 表示数字 0，5V 表示数字 1，那么一个码元可以表示两种状态 0 和 1，所以<strong>一个码元等于一个二进制比特位，此时波特率的大小与比特率一致</strong>；如果在通讯传输中，有 0V、2V、4V 以及 6V 分别表示二进制数 00、01、10、11，那么<strong>每个码元可以表示四种状态，即两个二进制比特位，所以码元数是二进制比特位数的一半，这个时候的波特率为比特率的一半。</strong></p>
<p>因为很多常见的通讯中一个码元都是表示两种状态，人们常常直接以波特率来表示比特率，虽然严格来说没什么错误，但不能混淆。</p>
<h1 id="USART"><a href="#USART" class="headerlink" title="USART"></a>USART</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43743762/article/details/97811470?ops_request_misc=&request_id=&biz_id=102&utm_term=stm32usart%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-97811470.142%5Ev100%5Epc_search_result_base2&spm=1018.2226.3001.4187">STM32—串口通讯详解_串口通讯的原理流程图-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/as480133937/article/details/99073783">【STM32】HAL库 STM32CubeMX教程四—UART串口通信详解_hal_uart_transmit-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/fuhanghang/article/details/123280368?ops_request_misc=%7B%22request_id%22:%22171370716116800226596446%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171370716116800226596446&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-123280368-null-null.142%5Ev100%5Epc_search_result_base8&utm_term=CH340%E8%8A%AF%E7%89%87&spm=1018.2226.3001.4187">ch340是什么芯片_ch340是干嘛的-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_59161987/article/details/128480063">STM32 —— USB 转 TTL（CH340）-CSDN博客</a></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>USART-通用同步&#x2F;异步收发器(Universal Synchronous&#x2F;Asynchronous Receiver&#x2F;Transmitter)，USART是一个全双工通用同步&#x2F;异步串行收发模块，该接口是一个高度灵活的串行通信设备。</p>
<blockquote>
<ul>
<li>STM32中的USART外设可以实现<strong>同步传输</strong>功能，所以命名为USART，比UART多了一个S，即synchronous(同步)</li>
</ul>
</blockquote>
<p>UART器件<strong>主要用来产生相关接口的协议信号</strong>，如<code>TTL串口</code> &#x2F;<code>RS232</code>&#x2F;<code>RS485</code>等<strong>串行接口标准规范和总线的标准规范</strong>，要使用传输数据的这些接口，就要按照接口规定的协议信号发送数据。所以<strong>UART期间广泛应用于串口通信中，扮演者传输者的角色</strong>。</p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>STM32的串口通常用于与其他设备进行通信。</p>
<p><strong>它可以用于与计算机、其他微控制器、传感器、显示屏或其他外围设备进行数据传输</strong>。串口通常用于发送和接收数据，可以是文本、二进制数据或其他格式。</p>
<p><strong>常见的应用</strong>：</p>
<p>通过<strong>串口进行调试、控制外部设备、传感器数据采集和与外部设备进行通信等</strong>。串口通常是嵌入式系统中基本且常用的通信接口之一。</p>
<h2 id="串口接受与发送"><a href="#串口接受与发送" class="headerlink" title="串口接受与发送"></a>串口接受与发送</h2><p>在 <strong>stm32f4xx_hal.c</strong>中包含#include &lt;stdio.h&gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f4xx_hal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> UART_HandleTypeDef huart1;   <span class="comment">//声明串口</span></span><br></pre></td></tr></table></figure>



<p><strong>重定向printf函数：</strong></p>
<p>在 <strong>stm32f4xx_hal.c</strong> 中重写fget和fput函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函数功能: 重定向c库函数printf到DEBUG_USARTx</span></span><br><span class="line"><span class="comment">  * 输入参数: 无</span></span><br><span class="line"><span class="comment">  * 返 回 值: 无</span></span><br><span class="line"><span class="comment">  * 说    明：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  HAL_UART_Transmit(&amp;huart1, (<span class="type">uint8_t</span> *)&amp;ch, <span class="number">1</span>, HAL_MAX_DELAY);</span><br><span class="line">  <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函数功能: 重定向c库函数getchar,scanf到DEBUG_USARTx</span></span><br><span class="line"><span class="comment">  * 输入参数: 无</span></span><br><span class="line"><span class="comment">  * 返 回 值: 无</span></span><br><span class="line"><span class="comment">  * 说    明：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint8_t</span> ch = <span class="number">0</span>;</span><br><span class="line">  HAL_UART_Receive(&amp;huart1, &amp;ch, <span class="number">1</span>, HAL_MAX_DELAY);<span class="comment">//该函数在轮询中会堵塞执行</span></span><br><span class="line">  <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * UART_HandleTypeDef *huart      UATR的别名    如 :   </span></span><br><span class="line"><span class="comment">  * UART_HandleTypeDef huart1;   别名就是huart1  </span></span><br><span class="line"><span class="comment">  *	*pData      需要发送的数据 </span></span><br><span class="line"><span class="comment">  *  Size    发送的字节数</span></span><br><span class="line"><span class="comment">  * Timeout   最大发送时间，发送数据超过该时间退出发送   </span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*在main函数中使用printf、getchar、scanf等*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> ch = getchar();<span class="comment">//从串口获取单个字符</span></span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="USART中断"><a href="#USART中断" class="headerlink" title="USART中断"></a>USART中断</h2><p>轮询状态下的串口接收数据会使cpu效率一直查看是否有数据，干不了其他事情，使程序堵塞，效率低下。但如果使用中断发送和接收比较高效,cpu需要处理时会被叫回处理，其他时间可以干其他事情,不会长期占用cpu时间。</p>
<blockquote>
<p><strong>轮询模式是阻塞模式，程序会等到所有数据发送&#x2F;接收完成后才会着向下执行</strong></p>
<p><strong>而中断和DMA是非阻塞模式，他们将任务交给外设后就会接着向下执行，不会等待数据发送&#x2F;接收完成</strong></p>
</blockquote>
<p><code>主要有三个函数：</code></p>
<ul>
<li><strong>串口中断处理函数</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_IRQHandler(UART_HandleTypeDef *huart);  </span><br></pre></td></tr></table></figure>

<p><strong>功能</strong>：对接收到的数据进行判断和处理 <strong>判断是发送中断还是接收中断</strong>，然后进行数据的发送和接收，在中断服务函数中使用</p>
<ul>
<li><strong>中断接收数据</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_Receive_IT(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>该函数启动后只能触发一次中断，进入一次中断回调函数。如果需要多次触发需要在中断回调函数中重新启用!!!</strong></p>
</blockquote>
<ul>
<li><strong>中断发送数据</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size)</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>串口接收中断回调函数</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)</span><br><span class="line">&#123;</span><br><span class="line">    .......</span><br><span class="line">        </span><br><span class="line">    HAL_UART_Receive_IT(&amp;huart1,&amp;charBuffer,<span class="number">1</span>);<span class="comment">//再次开启串口接收</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cplt代表 complete完成，代表接收完成后触发中断回调</span></span><br></pre></td></tr></table></figure>

<p><code>注意：别忘了在中断回调函数中重新启动接收!!!</code></p>
<ul>
<li><strong>空闲中断idle对应回调函数</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, <span class="type">uint16_t</span> Size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(huart == &amp;huart2)</span><br><span class="line">    &#123;</span><br><span class="line">        HAL_UART_Transmit_DMA(&amp;huart2, rData, Size);</span><br><span class="line"></span><br><span class="line">        HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart2,rData,<span class="keyword">sizeof</span>(rData));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ex代表扩展</span></span><br><span class="line"><span class="comment"> * 参数2：size代表接收的数据长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h2 id="实验-1"><a href="#实验-1" class="headerlink" title="实验"></a>实验</h2><h3 id="USART1普通中断回显实验"><a href="#USART1普通中断回显实验" class="headerlink" title="USART1普通中断回显实验"></a>USART1普通中断回显实验</h3><p><strong>主要的函数</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_Receive_IT(&amp;haurt1,(<span class="type">uint8_t</span>*)&amp;buffer,<span class="number">1</span>)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函数功能: 用于启用串口的接收中断，并指定接收数据存放位置。每当接收到数据时，将触发一个中断，然后调用相应的中断回调函数处理接收数据</span></span><br><span class="line"><span class="comment">  * 输入参数: 一共三个，串口别名，数据存放地址，字节数</span></span><br><span class="line"><span class="comment">  * 返 回 值: 无</span></span><br><span class="line"><span class="comment">  * 说    明：无</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li>UART_HandleTypeDef *huart   <strong>UATR的别名</strong>  如 :  UART_HandleTypeDef huart1;  别名就是huart1 </li>
<li>*pData   <strong>接收到的数据存放地址</strong></li>
<li>Size  <strong>一次接收的字节数</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart);  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函数功能: 串口接收中断回调函数，由用户自己编写,当接收到一个或多个字符后会被调用。在这个函数中处理接收到的数据，比如回显到终端或者储存到缓冲区中</span></span><br><span class="line"><span class="comment">  * 输入参数: 无</span></span><br><span class="line"><span class="comment">  * 返 回 值: 无</span></span><br><span class="line"><span class="comment">  * 说    明：无</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gpio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> buffer[<span class="number">255</span>];</span><br><span class="line"><span class="type">uint8_t</span> bufferCounter=<span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> charBuffer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	  	HAL_GPIO_WritePin(GPIOC,GPIO_PIN_2,GPIO_PIN_RESET);</span><br><span class="line">		HAL_GPIO_WritePin(GPIOC,GPIO_PIN_3,GPIO_PIN_RESET);</span><br><span class="line">	  </span><br><span class="line">		HAL_UART_Receive_IT(&amp;huart1,&amp;charBuffer,<span class="number">1</span>);<span class="comment">//开启串口接收中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//		HAL_GPIO_TogglePin(GPIOC,GPIO_PIN_2);</span></span><br><span class="line"><span class="comment">//	  HAL_GPIO_TogglePin(GPIOC,GPIO_PIN_3);</span></span><br><span class="line"><span class="comment">//	  HAL_Delay(1000);</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//		if(bufferCounter&gt;=255)</span></span><br><span class="line"><span class="comment">//		&#123;</span></span><br><span class="line"><span class="comment">//			HAL_UART_Transmit(&amp;huart1,(uint8_t * )&quot;数据溢出&quot;,10,HAL_MAX_DELAY);</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"><span class="comment">//		else</span></span><br><span class="line"><span class="comment">//		&#123;</span></span><br><span class="line">	</span><br><span class="line">			<span class="keyword">if</span>(huart == &amp;huart1)</span><br><span class="line">			&#123;</span><br><span class="line">				buffer[bufferCounter++] = charBuffer;</span><br><span class="line">				HAL_UART_Transmit(&amp;huart1,&amp;charBuffer,<span class="number">1</span>,HAL_MAX_DELAY);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">	</span><br><span class="line">		HAL_UART_Receive_IT(&amp;huart1,&amp;charBuffer,<span class="number">1</span>);<span class="comment">//开启串口中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>每次中断接收一个字节的数据，数据量大会频繁触发中断</p>
<p>可以改进为一次接收N个字节的数据。</p>
</blockquote>
<h3 id="USART2控制LED灯"><a href="#USART2控制LED灯" class="headerlink" title="USART2控制LED灯"></a>USART2控制LED灯</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gpio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> buffer[<span class="number">255</span>];</span><br><span class="line"><span class="type">uint8_t</span> bufferCounter=<span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> charBuffer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	  HAL_GPIO_WritePin(GPIOC,GPIO_PIN_2,GPIO_PIN_SET);</span><br><span class="line">		HAL_GPIO_WritePin(GPIOC,GPIO_PIN_3,GPIO_PIN_SET);</span><br><span class="line">	  </span><br><span class="line">	</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请操作小灯：\n1.只有小灯1亮\n2.只有小灯2亮\n3.两个小灯同时亮\n4.两个小灯同时熄灭\n&quot;</span>);</span><br><span class="line">		HAL_UART_Receive_IT(&amp;huart1,&amp;charBuffer,<span class="number">1</span>);<span class="comment">//开启串口接收中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//		HAL_GPIO_TogglePin(GPIOC,GPIO_PIN_2);</span></span><br><span class="line"><span class="comment">//	  HAL_GPIO_TogglePin(GPIOC,GPIO_PIN_3);</span></span><br><span class="line"><span class="comment">//	  HAL_Delay(1000);</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">			<span class="keyword">if</span>(huart == &amp;huart1)</span><br><span class="line">			&#123;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span>(charBuffer == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">				&#123;</span><br><span class="line">							HAL_GPIO_WritePin(GPIOC,GPIO_PIN_2,GPIO_PIN_RESET),</span><br><span class="line">							HAL_GPIO_WritePin(GPIOC,GPIO_PIN_3,GPIO_PIN_SET);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(charBuffer == <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">				&#123;</span><br><span class="line">							HAL_GPIO_WritePin(GPIOC,GPIO_PIN_2,GPIO_PIN_SET),</span><br><span class="line">							HAL_GPIO_WritePin(GPIOC,GPIO_PIN_3,GPIO_PIN_RESET);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(charBuffer == <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">				&#123;</span><br><span class="line">							HAL_GPIO_WritePin(GPIOC,GPIO_PIN_2,GPIO_PIN_RESET),</span><br><span class="line">							HAL_GPIO_WritePin(GPIOC,GPIO_PIN_3,GPIO_PIN_RESET);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">							HAL_GPIO_WritePin(GPIOC,GPIO_PIN_2,GPIO_PIN_SET),</span><br><span class="line">							HAL_GPIO_WritePin(GPIOC,GPIO_PIN_3,GPIO_PIN_SET);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">	</span><br><span class="line">		HAL_UART_Receive_IT(&amp;huart1,&amp;charBuffer,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在串口调试助手时，发送1，2，3，4在单片机上可以看到明显的现象</p>
</blockquote>
<h2 id="串口接收不定长数据"><a href="#串口接收不定长数据" class="headerlink" title="串口接收不定长数据"></a>串口接收不定长数据</h2><p>如果用hal库一次性接收大量数据，如果通过判断RXNE标志位，每次只接受一个字节会消耗大量mcu资源去频繁处理中断,如果一次性接收多个字节可能会导致数据无法对齐，如果一次接收大量字节，中断回调函数无法执行，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_Receive_IT(&amp;huart1,&amp;ch,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>像这样一次接收一个字节，如果数据量大，会频繁进入中断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_Receive_IT(&amp;huart1,&amp;ch,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>这样一次接收多个字节会导致接收数据错误</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_Receive_IT(&amp;huart1,&amp;ch,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>这样接收大量数据会直接进不了中断回调</p>
<p><strong>此时就需要我们的IDLE标志位能解决一次性接收大量数据的问题，也就是使用空闲串口中断</strong></p>
<blockquote>
<p><strong>收发不定长数据主要依靠IDLE(串口空闲中断)</strong>，所谓<strong>串口空闲中断</strong>就是，中断触发条件与接收的字节数无关，串口无数据接收时不会触发，必须要从接收到第一个数据开售，当RX引脚上无后续数据进入，串口接收从忙碌转为空闲时才会触发。可以认为空闲中断IDLE发生时就是一帧的数据包接收完成了，此时对数据进行分析处理即可。</p>
<p>一般用于接收大量数据</p>
</blockquote>
<ul>
<li><strong>串口接收数据</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HAL_UARTEx_ReceiveToIdle();<span class="comment">//阻塞</span></span><br><span class="line">HAL_UARTEx_ReceiveToIdle_IT();<span class="comment">//中断</span></span><br><span class="line">HAL_UARTEx_ReceiveToIdle_DMA(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size);<span class="comment">//DMA</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ex代表扩展，Idle代表空闲中断</span></span><br><span class="line"><span class="comment"> * 以DMA为例，参数1，2不变，参数3并不是想要接收的长度，而是一次接收的最大长度</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<ul>
<li><strong>空闲中断对应回调函数</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, <span class="type">uint16_t</span> Size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(huart == &amp;huart2)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ex代表扩展，Idle代表空闲中断</span></span><br><span class="line"><span class="comment"> * 参数2：size代表接收的数据长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用ReceiveToIdle相关函数时，<strong>不再调用RxCpltCallback回调，而是使用了RxEventCallback进行回调</strong></p>
</blockquote>
<h2 id="实验-2"><a href="#实验-2" class="headerlink" title="实验"></a>实验</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BUFFER_SIZE 10</span></span><br><span class="line"><span class="type">char</span> RxBuffer[MAX_BUFFER_SIZE];</span><br><span class="line"><span class="type">char</span> TxBuffer[MAX_BUFFER_SIZE];</span><br><span class="line"><span class="type">uint8_t</span> Usart_Flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	  HAL_UARTEx_ReceiveToIdle_IT(&amp;huart1,(<span class="type">uint8_t</span> *)RxBuffer,MAX_BUFFER_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Usart_Task();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Usart_Task</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(Usart_Flag)</span><br><span class="line">	&#123;</span><br><span class="line">		Usart_Flag = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UARTEx_RxEventCallback</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint16_t</span> Size)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	 <span class="keyword">if</span>(huart == &amp;huart1)</span><br><span class="line">	 &#123;</span><br><span class="line">		  Usart_Flag = <span class="number">1</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">	 </span><br><span class="line">	 HAL_UARTEx_ReceiveToIdle_IT(&amp;huart1,(<span class="type">uint8_t</span> *)RxBuffer,MAX_BUFFER_SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="HAL库函数的一些调用流程"><a href="#HAL库函数的一些调用流程" class="headerlink" title="HAL库函数的一些调用流程"></a>HAL库函数的一些调用流程</h1><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>HAL_外设名_Init()</span><br><span class="line">-- 该函数一般会调用<span class="number">2</span>函数，实际操作寄存器初始化外设功能，由HAL库实现</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>HAL_外设名_MspInit()</span><br><span class="line">-- 该函数是外设外围相关功能的初始化，比如：引脚、特殊功能比如时钟使能等等，由用户自己实现</span><br></pre></td></tr></table></figure>

<p><strong>以USART初始化来举例</strong>：</p>
<ol>
<li>定义一个UART_HandleTypeDef结构体句柄</li>
<li>通过HAL_UART_MspInit函数来实现串口外设的底层初始化</li>
</ol>
<ul>
<li><p>要做的功能：</p>
<ol>
<li><p>使能UART外设时钟</p>
</li>
<li><p>配置UART使用的引脚模式</p>
</li>
<li><p>如果要使用中断，就配置中断</p>
</li>
<li><p>如果要用DMA，就配置DMA</p>
</li>
</ol>
</li>
</ul>
<ol start="3">
<li>通过前面定义的结构体具备，来配置串口的波特率、数据字长、停止位、奇偶校验位。</li>
<li>如果要使用异步模式，则通过调用HAL_UART_Init()函数来将串口配置为异步模式。</li>
</ol>
<h1 id="TIM-定时器"><a href="#TIM-定时器" class="headerlink" title="TIM(定时器)"></a>TIM(定时器)</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>STM32中的定时器是一种内置的硬件模块，用于<strong>生成精确的时间延迟、执行周期性任务、捕获外部事件</strong>等。<strong>定时器通常用于需要精确时间控制的应用，比如实时操作系统、通信协议、PWM（脉冲宽度调制）生成等</strong>。</p>
<p><strong>以下常见的几种定时器</strong>:</p>
<ul>
<li><strong>高级定时器</strong></li>
<li><strong>通用定时器</strong></li>
<li><strong>基本定时器</strong></li>
</ul>
<p><strong>定时器的常见作用</strong>：</p>
<ol>
<li><strong>计时器模式（Timer Mode）</strong>：定时器可以作为简单的计时器，用于生成一段时间延迟。你可以设置定时器的计数值和时钟频率来控制延迟的精度。</li>
<li><strong>定时器中断（Timer Interrupts）</strong>：定时器可以配置为在计数器达到特定值时生成中断请求。这对于周期性任务执行或时间精确控制非常有用。</li>
<li><strong>PWM输出（Pulse Width Modulation）</strong>：定时器可以用来生成PWM信号，用于控制电机速度、LED亮度、音频输出等。</li>
<li><strong>捕获模式（Capture Mode）</strong>：定时器可以捕获外部事件的时间戳，比如测量输入脉冲的周期或脉宽。</li>
<li><strong>计数器级联（Timer Cascade）</strong>：一些STM32系列的芯片支持多个定时器级联，可以扩展定时器的计数范围或增加功能。</li>
</ol>
<p>还有一些相关知识例如:定时器的主从模式</p>
<p><strong>定时器相关寄存器可以查看参考手册、数据手册等</strong></p>
<p><strong>还有一些相关知识(定时器的主从模式等)，以下为定时器详细介绍</strong>：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44016222/article/details/123507270?ops_request_misc=%7B%22request_id%22:%22171386792116800185878220%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171386792116800185878220&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123507270-null-null.142%5Ev100%5Econtrol&utm_term=stm32%E5%AE%9A%E6%97%B6%E5%99%A8&spm=1018.2226.3001.4187">STM32-定时器详解_stm32定时器-CSDN博客</a></p>
<h2 id="基于定时器的LED闪烁"><a href="#基于定时器的LED闪烁" class="headerlink" title="基于定时器的LED闪烁"></a>基于定时器的LED闪烁</h2><h3 id="CubeMX配置"><a href="#CubeMX配置" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h3><ol>
<li><p><strong>确定时钟输入</strong>: 这里我们需要一个稳定的时钟输入，以精确的进行定时，因此可以选择内部时钟源。这里以<code>TIM2</code>为例，在CubeMX中将<code>Clock Source</code>选择为<code>Internal Clock</code>, 使用内部时钟源。那么这个内部时钟源是哪来的呢？参考芯片手册。找到时钟源输入频率。<strong>即在CubeMX中配置Clock Source为Internal Clock(内部时钟源)</strong></p>
</li>
<li><p><strong>确定预分频值</strong>：预分频值就是指时钟信号输入之后会在这里被分频，也就是降低了输入频率。 假设这里的值设定为2，则最终信号会变成36MHz，也就是计数器每秒会加36M次，很显然这个速度对我们来说还是太大了。 为了便于计算，我这里更倾向于让输出的时钟频率变成10k，这样每0.1ms定时器就加1。</p>
</li>
<li><p><strong>确定重装载值</strong>：</p>
</li>
</ol>
<p> 当我们在上面分完频后，就很容易计算这里的值应该为多少了。显然，要使定时器100ms触发一次，这里的这个值应该为1000，最后别忘了-1，才是准确的值(从0开始)。<strong>别忘了使能自动重装载enable</strong>。</p>
<ol start="4">
<li><strong>使能定时器中断</strong>：在NVIC中开启TIM中断。</li>
</ol>
<blockquote>
<p><strong>主要涉及三个概念</strong>：</p>
<ol>
<li><p><strong>Prescaler(psc)-预分频值</strong>：内部有一个预分频器PSC，简单来说就是分频值</p>
<p>时钟信号被分频后的频率 F&#x3D; TCLK&#x2F;(PSC+1) </p>
</li>
<li><p><strong>auto-reload preload(arr)-自动重装载值</strong>：内部有一个自动重装载寄存器，简单来说就是设置计数值上限，最大为65535</p>
</li>
<li><p><strong>CNT-计数器</strong>：内部有一个计数器自增，会与自动重装在寄存器比较，当计数值等于自动重装载值arr时，将会触发<strong>更新中断或更新事件</strong>，同时清零计数器</p>
</li>
</ol>
<p><strong>定时器溢出时间 Tout &#x3D;  (arr+1)&#x2F;F   &#x3D;   (arr+1)*(PSC+1) &#x2F;TCLK</strong></p>
<p><strong>注意：psc和arr的值配置时都要-1，因为从0开始数</strong></p>
</blockquote>
<p><strong>举个例子</strong>：</p>
<p>​		假设时钟源频率为72MHZ，我们设置psc为7200-1&#x3D;7199，那么得到分频后的时钟频率为10000HZ, 每秒计数10000次，要使定时器0.1s溢出一次，那么1000-1&#x3D;999次，1000&#x2F;10000 &#x3D; 0.1s</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/as480133937/article/details/99201209">【STM32】HAL库 STM32CubeMX教程六—-定时器中断_hal_tim_irqhandler-CSDN博客</a></p>
<h3 id="函数和业务代码"><a href="#函数和业务代码" class="headerlink" title="函数和业务代码"></a>函数和业务代码</h3><p><strong>主要函数</strong>：</p>
<p><strong>定时器中断处理函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_IRQHandler(&amp;htim2);</span><br></pre></td></tr></table></figure>



<p><strong>定时器溢出中断回调函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span>;   </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 在stm32f1xx_it.c中可以找到HAL_TIM_IRQHandler(&amp;htim2);里面调用了这个溢出中断回调函数</span></span><br><span class="line"><span class="comment">  */</span> </span><br></pre></td></tr></table></figure>



<p><strong>使能定时器中断</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_Base_Start_IT(&amp;htim2);</span><br><span class="line"><span class="comment">/*使用之前别忘了在setup中使能定时器中断*/</span></span><br></pre></td></tr></table></figure>



<p><strong>业务代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*定时器中断使能*/</span></span><br><span class="line">	HAL_TIM_Base_Start_IT(&amp;htim2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line">	 <span class="keyword">if</span>(htim == &amp;htim2)</span><br><span class="line">	 &#123;</span><br><span class="line">		 HAL_GPIO_TogglePin(GPIOC,GPIO_PIN_2);</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="RTC"><a href="#RTC" class="headerlink" title="RTC"></a>RTC</h2><p>STM32 微控制器中的 RTC（Real Time Clock，实时时钟）模块是一个低功耗的独立计时器，用于提供精确的时间和日期信息。<strong>RTC 模块设计为即使在主电源关闭的情况下也能继续运行，从而确保时间信息不会丢失。这通常是通过一个备用电池或超级电容来实现的，它能够为 RTC 供电，即便主电源断开</strong>。</p>
<p>以下是关于 STM32 中 RTC 的一些关键点：</p>
<ol>
<li><strong>功能</strong>:<ul>
<li><strong>提供实时时间</strong>：RTC 可以作为系统时钟，提供准确的小时、分钟、秒等。</li>
<li><strong>日历功能</strong>：除了时间，RTC 还可以提供年、月、日等日期信息。</li>
<li><strong>闹钟功能</strong>：可以设置特定时间触发中断，用于定时唤醒或其他用途。</li>
<li><strong>定时任务</strong>：可用于执行定期的任务或事件。</li>
</ul>
</li>
<li><strong>硬件特性</strong>:<ul>
<li>低功耗设计：RTC 在低功耗模式下也能工作，适合于电池供电的应用。</li>
<li>备用电源：通过 VBAT 引脚连接备用电源，保证在主电源断开后仍能维持时间信息。</li>
<li>时钟源：可以选择多种时钟源，如 LSE (低速外部晶振, 通常为 32.768kHz)、LSI (低速内部 RC 振荡器) 或 HSE (高速外部晶振) 经过分频后的信号。</li>
</ul>
</li>
</ol>
<h3 id="RTC时钟选择"><a href="#RTC时钟选择" class="headerlink" title="RTC时钟选择"></a>RTC时钟选择</h3><blockquote>
<p><strong>RTC设备因为其独特的运行方式（即掉电依旧运行）使用HSE分频时钟或者LSI的时候,在主电源VDD掉电的情况下,这两个时钟来源都会受到影响，资源消耗太大，小小的纽扣电池根本吃不消。</strong></p>
</blockquote>
<p>​	所以<strong>RTC一般都时钟低速外部时钟LSE</strong>,频率为实时时钟模块中常用的32.768KHz,因为32768 &#x3D; 2^15,分频容易实现,所以被广泛应用到RTC模块.(在主电源VDD有效的情况下(待机),RTC还可以配置闹钟事件使STM32退出待机模式).</p>
<blockquote>
<p><strong>故使用RTC时记得使能LSE的外部晶振，配置时钟树时RTC选择LSE</strong></p>
</blockquote>
<h3 id="RTC中断"><a href="#RTC中断" class="headerlink" title="RTC中断"></a>RTC中断</h3><blockquote>
<p><strong>秒中断</strong>：<br>这里时钟自带一个秒中断，每当计数加一的时候就会触发一次秒中断，。注意，这里所说的秒中断并非一定是一秒的时间，它是由RTC时钟源和分频值决定的“秒”的时间，当然也是可以做到1秒钟中断一次。我们通过往秒中断里写更新时间的函数来达到时间同步的效果</p>
<p><strong>闹钟中断</strong>：<br>闹钟中断就是设置一个预设定的值，计数每自加多少次触发一次闹钟中断</p>
</blockquote>
<h3 id="CubeMX配置-1"><a href="#CubeMX配置-1" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h3><blockquote>
<p>Activate Clock Source 激活时钟源<br>Activate calendar激活日历<br>这两个都要使能，作用也很明显，先是使能时钟源，再使能RTC日历</p>
<p>RTC_OUT： Not RTC_OUT<br>Tamper： ×</p>
<p>第一个参数：是否使能tamper引脚作为校正的秒脉冲输出</p>
<p>第二个参数：是否使能tamper引脚作为RTC入侵检测校验功能</p>
<p><strong>剩下的就是时间配置</strong></p>
</blockquote>
<h3 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*设置系统时间*/</span></span><br><span class="line">HAL_RTC_SetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, <span class="type">uint32_t</span> Format) </span><br><span class="line"><span class="comment">/*读取系统时间*/</span></span><br><span class="line">HAL_RTC_GetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, <span class="type">uint32_t</span> Format)</span><br><span class="line"><span class="comment">/*设置系统日期*/</span></span><br><span class="line">HAL_RTC_SetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, <span class="type">uint32_t</span> Format)</span><br><span class="line"><span class="comment">/*读取系统日期*/</span></span><br><span class="line"> HAL_RTC_GetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, <span class="type">uint32_t</span> Format)</span><br><span class="line"><span class="comment">/*启动报警功能*/</span></span><br><span class="line">HAL_RTC_SetAlarm(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, <span class="type">uint32_t</span> Format)</span><br><span class="line"><span class="comment">/*设置报警中断*/</span></span><br><span class="line">HAL_RTC_SetAlarm_IT(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, <span class="type">uint32_t</span> Format)</span><br><span class="line"><span class="comment">/*报警时间回调函数*/</span></span><br><span class="line">__weak <span class="type">void</span> <span class="title function_">HAL_RTC_AlarmAEventCallback</span><span class="params">(RTC_HandleTypeDef *hrtc)</span></span><br><span class="line"><span class="comment">/*写入备份储存器*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_RTCEx_BKUPWrite</span><span class="params">(RTC_HandleTypeDef *hrtc, <span class="type">uint32_t</span> BackupRegister, <span class="type">uint32_t</span> Data)</span></span><br><span class="line"><span class="comment">/*读取备份储存器*/</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">HAL_RTCEx_BKUPRead</span><span class="params">(RTC_HandleTypeDef *hrtc, <span class="type">uint32_t</span> BackupRegister  </span></span><br><span class="line"><span class="params"></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>参数1</strong>：RTC句柄结构体参数</p>
<p><strong>参数2</strong>：<strong>RTC_TimeTypeDef</strong> *sTime： 获取RTC时间的结构体</p>
<p><strong>参数3</strong>： <strong>获取时间的格式</strong><br><strong>RTC_FORMAT_BIN 使用2进制<br>RTC_FORMAT_BCD 使用BCD进制</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  RTC Time structure definition</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint8_t</span> Hours;            <span class="comment">/*!&lt; Specifies the RTC Time Hour.</span></span><br><span class="line"><span class="comment">                                 This parameter must be a number between Min_Data = 0 and Max_Data = 23 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Minutes;          <span class="comment">/*!&lt; Specifies the RTC Time Minutes.</span></span><br><span class="line"><span class="comment">                                 This parameter must be a number between Min_Data = 0 and Max_Data = 59 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Seconds;          <span class="comment">/*!&lt; Specifies the RTC Time Seconds.</span></span><br><span class="line"><span class="comment">                                 This parameter must be a number between Min_Data = 0 and Max_Data = 59 */</span></span><br><span class="line"></span><br><span class="line">&#125; RTC_TimeTypeDef;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  RTC Date structure definition</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint8_t</span> WeekDay;  <span class="comment">/*!&lt; Specifies the RTC Date WeekDay (not necessary for HAL_RTC_SetDate).</span></span><br><span class="line"><span class="comment">                         This parameter can be a value of @ref RTC_WeekDay_Definitions */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Month;    <span class="comment">/*!&lt; Specifies the RTC Date Month (in BCD format).</span></span><br><span class="line"><span class="comment">                         This parameter can be a value of @ref RTC_Month_Date_Definitions */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Date;     <span class="comment">/*!&lt; Specifies the RTC Date.</span></span><br><span class="line"><span class="comment">                         This parameter must be a number between Min_Data = 1 and Max_Data = 31 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Year;     <span class="comment">/*!&lt; Specifies the RTC Date Year.</span></span><br><span class="line"><span class="comment">                         This parameter must be a number between Min_Data = 0 and Max_Data = 99 */</span></span><br><span class="line"></span><br><span class="line">&#125; RTC_DateTypeDef;</span><br><span class="line"></span><br></pre></td></tr></table></figure>









<h3 id="实验-实时时间OLED显示"><a href="#实验-实时时间OLED显示" class="headerlink" title="实验-实时时间OLED显示"></a>实验-实时时间OLED显示</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> realTime[<span class="number">10</span>];</span><br><span class="line"><span class="type">char</span> realDate[<span class="number">10</span>];</span><br><span class="line">RTC_DateTypeDef GetDate;<span class="comment">//获取日期结构体</span></span><br><span class="line">RTC_TimeTypeDef GetTime;<span class="comment">//获取时间结构体</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_Delay(<span class="number">20</span>);</span><br><span class="line">    OLED_Init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    HAL_RTC_GetTime(&amp;hrtc, &amp;GetTime, RTC_FORMAT_BIN);</span><br><span class="line">   <span class="comment">/*分别从RTC获取时间结构体和日期结构体*/</span> HAL_RTC_GetDate(&amp;hrtc,&amp;GetDate,RTC_FORMAT_BIN);</span><br><span class="line">   </span><br><span class="line">    OLED_NewFrame();</span><br><span class="line"><span class="built_in">sprintf</span>(realDate,<span class="string">&quot;%02d/%02d/%02d&quot;</span>,<span class="number">2000</span>+GetData.Year, GetData.Month, GetData.Date);</span><br><span class="line">    <span class="built_in">sprintf</span>(realTime,<span class="string">&quot;%02d:%02d:%02d&quot;</span>,GetTime.Hours, GetTime.Minutes, GetTime.Seconds);</span><br><span class="line"></span><br><span class="line">    OLED_PrintString(<span class="number">0</span>, <span class="number">0</span>,realDate ,&amp;font16x16,OLED_COLOR_NORMAL);</span><br><span class="line">    OLED_PrintString(<span class="number">0</span>, <span class="number">16</span>,realTime ,&amp;font16x16,OLED_COLOR_NORMAL);</span><br><span class="line">    OLED_ShowFrame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="RTC掉电重置"><a href="#RTC掉电重置" class="headerlink" title="RTC掉电重置"></a>RTC掉电重置</h3><h4 id="BKP寄存器"><a href="#BKP寄存器" class="headerlink" title="BKP寄存器"></a>BKP寄存器</h4><p>是在嵌入式系统（如STM32微控制器）中用于在系统掉电或复位时保存数据的特殊寄存器。它们通常用于需要在掉电或复位后保留的重要数据，这些数据在重新上电或复位时能够被恢复。<strong>即使系统复位或电源复位，备份寄存器的内容会保留不变，直到手动修改或在特定条件下被重置</strong>。</p>
<blockquote>
<p>BKP寄存器可以在芯片手册中找到</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241008202341686-1752338032550-2.png" alt="image-20241008202341686"></p>
<h4 id="解决掉电重置代码"><a href="#解决掉电重置代码" class="headerlink" title="解决掉电重置代码"></a>解决掉电重置代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MX_RTC_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN RTC_Init 0 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END RTC_Init 0 */</span></span><br><span class="line"></span><br><span class="line">  RTC_TimeTypeDef sTime = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  RTC_DateTypeDef DateToUpdate = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN RTC_Init 1 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END RTC_Init 1 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Initialize RTC Only</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  hrtc.Instance = RTC;</span><br><span class="line">  hrtc.Init.AsynchPrediv = RTC_AUTO_1_SECOND;</span><br><span class="line">  hrtc.Init.OutPut = RTC_OUTPUTSOURCE_NONE;</span><br><span class="line">  <span class="keyword">if</span> (HAL_RTC_Init(&amp;hrtc) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN Check_RTC_BKUP */</span></span><br><span class="line">   <span class="comment">/*新增代码处1：*/</span></span><br><span class="line">  <span class="keyword">if</span>(HAL_RTCEx_BKUPRead(&amp;hrtc,RTC_BKP_DR1)!= <span class="number">0x1234</span>)</span><br><span class="line">    <span class="comment">// 读取备份寄存器，检查是否已经初始化过</span></span><br><span class="line">      </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* USER CODE END Check_RTC_BKUP */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize RTC and set the Time and Date</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    sTime.Hours = <span class="number">0x19</span>;</span><br><span class="line">    sTime.Minutes = <span class="number">0x0</span>;</span><br><span class="line">    sTime.Seconds = <span class="number">0x0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (HAL_RTC_SetTime(&amp;hrtc, &amp;sTime, RTC_FORMAT_BCD) != HAL_OK)</span><br><span class="line">    &#123;</span><br><span class="line">      Error_Handler();</span><br><span class="line">    &#125;</span><br><span class="line">    DateToUpdate.WeekDay = RTC_WEEKDAY_TUESDAY;</span><br><span class="line">    DateToUpdate.Month = RTC_MONTH_OCTOBER;</span><br><span class="line">    DateToUpdate.Date = <span class="number">0x8</span>;</span><br><span class="line">    DateToUpdate.Year = <span class="number">0x24</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (HAL_RTC_SetDate(&amp;hrtc, &amp;DateToUpdate, RTC_FORMAT_BCD) != HAL_OK)</span><br><span class="line">    &#123;</span><br><span class="line">      Error_Handler();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* USER CODE BEGIN RTC_Init 2 */</span></span><br><span class="line">    <span class="comment">/*新增代码处2：*/</span></span><br><span class="line">    <span class="comment">// 设置完成后，将标志位写入备份寄存器，标记RTC已初始化,下次开机后将不再初始化</span></span><br><span class="line">    HAL_RTCEx_BKUPWrite(&amp;hrtc,RTC_BKP_DR1,<span class="number">0x1234</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END RTC_Init 2 */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><p><strong>检查BKP寄存器值</strong>： 在 <code>USER CODE BEGIN Check_RTC_BKUP</code> 部分，通过 <code>HAL_RTCEx_BKUPRead()</code> 函数读取备份寄存器 <code>RTC_BKP_DR1</code> 的值。我们约定用值 <code>0x1234</code> 来表示RTC已经被初始化。<strong>该值自己约定即可！！！！</strong></p>
</li>
<li><p><strong>RTC初始化和时间设置</strong>： 如果读取到的值不是 <code>0x1234</code>，说明RTC未初始化，接着会进行RTC的时间和日期设置。否则，跳过初始化，保留当前时间。</p>
</li>
<li><p><strong>保存初始化标志</strong>： 设置完时间后，通过 <code>HAL_RTCEx_BKUPWrite()</code> 将 <code>0x1234</code> 写入 <code>RTC_BKP_DR1</code>，标记RTC已经完成初始化，以便下次重启时检测。</p>
</li>
</ol>
</blockquote>
<blockquote>
<p>在 STM32 中，备份寄存器可以使用 <code>RTC_BKP_DR1</code> 到<code>RTC_BKP_DRx</code>（多个寄存器）。上面的例子使用的是 <code>RTC_BKP_DR1</code>，你可以根据需要选择其他备份寄存器。</p>
</blockquote>
<h2 id="定时器外部时钟与循迹模块"><a href="#定时器外部时钟与循迹模块" class="headerlink" title="定时器外部时钟与循迹模块"></a>定时器外部时钟与循迹模块</h2><h3 id="循迹模块"><a href="#循迹模块" class="headerlink" title="循迹模块"></a>循迹模块</h3><p><strong>作用</strong>：为传送带测速&#x2F;测距，计算流水线上的货物数量等</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1N94y1u7Uz?spm_id_from=333.788.videopod.sections&vd_source=830e63bd86bd9268c1b7cd9ff383f386">【STM32】动画讲解定时器外部时钟 &amp; 实战传送带测速装置_哔哩哔哩_bilibili</a></p>
<h3 id="抖动脉冲"><a href="#抖动脉冲" class="headerlink" title="抖动脉冲"></a>抖动脉冲</h3><h3 id="输入滤波器"><a href="#输入滤波器" class="headerlink" title="输入滤波器"></a>输入滤波器</h3><h2 id="PWM"><a href="#PWM" class="headerlink" title="PWM"></a>PWM</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p> <strong>脉冲宽度调制-PWM</strong>，是英文“Pulse Width Modulation”的缩写，简称<strong>脉宽调制</strong>，其实是在利用微控制器的<strong>定时器模块</strong>来生成一种特定频率和占空比的<strong>脉冲信号</strong>，调整脉冲的宽度从而影响功率等。PWM信号是一种周期性的脉冲信号，通过调整脉冲的宽度（高电平时间）可以<strong>模拟模拟信号，控制电机速度、LED亮度、蜂鸣器响度</strong>等。</p>
<blockquote>
<p><strong>PWM无非就是一定的频率(周期)，输出不断交替的高低电平信号。</strong></p>
<p>占空比：高电平在一个周期中占用时间的比重叫做占空比，占空比越大其在宏观上表现的电压也就越大，成线性关系。</p>
<p>通用或者高级定时器具有输出比较模式，可以通过不断比较<strong>计数器</strong>与<strong>比较寄存器的值</strong>。</p>
</blockquote>
<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><ul>
<li><strong>启动定时器PWM输出</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_TIM_PWM_Start</span><span class="params">(TIM_HandleTypeDef *htim, <span class="type">uint32_t</span> Channel)</span>;</span><br><span class="line"><span class="comment">/*第一个参数为指向定时器句柄的指针，第二个参数为启动的通道，一个有1，2，3，4共四个,例：TIM_CHANNEL_1*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*函数返回一个 HAL_StatusTypeDef 类型的值，表示操作的状态。常见的返回值包括：HAL_OK(操作成功)、HAL_ERROR(操作失败)*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>启动PWM输出，并启动比较中断</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_PWM_Start_IT(&amp;htim2);</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>修改占空比</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__HAL_TIM_SetCompare(&amp;htim2, TIM_CHANNEL_1, pwmVal);</span><br><span class="line"><span class="comment">/*或*/</span></span><br><span class="line">__HAL_TIM_SET_COMPARE(&amp;htim2, TIM_CHANNEL_1, pwmVal);</span><br><span class="line"><span class="comment">/*前两个参数不变，第三个参数为用户占空比，占空比=pwmVal/arr*/</span></span><br><span class="line"></span><br><span class="line">-------------------上下两种都可以----------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">/*它是HAL库中的一个宏，用于快速设置定时器的比较寄存器的值。*/</span></span><br><span class="line">TIM2-&gt;CCR1 = pwmVal </span><br><span class="line">htim2.Instance-&gt;CCR1 = pwmVal</span><br><span class="line"><span class="comment">/*直接修改比较寄存器CCRx的值也可以访问定时器相关寄存器*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>修改PSC或ARR的值</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*修改预分频值,PSC寄存器*/</span></span><br><span class="line">htim2.Instance-&gt;PSC = <span class="number">72</span><span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*修改自动重装载值，ARR寄存器*/</span></span><br><span class="line">htim2.Instance-&gt;ARR = <span class="number">1000</span><span class="number">-1</span>;</span><br></pre></td></tr></table></figure>





<h3 id="实验-PWM控制LED亮度实现呼吸灯"><a href="#实验-PWM控制LED亮度实现呼吸灯" class="headerlink" title="实验-PWM控制LED亮度实现呼吸灯"></a>实验-PWM控制LED亮度实现呼吸灯</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/as480133937/article/details/99231677">【STM32】HAL库 STM32CubeMX教程七—PWM输出(呼吸灯)_stm32 hal pwm-CSDN博客</a></p>
<h4 id="CubeMX配置-2"><a href="#CubeMX配置-2" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h4><p><strong>第一步</strong>：配置时钟树</p>
<p><strong>第二步</strong>：选用定时器，这里用TIM2，Clock Source选择内部时钟源，四个独立通道channel任选一个，选择PWM模式(PWM Generation CH1),CH1代表通道1，对应引脚将自动配置为复用模式。</p>
<blockquote>
<p>Channel1~4 就是设置定时器通道的功能   (<strong>输入捕获、输出比较、PWM输出、单脉冲模式</strong>)</p>
</blockquote>
<p><strong>第三步</strong>：Mode选择PWM mode 1，Pulse(宽度&#x2F;占空比)先选择0，Fast Mode不使能，通道极性(CH Polarity)配置为Low(<strong>选择Low可以使占空比变为低电平占整个周期的比例</strong>)</p>
<blockquote>
<p>PWM mode 1 和 2 区别在于一个是向上计数一个是向下计数，以及频率和占空比是否固定上等</p>
<p>**CHPolarity的选择上：**当占空比为30%时，如果选择High那么高电平占30%，选择Low那么低电平占30%。</p>
<p>但一般情况下占空比都是指高电平所占周期的比例</p>
</blockquote>
<p><strong>第四步</strong>：设置预分频值和重装载值以及占空比，我设置arr &#x3D; 100-1，psc &#x3D; 71，得到的Fpwm &#x3D; 72000000&#x2F;7200 &#x3D; 10000HZ </p>
<blockquote>
<p><strong>定时溢出频率即pwm的频率，故Fpwm &#x3D;  TCLK&#x2F;(arr+1)*(PSC+1)</strong> </p>
<p><strong>占空比为高电平所占时间与整个周期比例：TIM2-&gt;CCR1&#x2F;arr</strong></p>
<p><strong>TIM2-&gt;CCR1是定时器2的比较(捕获)寄存器1可以修改其值来调整占空比</strong></p>
</blockquote>
<p><strong>第五步</strong>：生成项目</p>
<h4 id="业务代码-轮询修改占空比"><a href="#业务代码-轮询修改占空比" class="headerlink" title="业务代码(轮询修改占空比)"></a>业务代码(轮询修改占空比)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*按键控制LED呼吸灯开关*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 24-9-13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;gpio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdbool.h&quot;</span></span></span><br><span class="line"><span class="type">uint16_t</span> pwmVal = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> mode = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mode)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(pwmVal&lt;<span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pwmVal+=<span class="number">1</span>;</span><br><span class="line">            __HAL_TIM_SetCompare(&amp;htim3, TIM_CHANNEL_2, pwmVal);</span><br><span class="line">            HAL_Delay(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!mode)</span><br><span class="line">            &#123;</span><br><span class="line">                __HAL_TIM_SetCompare(&amp;htim3, TIM_CHANNEL_2, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(pwmVal)</span><br><span class="line">        &#123;</span><br><span class="line">            pwmVal-=<span class="number">1</span>;;</span><br><span class="line">            __HAL_TIM_SetCompare(&amp;htim3, TIM_CHANNEL_2, pwmVal);</span><br><span class="line">            HAL_Delay(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!mode)</span><br><span class="line">            &#123;</span><br><span class="line">                __HAL_TIM_SetCompare(&amp;htim3, TIM_CHANNEL_2, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        HAL_Delay(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">/*此时占空比为0，代表全为低电平，这里的延迟可以使到达最暗或者最亮之后可以持续一会，以便于灯的变化更加顺畅*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(GPIO_Pin == KEY1_Pin)</span><br><span class="line">  &#123;</span><br><span class="line">      HAL_TIM_Base_Start_IT(&amp;htim2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(htim == &amp;htim2)</span><br><span class="line">    &#123;</span><br><span class="line">        HAL_TIM_Base_Stop_IT(&amp;htim2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(HAL_GPIO_ReadPin(KEY1_GPIO_Port,KEY1_Pin) == GPIO_PIN_RESET)</span><br><span class="line">        &#123;</span><br><span class="line">            mode = !mode; <span class="comment">// 注意切换模式要卸载消抖里面，否则可能会出现关不上灯的情况</span></span><br><span class="line">            <span class="comment">// HAL_GPIO_TogglePin(LED_BLUE_GPIO_Port,LED_BLUE_Pin);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">		</span><br></pre></td></tr></table></figure>

<p><strong>tips</strong>：</p>
<ul>
<li>如果感觉灯到达最亮或者最暗的时间比较慢，可以调整一次循环中pwmVal加或减的值，使亮度变化更平滑。</li>
<li>如果感觉灯到达最亮或者最暗之后的维持的一段时间比较慢(快)，可以修改每一次大循环的延迟，HAL_Delay(200)比较合适</li>
<li>每一次pwmVal加或减之后有一个HAL_Delay(1),在每次循环迭代中产生一个较小的延迟，因为每一次while循环都是很快的pwmVal+&#x3D;1的速度远远小于一个pwm输出周期的时间，如果删除它那么占空比将会很快到达0，我们肉眼观察就是瞬间亮了又瞬间灭了，而不会产生亮度慢慢变化的结果，一般设置为1ms即可</li>
</ul>
<p><strong>提问：每一个周期不应是有高电平和低电平吗，为什么观察到的不是LED灯一闪一闪的到达最亮或最暗呢？</strong></p>
<p>那么我们平时见到的LED灯，当它的频率大于50Hz的时候，人眼就会产生视觉暂留效果，基本就看不到闪烁了，而是一个常亮的LED灯，</p>
<p>你在1秒内，高电平0.5秒，低电平0.5秒，(频率1Hz)如此反复，那么你看到的电灯就会闪烁，</p>
<p>但是如果是10毫秒内，5毫秒打开，5毫秒关闭，(频率100Hz) 这时候灯光的亮灭速度赶不上开关速度(LED灯还没完全亮就又熄灭了)，由于视觉暂留作用 人眼不感觉电灯在闪烁，而是感觉灯的亮度少了 ，然后占空比在不断变化，所以才会感觉在慢慢变亮和慢慢变暗。</p>
<h4 id="业务代码-定时器修改占空比"><a href="#业务代码-定时器修改占空比" class="headerlink" title="业务代码(定时器修改占空比)"></a>业务代码(定时器修改占空比)</h4><blockquote>
<p>另外启用了一个定时器修改占空比，数秒内让占空比从0~100。假定5s内，那么0.05s(50ms)增加一占空比，所以PSC &#x3D; 72-1，ARR &#x3D; 20000-1。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 24-10-14.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">uint8_t</span> pwmVal1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">uint8_t</span> pwmVal2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">uint8_t</span> pwmVal3 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> flag1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> flag2 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> flag3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_1);</span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_2);</span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_3);</span><br><span class="line">    HAL_TIM_Base_Start_IT(&amp;htim4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(htim-&gt;Instance == TIM4)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 通道1的呼吸效果</span></span><br><span class="line">        <span class="keyword">if</span>(!flag1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pwmVal1 &lt; <span class="number">100</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pwmVal1 += <span class="number">1</span>;</span><br><span class="line">                __HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_1, pwmVal1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag1 = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pwmVal1 &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pwmVal1 -= <span class="number">1</span>;</span><br><span class="line">                __HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_1, pwmVal1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag1 = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通道2的呼吸效果</span></span><br><span class="line">        <span class="keyword">if</span>(!flag2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pwmVal2 &lt; <span class="number">100</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pwmVal2 += <span class="number">2</span>;</span><br><span class="line">                __HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_2, pwmVal2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag2 = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pwmVal2 &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pwmVal2 -= <span class="number">2</span>;</span><br><span class="line">                __HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_2, pwmVal2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag2 = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通道3的呼吸效果</span></span><br><span class="line">        <span class="keyword">if</span>(!flag3)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pwmVal3 &lt; <span class="number">100</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pwmVal3 += <span class="number">3</span>;</span><br><span class="line">                __HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_3, pwmVal3);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag3 = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pwmVal3 &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pwmVal3 -= <span class="number">3</span>;</span><br><span class="line">                __HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_3, pwmVal3);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag3 = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="实验-PWM控制无源蜂鸣器"><a href="#实验-PWM控制无源蜂鸣器" class="headerlink" title="实验-PWM控制无源蜂鸣器"></a>实验-PWM控制无源蜂鸣器</h3><p>通过改变<strong>PWM频率</strong>，可以输出不同频率的方波信号。用这个信号驱动<strong>无源蜂鸣器</strong>，便能播放不同频率的声音。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul>
<li>学习板上的蜂鸣器型号为：<strong>QMB-09B-03电磁式无源蜂鸣器</strong>。</li>
<li>蜂鸣器内部有一个<strong>电磁线圈</strong>，能够驱动<strong>振动膜片</strong>发出声音。通过PWM给蜂鸣器提供不同频率的信号，即可发出不同频率的声音</li>
<li>实际操作中，除了控制<strong>PWM频率</strong>，还需要控制<strong>PWM占空比</strong>，以使膜片振动趋近于正弦波，从而发出清脆明亮的声音。在学习板上，使用<strong>20%占空比</strong>可以有较好的响度和音质</li>
</ul>
<h4 id="CubeMX配置-3"><a href="#CubeMX配置-3" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h4><blockquote>
<ol>
<li><strong>配置Debug，打开外部晶振，配置时钟树</strong></li>
<li><strong>配置对应按键输入模式，上拉等</strong></li>
<li><strong>找到蜂鸣器对应的TIM引脚和通道，勾选对应TIM内部时钟，对应通道选择PWM生成模式</strong></li>
<li><strong>TIM参数：PSC &#x3D; 72-1 ARR &#x3D; 按照要求或随意</strong></li>
</ol>
</blockquote>
<h4 id="业务代码"><a href="#业务代码" class="headerlink" title="业务代码"></a>业务代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim4,TIM_CHANNEL_4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// KEY1按下: 输出2kHz声波</span></span><br><span class="line">    <span class="keyword">if</span>(HAL_GPIO_ReadPin(KEY1_GPIO_Port,KEY1_Pin) == GPIO_PIN_RESET)</span><br><span class="line">    &#123;</span><br><span class="line">        HAL_Delay(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">if</span>(HAL_GPIO_ReadPin(KEY1_GPIO_Port,KEY1_Pin) == GPIO_PIN_RESET)</span><br><span class="line">        &#123;</span><br><span class="line">            htim4.Instance-&gt;ARR = <span class="number">500</span>;<span class="comment">// 2kHz = 72MHz / 72 / 500</span></span><br><span class="line">            __HAL_TIM_SET_COMPARE(&amp;htim4, TIM_CHANNEL_4, <span class="number">500</span>/<span class="number">5</span>);<span class="comment">// 设置占空比为20%</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(HAL_GPIO_ReadPin(KEY1_GPIO_Port,KEY1_Pin) == GPIO_PIN_RESET);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY2按下: 输出3kHz声波</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(HAL_GPIO_ReadPin(KEY2_GPIO_Port,KEY2_Pin) == GPIO_PIN_RESET)</span><br><span class="line">    &#123;</span><br><span class="line">        HAL_Delay(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">if</span> (HAL_GPIO_ReadPin(KEY2_GPIO_Port,KEY2_Pin) == GPIO_PIN_RESET)</span><br><span class="line">        &#123;</span><br><span class="line">            htim4.Instance-&gt;ARR = <span class="number">334</span>; <span class="comment">// 3kHz = 72MHz / 72 / 334</span></span><br><span class="line">            __HAL_TIM_SET_COMPARE(&amp;htim4, TIM_CHANNEL_4, <span class="number">1000</span>/<span class="number">5</span>);<span class="comment">// 设置占空比为20%</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(HAL_GPIO_ReadPin(KEY1_GPIO_Port,KEY1_Pin) == GPIO_PIN_RESET);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 否则: 关闭声波输出</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        __HAL_TIM_SET_COMPARE(&amp;htim4, TIM_CHANNEL_4, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    HAL_Delay(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="实验-PWM控制直流电机"><a href="#实验-PWM控制直流电机" class="headerlink" title="实验-PWM控制直流电机"></a>实验-PWM控制直流电机</h3><p><strong>直流电机一端通正极，一端通负极就可以旋转,电压越大，旋转也就越快，正负极反过来还可以实现反转</strong></p>
<h4 id="DRV8833电机驱动模块"><a href="#DRV8833电机驱动模块" class="headerlink" title="DRV8833电机驱动模块"></a>DRV8833电机驱动模块</h4><p>我们控制的是单相电机，一个正极一个负极，分别接入IN1、IN2。</p>
<p><strong>通常驱动一个小电机需要几百毫安的电流</strong>，但单片机上的I&#x2F;O口只能支持几毫安的电流，直接接上可能会损坏STM32单片机。所有我们需要一个电机驱动芯片</p>
<p>，常见的有DRV8833等。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20240929204303792-1752338032550-3.png" alt="image-20240929204303792"></p>
<blockquote>
<p>一共4个IN口，4个OUT口。其中<strong>N1 IN2与OUT1 OUT2一组，N3 N4与OUT3 OUT4一组</strong>。</p>
<p>我们可以通过单片机输出PWM到IN1 IN2，来控制OUT1 OUT2的输出来控制电机。IN3 IN4同理，也就是说DRV8833电机芯片可以驱动两个电机。</p>
<p><strong>SLEPP引脚可以让芯片暂停工作，实现低功耗。</strong></p>
<p><strong>FAULT的脚可以在出现控制错误时提醒单片机</strong></p>
<p><strong>VCC和GND脚用于给芯片和电机供电</strong></p>
</blockquote>
<blockquote>
<p><strong>原理</strong></p>
<p><strong>停止旋转时：</strong></p>
<p><strong>STM32向IN1输入高电平，向IN2输入低电平时。OUT1输出高电平，OUT2输出低电平，使电机正转。</strong></p>
<p><strong>STM32向IN1输入低电平，向IN2输入高电平时，OUT1输出低电平，OUT2输出高电平，电机反转</strong>。</p>
<p><strong>旋转时</strong>：</p>
<p><strong>IN1、IN2都输入高电平</strong>，OUT1与OUT2都输出低电平，相当于将电机的两根线短路，由于电机内的转子由很多线圈组成，相当于电感，产生反电动势阻碍电流变化，因此电流在整个回路中是缓慢变小消失，这种情况称为<strong>电流慢衰减</strong>。反电动势产生的磁场与定子产生的磁场相互作用，会使电机转子很快的刹停，叫<strong>刹车</strong>。</p>
<p><strong>IN1、IN2都输入低电平</strong>，DRV8833会将OUT1与OUT2都输出高电平，使得转子电流瞬间释放，这种情况称为<strong>电流快衰减</strong>，相当于将电机的两根线断路，无回路不能形成磁场，此时会随着摩擦力慢慢停下来，叫<strong>滑行</strong>。</p>
</blockquote>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><blockquote>
<p><strong>正转</strong>：      </p>
<p><strong>IN1             IN2               OUT1          OUT2</strong>   </p>
<p><strong>PWM输入     低电平            正转&amp;滑行(快衰减)</strong>    </p>
<p>​         </p>
<p>电机一会处于正转一会处于滑行，<strong>PWM占空比越高，正转时间越长</strong>，宏观上来看也就是<strong>电机转速也就越快</strong>。</p>
<p><strong>IN1             IN2               OUT1          OUT2</strong>   </p>
<p><strong>高电平    PWM输入              正转&amp;刹车(慢衰减)</strong>                  </p>
<p>电机一会处于正转一会处于刹车，<strong>PWM占空比越低，正转时间越长</strong>，宏观上来看也就是<strong>电机转速也就越快</strong>。  </p>
<blockquote>
<p> <strong>滑行和刹车区别</strong>： 都可以实现控制电机转速，区别就在于占空比一个高越快，一个低越快</p>
<p> <strong>应用场景</strong>：</p>
<ul>
<li><p>快衰减能够迅速降低电流，故常用于需要快速变化的高动态响应场景。</p>
</li>
<li><p>慢衰减电流变化比较平稳，因而比较适合用于平稳运行，降低噪音的场景中</p>
</li>
</ul>
<p> <strong>对于小电机来说其实感受不到什么区别</strong></p>
</blockquote>
</blockquote>
<blockquote>
<p><strong>反转</strong>：</p>
<p><strong>IN1             IN2               OUT1          OUT2</strong>   </p>
<p><strong>低电平     PWM输入           反转&amp;滑行</strong>     </p>
<p><strong>IN1             IN2               OUT1          OUT2</strong>   </p>
<p><strong>PWM输入     高电平             反转&amp;刹车</strong>    </p>
</blockquote>
<p><strong>注意：占空比过低时，电机可能无法启动</strong></p>
<h4 id="CubeMX配置-4"><a href="#CubeMX配置-4" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h4><blockquote>
<ol>
<li><strong>配置Debug，打开外部晶振，配置时钟树</strong></li>
<li><strong>查看对应引脚对应的TIM通道，切换到TIM配置，选择内部时钟源，将对应通道设置为PWM生成模式(一个通道正转，一个通道反转)</strong></li>
<li><strong>TIM参数配置：PSC &#x3D; 72-1 ，ARR &#x3D; 100-1 ，PWM频率变为10000HZ</strong></li>
<li>其他配置</li>
<li>生成代码</li>
</ol>
</blockquote>
<h4 id="业务代码-1"><a href="#业务代码-1" class="headerlink" title="业务代码"></a>业务代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> message[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COUNT_MID 20 <span class="comment">//停止转动</span></span></span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> speed = <span class="number">0</span>;<span class="comment">//电机转速由counter计算而来</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_Delay(<span class="number">20</span>);</span><br><span class="line">    OLED_Init();</span><br><span class="line"></span><br><span class="line">    HAL_TIM_Encoder_Start(&amp;htim1, TIM_CHANNEL_ALL);</span><br><span class="line">    <span class="comment">/*使用旋转编码器控制电机转速*/</span></span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim2, TIM_CHANNEL_1);</span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim2, TIM_CHANNEL_2);</span><br><span class="line">    <span class="comment">/*启动两个通道*/</span></span><br><span class="line">    </span><br><span class="line">    __HAL_TIM_SET_COMPARE(&amp;htim2, TIM_CHANNEL_1,COUNT_MID);</span><br><span class="line">    <span class="comment">/*设置编码器初始值为20，停止转动*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    counter = __HAL_TIM_GET_COUNTER(&amp;htim1);</span><br><span class="line">    <span class="comment">/*控制编码器count在0~40之间，0~19代表反转,21~40代表正转，离中点越远转速越快,0最快反转,40最快正转*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(counter&gt;<span class="number">60000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        counter = <span class="number">0</span>;</span><br><span class="line">        __HAL_TIM_SET_COUNTER(&amp;htim2,<span class="number">0</span>);<span class="comment">//保持反转最快</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(counter&gt;COUNT_MID*<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        counter = COUNT_MID*<span class="number">2</span>;</span><br><span class="line">        __HAL_TIM_SET_COUNTER(&amp;htim2, COUNT_MID*<span class="number">2</span>);<span class="comment">//保持正转最快</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*控制counter的值在0~40之间*/</span> </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(counter &lt; COUNT_MID)</span><br><span class="line">    &#123;</span><br><span class="line">        speed = (COUNT_MID - counter) * <span class="number">100</span> /  COUNT_MID; <span class="comment">//通过控制counter0~19,使speed映射在0~100之间</span></span><br><span class="line">        </span><br><span class="line">        __HAL_TIM_SET_COMPARE(&amp;htim2, TIM_CHANNEL_2, speed);</span><br><span class="line">        __HAL_TIM_SET_COMPARE(&amp;htim2, TIM_CHANNEL_1, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">/*反转&amp;滑行*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        speed = (counter - COUNT_MID) * <span class="number">100</span> / COUNT_MID;<span class="comment">//通过控制counter21~40,使speed映射在0~100之间</span></span><br><span class="line">        </span><br><span class="line">        __HAL_TIM_SET_COMPARE(&amp;htim2, TIM_CHANNEL_1, speed);</span><br><span class="line">        __HAL_TIM_SET_COMPARE(&amp;htim2, TIM_CHANNEL_2, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">/*正转&amp;滑行*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OLED_NewFrame();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(message, <span class="string">&quot;counter:%d&quot;</span>, counter);</span><br><span class="line">    OLED_PrintString(<span class="number">0</span>, <span class="number">0</span>, message,&amp;font16x16,OLED_COLOR_NORMAL);</span><br><span class="line"></span><br><span class="line">    OLED_ShowFrame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>最好将该DRV8833模块拆分为单独的.c&#x2F;.h 实现驱动的编写!!!!</strong></p>
</blockquote>
<h4 id="驱动库"><a href="#驱动库" class="headerlink" title="驱动库"></a>驱动库</h4><p>DRV8833电机驱动：</p>
<p><a target="_blank" rel="noopener" href="https://led.baud-dance.com/">波特律动LED字模生成器 (baud-dance.com)</a></p>
<p><strong>可以参照别人写的驱动，自己编写代码!!!!!!!!</strong></p>
<h2 id="输入捕获"><a href="#输入捕获" class="headerlink" title="输入捕获"></a>输入捕获</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1HM4m1R75B/?spm_id_from=333.788&vd_source=830e63bd86bd9268c1b7cd9ff383f386">【STM32】动画讲解输入捕获 并实现超声波测距_哔哩哔哩_bilibili</a></p>
<h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p><strong>输入捕获</strong>：当定时器输入通道上检测到<strong>上升沿(或者下降沿)时</strong>，立刻将此时计数器的值记录到捕获寄存器中，等待程序稍后读取，并且可以借用另一个输入通道的捕获寄存器进行输入捕获。此种方法不会受到软件运行时间的干扰，更加准确。</p>
<h3 id="捕获寄存器"><a href="#捕获寄存器" class="headerlink" title="捕获寄存器"></a>捕获寄存器</h3><p>对于通用定时器和高级定时器来说，<strong>每个输入通道</strong>都有它自己的捕获寄存器，。</p>
<blockquote>
<p>假设我们启动了输入通道1(TI1FP1)的输入捕获模式，并且设定为上升沿捕获，定时器启动计数后，<strong>若输入到输入通道TI1的信号出现了一个上升沿，边沿检测器立即检测到就会通过TI1FP1传递到捕获寄存器1，捕获寄存器1便立刻将此时计数器的值复制到自身</strong>，如果对此输入捕获开启了中断，就还会触发输入捕获中断，通知程序尽快读取捕获寄存器中的数值，这样就获取到了<strong>上升沿出现时定时器的时刻，当我们再获取下降沿出现时定时器的时刻，就可以获得到高电平持续时间</strong></p>
<p>但一个输入通道的输入捕获只能进行上升沿捕获或者下降沿捕获，不能设置为双边沿捕获。所以STM32又从TI1上引出了一条线 连接到了<strong>捕获寄存器2</strong>上，这条线就是<strong>TI1FP2</strong>。</p>
<p><strong>输入捕获的直接模式和间接模式</strong>：<strong>信号从TI1引入</strong>，在自己的捕获寄存器1上进行输入捕获，就叫做<strong>输入捕获的直接模式</strong>。而借用捕获寄存器2进行输入捕获，则叫做<strong>输入捕获的间接模式</strong>。</p>
<p><strong>TI1和TI2是一对可以相互借用，TI3和TI4是一对可以相互借用</strong></p>
</blockquote>
<h3 id="相关函数-1"><a href="#相关函数-1" class="headerlink" title="相关函数"></a>相关函数</h3><p><strong>输入捕获函数启动</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_IC_Start(&amp;htim1, TIM_CHANNEL_3);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*IC就是input Capture输入捕获的意思*/</span></span><br></pre></td></tr></table></figure>



<p><strong>输入捕获中断</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_IC_Start_IT(&amp;htim1, TIM_CHANNEL_4);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*当下降沿来临时，说明高电平结束，我们需要获取两个输入捕获寄存器的值进行计算，因此需要在通道4捕获完成后,中断通知我们*/</span></span><br></pre></td></tr></table></figure>



<p><strong>读取捕获寄存器数值</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_ReadCapturedValue(&amp;htim1,TIM_CHANNEL_3);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*读取对应通道的捕获寄存器值*/</span></span><br></pre></td></tr></table></figure>



<p><strong>输入捕获中断回调</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_IC_CaptureCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*在输入捕获完成后将会进入该函数*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>定时器计数值设置</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__HAL_TIM_SET_COUNTER(&amp;htim1,<span class="number">0</span>);</span><br><span class="line"><span class="comment">/*参数1为对应定时器句柄，参数2为设置的值*/</span></span><br></pre></td></tr></table></figure>





<h3 id="输入捕获单通道测频率"><a href="#输入捕获单通道测频率" class="headerlink" title="输入捕获单通道测频率"></a>输入捕获单通道测频率</h3><ol>
<li><strong>CubeMX配置</strong></li>
</ol>
<p>只需要开启对应TIM时钟，配置对应引脚的对应通道为输入捕获直接模式(direct)。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250405141730990.png" alt="image-20250405141730990"></p>
<blockquote>
<ol>
<li><p><strong>TIM的ARR值要尽可能的大，避免在测量时CNT溢出</strong></p>
</li>
<li><p><strong>TIM的PSC也需要设置一些值，避免标准频率过快，在ARR很小时，计数很快，也容易溢出</strong></p>
</li>
</ol>
</blockquote>
<h4 id="业务代码-2"><a href="#业务代码-2" class="headerlink" title="业务代码"></a>业务代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">		HAL_TIM_IC_Start_IT(&amp;htim2,TIM_CHANNEL_1); <span class="comment">//输入捕获中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_IC_CaptureCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(htim == &amp;htim2)</span><br><span class="line">	&#123;</span><br><span class="line">		Frequent_A = <span class="number">1000000</span> / HAL_TIM_ReadCapturedValue(&amp;htim2,TIM_CHANNEL_1);</span><br><span class="line">        <span class="comment">/** 用APB外设进行PSC分频后的时钟计算频率，使用测周法，f = 				fa / N  </span></span><br><span class="line"><span class="comment">            fa = 80Mhz / PSC</span></span><br><span class="line"><span class="comment">            N = CCRx</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">		__HAL_TIM_SetCounter(&amp;htim2,<span class="number">0</span>);<span class="comment">//未配置从模式，所以需要手动清零</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意对于每次读取CCR之后都是一个新的周期开始，如果没有配置从模式触发CNT复位，那么我们需要在读取CCR手动将CNT复位，避免溢出</p>
</blockquote>
<h3 id="超声波测距介绍"><a href="#超声波测距介绍" class="headerlink" title="超声波测距介绍"></a>超声波测距介绍</h3><p><strong>超声波测距模块是各种需要测距的产品中常用的一类传感器</strong>：</p>
<blockquote>
<p><strong>测距原理</strong>：首先发送一定频率的超声波，超声波遇见被测物体后就会被反射回来，当模块接收到反射回来的超声波后，只要将超声波从发送到接收的时间差乘以声速，再除以2 , 就可以得到超声波测距模块和被测物体的距离了。</p>
<p>(发送时刻-接受时刻)×声速 ÷ 2 &#x3D; 距离</p>
<p>注意：若被测物体和超声波测距模块之间有障碍物，则测得的是障碍物的距离，因而某些场景不适合，但<strong>倒车雷达</strong>等需要对一个范围内进行测距的便非常合适。</p>
</blockquote>
<p><strong>超声波测距模块以HC-SR04为例：共有四个引脚</strong></p>
<blockquote>
<ul>
<li><p>VCC</p>
</li>
<li><p>GND</p>
</li>
<li><p><strong>控制端Trig</strong>：用于触发模块进行测距</p>
</li>
<li><p><strong>输出端Echo</strong>：用于测量模块输出的高电平持续时间</p>
</li>
</ul>
<p><strong>原理</strong>：当需要超声波测距时，只需要通过<strong>GPIO口向Trig引脚</strong>发送一个脉冲信号，超声波模块接收到脉冲信号就会向外发送一段超声波，然后模块会将Echo拉高，当模块接收到反射回来的超声波后，Echo会被拉低，<strong>那么Echo高电平持续时间也就是超声波在往返路途中消耗的时间</strong>。</p>
<p><strong>向Trig引脚发送脉冲信号(启动超声波测距)</strong>：先将GPIO口拉高，等待一会后，再将GPIO口拉低即可，<strong>等待的时间可以查看超声波模块手册(us级别）</strong></p>
<p><strong>测量Echo上高电平持续时间(得到超声波往返时间)</strong>：使用STM32定时器上的<strong>输入捕获,通过两个输入捕获寄存器的差可以得到高电平持续时间</strong></p>
</blockquote>
<ol>
<li><strong>CubeMX配置</strong></li>
</ol>
<blockquote>
<p> <strong>CubeMX配置</strong>：</p>
<p> 先启动Debug，开启外部晶振，配置时钟树72MHZ，使用OLED屏幕显示测距，所以打开I2C1。</p>
<p> 查看手册找到控制端Trig和输出端Echo对应引脚，Trig配置为GPIO_Output，Echo配置为TIM1_CH3，并打好对应Label</p>
<p> 然后转到TIM1，选择内部时钟源，配置TIM1的Channel3为输入捕获直接模式(Input Caputure direct mode)，配置Channel4为输入捕获间接模式(indirect)</p>
<p> 转到参数设置：PSC设置为72-1，计数器频率变为1MHZ，每1us计数值+1</p>
<p> Arr &#x3D; 65535</p>
<p> <strong>Input Capture Channel 3</strong> ：设置<strong>上升沿检测</strong>，<strong>输入捕获直接模式(direct)</strong>，<strong>捕获寄存器前的分频设置为不分频</strong>，<strong>Input Filter(滤波)为0</strong>，因为没什么抖动所以不用滤波。</p>
<p> <strong>Input Capture Channel 4</strong>：置<strong>下降沿检测</strong>，<strong>输入捕获间接模式(indirect)</strong>，<strong>捕获寄存器前的分频设置为不分频</strong>，<strong>Input Filter(滤波)为0</strong>，</p>
<p> 因为需要使用中断模式，<strong>最后使能TIM1捕获比较中断(TIM1 capture compare interrupt)</strong></p>
</blockquote>
<h4 id="业务代码-3"><a href="#业务代码-3" class="headerlink" title="业务代码"></a>业务代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> upEdge = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> downEdge = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> distance = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_Delay(<span class="number">20</span>);</span><br><span class="line">    OLED_Init();</span><br><span class="line"></span><br><span class="line">    HAL_TIM_Base_Start(&amp;htim1);<span class="comment">//启动定时器</span></span><br><span class="line">    HAL_TIM_IC_Start(&amp;htim1, TIM_CHANNEL_3);<span class="comment">//启动上升沿输入捕获</span></span><br><span class="line">    HAL_TIM_IC_Start_IT(&amp;htim1, TIM_CHANNEL_4);<span class="comment">//启动下降沿输入捕获,此处中断启动，因为得到捕获值后要计算</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="comment">/*Tig引脚发送脉冲信号：先拉高Trig引脚，等待一段时间后，再拉低     用于启动超声波测距*/</span></span><br><span class="line">    HAL_GPIO_WritePin(Trig_GPIO_Port,Trig_Pin,GPIO_PIN_SET);</span><br><span class="line">    HAL_Delay(<span class="number">1</span>);</span><br><span class="line">    HAL_GPIO_WritePin(Trig_GPIO_Port,Trig_Pin,GPIO_PIN_RESET);</span><br><span class="line">    <span class="comment">/*重置计数器的值，避免下降沿捕获数值小于上升沿捕获数值*/</span></span><br><span class="line">    __HAL_TIM_SET_COUNTER(&amp;htim1,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*使用显示器*/</span></span><br><span class="line">    OLED_NewFrame();</span><br><span class="line">    <span class="built_in">sprintf</span>(message,<span class="string">&quot;距离：%.2fcm&quot;</span>,distance);</span><br><span class="line">    OLED_PrintString(<span class="number">0</span>,<span class="number">0</span>,message,&amp;font16x16,OLED_COLOR_NORMAL);</span><br><span class="line">    OLED_ShowFrame();</span><br><span class="line">    </span><br><span class="line">    HAL_Delay(<span class="number">500</span>);<span class="comment">//缓慢发送</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_IC_CaptureCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*在HAL_TIM_IRQHandler中可以发现每次进入中断回调函数前，htim-&gt;Channel都会被重新赋值*/</span></span><br><span class="line">    <span class="comment">/*以表示当前处理的是哪个通道, 注意和之前的HAL_CHANNEL_4是不同的*/</span></span><br><span class="line">    <span class="keyword">if</span>(htim == &amp;htim1 &amp;&amp; htim-&gt;Channel == HAL_TIM_ACTIVE_CHANNEL_4)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        upEdge = HAL_TIM_ReadCapturedValue(&amp;htim1,TIM_CHANNEL_3);</span><br><span class="line">        <span class="comment">/*分别通过两个捕获寄存器得到上升沿对应计数和下降沿对应计数*/</span></span><br><span class="line">        downEdge = HAL_TIM_ReadCapturedValue(&amp;htim1,TIM_CHANNEL_4);</span><br><span class="line">        distance = (upEdge - downEdge) * <span class="number">0.034</span> / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">/*TIM分频后为1Mhz即1μs一次,声速影响条件较多，这里取340m/s，即0.034cm/us,最后单位为cm*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>启动超声波测距</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">startMeasureDistance</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*Trig引脚发送脉冲信号：先拉高Trig引脚，等待一段时间后，再拉低     用于启动超声波测距*/</span></span><br><span class="line">    HAL_GPIO_WritePin(Trig_GPIO_Port,Trig_Pin,GPIO_PIN_SET);</span><br><span class="line">    HAL_Delay(<span class="number">1</span>);</span><br><span class="line">    HAL_GPIO_WritePin(Trig_GPIO_Port,Trig_Pin,GPIO_PIN_RESET);</span><br><span class="line">    <span class="comment">/*重置计数器的值，避免下降沿捕获数值小于上升沿捕获数值*/</span></span><br><span class="line">    __HAL_TIM_SET_COUNTER(&amp;htim1,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>计算高电平持续时间和被测物体距离</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_IC_CaptureCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*在HAL_TIM_IRQHandler中可以发现每次进入中断回调函数前，htim-&gt;Channel都会被重新赋值*/</span></span><br><span class="line">    <span class="comment">/*以表示当前处理的是哪个通道, 注意和之前的HAL_CHANNEL_4是不同的*/</span></span><br><span class="line">    <span class="keyword">if</span>(htim == &amp;htim1 &amp;&amp; htim-&gt;Channel == HAL_TIM_ACTIVE_CHANNEL_4)</span><br><span class="line">    &#123;</span><br><span class="line">        upEdge = HAL_TIM_ReadCapturedValue(&amp;htim1,TIM_CHANNEL_3);</span><br><span class="line">        downEdge = HAL_TIM_ReadCapturedValue(&amp;htim1,TIM_CHANNEL_4);</span><br><span class="line">        distance = (downEdge - upEdge) * <span class="number">0.034</span> / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">/*TIM分频后为1Mhz即1μs一次,声速影响条件较多，这里取340m/s，即0.034cm/us,最后单位为cm*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="旋转编码器"><a href="#旋转编码器" class="headerlink" title="旋转编码器"></a>旋转编码器</h2><p><strong>概念</strong>：用来测量位置、速度或旋转方向的传感器，当期旋转轴旋转时，其输出端可以输出与<strong>旋转速度和方向对应的方波信号</strong>，读取方波信号的频率和相位信息可以得知<strong>旋转轴的速度和方向</strong>。</p>
<p><strong>常见的有</strong>：<strong>增量型旋转编码器、绝对型编码器</strong>等</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1f4421U7Uj/?spm_id_from=333.337.search-card.all.click&vd_source=830e63bd86bd9268c1b7cd9ff383f386">【STM32教程】扭扭扭，转转转，轻松掌握编码器！_哔哩哔哩_bilibili</a></p>
<h3 id="增量型旋转编码器"><a href="#增量型旋转编码器" class="headerlink" title="增量型旋转编码器"></a>增量型旋转编码器</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p><strong>增量型旋转编码器一般有A、B两相输出信号</strong>，当旋转编码器没有旋转时，A、B两相均没有电平变化，稳定输出高电平或者低电平。</p>
<p>当旋转编码器被<strong>顺时针旋转</strong>时，A相会输出一个方波，B相此时也会输出一个方波，但是<strong>B相方波领先A相90度</strong>，也就是B相先产生上升沿&#x2F;下降沿，稍后A相再产生上升沿&#x2F;下降沿。也可以说A相上升沿时，B相为高电平，A相为下降沿时，B相为低电平。</p>
<p>当<strong>逆时针旋转时</strong>，情况相反，<strong>B相方波落后A相90度</strong>，A相上升沿时，B相为低电平，A相为上升沿时，B相为高电平。</p>
<blockquote>
<p><strong>这样我们可以</strong>：</p>
<ol>
<li>通过计算A相或者B相上升沿或者下降沿的数量来获取旋转编码器的角度。</li>
<li>可以通过A相边沿时，B相电平的情况得知当前的旋转方向</li>
</ol>
<p><strong>注意</strong>：不同旋转方向下A、B相到底谁在前谁在后，也可能根据具体元器件的不同而反过来！！！！</p>
</blockquote>
<blockquote>
<p>查阅旋转编码器的手册中可以看到，20 pulses&#x2F;360°，即每360读输出20个脉冲，也就是每个脉冲为18°，所以用**脉冲数量乘以18°**就能得到真实的旋转角度</p>
<p><strong>旋转角度° &#x3D; 脉冲数量 * 每个脉冲对应的角度</strong> </p>
<p>当然对于旋钮这种用户输入，我们一般只需要知道用户向哪个方向旋转了多大程度就好，不必计算真实角度</p>
</blockquote>
<h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><blockquote>
<p><strong>思路1(中断)</strong>：</p>
<ol>
<li><p>将A、B相信号接入到GPIO口后，将A相的GPIO口设置为上升沿(或者下降沿触发中断)，然后再<strong>中断回调</strong>中读取B相GPIO口的电平状态，即可判断旋转方向。</p>
</li>
<li><p>同时，根据旋转方向对计数值加1或减1，来记录脉冲数量。</p>
</li>
</ol>
<p><strong>缺点</strong>：</p>
<p>处理单片机上转的慢的旋钮效果不错，但是处理转的非常快的电机的旋转编码器时，<strong>容易频繁触发中断，导致CPU工作效率低</strong>，还有可能出现软件处理跟不上导致<strong>丢步问题</strong>。</p>
</blockquote>
<blockquote>
<p><strong>思路2(定时器)</strong>:</p>
<p>通用&#x2F;高级定时器为增量型编码器准备了<strong>专门的编码器接口</strong>，只要将A、B两相信号同时输入进去就可以实现<strong>正传时计数器自增，反转时计数器自减</strong>。</p>
<p><strong>那么我们将如何将A、B相信号输入编码器呢？</strong></p>
<p>编码器两个输入接口其实是早已了解过的TI1FP1和TI2FP2，也就是说我们**直接将A、B相信号接入到定时器的通道1(TI1)和通道2(TI2)，就可以接入到编码器接口，让编码器可以根据A、B相的信号 控制计数器进行增加和减少,**而且还可以利用这两个通道的滤波器与边沿检测器对A、B相信号初步处理</p>
</blockquote>
<blockquote>
<p><strong>编码器接口对上下边沿都很敏感</strong>，对于A、B相上的一组脉冲会计数两次。例如：A相下降沿时，B相为低电平，计数器+1，A相上升沿时，B相为高电平，计数器又+1。反向时同理。</p>
<p><strong>一句话来说就是：一个脉冲上下降沿都会被计数，一共两次</strong></p>
</blockquote>
<h3 id="实验-使用增量型旋转编码器控制小灯亮度"><a href="#实验-使用增量型旋转编码器控制小灯亮度" class="headerlink" title="实验-使用增量型旋转编码器控制小灯亮度"></a>实验-使用增量型旋转编码器控制小灯亮度</h3><h4 id="CubeMX配置-5"><a href="#CubeMX配置-5" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h4><ol>
<li><p><strong>配置Debug，打开外部晶振，配置时钟树</strong></p>
</li>
<li><p><strong>查阅原理图找到A相、B相、按键找到对应引脚和TIM(该板为TIM1)，配置引脚和TIM</strong></p>
</li>
<li><p><strong>由于旋转编码器能自主产生两路信号，故不用配置内部时钟源。直接找到Combined Channels(组合通道)设置，选择为Encoder Mode(编码器模式)，引脚自动被设置。</strong></p>
</li>
<li><p><strong>旋转编码器对应定时器参数配置</strong>：</p>
</li>
</ol>
<blockquote>
<blockquote>
<p><strong>Counter Settings</strong>:</p>
<p>PSC：默认为0不分频，由于编码器对上下沿都敏感，此时编码器旋转一次计数为2，如果想要旋转一次计数器计数为1的话，设置PSC &#x3D; 2-1 (二分频)即可，或者可以在代码中手动对counter值进行修改</p>
<p>ARR：编码器对应定时器的计数器，保持默认的65535，或设置为想要的值即可</p>
</blockquote>
<blockquote>
<p><strong>Encoder</strong>：</p>
<p>Encoder Mode：是选择在哪个通道进行计数，如果选择两个通道都计数的话，一个脉冲将会被计数4次，通常配置为TI1即可</p>
<p>Polarity(极性设置)：类似于有效电平机制，设置下降沿有效，会将此通道波形翻转，如果与平时顺时针增加，逆时针减少不符，可<strong>以修改一个通道的极性即可</strong></p>
<p>IC Selection(输入捕获)：只能进行直接捕获 走TI1FP1和TI2FP2</p>
<p>Prescaler Division Ratio(预分频器分频比)：不进行预分频</p>
<p>Input Filter(输入滤波)：可以设置为最大值15，不滤波其实也没为问题</p>
</blockquote>
</blockquote>
<ol start="5">
<li>编码器可以按下当按键使用，配置为输入模式或中断模式都可，注意是否需要开启内部上拉。</li>
<li>为了实现亮度调节，找到小灯对应的定时器设置(这里为TIM3)，勾选内部时钟源，将通道设置为PWM生成模式(PWM Generation)，PSC &#x3D; 72-1  ARR &#x3D; 100-1</li>
<li>为了使用OLED，打开I2C1</li>
</ol>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ul>
<li><strong>编码器启动</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_Encoder_Start(&amp;htim1,TIM_CHANNEL_ALL);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*参数1：定时器对应结构体句柄*/</span></span><br><span class="line"><span class="comment">/*参数2：对应通道，对于只有一相信号的单相编码器来说，填通道1或2。若有A、B两项以上的，一般填TIM_CHANNEL_ALL，所有通道,其实也就是通道1和2。*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>获取定时器计数值</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__HAL_TIM_GET_COUNTER(&amp;htim1);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*内部库使用，能够获取当前的计数器值，编码器旋转时计数值会自增或自减*/</span></span><br></pre></td></tr></table></figure>



<h4 id="业务代码-4"><a href="#业务代码-4" class="headerlink" title="业务代码"></a>业务代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> Channel[<span class="number">3</span>] = &#123;TIM_CHANNEL_1, TIM_CHANNEL_2, TIM_CHANNEL_3&#125;;</span><br><span class="line"><span class="type">int</span> ChannelIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_Delay(<span class="number">20</span>);</span><br><span class="line">    OLED_Init();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/*启动编码器，启动小灯的PWM输出*/</span></span><br><span class="line">    HAL_TIM_Encoder_Start(&amp;htim1, TIM_CHANNEL_ALL);</span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim3,TIM_CHANNEL_1);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     counter = __HAL_TIM_GET_COUNTER(&amp;htim1);</span><br><span class="line">    __HAL_TIM_SET_COMPARE(&amp;htim3, Channel[ChannelIndex], counter);</span><br><span class="line">    <span class="comment">/*每次循环更新encoder定时器的计数值*/</span></span><br><span class="line">    </span><br><span class="line">    OLED_NewFrame();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(message, <span class="string">&quot;counter:%d&quot;</span>, counter);</span><br><span class="line">    OLED_PrintString(<span class="number">0</span>, <span class="number">0</span>, message, &amp;font16x16, OLED_COLOR_NORMAL);</span><br><span class="line">    OLED_DrawRectangle(<span class="number">0</span>,<span class="number">20</span>,<span class="number">100</span>,<span class="number">12</span>,OLED_COLOR_NORMAL);</span><br><span class="line">    OLED_DrawFilledRectangle(<span class="number">1</span>,<span class="number">20</span>,counter,<span class="number">12</span>,OLED_COLOR_NORMAL);</span><br><span class="line">    OLED_ShowFrame();</span><br><span class="line">    HAL_Delay(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">/*OLED上显示counter，和进度条*/</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (GPIO_Pin == KEY_ENCODER_Pin)</span><br><span class="line">    &#123;</span><br><span class="line">        HAL_TIM_PWM_Stop(&amp;htim3,Channel[ChannelIndex]);</span><br><span class="line">        ChannelIndex = (ChannelIndex+<span class="number">1</span>)%<span class="number">3</span>;</span><br><span class="line">        HAL_TIM_PWM_Start(&amp;htim3,Channel[ChannelIndex]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*实现按下编码器切换小灯，未作消抖处理*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="舵机-SERVO"><a href="#舵机-SERVO" class="headerlink" title="舵机(SERVO)"></a>舵机(SERVO)</h2><p>概念：舵机由于经常用于控制航模船模的舵面而得名，是一种比较简易的伺服电机系统。</p>
<h3 id="原理-PWM"><a href="#原理-PWM" class="headerlink" title="原理(PWM)"></a>原理(PWM)</h3><blockquote>
<p>以SG90为例，可以控制舵机从0°旋转到180°<strong>，查看舵机手册</strong>可以得到0<del>180°分别对应着500</del>2500us的高电平时长。</p>
<p>我们见到的多数舵机通常使用<strong>50HZ</strong>，也就是<strong>周期为20ms的PWM信号</strong>进行控制，因而500us~2500us对应的占空比为：</p>
<p>500us<del>2500us&#x2F;20ms &#x3D; 2.5%</del>12.5% -&gt; 0°~180°  </p>
<p>即输出占空比为2.5%时，舵机旋转到0°，输出占空比为7.5%，舵机旋转到90°，输出占空比为12.5%时，舵机旋转到180°</p>
<p><strong>绝大多数舵机控制的占空比范围都是2.5%~12.5%，因为绝大多数的航模遥控器也是输出这个范围的信号</strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/99-1752338032550-4.png" alt="image-20241123213856589"></p>
<h3 id="实验-使用旋转编码器控制舵机-SG90-旋转"><a href="#实验-使用旋转编码器控制舵机-SG90-旋转" class="headerlink" title="实验-使用旋转编码器控制舵机(SG90)旋转"></a>实验-使用旋转编码器控制舵机(SG90)旋转</h3><h4 id="CubeMX配置-6"><a href="#CubeMX配置-6" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h4><ol>
<li><strong>配置Debug，打开外部晶振，配置时钟树</strong></li>
<li><strong>配置好旋转编码器</strong>，PSC默认，ARR设置为20，其余默认即可</li>
<li>查看手册找到舵机对应TIM，打开内部时钟，配置对应通道的PWM生成模式。</li>
<li>使用<strong>50HZ</strong>的PWM信号，假设TIM的内部时钟为72MHZ，配置PSC为720-1 ，ARR &#x3D; 2000-1。</li>
<li>生成代码</li>
</ol>
<blockquote>
<p>注意：因为旋转编码器20个脉冲对应的是360°，也就是计数40次。而舵机只能旋转180°，所以最大计数值应该设为20</p>
</blockquote>
<h4 id="业务代码-5"><a href="#业务代码-5" class="headerlink" title="业务代码"></a>业务代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_COUNT 20</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> message[<span class="number">50</span>]</span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> duty = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// AHT20_Init();</span></span><br><span class="line"></span><br><span class="line">    HAL_Delay(<span class="number">20</span>);</span><br><span class="line">    OLED_Init();</span><br><span class="line"></span><br><span class="line">    HAL_TIM_Encoder_Start(&amp;htim1, TIM_CHANNEL_ALL);</span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim4,TIM_CHANNEL_3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    counter = __HAL_TIM_GET_COUNTER(&amp;htim1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*占空比(duty cycle)*/</span></span><br><span class="line">    duty = ((((<span class="type">float</span>)counter / MAX_COUNT)*<span class="number">10</span> + <span class="number">2.5</span>)/<span class="number">100.0</span>)*<span class="number">2000</span>;</span><br><span class="line">    <span class="comment">/*定时器最大值为2000,计算占空比为2.5%~12.5%对应的比较寄存器的值*/</span></span><br><span class="line">    __HAL_TIM_SET_COMPARE(&amp;htim4, TIM_CHANNEL_3, duty);</span><br><span class="line"></span><br><span class="line">    OLED_NewFrame();</span><br><span class="line">    <span class="built_in">sprintf</span>(message, <span class="string">&quot;counter:%d&quot;</span>, counter);</span><br><span class="line">    OLED_PrintString(<span class="number">0</span>, <span class="number">0</span>, message,&amp;font16x16,OLED_COLOR_NORMAL);</span><br><span class="line">    OLED_ShowFrame();</span><br><span class="line">    HAL_Delay(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="看门狗"><a href="#看门狗" class="headerlink" title="看门狗"></a>看门狗</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>STM32微控制器中的看门狗外设是一种用于<strong>监视系统运行的外设，它是一种硬件计时器，用于检测系统是否正常运行</strong>。其基本原理是周期性地重置系统，以确保系统在正常情况下能够响应。当系统出现异常情况（如死循环、软件错误等）导致停止响应时，看门狗定时器将超时并执行其预设的动作，例如重置系统或触发中断，从而使系统得以恢复或采取适当的措施。</p>
<p>在STM32微控制器中，看门狗外设主要分为两种类型：<strong>独立看门狗和窗口看门狗。</strong></p>
<h2 id="独立看门狗"><a href="#独立看门狗" class="headerlink" title="独立看门狗"></a>独立看门狗</h2><p><strong>独立看门狗-IWDG</strong>(Independent Watchdog)：</p>
<ul>
<li><strong>特点</strong>： 独立看门狗是一种基本的看门狗类型，本质是一个单独的定时器，独立于主处理器，即使主时钟发生故障仍然有效。</li>
<li><strong>驱动时钟</strong>：由专用的低速时钟（LSI）驱动（40kHz），由于LSI的时钟频率不精确，故<strong>独立看门狗只适用于对时间精度要求比较低的场合</strong>。</li>
<li><strong>用途</strong>： <strong>独立看门狗主要用于监视整个系统的运行状态</strong>。当系统出现故障、死锁或其他异常情况时，独立看门狗会在预设的超时时间内未收到系统的喂狗信号时，触发重启操作，以恢复系统的正常运行。</li>
</ul>
<blockquote>
<p>独立看门狗可以简单理解为<strong>一个12位的递减计数器</strong>，看门狗激活后，如果计数器的重装载值递减到0，系统就会产生复位。如果在计数器递减到0之前刷新了计数器值，那么系统就不会产生复位。<strong>这个刷新计数器的过程我们称为”喂狗”</strong></p>
</blockquote>
<h3 id="CubeMX配置-7"><a href="#CubeMX配置-7" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h3><p>LSI时钟并不直接提供给计数器时钟，而是通过一个8位的预分频器寄存器IWDG_PR分频后输入给计数器时钟(具体见STM32xxxx的参考手册IWDG寄存器章节)。</p>
<blockquote>
<p>CubeMX配置:</p>
<p>预分频系数prescaler取值：4、8、16、32、64、128、256。</p>
<p>溢出时间：Tout &#x3D; (4*2^pre^ )  &#x2F; 40 * rl r &#x3D;  (prescaler&#x2F;40) *rlr    单位：ms</p>
<ul>
<li><p>pre是预分频系数(0-6)，而(4*2^pre^)是prescaler的取值代表4分频、8分频等。</p>
</li>
<li><p>rlr是重装载寄存器的值   (12位,rlr&lt;4096,即0xFFF)</p>
</li>
<li><p>40KHz为LSI输入时钟频率</p>
</li>
<li><p>prescaler&#x2F;40是分频后的频率的倒数即周期，再乘rlr代表定时器溢出时间</p>
</li>
</ul>
</blockquote>
<h3 id="相关函数-2"><a href="#相关函数-2" class="headerlink" title="相关函数"></a>相关函数</h3><p><strong>看门狗初始化函数</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_IWDG_Init(IWDG_HandleTypeDef *hiwdg)</span><br></pre></td></tr></table></figure>

<p><strong>喂狗函数</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_IWDG_Refresh(IWDG_HandleTypeDef *hiwdg)</span><br><span class="line">    </span><br><span class="line">举例：  HAL_IWDG_Refresh(&amp;hiwdg);   <span class="comment">//看门狗喂狗</span></span><br></pre></td></tr></table></figure>



<h2 id="窗口看门狗"><a href="#窗口看门狗" class="headerlink" title="窗口看门狗"></a>窗口看门狗</h2><p><strong>窗口看门狗-WWDG</strong>(Window Watchdog)：</p>
<ul>
<li><strong>特点：</strong> 窗口看门狗是一种高级的看门狗类型，它具有两个阈值，即看门狗窗口。只有在这个窗口内喂狗信号才被视为有效，超出窗口范围的喂狗信号会被视为异常。</li>
<li><strong>驱动时钟</strong>：由APB1时钟(如：36MHZ)分频后得到时钟驱动，通过可配置的时间窗口来检测应用程序非正常的过迟或过早操作。 窗口看门狗最适合那些要求看门狗在精确计时窗口起作用的程序。</li>
<li><strong>用途：</strong> 窗口看门狗不仅可以监视系统的整体运行状态，还可以检测特定时间段内的系统运行状态。<strong>它可以帮助系统在特定的时间窗口内完成任务，以确保系统的实时性和稳定性</strong>。比如一个程序段正常运行的时间是50ms， 在运行完这个段程序之后紧接着进行喂狗，如果在规定的时间窗口内还没有喂狗，那就说明我们监控的程序出故障了，跑飞了，那么就会产生系统复位，让程序重新运行。</li>
</ul>
<blockquote>
<p>窗口看门狗跟独立看门狗一样，也是一个递减计数器不断的往下递减计数，当减到一个固定值 <strong>0x3F</strong> 时还不喂狗的话，产生复位，这个值叫窗口的下限，是固定的值，不能改变。</p>
<p>窗口看门狗之所以称为窗口，就是因为<strong>其喂狗时间限制在一个有上下限(上下窗口)的范围内（计数器减到某个值~计数器减到0x3F），在这个范围内才可以喂狗，可以通过设定相关寄存器，设定其上限时间（但是下限是固定的0x3F）</strong></p>
</blockquote>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>相比于独立看门狗，窗口看门狗可以使能中断，如果使能了提前唤醒中断，系统出现问题，喂狗函数没有生效，那么在计数器由减到<strong>0x40 (0x3F+1)</strong>  的时候，<strong>便会先进入中断，之后再递减一次才会复位</strong>。当然你也可以在中断里面喂狗</p>
<blockquote>
<p><strong>喂狗的操作，必须要在主循环里，而不能放在定时器中断里</strong>！这是很多初学者容易犯的错误！因为，如果出现了主循环跑飞或者陷入某个死循环，定时器中断可能还在正常运行，定期进入中断喂狗，则看门狗不能复位系统，起不到监测系统正常运行的作用；</p>
</blockquote>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><blockquote>
<ol>
<li><p>预分频系数选择(prescaler)：1、2、4、8</p>
</li>
<li><p>window value：上窗口值（要求在0x3F和计数器值之间）</p>
</li>
<li><p>free-running downcounter value：向下递减的计数器值，如果不喂狗到0x3F会复位MCU(有7位，取值为0~127)</p>
</li>
<li><p>Early wakeup interrupt：Enable使能提前唤醒中断，并开启中断</p>
</li>
</ol>
</blockquote>
<blockquote>
<p>若APB1时钟为36MHZ，选择8分频，计数器取最大值127,上窗口设置为126</p>
<p>分频后 CLK &#x3D; (APB1CLK&#x2F;4096)&#x2F;8 &#x3D; 1098.63281HZ</p>
<p>(127-126)&#x2F;1098.63281 &#x3D; 0.910ms (递减到上窗口的最短时间)</p>
<p>(127-0x3F)&#x2F;1098.63281 &#x3D;  58.25ms(递减到下窗口的最长时间)</p>
<p>喂狗窗口期为：0.910ms~58.25ms，超出这个时间没有喂狗那么MCU就会复位</p>
</blockquote>
<h3 id="相关函数-3"><a href="#相关函数-3" class="headerlink" title="相关函数"></a>相关函数</h3><p><strong>看门狗初始化</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_WWDG_Init(WWDG_HandleTypeDef *hwwdg)</span><br></pre></td></tr></table></figure>

<p><strong>喂狗</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_WWDG_Refresh(WWDG_HandleTypeDef *hwwdg)</span><br></pre></td></tr></table></figure>

<p><strong>看门狗中断处理函数</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_WWDG_IRQHandler(WWDG_HandleTypeDef *hwwdg)</span><br></pre></td></tr></table></figure>

<p><strong>看门狗中断回调函数</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__weak <span class="title function_">HAL_WWDG_EarlyWakeupCallback</span><span class="params">(WWDG_HandleTypeDef *hwwdg)</span>;</span><br></pre></td></tr></table></figure>



<h3 id="实验-3"><a href="#实验-3" class="headerlink" title="实验"></a>实验</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*创建的user.c中*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wwdg.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> early_wwdg_flag = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*中断发生标志位*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setUp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">		HAL_GPIO_WritePin(LED0_GPIO_Port,LED0_Pin,GPIO_PIN_RESET);</span><br><span class="line">		HAL_GPIO_WritePin(LED1_GPIO_Port,LED1_Pin,GPIO_PIN_RESET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">if</span>(early_wwdg_flag==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			HAL_GPIO_WritePin(LED1_GPIO_Port,LED1_Pin,GPIO_PIN_SET);</span><br><span class="line">			HAL_WWDG_Refresh(&amp;hwwdg);</span><br><span class="line">        </span><br><span class="line">			early_wwdg_flag = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*清除该标志位，等待下一次中断喂狗,避免一直重复喂狗*/</span></span><br><span class="line">		&#125;s</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_WWDG_EarlyWakeupCallback</span><span class="params">(WWDG_HandleTypeDef *hwwdg)</span></span><br><span class="line">&#123;</span><br><span class="line">			early_wwdg_flag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>设置了一个中断进入标志位，当主循环中检测到进入中断后，则喂狗，避免复位</p>
<p>烧录到开发板后可以看到，LED1亮起之后熄灭，没有再亮起，代表没有复位，实验成功。</p>
<p><strong>注意：最好不要在中断回调函数中喂狗</strong></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/as480133937/article/details/99121645">【STM32】HAL库 STM32CubeMX教程五—-看门狗(独立看门狗,窗口看门狗)_使用hall库程序跑飞-CSDN博客</a></p>
<h1 id="传感器模块"><a href="#传感器模块" class="headerlink" title="传感器模块"></a>传感器模块</h1><p>传感器元件(光敏电阻&#x2F;热敏电阻&#x2F;红外接收管等)的电阻会随外界的模拟量的变化而变化，通过与<strong>定值电阻分压即可得到模拟电压输出，再通过电压比较器进行二值化即可得到数字电压输出</strong>。</p>
<h1 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Analog-to-Digital Converter的缩写。指模&#x2F;数转换器或者模拟&#x2F;数字转换器。是指将连续变量的<strong>模拟信号</strong>转换为离散的<strong>数字信号</strong>的器件。</p>
<p>典型的模拟数字转换器将<strong>模拟信号</strong>转换为表示一定比例<strong>电压值的数字信号。</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/as480133937/article/details/99627062">【STM32】HAL库 STM32CubeMX教程九—ADC_cubemx adc-CSDN博客</a></p>
<p><strong>重要概念</strong>：</p>
<ol>
<li>转换模式：<strong>单次转换模式，连续转换模式，扫描模式，间断模式</strong>等</li>
<li>ADC单&#x2F;多通道</li>
<li>数据左&#x2F;右对齐</li>
<li>电压输入范围</li>
<li>ADC输入通道</li>
<li>注入通道(和中断类似)，规则通道</li>
<li>ADC时钟</li>
<li>外部触发转换(定时器、中断)</li>
<li>中断触发条件三个：<strong>规则通道转换结束</strong>、<strong>注入通道转换结束</strong>、<strong>模拟看门狗状态位被设置</strong></li>
<li>DMA触发：只有ADC1和ADC3才可，通常使用ADC都开启DMA</li>
</ol>
<h2 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h2><p>CubeMX中配置</p>
<p>1. </p>
<blockquote>
<p><strong>ADCs_Common_Settings</strong>:<br><strong>Mode</strong>     ADC_Mode_Independent<br>这里设置为独立模式</p>
<p>独立模式模式下，双ADC不能同步，每个ADC接口独立工作。所以如果不需要ADC同步或者只是用了一个ADC的时候，应该设成独立模式，多个ADC同时使用时会有其他模式，如双重ADC同步模式，两个ADC同时采集一个或多个通道，可以提高采样率</p>
<p><strong>Data Alignment</strong> (数据对齐方式): 右对齐&#x2F;左对齐</p>
<p>这个上方有讲解，数据的左右对齐</p>
<p><strong>Scan Conversion Mode</strong>( 扫描模式 ) ：   </p>
<p>如果只是用了一个通道的话，DISABLE就可以了(也只能DISABLE)，如果使用了多个通道的话，会自动设置为ENABLE。 就是是否开启扫描模式</p>
<p><strong>Continuous Conversion Mode</strong>(连续转换模式)    </p>
<p>设置为ENABLE，即连续转换。如果设置为DISABLE，则是单次转换。两者的区别在于连续转换直到所有的数据转换完成后才停止转换，而单次转换则只转换一次数据就停止，要再次触发转换才可以进行转换</p>
<p><strong>Discontinuous Conversion Mode</strong>(间断模式)    </p>
<p>因为我们只用到了1个ADC,所以这个直接不使能即可</p>
<hr>
<p><strong>ADC_RegularConversionMode(规则通道设置)</strong>:</p>
<p><strong>Enable Regular Conversions</strong> (启用常规转换模式)    </p>
<p>使能 否则无发进行下方配置</p>
<p><strong>Number OF Conversion</strong>(转换通道数)   <br>用到几个通道就设置为几<br>多个通道自动使能扫描模式</p>
<p><strong>Extenal Trigger Conversion Source</strong> (外部触发转换源)</p>
<p>设定ADC的触发方式:</p>
<ul>
<li><p>Regular Conversion launched by software 规则的软件触发 调用函数触发即可</p>
</li>
<li><p>Timer X Capture Compare X event 外部引脚触发,</p>
</li>
<li><p>Timer X Trigger Out event 定时器通道输出触发 需要设置相应的定时器设置</p>
</li>
</ul>
<hr>
<p><strong>Rank(转换顺序)</strong>：         <br>这个只修改通道Sampling Time(采样时间)即可，设置为239.5Cycles</p>
<blockquote>
<p><strong>不同的采样时间会影响到ADC的转换精度和转换速度。较长的采样时间可以提供更稳定的转换结果，适合高阻抗的信号源，但会增加总的转换时间；而较短的采样时间可以提高转换速度，但可能会降低精度，特别是在处理高阻抗信号时。</strong></p>
</blockquote>
<p>多个通道时会有多个Rank，可以设定每个通道的转换顺序<br>ADC总转换时间如下计算：</p>
<p>TCONV &#x3D; 采样时间+ 12.5个周期</p>
<p>当ADCCLK&#x3D;14MHz(最大)，采样时间为1.5周期(最快)时，TCONV &#x3D;1.5+12.5&#x3D;14周期&#x3D;1μs。</p>
<p>因此，ADC的最小采样时间1us（ADC时钟&#x3D;14MHz，采样周期为1.5周期下得到）</p>
<hr>
<p><strong>ADC_injected_ConversionMode</strong>(注入通道设置):<br>也就是注入通道的设置，和转换通道没啥太大区别，这里不再详解</p>
<hr>
<p><strong>WahchDog</strong>：<br>Enable Analog WatchDog Mode(使能模拟看门狗中断)</p>
<p>本质也测量值就是超出测量范围或者低于最低范围，启动看门狗</p>
</blockquote>
<ol start="2">
<li>ADC转换结束中断配置</li>
<li>ADC 的DMA传输配置</li>
</ol>
<h2 id="相关函数-4"><a href="#相关函数-4" class="headerlink" title="相关函数"></a>相关函数</h2><ul>
<li>开启ADC的3种模式(轮询模式 中断模式 DMA模式)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">• HAL_ADC_Start(&amp;hadcx);       <span class="comment">//轮询模式开启ADC</span></span><br><span class="line">• HAL_ADC_Start_IT(&amp;hadcx);       <span class="comment">//中断轮询模式开启ADC</span></span><br><span class="line">• HAL_ADC_Start_DMA(&amp;hadcx)；       <span class="comment">//DMA模式开启ADC</span></span><br></pre></td></tr></table></figure>

<ul>
<li>关闭ADC的3种模式（轮询模式 中断模式 DMA模式）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">• HAL_ADC_Stop()</span><br><span class="line">• HAL_ADC_Stop_IT()</span><br><span class="line">• HAL_ADC_Stop_DMA()</span><br></pre></td></tr></table></figure>



<ul>
<li>读取ADC转换值</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">• HAL_ADC_GetValue()</span><br></pre></td></tr></table></figure>



<ul>
<li>ADC校准函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">• HAL_ADCEx_Calibration_Start()</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 通常精度要求时使用，一般添加在初始化ADC之后.</span></span><br><span class="line"><span class="comment"> * 注意F4系列不支持！！！！</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<ul>
<li>等待转换结束函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">• HAL_ADC_PollForConversion(&amp;hadc1, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">第一个参数为指定的ADC,第二个参数为最大等待时间</span><br></pre></td></tr></table></figure>

<ul>
<li>ADC中断回调函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">• HAL_ADC_ConvCpltCallback()</span><br><span class="line"></span><br><span class="line">转换完成后回调，DMA模式下DMA传输完成后调用</span><br></pre></td></tr></table></figure>

<ul>
<li>规则通道以及看门狗的配置</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">• HAL_ADC_ConfigChannel() 配置规则组通道</span><br><span class="line">• HAL_ADC_AnalogWDGConfig(）</span><br></pre></td></tr></table></figure>



<h2 id="实验-轮询读取ADC的值"><a href="#实验-轮询读取ADC的值" class="headerlink" title="实验-轮询读取ADC的值"></a>实验-轮询读取ADC的值</h2><h3 id="CubeMX配置-8"><a href="#CubeMX配置-8" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h3><p>1.开启对应ADC通道</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250406235430236.png" alt="image-20250406235430236"></p>
<p>2.选择不开启连续转换模式，同时设置适当的采样时间</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../../../Notes/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6/%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91/image/image-20250406235546049.png" alt="image-20250406235546049"></p>
<h3 id="业务代码-6"><a href="#业务代码-6" class="headerlink" title="业务代码"></a>业务代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	 HAL_ADCEx_Calibration_Start(&amp;hadc2,ADC_SINGLE_ENDED);<span class="comment">//启动校准</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_ADC_Start(&amp;hadc2);<span class="comment">//启动ADC转换</span></span><br><span class="line">	HAL_ADC_PollForConversion(&amp;hadc2,<span class="number">50</span>);<span class="comment">//等待转换完成</span></span><br><span class="line">	AD_Value = HAL_ADC_GetValue(&amp;hadc2);</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="实验-使用ADC读取电位器电压-单通道"><a href="#实验-使用ADC读取电位器电压-单通道" class="headerlink" title="实验-使用ADC读取电位器电压(单通道)"></a>实验-使用ADC读取电位器电压(单通道)</h2><h3 id="电位器介绍"><a href="#电位器介绍" class="headerlink" title="电位器介绍"></a>电位器介绍</h3><p><strong>电位器</strong>（Potentiometer）是一种三端的可调电阻器，常用于调节电压、电流或信号强度。它通过转动或滑动一个机械部件（如旋钮或滑杆）来改变电阻值，实现电路中的电压分配或控制。</p>
<blockquote>
<ol>
<li><p><strong>在stm32单片机上使用VOL标注</strong></p>
</li>
<li><p>原理图中标注为<strong>Variable resistor（可变电阻）</strong></p>
</li>
</ol>
</blockquote>
<h3 id="CubeMX配置-9"><a href="#CubeMX配置-9" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h3><blockquote>
<ol>
<li><p>配置Debug，打开外部晶振，配置时钟树。<strong>为了ADC转换结果的准确性，配置时钟树时注意分频后的ADC时钟信号最好不超过14Mhz</strong></p>
</li>
<li><p>从原理图中找到对应引脚，查看其对应ADC通道，然后在对应ADC中勾选通道</p>
</li>
<li><ul>
<li>ADC_Settings -&gt; Continuous Conversion Mode设为Enable，使ADC转换持续进行，不需要每次获取之前手动触发转换</li>
<li>ADC_Regular_ConversionMode -&gt; Rank -&gt; Sampling Time设为239.5 Cycles，最长采样时间，可以获得更稳定的转换结果，采样时间越长，转换结果越准确</li>
</ul>
</li>
<li><p>若有OLED显示等配置即可</p>
</li>
<li><p>生成项目</p>
</li>
</ol>
</blockquote>
<h3 id="业务代码-7"><a href="#业务代码-7" class="headerlink" title="业务代码"></a>业务代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> message[<span class="number">50</span>];</span><br><span class="line"><span class="type">char</span> message2[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ADValue = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> voltage = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// AHT20_Init();</span></span><br><span class="line"></span><br><span class="line">    HAL_Delay(<span class="number">20</span>);</span><br><span class="line">    OLED_Init();</span><br><span class="line"></span><br><span class="line">    HAL_ADC_Start(&amp;hadc1);</span><br><span class="line">   <span class="comment">/*启动ADC连续转换*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*ADC读取原始值获取*/</span></span><br><span class="line">     ADValue = HAL_ADC_GetValue(&amp;hadc1);</span><br><span class="line">	<span class="comment">/*12位精度的ADC，测量范围为0~3.3V,进行电压计算*/</span></span><br><span class="line">    <span class="comment">/*该处电压范围可以在对应原理图上的VOL找到*/</span></span><br><span class="line">    voltage = ADValue * <span class="number">3.3</span> / <span class="number">4096</span>;</span><br><span class="line"></span><br><span class="line">    OLED_NewFrame();</span><br><span class="line">    <span class="built_in">sprintf</span>(message, <span class="string">&quot;ADValue:%d&quot;</span>, ADValue);</span><br><span class="line">    <span class="built_in">sprintf</span>(message2, <span class="string">&quot;voltage:%.2fV&quot;</span>, voltage);</span><br><span class="line">    OLED_PrintString(<span class="number">0</span>, <span class="number">0</span>, message,&amp;font16x16,OLED_COLOR_NORMAL);</span><br><span class="line">    OLED_PrintString(<span class="number">0</span>,<span class="number">16</span>,message2,&amp;font16x16,OLED_COLOR_NORMAL);</span><br><span class="line">    OLED_ShowFrame();</span><br><span class="line">    HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实验-使用NTC热敏传感器测量温度-单通道"><a href="#实验-使用NTC热敏传感器测量温度-单通道" class="headerlink" title="实验-使用NTC热敏传感器测量温度(单通道)"></a>实验-使用NTC热敏传感器测量温度(单通道)</h2><h3 id="NTC-热敏电阻介绍"><a href="#NTC-热敏电阻介绍" class="headerlink" title="NTC-热敏电阻介绍"></a>NTC-热敏电阻介绍</h3><p><strong>NTC</strong> 是指 <strong>负温度系数热敏电阻</strong>（<strong>Negative Temperature Coefficient thermistor</strong>），是一种随着<strong>温度升高电阻值下降</strong>的热敏电阻器件。它的主要特点是电阻值与温度呈反比关系。</p>
<h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>NTC热敏电阻本身是一个单独的电阻。在这个电路中，通常会与一个已知电阻（如10kΩ）串联，以形成一个分压器，这样可以通过测量电压来推算出NTC的电阻值。具体来说，NTC传感器的电阻值会随着温度变化而变化，而通过这个分压器电路可以得到一个对应的电压信号。</p>
<p>单片机上的原理图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20240927235951857-1752338032550-5.png" alt="image-20240927235951857"></p>
<blockquote>
<p><strong>电路工作原理</strong>：</p>
<ol>
<li><strong>NTC与固定电阻串联</strong>：电路中有一个NTC热敏电阻R_ntc和一个已知固定电阻R1串联。</li>
<li>电源：整个电路连接到一个电源Vcc（例如3.3V）。</li>
<li><strong>分压器</strong>：在NTC热敏电阻上得到的电压V_ntc 。</li>
</ol>
<p><strong>计算步骤</strong>：</p>
<ol>
<li><p><strong>通过ADC(12位)读取电压</strong>：ADC测量得到的值adc_value 代表的是在NTC热敏电阻上的电压：V_ntc &#x3D; (adc_value &#x2F; 4096 )* Vcc</p>
</li>
<li><p><strong>由分压公式</strong>有: V_ntc &#x3D; (R_ntc&#x2F;R_ntc+R1 ) * Vcc</p>
</li>
</ol>
<p>R_ntc &#x3D; R1 * (v_ntc &#x2F; vcc - v_ntc)</p>
<ol start="3">
<li><strong>将ADC的值带入后简化得到R_ntc的值</strong>：</li>
</ol>
<p><strong>R_ntc &#x3D; R1 * (adc_value &#x2F; 4096 - adc_value)</strong></p>
<p><strong>计算公式为</strong>：<br>$$<br>R_{ntc} &#x3D; R_1*\frac{adValue}{4096-adValue}<br>$$</p>
</blockquote>
<blockquote>
<p>得到R_ntc的值之后，使用B值公式计算出NTC热敏电阻的阻值对应温度T_ntc<br>$$<br>T_{ntc} &#x3D; \frac{B}{ln\frac{R_{ntc}}{R1}+\frac{B}{T_0}}<br>$$<br>R_ntc：T_ntc温度下通过ADC计算得到的NTC电阻(单位为Ω)</p>
<p>R1：参考温度下ntc的电阻值(常温25°c，298.15K)</p>
<p>B：给出的B值(NTC热敏电阻的材料常数，单位K)</p>
<p>T0：常温(25℃，298.15K)</p>
</blockquote>
<h3 id="CubeMX配置-10"><a href="#CubeMX配置-10" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h3><blockquote>
<ol>
<li><p>配置Debug，打开外部晶振，配置时钟树。<strong>为了ADC转换结果的准确性，配置时钟树时注意分频后的ADC时钟信号最好不超过14Mhz</strong></p>
</li>
<li><p>从原理图中找到对应引脚，查看其对应ADC通道，然后在对应ADC中勾选通道</p>
</li>
<li><ul>
<li>ADC_Settings -&gt; Continuous Conversion Mode设为Enable，使ADC转换持续进行，不需要每次获取之前手动触发转换</li>
<li>ADC_Regular_ConversionMode -&gt; Rank -&gt; Sampling Time设为239.5 Cycles，最长采样时间，可以获得更稳定的转换结果，采样时间越长，转换结果越准确</li>
</ul>
</li>
<li><p>若有OLED显示等配置即可</p>
</li>
<li><p>生成项目</p>
</li>
</ol>
</blockquote>
<h3 id="业务代码-8"><a href="#业务代码-8" class="headerlink" title="业务代码"></a>业务代码</h3><ul>
<li><strong>通过ADC值计算NTC电阻值</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">getResistance</span><span class="params">(<span class="type">uint32_t</span> adValue)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (adValue / (<span class="number">4096.0f</span> - adValue)) * <span class="number">10000.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*参数adValue:ADC转换的结果*/</span></span><br><span class="line"><span class="comment">/*10000.f 为串联电阻值大小10KΩ*/</span></span><br><span class="line"><span class="comment">/*返回值：NTC电阻值，浮点数类型，单位Ω*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>通过NTC阻值计算温度</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">calTemperature</span><span class="params">(<span class="type">float</span> R)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> B = <span class="number">3950.0f</span>;</span><br><span class="line">    <span class="type">float</span> R1 = <span class="number">10000.0f</span>;</span><br><span class="line">    <span class="type">float</span> T0 = <span class="number">25.0f</span>;</span><br><span class="line">    <span class="keyword">return</span>  B /(<span class="built_in">log</span>(R/R1)+ B/(<span class="number">273.15</span>+T0)) - <span class="number">273.15</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*C语言中log函数就是以e为底数的函数，即lnx*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 参数R：通过adValue计算得到的电阻</span></span><br><span class="line"><span class="comment">  * B：手册上给出的B值常数</span></span><br><span class="line"><span class="comment">  * R1: 串联电阻大小10KΩ</span></span><br><span class="line"><span class="comment">  * T0: 常温25℃</span></span><br><span class="line"><span class="comment">  * 返回值：温度，float类型，单位摄氏度</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">getResistance</span><span class="params">(<span class="type">uint32_t</span> adValue)</span>;</span><br><span class="line"><span class="type">float</span> <span class="title function_">calTemperature</span><span class="params">(<span class="type">float</span> R)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> message[<span class="number">50</span>];</span><br><span class="line"><span class="type">char</span> message2[<span class="number">50</span>];</span><br><span class="line"><span class="type">int</span> adValue = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> R = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> temp = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_Delay(<span class="number">20</span>);</span><br><span class="line">    OLED_Init();</span><br><span class="line"></span><br><span class="line">    HAL_ADC_Start(&amp;hadc1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    adValue = HAL_ADC_GetValue(&amp;hadc1);</span><br><span class="line"></span><br><span class="line">    R  = getResistance(adValue);</span><br><span class="line">    <span class="comment">/*计算当前NTC电阻*/</span></span><br><span class="line">    temp = calTemperature(R);   </span><br><span class="line">     <span class="comment">/*C语言中log函数就是以e为底数的函数，即ln*/</span></span><br><span class="line"></span><br><span class="line">    OLED_NewFrame();</span><br><span class="line">    <span class="built_in">sprintf</span>(message, <span class="string">&quot;ADValue:%d&quot;</span>, adValue);</span><br><span class="line">    <span class="built_in">sprintf</span>(message2, <span class="string">&quot;temp:%.2f&quot;</span>, temp);</span><br><span class="line">    OLED_PrintString(<span class="number">0</span>, <span class="number">0</span>, message,&amp;font16x16,OLED_COLOR_NORMAL);</span><br><span class="line">    OLED_PrintString(<span class="number">0</span>,<span class="number">16</span>,message2,&amp;font16x16,OLED_COLOR_NORMAL);</span><br><span class="line">    OLED_ShowFrame();</span><br><span class="line">    HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h1><h2 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h2><p><strong>DMA，全称Direct Memory Access，即直接存储器访问。</strong></p>
<p><strong>DMA传输将数据从一个地址空间复制到另一个地址空间，提供在外设和存储器之间或者存储器和存储器之间的高速数据传输，无须CPU的干预，通过DMA数据可以快速地移动。这就节省了CPU的资源来做其他操作。</strong></p>
<p><strong>DMA的作用就是实现数据的直接传输，而去掉了传统数据传输需要CPU寄存器参与的环节</strong></p>
<blockquote>
<p><strong>一般在 数据量大的时候，频繁进入中断可能会出现问题，此时采用DMA搬运</strong></p>
<p><strong>DMA是CPU的小助手</strong></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/as480133937/article/details/104827639">【STM32】HAL库 STM32CubeMX教程十一—DMA (串口DMA发送接收)_stm32h7 串口dma 发送 第一次成功-CSDN博客</a></p>
<h2 id="DMA传输方式"><a href="#DMA传输方式" class="headerlink" title="DMA传输方式"></a>DMA传输方式</h2><ul>
<li><strong>方法1</strong>：DMA_Mode_Normal，正常模式。</li>
</ul>
<p>当一次DMA数据传输完后，停止DMA传送 ，也就是只传输一次
　　</p>
<ul>
<li><strong>方法2</strong>：DMA_Mode_Circular，循环传输模式。</li>
</ul>
<p>当传输结束时，硬件自动会将传输数据量寄存器进行重装，进行下一轮的数据传输。 也就是多次传输模式</p>
<h2 id="串口DMA模式与收发不定长数据"><a href="#串口DMA模式与收发不定长数据" class="headerlink" title="串口DMA模式与收发不定长数据"></a>串口DMA模式与收发不定长数据</h2><h3 id="DMA模式"><a href="#DMA模式" class="headerlink" title="DMA模式"></a>DMA模式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*只需要将串口中断发送函数改为DMA即可*/</span></span><br><span class="line"></span><br><span class="line">串口DMA发送数据：</span><br><span class="line">HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size)</span><br><span class="line"></span><br><span class="line">串口DMA接收数据：</span><br><span class="line">HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size)</span><br><span class="line"></span><br><span class="line">串口DMA恢复函数</span><br><span class="line">HAL_UART_DMAResume(&amp;huart1)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用DMA方式时，还是有中断参与其中，RxCpltCallback函数同样是由中断触发，只不过不是串口中断，而是<strong>DMA传输完成中断</strong>，DMA还有的就是<strong>传输过半中断</strong></p>
</blockquote>
<h3 id="收发不定长数据-Idle"><a href="#收发不定长数据-Idle" class="headerlink" title="收发不定长数据-Idle"></a>收发不定长数据-Idle</h3><blockquote>
<p><strong>收发不定长数据主要依靠IDLE(串口空闲中断)</strong>，所谓<strong>串口空闲中断</strong>就是，中断触发条件与接收的字节数无关，串口无数据接收时不会触发，必须要从接收到第一个数据开售，当RX引脚上无后续数据进入，串口接收从忙碌转为空闲时才会触发。可以认为空闲中断IDLE发生时就是一帧的数据包接收完成了，此时对数据进行分析处理即可。</p>
<p>一般用于接收大量数据</p>
</blockquote>
<ul>
<li><strong>串口接收数据</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HAL_UARTEx_ReceiveToIdle();<span class="comment">//阻塞</span></span><br><span class="line">HAL_UARTEx_ReceiveToIdle_IT();<span class="comment">//中断</span></span><br><span class="line">HAL_UARTEx_ReceiveToIdle_DMA(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size);<span class="comment">//DMA</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ex代表扩展，Idle代表空闲中断</span></span><br><span class="line"><span class="comment"> * 以DMA为例，参数1，2不变，参数3并不是想要接收的长度，而是一次接收的最大长度</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<ul>
<li><strong>空闲中断对应回调函数</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, <span class="type">uint16_t</span> Size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(huart == &amp;huart2)</span><br><span class="line">    &#123;</span><br><span class="line">        HAL_UART_Transmit_DMA(&amp;huart2, rData, Size);</span><br><span class="line"></span><br><span class="line">        HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart2,rData,<span class="keyword">sizeof</span>(rData));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ex代表扩展，Idle代表空闲中断</span></span><br><span class="line"><span class="comment"> * 参数2：size代表接收的数据长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用ReceiveToIdle相关函数时，<strong>不再调用RxCpltCallback回调，而是使用了RxEventCallback进行回调</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 24-9-13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;gpio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdbool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="type">uint16_t</span> pwmVal = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> mode = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> rData[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*首先还是要以Idle，启动中断或DMA模式*/</span></span><br><span class="line">    HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart2,rData,<span class="number">50</span>);</span><br><span class="line">    <span class="comment">// HAL_UARTEx_ReceiveToIdle_IT(&amp;huart2,rData,50);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UARTEx_RxEventCallback</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint16_t</span> Size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(huart == &amp;huart2)</span><br><span class="line">    &#123;</span><br><span class="line">        HAL_UART_Transmit_DMA(&amp;huart2, rData, Size);</span><br><span class="line"></span><br><span class="line">        HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart2,rData,<span class="keyword">sizeof</span>(rData));<span class="comment">//再次开启串口DMA或中断接收模式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="DMA传输过半中断"><a href="#DMA传输过半中断" class="headerlink" title="DMA传输过半中断"></a>DMA传输过半中断</h3><blockquote>
<p>可以使用IT或DMA方式启动空闲中断，但是使用DMA模式时，除了串口的空闲中断外，<strong>DMA的传输过半中断</strong>也会触发RxEventCallback回调函数，即接收的数据量到达我们设置的最大值的一半时，也会触发这个回调函数，一般场景不适用，但某些场景有用。</p>
<p>可以通过加大数组长度或关闭DMA传输过半中断解决</p>
<p>所以一般情况下要关闭DMA传输过半中断</p>
</blockquote>
<ul>
<li><strong>关闭DMA传输过半中断</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__HAL_DMA_DISABLE_IT(&amp;hdma_usart2_rx,DMA_IT_HT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数1：DMA通道的指针地址，上面是usart2的rx通道</span></span><br><span class="line"><span class="comment">//参数2：需要关闭的中断,DMA_IT_HT就是传输过半中断</span></span><br><span class="line"><span class="comment">//每次DMA方式启动时都需要关闭!!!!</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：如果勾选了外设.c&#x2F;.h文件单独生成，那么需要在usart.h中使用extern DMA_HandleTypeDef hdma_usart2_rx,否则找不到定义</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f1xx_hal.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdbool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> DMA_HandleTypeDef hdma_usart2_rx;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> pwmVal = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> mode = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> rData[<span class="number">10</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_2);</span></span><br><span class="line"></span><br><span class="line">    HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart2,rData,<span class="number">10</span>);</span><br><span class="line">    __HAL_DMA_DISABLE_IT(&amp;hdma_usart2_rx,DMA_IT_HT);</span><br><span class="line">    <span class="comment">/*关闭DMA半传输中断*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UARTEx_RxEventCallback</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint16_t</span> Size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(huart == &amp;huart2)</span><br><span class="line">    &#123;</span><br><span class="line">        HAL_UART_Transmit_DMA(&amp;huart2, rData, Size);</span><br><span class="line"></span><br><span class="line">        HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart2,rData,<span class="keyword">sizeof</span>(rData));</span><br><span class="line">        __HAL_DMA_DISABLE_IT(&amp;hdma_usart2_rx,DMA_IT_HT);</span><br><span class="line">        <span class="comment">/*再次关闭DMA半传输中断*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="蓝牙模块与简易数据包解析"><a href="#蓝牙模块与简易数据包解析" class="headerlink" title="蓝牙模块与简易数据包解析"></a>蓝牙模块与简易数据包解析</h1><h2 id="蓝牙模块介绍"><a href="#蓝牙模块介绍" class="headerlink" title="蓝牙模块介绍"></a>蓝牙模块介绍</h2><p>蓝牙通信是其常见的无线通信方式之一。蓝牙模块可以帮助STM32实现与其他设备（如手机、电脑、其他蓝牙设备）之间的无线通信。蓝牙模块在STM32系统中可以通过<strong>UART、SPI、I2C</strong>等接口与主控制器连接。</p>
<p><strong>蓝牙主要分类是</strong>：<strong>经典蓝牙</strong>和<strong>低功耗蓝牙</strong>(Bluetooth Low Energy,<strong>简称BLE</strong>)</p>
<p><strong>经典蓝牙：一般像耳机这种持续传输数据的</strong></p>
<p><strong>低功耗蓝牙：间歇性同步数据设备常用于嵌入式，如手环</strong></p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>……</p>
<h2 id="实验-蓝牙发送数据控制LED-UART"><a href="#实验-蓝牙发送数据控制LED-UART" class="headerlink" title="实验(蓝牙发送数据控制LED-UART)"></a>实验(蓝牙发送数据控制LED-UART)</h2><h3 id="简易数据包解析"><a href="#简易数据包解析" class="headerlink" title="简易数据包解析"></a>简易数据包解析</h3><blockquote>
<p>首先三个小灯、亮灭对应：</p>
<p>0x01   0x02  0x03        0xFF      0x00</p>
<p>红灯   绿灯   蓝灯        亮           灭</p>
<p>例如： 0x01 0x00 0x03 0xFF 代表红灯熄灭，蓝灯亮</p>
<ul>
<li><p>指令一般都会有包头，表示一帧数据的开始，这里规定包头为0xAA</p>
</li>
<li><p>包头后往往有一位数据包长度，指示此数据包一共多长</p>
</li>
<li><p>最后一位为校验和，为前面所有数据的和取<strong>1字节(16进制最后两位)</strong>，当收到数据后自行计算出的结果与数据包中自带的校验位比较，相同则用，不同舍弃</p>
</li>
</ul>
<p>假定: </p>
<p>AA 09 01 FF 02 FF 03 FF </p>
<p>AA + 9 +1 + FF + 3 + FF &#x3D; 3B6  故校验位为B6</p>
<p>当向蓝色发送数据为</p>
<p>AA 09 01 FF 02 FF 03 FF B6(校验位) 代表包头0xAA 长度0x09 红灯绿灯蓝灯都亮</p>
</blockquote>
<h3 id="蓝牙发送数据控制LED开关"><a href="#蓝牙发送数据控制LED开关" class="headerlink" title="蓝牙发送数据控制LED开关"></a>蓝牙发送数据控制LED开关</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1114y1D7a4/?spm_id_from=333.788&vd_source=830e63bd86bd9268c1b7cd9ff383f386">【keysking的STM32教程】第11集 使用蓝牙模块与简易数据包解析_哔哩哔哩_bilibili</a></p>
<ul>
<li>使用<strong>DX-BT24模块(BLE5.1)，实现蓝牙透传通信</strong>，波特率设置为9600</li>
<li>使用<strong>UART</strong>连接，UARTEx扩展库，实现不定长数据快速传输，不占用CPU资源</li>
<li>使用DMA通道，实现串口数据的快速传输，不占用cpu资源</li>
</ul>
<p>CubeMX配置：<a target="_blank" rel="noopener" href="https://docs.keysking.com/docs/stm32/example/UART_BLE_ECHO">【BLE 蓝牙】蓝牙透传通信 | 波特律动 (keysking.com)</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 24-9-13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f1xx_hal.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdbool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> rData[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> ReceiveData[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart3,ReceiveData,<span class="keyword">sizeof</span>(ReceiveData));</span><br><span class="line">    __HAL_DMA_DISABLE_IT(&amp;hdma_usart3_rx,DMA_IT_HT);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UARTEx_RxEventCallback</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint16_t</span> Size)</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    GPIO_PinState state = GPIO_PIN_RESET;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(huart == &amp;huart3)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ReceiveData[<span class="number">0</span>] == <span class="number">0xAA</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ReceiveData[<span class="number">1</span>] == Size)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">uint8_t</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Size<span class="number">-1</span>;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum += ReceiveData[i];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(sum == ReceiveData[Size<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;Size<span class="number">-1</span>;i+=<span class="number">2</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(ReceiveData[i+<span class="number">1</span>] == <span class="number">0xFF</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            state = GPIO_PIN_SET;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span>(ReceiveData[i] == <span class="number">0x01</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            HAL_GPIO_WritePin(LED_BLUE_GPIO_Port,LED_BLUE_Pin,state);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(ReceiveData[i] == <span class="number">0x03</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            HAL_GPIO_WritePin(LED_RED_GPIO_Port,LED_RED_Pin,state);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        HAL_UART_Transmit_DMA(&amp;huart3, ReceiveData, Size);</span><br><span class="line"></span><br><span class="line">        HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart3,ReceiveData,<span class="keyword">sizeof</span>(ReceiveData));</span><br><span class="line">        __HAL_DMA_DISABLE_IT(&amp;hdma_usart3_rx,DMA_IT_HT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>最后使用蓝牙调试助手蓝牙，打开微信小程序【大夏无线传输助手】，点击【搜索】，找到 BT24，连接后发送</p>
<p><strong>注意：切换16进制发送</strong></p>
</blockquote>
<h1 id="IIC"><a href="#IIC" class="headerlink" title="IIC"></a>IIC</h1><h2 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h2><p><strong>I²C(Inter－Integrated Circuit)总线</strong>是一种由<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=NXP&spm=1001.2101.3001.7020">NXP</a>（原PHILIPS）公司开发的两线式串行总线，用于连接微控制器及其外围设备。多用于主控制器和从器件间的主从通信，在小数据量场合使用，传输距离短，主从模式下，任意时刻只能有一个主机等特性，可以有多个从机。</p>
<p><strong>IIC是一种低速的，半双工，同步</strong>的通信总线 ，常用于连接微控制器与各种外围设备。</p>
<p>在 STM32 中，I²C 接口可以应用于以下几种场景：</p>
<blockquote>
<ol>
<li><strong>传感器读取</strong>：许多环境传感器（如温度、湿度、加速度等）使用 I²C 作为通信方式。通过 STM32 的 I²C 接口可以轻松地与这些传感器进行数据交换。</li>
<li><strong>显示模块控制</strong>：一些小型的 <strong>OLED 或 LCD 显示屏</strong>使用 I²C 接口进行命令和数据传输。STM32 可以用来驱动这些显示模块以显示信息或图像。</li>
<li><strong>音频编解码器</strong>：部分音频编解码芯片使用 I²C 作为配置接口，STM32 可以通过 I²C 配置这些芯片的工作模式，并接收或发送音频信号。</li>
<li><strong>实时时钟模块（RTC）</strong>：某些 RTC 模块也采用 I²C 接口来同步时间和日期信息，STM32 可以用作主控来更新 RTC 或从 RTC 获取时间。</li>
<li>………………</li>
</ol>
</blockquote>
<blockquote>
<p><strong>这里要注意IIC是为了与低速设备通信而发明的，所以IIC的传输速率比不上SPI</strong></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/as480133937/article/details/105366932">IIC原理超详细讲解—值得一看-CSDN博客</a>！！！！！！！！</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p><strong>IIC分为软件IIC和硬件IIC</strong></p>
<p><strong>软件IIC</strong>：软件IIC通信指的是用单片机的两个I&#x2F;O端口模拟出来的IIC，用软件控制管脚状态以模拟I2C通信波形，软件模拟寄存器的工作方式。</p>
<p><strong>硬件IIC</strong>：一块硬件电路，硬件I2C对应芯片上的I2C外设，有相应I2C驱动电路，其所使用的I2C管脚也是专用的，硬件（固件）I2C是直接调用内部寄存器进行配置。</p>
<p>硬件I2C的效率要远高于软件的，而软件I2C由于不受管脚限制，接口比较灵活。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>IIC一共有只有两个总线： <strong>一条是双向的串行数据线SDA，一条是串行时钟线SCL</strong>，数据线同时间只能发送或接收数据，故为<strong>半双工通信</strong>。</p>
<ul>
<li><p>SDA(Serial data)是数据线，D代表Data也就是数据，Send Data 也就是用来传输数据的。</p>
</li>
<li><p>SCL(Serial clock line)是时钟线，C代表Clock 也就是时钟 也就是控制数据发送的时序的</p>
</li>
</ul>
<blockquote>
<p>所有接到I2C总线设备上的串行数据SDA都接到总线的SDA上，各设备的时钟线SCL接到总线的SCL上。I2C总线上的每个设备都自己一个唯一的地址，来确保不同设备之间访问的准确性。</p>
</blockquote>
<h2 id="物理层与协议层"><a href="#物理层与协议层" class="headerlink" title="物理层与协议层"></a>物理层与协议层</h2><ul>
<li><strong>物理层</strong></li>
</ul>
<blockquote>
<p>I2C 总线在物理连接上非常简单，分别由<strong>SDA(串行数据线)和SCL(串行时钟线)及上拉电阻</strong>组成。</p>
<p><strong>SCL和SDA都需要接上拉电阻</strong> (大小由速度和容性负载决定一般在3.3K-10K之间) 保证数据的稳定性，减少干扰。</p>
<p>通信原理：是通过对SCL和SDA线高低电平时序的控制，来产生I2C总线协议所需要的信号进行数据的传递。<strong>在总线空闲状态时，SCL和SDA被上拉电阻Rp拉高，使SDA和SCL线都保持高电平。</strong></p>
</blockquote>
<ul>
<li><strong>协议层</strong></li>
</ul>
<blockquote>
<p>I2C 总线在传送数据过程中共有三种类型信号， 它们分别是：开始信号、结束信号和应答信号。</p>
<ul>
<li><p><strong>开始信号</strong>：SCL 为高电平时，SDA 由高电平向低电平跳变，开始传送数据。</p>
</li>
<li><p><strong>结束信号</strong>：SCL 为高电平时，SDA 由低电平向高电平跳变，结束传送数据。</p>
</li>
<li><p><strong>应答信号</strong>：每当主机向从机发送完一个字节的数据，主机总是需要等待从机给出一个应答信号，以确认从机是否成功接收到了数据。</p>
</li>
</ul>
<p><strong>应答信号：主机SCL拉高，读取从机SDA的电平，为低电平表示产生应答</strong></p>
<p><strong>应答信号为低电平时，规定为有效应答位（ACK，简称应答位），表示接收器已经成功地接收了该字节；</strong><br><strong>应答信号为高电平时，规定为非应答位（NACK），一般表示接收器接收该字节没有成功。</strong></p>
<p><strong>每发送一个字节</strong>（8个bit）在一个字节传输的8个时钟后的第九个时钟期间，接收器接收数据后必须回一个ACK应答信号给发送器，这样才能进行数据传输。</p>
<p>应答出现在每一次主机完成8个数据位传输后紧跟着的时钟周期，低电平0表示应答，1表示非应答。</p>
<p><strong>注意：这些信号中，起始信号是必需的，结束信号和应答信号，都可以不要。</strong></p>
</blockquote>
<ul>
<li><strong>时序图</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241103171954458-1752338032551-7.png" alt="image-20241103171954458"></p>
<ul>
<li><strong>应答</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241103174539094-1752338032551-6.png" alt="image-20241103174539094"></p>
<h2 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h2><p><strong>主机和从机的概念</strong>：</p>
<p>主机就是负责整个系统的任务协调与分配，从机一般是通过接收主机的指令从而完成某些特定的任务，主机和从机之间通过总线连接，进行数据通讯。</p>
<ul>
<li>发布主要命令的称为主机</li>
<li>接受命令的称为从机</li>
</ul>
<blockquote>
<p>I2C是一种主从通信协议，允许多个设备连接在同一条总线上。每个从设备都有一个唯一的地址，称为<strong>Slave Address</strong>，以便主设备能够与特定的从设备进行通信。</p>
<p><strong>Slave Address</strong>是由7位或10位组成的二进制数字，在通信时主设备将此地址发送到总线上，从设备根据地址进行识别。</p>
</blockquote>
<blockquote>
<p>当主设备想要与某个从设备通信时，它会发送从设备的地址。如果从设备检测到自己的地址匹配，它将响应通信请求。主设备可以发送读命令或写命令，以此来从从设备获取数据或向其发送数据。</p>
<p>例如，假设STM32作为I2C主设备，而一个SSD1306 OLED显示屏作为从设备。SSD1306的I2C地址为<code>0x3C</code>（或<code>0x78</code>表示为8位地址）。主设备通过发送<code>0x3C</code>的地址来选择并与这个显示屏通信。</p>
</blockquote>
<h2 id="IIC相关函数"><a href="#IIC相关函数" class="headerlink" title="IIC相关函数"></a>IIC相关函数</h2><h3 id="IIC读写"><a href="#IIC读写" class="headerlink" title="IIC读写"></a>IIC读写</h3><ul>
<li><strong>IIC写函数</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, <span class="type">uint16_t</span> DevAddress, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size, <span class="type">uint32_t</span> Timeout);</span><br><span class="line"></span><br><span class="line">- hi2c 设置使用的是那个IIC 例：&amp;hi2c2</span><br><span class="line">- DevAddress 写入的地址 设置写入数据的地址 例 <span class="number">0xA0</span></span><br><span class="line">- *pData 需要写入的数据</span><br><span class="line">- Size 要发送的字节数</span><br><span class="line">- Timeout 最大传输时间，超过传输时间将自动退出传输函数</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>IIC读函数</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, <span class="type">uint16_t</span> DevAddress, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size, <span class="type">uint32_t</span> Timeout);</span><br><span class="line"></span><br><span class="line">- 参数同上</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>IIC写数据函数</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, <span class="type">uint16_t</span> DevAddress, <span class="type">uint16_t</span> MemAddress, <span class="type">uint16_t</span> MemAddSize, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size, <span class="type">uint32_t</span> Timeout);</span><br><span class="line"><span class="comment">/* 第1个参数为I2C操作句柄</span></span><br><span class="line"><span class="comment">   第2个参数为从机设备地址</span></span><br><span class="line"><span class="comment">   第3个参数为从机寄存器地址</span></span><br><span class="line"><span class="comment">   第4个参数为从机寄存器地址长度</span></span><br><span class="line"><span class="comment">   第5个参数为发送的数据的起始地址</span></span><br><span class="line"><span class="comment">   第6个参数为传输数据的大小</span></span><br><span class="line"><span class="comment">   第7个参数为操作超时时间 　　*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- *hi2c： I2C设备号指针，设置使用的是那个IIC 例：&amp;hi2c2</span><br><span class="line">- DevAddress： 从设备地址 从设备的IIC地址 例E2PROM的设备地址 <span class="number">0xA0</span></span><br><span class="line">- MemAddress： 从机寄存器地址 ，每写入一个字节数据，地址就会自动+<span class="number">1</span>,如果是<span class="number">256</span>K的寄存器，那么就是<span class="number">00</span>~FF</span><br><span class="line">- MemAddSize： 从机寄存器地址字节长度 <span class="number">8</span>位或<span class="number">16</span>位</span><br><span class="line">  写入数据的字节类型 <span class="number">8</span>位还是<span class="number">16</span>位</span><br><span class="line">  <span class="number">8b</span>it:I2C_MEMADD_SIZE_8BIT</span><br><span class="line">  <span class="number">16b</span>it:I2C_MEMADD_SIZE_16BIT</span><br><span class="line">- *pData： 需要写入的的数据的起始地址</span><br><span class="line">- Size： 传输数据的大小 多少个字节</span><br><span class="line">- Timeout： 最大读取时间，超过时间将自动退出函数</span><br><span class="line">      </span><br></pre></td></tr></table></figure>

<p><strong>8位读写</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HAL_I2C_Mem_Write(&amp;hi2c2, ADDR, i, I2C_MEMADD_SIZE_8BIT,&amp;(I2C_Buffer_Write[i]),<span class="number">8</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">HAL_I2C_Mem_Read(&amp;hi2c2, ADDR, i, I2C_MEMADD_SIZE_8BIT,&amp;(I2C_Buffer_Write[i]),<span class="number">8</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>16位读写</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_I2C_Mem_Write(&amp;hi2c2, ADDR, i, I2C_MEMADD_SIZE_16BIT,&amp;(I2C_Buffer_Write[i]),<span class="number">8</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">HAL_I2C_Mem_Read(&amp;hi2c2, ADDR, i, I2C_MEMADD_SIZE_16BIT,&amp;(I2C_Buffer_Write[i]),<span class="number">8</span>, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>与上方写函数区别</strong>： </p>
<p><strong>IIC写多个数据</strong> 该函数<strong>适用于IIC外设里面还有子地址寄存器的设备，比方说E2PROM,除了设备地址，每个存储字节都有其对应的地址</strong></p>
<p>**如果只往某个外设中写数据，则用Master_Transmit。　如果是外设里面还有子地址，例如我们的E2PROM，有设备地址，还有每个数据的寄存器存储地址。则用Mem_Write。<br>Mem_Write是2个地  **</p>
<p><strong>址，Master_Transmit只有从机地址</strong></p>
</blockquote>
<h3 id="IIC中断"><a href="#IIC中断" class="headerlink" title="IIC中断"></a>IIC中断</h3><ul>
<li><strong>中断和DMA相关函数</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HAL_I2C_Master_Transmit_IT(&amp;hi2c1,AHT20_ADDRESS,sendBuffer,<span class="keyword">sizeof</span>(sendBuffer));</span><br><span class="line"><span class="comment">/*中断读写*/</span></span><br><span class="line">HAL_I2C_Master_Receive_IT(&amp;hi2c1,AHT20_ADDRESS,readBuffer,<span class="keyword">sizeof</span>(readBuffer));</span><br><span class="line"></span><br><span class="line">HAL_I2C_Master_Transmit_DMA(&amp;hi2c1,AHT20_ADDRESS,readBuffer,<span class="keyword">sizeof</span>(readBuffer));</span><br><span class="line"><span class="comment">/*DMA模式读写*/</span></span><br><span class="line">HAL_I2C_Master_Receive_DMA(&amp;hi2c1,AHT20_ADDRESS,readBuffer,<span class="keyword">sizeof</span>(readBuffer));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断回调函数和DMA模式下进入的回调函数相同，都是下面的函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_I2C_MasterTxCpltCallback</span><span class="params">(I2C_HandleTypeDef *hi2c)</span>;<span class="comment">//发送回调</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_I2C_MasterRxCpltCallback</span><span class="params">(I2C_HandleTypeDef *hi2c)</span>;<span class="comment">//接收回调</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure>







<h2 id="实验-读写EEPROM-AT24C02"><a href="#实验-读写EEPROM-AT24C02" class="headerlink" title="实验-读写EEPROM(AT24C02)"></a>实验-读写EEPROM(AT24C02)</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/as480133937/article/details/105259075">【STM32】HAL库 STM32CubeMX教程十二—IIC(读取AT24C02 )_hal iic-CSDN博客</a></p>
<h3 id="EEPROM介绍"><a href="#EEPROM介绍" class="headerlink" title="EEPROM介绍"></a>EEPROM介绍</h3><p>AT24C02是一个2K Bit的串行EEPROM存储器（掉电不丢失），内部含有256个字节。在<strong>24C02里面有一个8字节的页写缓冲器</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241103234626099-1752338032551-8.png" alt="image-20241103234626099"></p>
<blockquote>
<p>可以通过存储IC的型号来计算芯片的存储容量是多大，比如<strong>24C02后面的02表示的是可存储2Kbit的数据，转换为字节的存储量为2*1024&#x2F;8 &#x3D; 256byte。</strong></p>
<p>那么24C04后面的04表示的是可存储4Kbit的数据，转换为字节的储存量为41024&#x2F;8 &#x3D; 512byte，以此来类推其它型号的存储空间。</p>
</blockquote>
<h3 id="设备地址"><a href="#设备地址" class="headerlink" title="设备地址"></a>设备地址</h3><p><strong>下图为芯片从地址：</strong></p>
<p>可以看出对于不同大小的24Cxx，具有不同的从器件地址。由于24C02为2k容量，也就是说只需要参考图中第一行的内容：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241103234639611-1752338032551-9.png" alt="image-20241103234639611"></p>
<blockquote>
<p><strong>这些只需要查看对应的手册都能找到</strong></p>
</blockquote>
<p><strong>芯片的寻址</strong>：<br>AT24C02设备地址为如下，前四位固定为1010，A2<del>A0为由管脚电平。AT24C02 EEPROM Board模块电路图中中默认为接地。所以A2</del>A0默认为000，最后一位表示读写操作。所以AT24Cxx的读地址为0xA1,写地址为0xA0。</p>
<p>电路图如图：其中E0、E1、E2对应上图中的A0、A1、A2，都是接地所以为000</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250125220718954-1752338032551-10.png" alt="image-20250125220718954"></p>
<p>也就是说如果是<br><strong>写</strong>24C02的时候，从器件地址为1010 000 0（0xA0）；<br><strong>读</strong>24C02的时候，从器件地址为1010 000 1（0xA1）。</p>
<p><strong>片内地址寻址</strong>：</p>
<p>芯片寻址可对内部256Byte中的任一个进行读&#x2F;写操作，其寻址范围为00~FF，共256个寻址单位。</p>
<p>对应的修改 A2A1A0 三位数据即可</p>
<h3 id="写读数据"><a href="#写读数据" class="headerlink" title="写读数据"></a>写读数据</h3><blockquote>
<p><strong>注意：</strong></p>
<ol>
<li><p>在写数据的过程中，<strong>每成功写入一个字节，E2PROM存储空间的地址就会自动加1，当加到0xFF后，再写一个字节，地址就会溢出又变成0x00</strong>。</p>
</li>
<li><p><strong>写数据的时候需要注意，E2PROM是先写到缓冲区，然后再“搬运到”到掉电非易失区。所以这个过程需要一定的时间，AT24C02这个过程是不超过5ms！</strong><br>所以，当我们在写多个字节时，写入一个字节之后，再写入下一个字节之前，必须<strong>延时5ms</strong>才可以</p>
</li>
</ol>
</blockquote>
<p><code>对应延时的5ms来自芯片手册以下部分：</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20250125220125226-1752338032551-11.png" alt="image-20250125220125226"></p>
<p><strong>对应教程</strong>:<a target="_blank" rel="noopener" href="https://blog.csdn.net/as480133937/article/details/105259075">https://blog.csdn.net/as480133937/article/details/105259075</a></p>
<h3 id="CubeMX配置-11"><a href="#CubeMX配置-11" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h3><blockquote>
<ol>
<li>查看芯片手册打开对应I2C外设，参数全部默认即可</li>
<li>启动对应的串口</li>
</ol>
</blockquote>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 24-11-4.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;userCode.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;i2c.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AT24C02_ADDR_WRITE 0xA0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AT24C02_ADDR_READ 0xA1</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> message[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">uint8_t</span> sendBuffer[<span class="number">256</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">uint8_t</span> receiveBuffer[<span class="number">256</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   HAL_GPIO_WritePin(LED0_GPIO_Port,LED0_Pin,GPIO_PIN_RESET);</span><br><span class="line">   HAL_GPIO_WritePin(LED1_GPIO_Port,LED1_Pin,GPIO_PIN_RESET);</span><br><span class="line">   HAL_GPIO_WritePin(LED2_GPIO_Port,LED2_Pin,GPIO_PIN_RESET);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// HAL_UART_Transmit(&amp;huart1,&quot;Hello World&quot;,11,1000);</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">256</span>; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      sendBuffer[i] = i;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">32</span>;j++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span>(HAL_I2C_Mem_Write(&amp;hi2c1,AT24C02_ADDR_WRITE,j*<span class="number">8</span>,</span><br><span class="line">         I2C_MEMADD_SIZE_8BIT,sendBuffer+j*<span class="number">8</span>,<span class="number">8</span>,<span class="number">1000</span>) == HAL_OK)</span><br><span class="line">      &#123;</span><br><span class="line">         HAL_UART_Transmit(&amp;huart1,<span class="string">&quot;Write Test OK\n&quot;</span>,<span class="number">14</span>,<span class="number">1000</span>);</span><br><span class="line">         HAL_Delay(<span class="number">20</span>);<span class="comment">//写数据的时候大于5ms的延时</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">         HAL_UART_Transmit(&amp;huart1,<span class="string">&quot;Write Test Failed\n&quot;</span>,<span class="number">18</span>,<span class="number">1000</span>);</span><br><span class="line">         HAL_Delay(<span class="number">20</span>);<span class="comment">//同上</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">      // wrinte date to EEPROM   如果要一次写一个字节，写256次，用这里的代码</span></span><br><span class="line"><span class="comment">      for(i=0;i&lt;BufferSize;i++)</span></span><br><span class="line"><span class="comment">      &#123;</span></span><br><span class="line"><span class="comment">          HAL_I2C_Mem_Write(&amp;hi2c1, ADDR_24LCxx_Write, i, I2C_MEMADD_SIZE_8BIT,&amp;WriteBuffer[i],1，0xff);//使用I2C块读，出错。因此采用此种方式，逐个单字节写入</span></span><br><span class="line"><span class="comment">        HAL_Delay(5);//此处延时必加，与AT24C02写时序有关</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">      printf(&quot;\r\n EEPROM 24C02 Write Test OK \r\n&quot;);</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">   HAL_I2C_Mem_Read(&amp;hi2c1,AT24C02_ADDR_READ,<span class="number">0</span>,I2C_MEMADD_SIZE_8BIT,receiveBuffer,<span class="number">256</span>,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">256</span>;k++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">sprintf</span>(message,<span class="string">&quot;0x%02X &quot;</span>,receiveBuffer[k]);</span><br><span class="line">      HAL_UART_Transmit(&amp;huart1,message,<span class="number">6</span>,<span class="number">1000</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// HAL_UART_Transmit(&amp;huart1,&quot;Hello World&quot;,11,1000);</span></span><br><span class="line">   <span class="comment">// HAL_Delay(1000);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意事项</strong>：</p>
<ul>
<li><p><strong>AT24C02的IIC每次写之后要延时一段时间才能继续写 每次写之后要delay 5ms左右 不管硬件IIC采用何种形式（DMA，IT），都要确保两次写入的间隔大于5ms;</strong></p>
</li>
<li><p><strong>AT24C02页写入只支持8个byte，所以需要分32次写入。这不是HAL库的bug，而是AT24C02的限制，其他的EEPROM可以支持更多byte的写入。</strong><br><strong>当然，你也可以每次写一个字节，分成256次写入，也是可以的 那就用注释了的代码即可</strong></p>
</li>
<li><p><strong>读写函数最后一个超时调整为1000以上 因为我们一次写8个字节，延时要久一点</strong></p>
</li>
<li><p><strong>注意读取AT24C02数据的时候延时也要久一点，否则会造成读的数据不完整</strong></p>
</li>
</ul>
</blockquote>
<h2 id="实验-使用AHT20温湿度传感器-轮询"><a href="#实验-使用AHT20温湿度传感器-轮询" class="headerlink" title="实验-使用AHT20温湿度传感器(轮询)"></a>实验-使用AHT20温湿度传感器(轮询)</h2><p><a target="_blank" rel="noopener" href="https://docs.keysking.com/docs/stm32/example/I2C_AHT20">【I²C总线】AHT20温湿度传感器 | 波特律动 (keysking.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1QN411D7ak/?spm_id_from=pageDriver&vd_source=830e63bd86bd9268c1b7cd9ff383f386">【STM32入门教程-2024】第12集 IIC通信与温湿度传感器AHT20(DHT20)_哔哩哔哩_bilibili</a></p>
<h3 id="CubeMX配置："><a href="#CubeMX配置：" class="headerlink" title="CubeMX配置："></a>CubeMX配置：</h3><blockquote>
<ol>
<li>打开I2C外设，参数全部默认即可</li>
<li>启动对应的串口</li>
</ol>
</blockquote>
<h3 id="传感器读取流程"><a href="#传感器读取流程" class="headerlink" title="传感器读取流程"></a>传感器读取流程</h3><p>打开温湿度传感器AHT20数据手册，找到5.4传感器读取流程</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20240920220016640-1752338032551-12.png" alt="image-20240920220016640"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*读取流程1*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> readBuffer;</span><br><span class="line">    HAL_Delay(<span class="number">40</span>);</span><br><span class="line">    HAL_I2C_Master_Transmit(&amp;hi2c1,AHT20_ADDRESS,&amp;readBuffer,<span class="number">1</span>,<span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( (readBuffer &amp; <span class="number">0x08</span>) == <span class="number">0x00</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint8_t</span> sendBuffer[<span class="number">3</span>] = &#123;<span class="number">0xBE</span>,<span class="number">0x08</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line">        HAL_I2C_Master_Transmit(&amp;hi2c1,AHT20_ADDRESS,sendBuffer,<span class="keyword">sizeof</span>(sendBuffer),<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>(readBuffer &amp; 0x08) &#x3D;&#x3D; 0x00 这里按位与就是确定第4位Bit[3]是否为1，不为1就发送sendBuffer</strong></p>
<p>注意&amp;的优先级很低，要加括号</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AHT20_ReadData</span><span class="params">(<span class="type">float</span>* temperature, <span class="type">float</span>* humidity)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> sendBuffer[<span class="number">3</span>] = &#123;<span class="number">0xAC</span>,<span class="number">0x33</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line">    <span class="type">uint8_t</span> readBuffer[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*流程2*/</span> HAL_I2C_Master_Transmit(&amp;hi2c1,AHT20_ADDRESS,sendBuffer,<span class="keyword">sizeof</span>(sendBuffer),<span class="number">100</span>);</span><br><span class="line">    HAL_Delay(<span class="number">75</span>);</span><br><span class="line">    HAL_I2C_Master_Receive(&amp;hi2c1,AHT20_ADDRESS,readBuffer,<span class="keyword">sizeof</span>(readBuffer),<span class="number">100</span>);</span><br><span class="line">    ----------------------------------------</span><br><span class="line">   <span class="comment">/*流程3*/</span></span><br><span class="line">    <span class="keyword">if</span>((readBuffer[<span class="number">0</span>] &amp; <span class="number">0x80</span>) == <span class="number">0x00</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint32_t</span> data = <span class="number">0</span>;</span><br><span class="line">        data = ((<span class="type">uint32_t</span>)readBuffer[<span class="number">1</span>] &lt;&lt; <span class="number">12</span>) + ((<span class="type">uint32_t</span>)readBuffer[<span class="number">2</span>] &lt;&lt; <span class="number">4</span>) + ((<span class="type">uint32_t</span>)readBuffer[<span class="number">3</span>] &gt;&gt; <span class="number">4</span>);</span><br><span class="line">     <span class="comment">/*流程4*/</span>   </span><br><span class="line">        *humidity = (data * <span class="number">100.0</span>)/(<span class="number">1</span>&lt;&lt;<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        data = ( ((<span class="type">uint32_t</span>)readBuffer[<span class="number">3</span>]&amp;<span class="number">0x0F</span>) &lt;&lt; <span class="number">16</span>) + ((<span class="type">uint32_t</span>)readBuffer[<span class="number">4</span>] &lt;&lt; <span class="number">8</span>) + (<span class="type">uint32_t</span>)readBuffer[<span class="number">5</span>];</span><br><span class="line">     <span class="comment">/*流程4*/</span></span><br><span class="line">        *temperature = (data*<span class="number">200.0</span>)/(<span class="number">1</span>&lt;&lt;<span class="number">20</span>)<span class="number">-50</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20240920221150638-1752338032551-13.png" alt="image-20240920221150638"></p>
<blockquote>
<p>上图中蓝色为从机发送给主机的数据，可得温度和湿度都是2.5个字节</p>
<p><strong>需要将其拆开后拼接起来可得到温湿度数据，使用位操作，此时注意强制转换为uint32_t避免移动时丢失数据</strong></p>
</blockquote>
<p>  <strong>最后计算</strong>：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20240920221420656-1752338032552-15.png" alt="image-20240920221420656"></p>
<blockquote>
<p><strong>SRH就是拼接后的湿度，ST就是拼接后的温度</strong></p>
</blockquote>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><blockquote>
<p>我们通常会为不同的模块单独建立驱动文件, <strong>新建.c&#x2F;.h文件aht20.c和aht20.h，在main.c中进行获取温湿度并显示</strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20240920220428021-1752338032552-14.png" alt="image-20240920220428021"></p>
<p>设备地址7位，但是发送时通常是8位，包括一位读写为，故要左移一位即01110000故设备地址为0x70，使用函数时会根据读或写，自动帮我们确定最后一位为0还是1，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*aht20.h文件*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 24-9-20.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> AHT20_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AHT20_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;i2c.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AHT20_ADDRESS 0x70</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_ReadData</span><span class="params">(<span class="type">float</span>* temperature,<span class="type">float</span>* humidity)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//AHT20_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*aht20.c文件*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 24-9-20.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;aht20.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> readBuffer;</span><br><span class="line">    HAL_Delay(<span class="number">40</span>);</span><br><span class="line">    HAL_I2C_Master_Transmit(&amp;hi2c1,AHT20_ADDRESS,&amp;readBuffer,<span class="number">1</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>( (readBuffer &amp; <span class="number">0x08</span>) == <span class="number">0x00</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint8_t</span> sendBuffer[<span class="number">3</span>] = &#123;<span class="number">0xBE</span>,<span class="number">0x08</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line">        HAL_I2C_Master_Transmit(&amp;hi2c1,AHT20_ADDRESS,sendBuffer,<span class="keyword">sizeof</span>(sendBuffer),<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_ReadData</span><span class="params">(<span class="type">float</span>* temperature, <span class="type">float</span>* humidity)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> sendBuffer[<span class="number">3</span>] = &#123;<span class="number">0xAC</span>,<span class="number">0x33</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line">    <span class="type">uint8_t</span> readBuffer[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">    HAL_I2C_Master_Transmit(&amp;hi2c1,AHT20_ADDRESS,sendBuffer,<span class="keyword">sizeof</span>(sendBuffer),<span class="number">100</span>);</span><br><span class="line">    HAL_Delay(<span class="number">75</span>);</span><br><span class="line">    HAL_I2C_Master_Receive(&amp;hi2c1,AHT20_ADDRESS,readBuffer,<span class="keyword">sizeof</span>(readBuffer),<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((readBuffer[<span class="number">0</span>] &amp; <span class="number">0x80</span>) == <span class="number">0x00</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint32_t</span> data = <span class="number">0</span>;</span><br><span class="line">        data = ((<span class="type">uint32_t</span>)readBuffer[<span class="number">1</span>] &lt;&lt; <span class="number">12</span>) + ((<span class="type">uint32_t</span>)readBuffer[<span class="number">2</span>] &lt;&lt; <span class="number">4</span>) + ((<span class="type">uint32_t</span>)readBuffer[<span class="number">3</span>] &gt;&gt; <span class="number">4</span>);</span><br><span class="line">        *humidity = (data * <span class="number">100.0</span>)/(<span class="number">1</span>&lt;&lt;<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        data = ( ((<span class="type">uint32_t</span>)readBuffer[<span class="number">3</span>]&amp;<span class="number">0x0F</span>) &lt;&lt; <span class="number">16</span>) + ((<span class="type">uint32_t</span>)readBuffer[<span class="number">4</span>] &lt;&lt; <span class="number">8</span>) + (<span class="type">uint32_t</span>)readBuffer[<span class="number">5</span>];</span><br><span class="line">        *temperature = (data*<span class="number">200.0</span>)/(<span class="number">1</span>&lt;&lt;<span class="number">20</span>)<span class="number">-50</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 24-9-13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;gpio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;aht20.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f1xx_hal.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdbool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> temperature;</span><br><span class="line"><span class="type">float</span> humidity;</span><br><span class="line"><span class="type">char</span> message[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    AHT20_Init();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    AHT20_ReadData(&amp;temperature,&amp;humidity);</span><br><span class="line">    <span class="built_in">sprintf</span>(message,<span class="string">&quot;温度：%.lf°c 湿度: %.lf %%&quot;</span>,temperature,humidity);</span><br><span class="line">   <span class="comment">/*sprintf函数可以拼接字符串,需要包含stdio.h文件*/</span> HAL_UART_Transmit(&amp;huart2,message,<span class="keyword">sizeof</span>(message),<span class="number">1000</span>);</span><br><span class="line">	<span class="comment">/*发送到串口，使用串口调试助手*/</span></span><br><span class="line">    HAL_Delay(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="IIC中断与DMA以及状态机编程"><a href="#IIC中断与DMA以及状态机编程" class="headerlink" title="IIC中断与DMA以及状态机编程"></a>IIC中断与DMA以及状态机编程</h2><blockquote>
<p> <strong>IIC中断和DMA使用方法和串口类似</strong></p>
</blockquote>
<h3 id="相关函数-5"><a href="#相关函数-5" class="headerlink" title="相关函数"></a>相关函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">HAL_I2C_Master_Transmit_IT(&amp;hi2c1,AHT20_ADDRESS,sendBuffer,<span class="keyword">sizeof</span>(sendBuffer));</span><br><span class="line"><span class="comment">/*中断读写*/</span></span><br><span class="line">HAL_I2C_Master_Receive_IT(&amp;hi2c1,AHT20_ADDRESS,readBuffer,<span class="keyword">sizeof</span>(readBuffer));</span><br><span class="line"></span><br><span class="line">HAL_I2C_Master_Transmit_DMA(&amp;hi2c1,AHT20_ADDRESS,readBuffer,<span class="keyword">sizeof</span>(readBuffer));</span><br><span class="line"><span class="comment">/*DMA模式读写*/</span></span><br><span class="line">HAL_I2C_Master_Receive_DMA(&amp;hi2c1,AHT20_ADDRESS,readBuffer,<span class="keyword">sizeof</span>(readBuffer));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断回调函数和DMA模式下进入的回调函数相同，都是下面的函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_I2C_MasterTxCpltCallback</span><span class="params">(I2C_HandleTypeDef *hi2c)</span>;<span class="comment">//发送回调</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_I2C_MasterRxCpltCallback</span><span class="params">(I2C_HandleTypeDef *hi2c)</span>;<span class="comment">//接收回调</span></span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="状态机编程"><a href="#状态机编程" class="headerlink" title="状态机编程"></a>状态机编程</h3><blockquote>
<p> 在STM32微控制器（MCU）编程中，状态机（State Machine）是一种常用的设计模式，用来管理复杂系统的不同状态以及在状态之间进行的切换。<strong>状态机编程有助于使代码结构清晰、易于维护，特别适用于处理嵌入式系统中的顺序逻辑、通信协议、控制流程等问题</strong>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*状态机编程通常是使用枚举设定状态，例如该模块实验中可以设置如下状态*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    AHT_MEASURE,</span><br><span class="line">    AHT_SEND,</span><br><span class="line">    AHT_GET,</span><br><span class="line">    AHT_RECEIVE,</span><br><span class="line">    AHT_ANALYSIS</span><br><span class="line">&#125; AHT20State;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 0:初始状态发送测量命令</span></span><br><span class="line"><span class="comment"> * 1：发送中</span></span><br><span class="line"><span class="comment"> * 2：发送完成,75ms后进行读取</span></span><br><span class="line"><span class="comment"> * 3：读取中</span></span><br><span class="line"><span class="comment"> * 4：读取完成，数据解析</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*轮询中对应处理*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">switch</span> (aht20State)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> AHT_MEASURE:</span><br><span class="line">            AHT20_Measure();</span><br><span class="line">            aht20State = AHT_SEND;</span><br><span class="line">        <span class="keyword">case</span> AHT_GET:</span><br><span class="line">            HAL_Delay(<span class="number">75</span>);</span><br><span class="line">            AHT20_Get();</span><br><span class="line">            aht20State = AHT_RECEIVE;</span><br><span class="line">        <span class="keyword">case</span> AHT_ANALYSIS:</span><br><span class="line">            AHT20_Analysis(&amp;temperature,&amp;humidity);</span><br><span class="line">            <span class="built_in">sprintf</span>(message,<span class="string">&quot;温度：%.1lf°c 湿度:%.1lf %%&quot;</span>,temperature,humidity);</span><br><span class="line"></span><br><span class="line">            HAL_UART_Transmit(&amp;huart2,message,<span class="keyword">sizeof</span>(message),<span class="number">1000</span>);</span><br><span class="line">            HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">            aht20State =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="实验-使用AHT20温湿度传感器-状态机"><a href="#实验-使用AHT20温湿度传感器-状态机" class="headerlink" title="实验-使用AHT20温湿度传感器(状态机)"></a>实验-使用AHT20温湿度传感器(状态机)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*aht20.h文件*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 24-9-20.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> AHT20_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AHT20_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;i2c.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AHT20_ADDRESS 0x70</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    AHT_MEASURE,</span><br><span class="line">    AHT_SEND,</span><br><span class="line">    AHT_GET,</span><br><span class="line">    AHT_RECEIVE,</span><br><span class="line">    AHT_ANALYSIS</span><br><span class="line">&#125; AHT20State;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 0:初始状态发送测量命令</span></span><br><span class="line"><span class="comment"> * 1：发送中</span></span><br><span class="line"><span class="comment"> * 2：发送完成,75ms后进行读取</span></span><br><span class="line"><span class="comment"> * 3：读取中</span></span><br><span class="line"><span class="comment"> * 4：读取完成，数据解析</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//void AHT20_ReadData(float* temperature,float* humidity);</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_Measure</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_Get</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_Analysis</span><span class="params">(<span class="type">float</span>* temperature, <span class="type">float</span>* humidity)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//AHT20_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*aht20.c文件*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;aht20.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> readBuffer[<span class="number">6</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> readBuffer;</span><br><span class="line">    HAL_Delay(<span class="number">40</span>);</span><br><span class="line">    HAL_I2C_Master_Transmit(&amp;hi2c1,AHT20_ADDRESS,&amp;readBuffer,<span class="number">1</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>( (readBuffer &amp; <span class="number">0x08</span>) == <span class="number">0x00</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint8_t</span> sendBuffer[<span class="number">3</span>] = &#123;<span class="number">0xBE</span>,<span class="number">0x08</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line">        HAL_I2C_Master_Transmit(&amp;hi2c1,AHT20_ADDRESS,sendBuffer,<span class="keyword">sizeof</span>(sendBuffer),<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_Measure</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*此处的sendBuffer为了避免该函数作用域结束后回收，故设置为static方便多次测量*/</span></span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> sendBuffer[<span class="number">3</span>] = &#123;<span class="number">0xAC</span>,<span class="number">0x33</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line">    HAL_I2C_Master_Transmit_DMA(&amp;hi2c1,AHT20_ADDRESS,sendBuffer,<span class="keyword">sizeof</span>(sendBuffer));<span class="comment">//或者以中断模式启动，都是非阻塞模式</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_Get</span><span class="params">()</span></span><br><span class="line">&#123; HAL_I2C_Master_Receive_DMA(&amp;hi2c1,AHT20_ADDRESS,readBuffer,<span class="keyword">sizeof</span>(readBuffer));<span class="comment">//或者以中断模式启动，都是非阻塞模式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_Analysis</span><span class="params">(<span class="type">float</span>* temperature, <span class="type">float</span>* humidity)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>((readBuffer[<span class="number">0</span>] &amp; <span class="number">0x80</span>) == <span class="number">0x00</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint32_t</span> data = <span class="number">0</span>;</span><br><span class="line">        data = ((<span class="type">uint32_t</span>)readBuffer[<span class="number">1</span>] &lt;&lt; <span class="number">12</span>) + ((<span class="type">uint32_t</span>)readBuffer[<span class="number">2</span>] &lt;&lt; <span class="number">4</span>) + ((<span class="type">uint32_t</span>)readBuffer[<span class="number">3</span>] &gt;&gt; <span class="number">4</span>);</span><br><span class="line">        *humidity = (data * <span class="number">100.0</span>)/(<span class="number">1</span>&lt;&lt;<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        data = ( ((<span class="type">uint32_t</span>)readBuffer[<span class="number">3</span>]&amp;<span class="number">0x0F</span>) &lt;&lt; <span class="number">16</span>) + ((<span class="type">uint32_t</span>)readBuffer[<span class="number">4</span>] &lt;&lt; <span class="number">8</span>) + (<span class="type">uint32_t</span>)readBuffer[<span class="number">5</span>];</span><br><span class="line">        *temperature = (data*<span class="number">200.0</span>)/(<span class="number">1</span>&lt;&lt;<span class="number">20</span>)<span class="number">-50</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 24-9-13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;gpio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;aht20.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f1xx_hal.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdbool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> temperature;</span><br><span class="line"><span class="type">float</span> humidity;</span><br><span class="line"><span class="type">char</span> message[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">AHT20State aht20State;<span class="comment">//状态机枚举变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    AHT20_Init();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">switch</span> (aht20State)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> AHT_MEASURE:</span><br><span class="line">            AHT20_Measure();</span><br><span class="line">            aht20State = AHT_SEND;</span><br><span class="line">        <span class="keyword">case</span> AHT_GET:</span><br><span class="line">            HAL_Delay(<span class="number">75</span>);</span><br><span class="line">            AHT20_Get();</span><br><span class="line">            aht20State = AHT_RECEIVE;</span><br><span class="line">        <span class="keyword">case</span> AHT_ANALYSIS:</span><br><span class="line">            AHT20_Analysis(&amp;temperature,&amp;humidity);</span><br><span class="line">            <span class="built_in">sprintf</span>(message,<span class="string">&quot;温度：%.1lf°c 湿度:%.1lf %%&quot;</span>,temperature,humidity);</span><br><span class="line"></span><br><span class="line">            HAL_UART_Transmit(&amp;huart2,message,<span class="keyword">sizeof</span>(message),<span class="number">1000</span>);</span><br><span class="line">            HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">            aht20State =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_I2C_MasterTxCpltCallback</span><span class="params">(I2C_HandleTypeDef *hi2c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(hi2c == &amp;hi2c1)</span><br><span class="line">    &#123;</span><br><span class="line">        aht20State = AHT_GET;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_I2C_MasterRxCpltCallback</span><span class="params">(I2C_HandleTypeDef *hi2c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(hi2c == &amp;hi2c1)</span><br><span class="line">    &#123;</span><br><span class="line">        aht20State = AHT_ANALYSIS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h1><h2 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h2><p><strong>SPI 是英语Serial Peripheral interface的缩写</strong>，顾名思义就是<strong>串行外围设备接口</strong>。是Motorola(摩托罗拉)首先在其MC68HCXX系列处理器上定义的。</p>
<p><strong>SPI是一种高速的，全双工，同步</strong>的通信总线，并且在芯片的管脚上只占用四根线，节约了芯片的管脚，同时为PCB的布局上节省空间，提供方便。</p>
<p>主要应用在 EEPROM，FLASH，实时时钟，AD转换器，还有数字信号处理器和数字信号解码器之间。</p>
<blockquote>
<p> <strong>SPI是全双工且SPI没有定义速度限制，一般的实现通常能达到甚至超过10 Mbps</strong></p>
</blockquote>
<p><strong>学习资料</strong>：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/as480133937/article/details/105764119">SPI原理超详细讲解—值得一看-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/as480133937/article/details/105849607?spm=1001.2014.3001.5502">【STM32】HAL库 STM32CubeMX教程十四—SPI_cubemx spi-CSDN博客</a></p>
<h2 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h2><blockquote>
<p><strong>SPI分为主、从两种模式</strong>，一个SPI通讯系统需要包含<strong>一个（且只能是一个）主设备</strong>，一个或多个从设备。<strong>提供时钟的为主设备（Master</strong>），<strong>接收时钟的设备为从设备（Slave）</strong>。</p>
<p>SPI接口的读写操作，都是由主设备发起。当存在多个从设备时，通过各自的<strong>片选信号</strong>进行管理。</p>
</blockquote>
<h2 id="信号线"><a href="#信号线" class="headerlink" title="信号线"></a>信号线</h2><p><strong>SPI接口有四条信号线通信</strong>:</p>
<ol>
<li><p><strong>SDI(数据输入)</strong></p>
</li>
<li><p><strong>SDO(数据输出)</strong></p>
</li>
<li><p><strong>SCK(时钟)</strong></p>
</li>
<li><p><strong>CS(片选)</strong></p>
</li>
</ol>
<blockquote>
<ul>
<li><strong>MISO</strong>(Master input Slave output)： 主设备输入&#x2F;从设备输出引脚。该引脚在从模式下发送数据，在主模式下接收数据。</li>
<li><strong>MOSI</strong>： 主设备输出&#x2F;从设备输入引脚。该引脚在主模式下发送数据，在从模式下接收数据。</li>
<li><strong>SCLK</strong>：<strong>串行时钟信号</strong>，由主设备产生。</li>
<li><strong>CS&#x2F;SS</strong>：<strong>从设备片选信号</strong>，由主设备控制。它的功能是用来作为“片选引脚”，<strong>也就是选择指定的从设备，让主设备可以单独地与特定从设备通讯，避免数据线上的冲突。</strong></li>
</ul>
</blockquote>
<p><strong>对应硬件上为4根线</strong></p>
<p><strong>SPI一对一</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241106150546130-1752338032552-16.png" alt="image-20241106150546130"></p>
<p><strong>SPI一对多</strong>:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241106150618856-1752338032552-17.png" alt="image-20241106150618856"></p>
<h2 id="数据发送和接收"><a href="#数据发送和接收" class="headerlink" title="数据发送和接收"></a>数据发送和接收</h2><blockquote>
<p><strong>SPI主机和从机都有一个串行移位寄存器(8位)，主机通过向它的SPI串行寄存器写入一个字节来发起一次传输。</strong></p>
<ol>
<li>首先拉低对应SS信号线，表示与该设备进行通信</li>
<li>主机通过发送SCLK时钟信号，来告诉从机写数据或者读数据<br>这里要注意，SCLK时钟信号可能是低电平有效，也可能是高电平有效，因为SPI有四种模式，这个我们在下面会介绍</li>
<li>主机(Master)将要发送的数据写到发送数据缓存区(Memory)，缓存区经过移位寄存器(0~7)，串行移位寄存器通过MOSI信号线将字节一位一位的移出去传送给从机，，同时MISO接口接收到的数据经过移位寄存器一位一位的移到接收缓存区。</li>
<li>从机(Slave)也将自己的串行移位寄存器(0~7)中的内容通过MISO信号线返回给主机。同时通过MOSI信号线接收主机发送的数据，这样，<strong>两个移位寄存器中的内容就被交换。</strong></li>
</ol>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241106151444762-1752338032552-18.png" alt="image-20241106151444762"></p>
<h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><blockquote>
<p><strong>根据时钟极性（CPOL）及相位（CPHA）不同</strong>，<strong>SPI有四种工作模式</strong>。<br>时钟极性(CPOL)定义了时钟空闲状态电平：</p>
<p>CPOL&#x3D;0为时钟空闲时为<strong>低电平</strong><br>CPOL&#x3D;1为时钟空闲时为<strong>高电平</strong><br>时钟相位(CPHA)定义数据的采集时间。</p>
<p>CPHA&#x3D;0:在时钟的<strong>第一个跳变沿</strong>（上升沿或下降沿）进行数据采样。<br>CPHA&#x3D;1:在时钟的<strong>第二个跳变沿</strong>（上升沿或下降沿）进行数据采样。</p>
</blockquote>
<p><strong>对应组合四种模式为</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241106151100423-1752338032552-19.png" alt="image-20241106151100423"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/as480133937/article/details/105764119">SPI原理超详细讲解—值得一看-CSDN博客</a></p>
<h2 id="W25Q128-FLASH芯片"><a href="#W25Q128-FLASH芯片" class="headerlink" title="W25Q128 FLASH芯片"></a>W25Q128 FLASH芯片</h2><p><strong>W25Q128是一款SPI通信的FLASH芯片，可以通过标准&#x2F;两线&#x2F;四线SPI控制</strong></p>
<p>FLASH的大小为16M，分为 256 个块（Block），每个块大小为 64K 字节，每个块又分为 16个扇区（Sector），每个扇区 4K 个字节。</p>
<p>通过SPI通信协议即可实现MCU(STM32)和 W25Q128 之间的通信。实现W25Q128的控制需要通过SPI协议发送相应的控制指令，并满足一定的时序。</p>
<p>打开芯片手册可以找到对应的操作：</p>
<ol>
<li><strong>写使能</strong></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241106154535945-1752338032552-20.png" alt="image-20241106154535945"></p>
<blockquote>
<p>阅读最后一段英文可知：</p>
<p>写入使能通过将 &#x2F;CS 驱动为低电平，将指令代码“06H(0x06)”在 CLK 的上升沿时移至数据输入 （DI） 引脚，然后驱动 &#x2F;CS 为高电平</p>
<p><strong>即：向FLASH发送0x06 写使能命令即可开启写使能，首先CS片选拉低，控制写入字节函数写入命令，CS片选拉高。</strong></p>
</blockquote>
<ol start="2">
<li><strong>扇区擦除指令(Sector Erase)</strong></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241106155057196-1752338032552-21.png" alt="image-20241106155057196"></p>
<blockquote>
<p>第二排可以看到</p>
<p>必须先执行 Write Enable 指令，设备才会接受 Sector Erase。通过将 &#x2F;CS 引脚驱动为低电平来启动该指令，再将指令代码“20H”+24为扇区地址 （A23-A0） </p>
<p>在最后一个字节的第 8 位被锁存后，必须将 &#x2F;CS 引脚驱动为高电平。如果未执行此操作，则Sector Erase 指令将不会被执行。</p>
<p>即：</p>
<p><strong>扇区擦除指令，数据写入前必须擦除对应的存储单元，该指令先拉低&#x2F;CS引脚电平,接着传输“20H”指令和要24位要擦除扇区的地址。</strong></p>
</blockquote>
<ol start="3">
<li><strong>读命令</strong></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241106175057582-1752338032552-22.png" alt="image-20241106175057582"></p>
<blockquote>
<p><strong>第一排：读取可以一次读取一个或多个数据字节</strong></p>
<p><strong>先拉低CS电平，再传输03H，接着通过DI管教传输24为地址，最终数据通过DO引脚引出。每传输一个字节地址自动递增，所以只要时钟继续传输，就可以不断读取出储存器中的数据。</strong></p>
</blockquote>
<ol start="4">
<li><p>状态读取命令(Read Status Register)</p>
</li>
<li><p>写入命令(Page Program)</p>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20241106175641621-1752338032552-23.png" alt="image-20241106175641621"></p>
<blockquote>
<p>在对W25Q128 FLASH的写入数据的操作中一<strong>定要先擦出扇区，在进行写入，否则将会发生数据错误。</strong><br>W25Q128 FLASH一次性最大写入只有256个字节。<br>在进行写操作之前，一定要开启写使能(Write Enable)。<br>当只接收数据时不但能只检测RXNE状态 ，必须同时向发送缓冲区发送数据才能驱动SCK时钟跳变。</p>
</blockquote>
<h2 id="实验读写FLASH-W25Q128"><a href="#实验读写FLASH-W25Q128" class="headerlink" title="实验读写FLASH(W25Q128)"></a>实验读写FLASH(W25Q128)</h2><h3 id="CubeMX配置-12"><a href="#CubeMX配置-12" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h3><p><strong>主要说SPI配置页面</strong>：</p>
<ol>
<li><strong>Mode</strong>： Full-Duplex为全双工  Half-Duplex半双工</li>
</ol>
<ul>
<li>有主机模式全双工&#x2F;半双工</li>
<li>从机模式全双工&#x2F;半双工</li>
<li>只接收主机模式&#x2F;只接收从机模式</li>
<li>只发送主机模式</li>
</ul>
<p><strong>2. Hardware NSS Signal</strong>(硬件片选信号)：片选分为软件片选和硬件片选。STM32有硬件片选信号，可以选择使能，也可以使用其他IO口接到芯片的NSS上进行代替</p>
<p><strong>其中SIP1的片选NSS ： SPI1_NSS（PA4）<br>其中SIP2的片选NSS ： SPI2_NSS（PB12）</strong></p>
<p>如果片选引脚没有连接 SPI1_NSS（PA4）或者SPI2_NSS（PB12），则需要选择软件片选</p>
<blockquote>
<p>NSS管脚及我们熟知的片选信号，作为主设备NSS管脚为高电平，从设备NSS管脚为低电平。当NSS管脚为低电平时，该spi设备被选中，可以和主设备进行通信。在stm32中，每个spi控制器的NSS信号引脚都具有两种功能，即输入和输出。</p>
<p>所谓的输入就是NSS管脚的信号给自己。所谓的输出就是将NSS的信号送出去，给从机。</p>
<p>对于NSS的输入，又分为软件输入和硬件输入。</p>
<p><strong>软件输入</strong>：<br>NSS分为内部管脚和外部管脚，通过设置spi_cr1寄存器的ssm位和ssi位都为1可以设置NSS管脚为软件输入模式且内部管脚提供的电平为高电平，其中SSM位为使能软件输入位。SSI位为设置内部管脚电平位。同理通过设置SSM和SSI位1和0则此时的NSS管脚为软件输入模式但内部管脚提供的电平为0。若从设备是一个其他的带有spi接口的芯片，并不能选择NSS管脚的方式，则可以有两种办法：</p>
<p><strong>1. 将NSS管脚直接接低电平。</strong></p>
<p><strong>2. 通过主设备的任何一个gpio口去输出低电平选中从设备。</strong></p>
<p><strong>硬件输入</strong>：<br>主机接高电平，从机接低电平。</p>
</blockquote>
<p><strong>硬件片选信号直接配置即可，下面说软件片选</strong></p>
<blockquote>
<p>只需要对应软件片选引脚(选择硬件片选对应引脚)，选择GPIO_Output,然后设置下备注即可SPI2_CS</p>
</blockquote>
<blockquote>
<p> W25Q128V芯片闪存芯片进行通信，所以设置为<strong>主机全双工</strong></p>
</blockquote>
<hr>
<p>然后进行基本参数配置：</p>
<blockquote>
<p><strong>Basic Parameters</strong>:</p>
<p>Frame Format(帧格式):默认Motorola通信格式</p>
<p>Data Size: 默认8bit</p>
<p>First Bit：有MSB First(高位在前)和LSB First(低位在前)</p>
<p><strong>Clock Parameters:</strong></p>
<p>Prescaler(for Baud Rate):SPI波特率分频值，决定SPI时钟参数</p>
<p>Baud Rate：上面设置分频后得到的传输速率</p>
<p>Clock Polarity(CPOL)：时钟极性，选择是高还是低电平</p>
<p>Clock Phase(CPHA)：时钟相位，选择第几个跳变沿(上升&#x2F;下降沿)采样</p>
<p><strong>Advanced Parameters</strong>:</p>
<p>CRC Calculation：CRC校验项，提高通信可靠性</p>
<p>NSS Signal Type：选择软件片选或者硬件片选</p>
<p>SPI配置中设置数据长度为8bit,MSB先输出分频为64分频，则波特率为125KBits&#x2F;s。其他为默认设置。<br>Motorla格式，CPOL设置为Low,CPHA设置为第一个边沿。不开启CRC检验，NSS为软件控制。</p>
</blockquote>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>因为我们是软件使能片选，定义片选引脚，<strong>CS片选低电平为有效使能</strong>， <strong>CS片选高电平不使能</strong></p>
<p>这里用两个宏定义来代替</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以W25Q128为例</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_CS_Enable() 			HAL_GPIO_WritePin(GPIOA, SPI1_CS_Pin, GPIO_PIN_RESET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_CS_Disable() 		HAL_GPIO_WritePin(GPIOA, SPI1_CS_Pin, GPIO_PIN_SET)</span></span><br></pre></td></tr></table></figure>



<p>使用野火官方提供的驱动即可</p>
<h2 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h2><p>从对应SPI头文件可以看到对应<strong>轮询，中断和DMA三种方式</strong></p>
<ul>
<li><strong>SPI发送&#x2F;接收数据函数</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size, <span class="type">uint32_t</span> Timeout);<span class="comment">//发送数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * hspi: 选择SPI1/2，比如&amp;hspi1，&amp;hspi2</span></span><br><span class="line"><span class="comment">  * pData ： 需要发送的数据，可以为数组</span></span><br><span class="line"><span class="comment">  * Size： 发送数据的字节数，1 就是发送一个字节数据</span></span><br><span class="line"><span class="comment">  * Timeout： 超时时间，就是执行发送函数最长的时间，超过该时间自动退出发送函数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">HAL_SPI_Receive(SPI_HandleTypeDef *hspi, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size, <span class="type">uint32_t</span> Timeout);<span class="comment">//接收数据</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li><strong>SPI中断函数</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　</span><br><span class="line">HAL_SPI_TransmitReceive_IT(&amp;hspi1, TXbuf,RXbuf,CommSize);</span><br><span class="line"><span class="comment">//中断启动,当SPI上接收出现了 CommSize个字节的数据后，中断函数会调用SPI回调函数：</span></span><br><span class="line">HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi)</span><br><span class="line"><span class="comment">//中断回调</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>











<h1 id="OLED"><a href="#OLED" class="headerlink" title="OLED"></a>OLED</h1><h2 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h2><p>所谓OLED，就是由一个个发光的二极管(发光小灯)组成，<strong>每个小灯称为一个像素</strong>，只要在屏幕上有选择的点亮一部分小灯，就可以显示我们想要的图案，<strong>而小灯排列的数目就是分辨率</strong>。</p>
<blockquote>
<p><strong>常见尺寸分辨率：128X64 -&gt;128列，64行小灯</strong>，此时如果再按照之前的方法一个引脚控制一个小灯的话消耗太大,显然不可能。所以我们<strong>需要屏幕驱动芯片</strong></p>
</blockquote>
<p>有了屏幕驱动芯片，我们只需要通过<strong>IIC或者SPI</strong>等通讯协议与屏幕驱动芯片进行通信，就可以操控这些小灯的亮灭。</p>
<p><strong>常见屏幕驱动芯片有SSD1306、CH1116、SH1106等</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV19u4y197df/?spm_id_from=333.788&vd_source=830e63bd86bd9268c1b7cd9ff383f386">【STM32入门教程-2024】第14集 如何在OLED屏幕上挥毫_哔哩哔哩_bilibili</a></p>
<h2 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h2><p><strong>与CH1116的通信分为两类：指令和数据</strong></p>
<p>以CH1116为例：分辨率为64X128，将64行划分为page0~page7(8页)，</p>
<p>每一个page从0到7共8行，列数为128不变。</p>
<p><strong>从芯片数据手册可以查到，CH1116的从地址为0x7A</strong></p>
<blockquote>
<p>通常在对应芯片手册(下面为CH1116芯片)中可以找到I2C地址，如下图7位为:0111100或0111101，第8位为R&#x2F;W位，故为0x7A</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../assets/image-20240922165310629-1752338032552-24.png" alt="image-20240922165310629"></p>
<blockquote>
<ol>
<li><strong>指令通讯格t式</strong>：</li>
</ol>
<p><strong>0x7A + 0x00  一字节指令</strong>  </p>
<p>0x7A为IIC地址，0x00开头+一字节指令是我们需要发送的。</p>
<p>设置页地址只分为一次，例如：</p>
<p>想设置页地址为page0  0xB0   -&gt; 0x7A 0x00 0xB0  </p>
<p>想设置页地址为 page7  0xB7  -&gt; 0x7A 0x00 0xB7                   </p>
<p>设置列地址需要发送两次指令，假设我们需要设置列地址为0x5A</p>
<p>第一次发送  0x0A，将列地址低4位设置为A</p>
<p>第二次发送   0x15，将列地址高4位设置为5</p>
<p>即，低位0x0，高位0x1</p>
<ol start="2">
<li><strong>数据通讯格式</strong>：</li>
</ol>
<p><strong>0x7A +  0x40  任意数量的数据</strong></p>
<p>0x7A为IIC地址，(0x40开头+任意数量数据)为我们发送的。</p>
</blockquote>
<blockquote>
<p><strong>CH1116等芯片特性</strong>：设置完一字节的8个像素后，列地址会自动+1，这样下一个数据就可以写到本页的下一列里。</p>
<p>利用这特性我们只需要将页地址和列地址都设置为0，然后一次性发送128个字节，就可以直接完成一页屏幕的像素设置</p>
<p>设置第0页: 0x7A 0x00 0xB0  -&gt;需要在循环中手动自增,遍历</p>
<p>设置第0列: 0x7A 0x00 0x0<strong>0</strong> &amp; 0x7A 0x00 0x1<strong>0</strong> -&gt;自动自增</p>
<p>发送显示数据： 0xFF 0xFF ……….共128个</p>
</blockquote>
<h2 id="驱动函数"><a href="#驱动函数" class="headerlink" title="驱动函数"></a>驱动函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*OLED在使用之前需要初始化*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">    OLED_SendCmd(<span class="number">0xAE</span>); <span class="comment">/*关闭显示 display off*/</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0x02</span>); <span class="comment">/*设置列起始地址 set lower column address*/</span></span><br><span class="line">    OLED_SendCmd(<span class="number">0x10</span>); <span class="comment">/*设置列结束地址 set higher column address*/</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0x40</span>); <span class="comment">/*设置起始行 set display start line*/</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0xB0</span>); <span class="comment">/*设置页地址 set page address*/</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0x81</span>); <span class="comment">/*设置对比度 contract control*/</span></span><br><span class="line">    OLED_SendCmd(<span class="number">0xCF</span>); <span class="comment">/*128*/</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0xA1</span>); <span class="comment">/*设置分段重映射 从右到左 set segment remap*/</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0xA6</span>); <span class="comment">/*正向显示 normal / reverse*/</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0xA8</span>); <span class="comment">/*多路复用率 multiplex ratio*/</span></span><br><span class="line">    OLED_SendCmd(<span class="number">0x3F</span>); <span class="comment">/*duty = 1/64*/</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0xAD</span>); <span class="comment">/*设置启动电荷泵 set charge pump enable*/</span></span><br><span class="line">    OLED_SendCmd(<span class="number">0x8B</span>); <span class="comment">/*启动DC-DC */</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0x33</span>); <span class="comment">/*设置泵电压 set VPP 10V */</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0xC8</span>); <span class="comment">/*设置输出扫描方向 COM[N-1]到COM[0] Com scan direction*/</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0xD3</span>); <span class="comment">/*设置显示偏移 set display offset*/</span></span><br><span class="line">    OLED_SendCmd(<span class="number">0x00</span>); <span class="comment">/* 0x00 */</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0xD5</span>); <span class="comment">/*设置内部时钟频率 set osc frequency*/</span></span><br><span class="line">    OLED_SendCmd(<span class="number">0xC0</span>);</span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0xD9</span>); <span class="comment">/*设置放电/预充电时间 set pre-charge period*/</span></span><br><span class="line">    OLED_SendCmd(<span class="number">0x1F</span>); <span class="comment">/*0x22*/</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0xDA</span>); <span class="comment">/*设置引脚布局 set COM pins*/</span></span><br><span class="line">    OLED_SendCmd(<span class="number">0x12</span>);</span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0xDB</span>); <span class="comment">/*设置电平 set vcomh*/</span></span><br><span class="line">    OLED_SendCmd(<span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// OLED_NewFrame();</span></span><br><span class="line">    <span class="comment">// OLED_ShowFrame();</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0xAF</span>); <span class="comment">/*开启显示 display ON*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该函数内容一般厂商会提供，网上搜即可，当然没有的话只有自己写了*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*发送指令*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_SendCmd</span><span class="params">(<span class="type">uint8_t</span> cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> sendBuffer[<span class="number">2</span>] = &#123;<span class="number">0x00</span>,cmd&#125;;</span><br><span class="line">    HAL_I2C_Master_Transmit(&amp;hi2c1,OLED_ADDRESS,sendBuffer,<span class="keyword">sizeof</span>(sendBuffer),HAL_MAX_DELAY);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    OLED_SendCmd(<span class="number">0xB0</span>);<span class="comment">//设置页</span></span><br><span class="line">    OLED_SendCmd(<span class="number">0x02</span>);<span class="comment">//设置列低四位</span></span><br><span class="line">    OLED_SendCmd(<span class="number">0x10</span>);<span class="comment">//设置列高四位</span></span><br><span class="line">    <span class="comment">/*发送指令，设置页和列*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">uint8_t</span> sendBuffer[] = &#123;<span class="number">0x40</span>,<span class="number">0xAA</span>&#125;;</span><br><span class="line">    HAL_I2C_Master_Transmit(&amp;hi2c1,OLED_ADDRESS,sendBuffer,<span class="keyword">sizeof</span>(sendBuffer),HAL_MAX_DELAY);</span><br><span class="line">    <span class="comment">/*发送数据，设置亮灭*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>由于屏幕任意点亮灭是随机的，启动时会花屏，所以需要我们利用显存刷新一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> GRAM[<span class="number">8</span>][<span class="number">128</span>];<span class="comment">//定义显存</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_NewFrame</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">memset</span>(GRAM,<span class="number">0</span>,<span class="keyword">sizeof</span>(GRAM));</span><br><span class="line">&#125;<span class="comment">//将所有像素清空</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowFrame</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> sendBuffer[<span class="number">129</span>];</span><br><span class="line">    sendBuffer[<span class="number">0</span>] = <span class="number">0x40</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">uint8_t</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">uint8_t</span> j=<span class="number">0</span>;j&lt;<span class="number">128</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            sendBuffer[j+<span class="number">1</span>] = GRAM[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        OLED_SendCmd(<span class="number">0xB0</span>+i);</span><br><span class="line">        OLED_SendCmd(<span class="number">0x02</span>);</span><br><span class="line">        OLED_SendCmd(<span class="number">0x10</span>);  	     HAL_I2C_Master_Transmit(&amp;hi2c1,OLED_ADDRESS,sendBuffer,<span class="keyword">sizeof</span>(sendBuffer),HAL_MAX_DELAY);</span><br><span class="line">        <span class="comment">/*只需要对page进行增加，列由于特性会自增，故不需要增加*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_SetPixel</span><span class="params">(<span class="type">uint8_t</span> x,<span class="type">uint8_t</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*该函数作用是使指定坐标亮起*/</span></span><br><span class="line">    <span class="comment">/*描述屏幕时，使用的是下x，y坐标系第四象限,x为列坐标，y为行坐标*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">128</span> || y&gt;=<span class="number">64</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    GRAM[y/<span class="number">8</span>][x] = <span class="number">0x01</span> &lt;&lt; (y%<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">uint8_t</span> i=<span class="number">0</span>;i&lt;<span class="number">64</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        OLED_NewFrame();<span class="comment">//清空显存</span></span><br><span class="line"></span><br><span class="line">        OLED_SetPixel(<span class="number">2</span>*i,i);<span class="comment">//画点</span></span><br><span class="line">        OLED_ShowFrame();<span class="comment">//显示显存</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/*你将会得到一个在屏幕上移动的点*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*OLED初始化通常前面跟一个延时,*/</span></span><br><span class="line">    HAL_Delay(<span class="number">20</span>);</span><br><span class="line">    OLED_Init();</span><br><span class="line">    <span class="comment">/*STM32启动比OLED上电快, 可等待20ms再初始化OLED,避免LED比STM32启动更早*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="取模-图模-字模"><a href="#取模-图模-字模" class="headerlink" title="取模(图模+字模)"></a>取模(图模+字模)</h2><h2 id="CubeMX配置-13"><a href="#CubeMX配置-13" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h2><blockquote>
<p>正常启动I2C配置，由于有大量数据，故只需要将I2C模式标准模式切换为快速模式(Fast Mode)，使用外部高速时钟即可.。</p>
</blockquote>
<h2 id="移植"><a href="#移植" class="headerlink" title="移植"></a>移植</h2><p>为了便于使用，驱动库可以直接移植</p>
<p><a target="_blank" rel="noopener" href="https://led.baud-dance.com/">波特律动LED字模生成器 (baud-dance.com)</a></p>
<p>图模和字模的使用方法：</p>
<blockquote>
<p>使用波特率动取模后，将取模后的代码复制到font.c文件最下方，最后再调用OLED_DrawImage或OLED_PrintString即可使用</p>
</blockquote>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://i.postimg.cc/fbN6bFqP/20220206101541-14a48.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://i.postimg.cc/fbN6bFqP/20220206101541-14a48.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">THEDI</div><div class="post-copyright__author_desc">我想睡到12点!</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://www.thekqd.top/2023/04/02/STM32HAL%E5%BA%93/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://www.thekqd.top/2023/04/02/STM32HAL%E5%BA%93/')">STM32(HAL库)</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/null" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/null" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://www.thekqd.top/2023/04/02/STM32HAL%E5%BA%93/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=STM32(HAL库)&amp;url=https://www.thekqd.top/2023/04/02/STM32HAL%E5%BA%93/&amp;pic=/assets/43.webp" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.thekqd.top" target="_blank">THEDI的仓库</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/STM32/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>STM32<span class="tagsPageCount">2</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="/assets/26.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/06/Linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/100.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux常用指令</div></div></a></div><div class="next-post pull-right"><a href="/2023/07/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/25.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">多线程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2025/01/13/STM32%E6%A0%87%E5%87%86%E5%BA%93/" title="STM32(标准库)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/14.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-01-13</div><div class="title">STM32(标准库)</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://i.postimg.cc/fbN6bFqP/20220206101541-14a48.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">THEDI</h1><div class="author-info__desc">我想睡到12点!</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="/assets/QRCode.jpg" target="_blank" title="微信"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-weixin"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/" target="_blank" title="B站"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg></a><a class="social-icon faa-parent animated-hover" href="mailto:1244381125@qq.com" target="_blank" title="QQ邮箱"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxiang"></use></svg></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">不要偷看我的博客!</div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(null) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%92%8C%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-number">1.</span> <span class="toc-text">实验和一些好用的工具</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%B2%E8%A7%A3%E8%A7%86%E9%A2%91"><span class="toc-number">2.</span> <span class="toc-text">讲解视频</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GPIO"><span class="toc-number">3.</span> <span class="toc-text">GPIO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GPIO%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.1.</span> <span class="toc-text">GPIO介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GPIO%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text">GPIO工作模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%82%B9%E7%81%AF"><span class="toc-number">3.3.</span> <span class="toc-text">点灯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">STM32启动流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6"><span class="toc-number">4.1.</span> <span class="toc-text">启动文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RCC"><span class="toc-number">5.</span> <span class="toc-text">RCC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RCC%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.1.</span> <span class="toc-text">RCC介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E4%BD%8D"><span class="toc-number">5.2.</span> <span class="toc-text">复位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%92%9F"><span class="toc-number">5.3.</span> <span class="toc-text">时钟</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E6%BA%90"><span class="toc-number">5.3.1.</span> <span class="toc-text">时钟源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9FSYSCLK"><span class="toc-number">5.3.2.</span> <span class="toc-text">系统时钟SYSCLK</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%97%B6%E9%92%9F%E6%A0%91"><span class="toc-number">5.4.</span> <span class="toc-text">配置时钟树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SysTick"><span class="toc-number">6.</span> <span class="toc-text">SysTick</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">6.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="toc-number">6.2.</span> <span class="toc-text">寄存器介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#uwTick"><span class="toc-number">6.3.</span> <span class="toc-text">uwTick</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#uwTick%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">6.3.1.</span> <span class="toc-text">uwTick的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#uwTick%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">6.3.2.</span> <span class="toc-text">uwTick的使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8-uwTick"><span class="toc-number">6.3.3.</span> <span class="toc-text">如何配置和使用 uwTick</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">6.3.3.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96-uwTick"><span class="toc-number">6.3.3.2.</span> <span class="toc-text">读取 uwTick</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%90%8E%E7%9A%84%E6%97%B6%E9%97%B4"><span class="toc-number">6.3.3.3.</span> <span class="toc-text">获取系统启动后的时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98"><span class="toc-number">6.3.3.4.</span> <span class="toc-text">处理溢出问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HAL-Delay"><span class="toc-number">6.3.4.</span> <span class="toc-text">HAL_Delay</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0"><span class="toc-number">6.3.5.</span> <span class="toc-text">自定义延时函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">6.3.6.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#uwTick%E4%B8%8E%E7%A1%AC%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E5%A4%96%E8%AE%BE%E5%8C%BA%E5%88%AB"><span class="toc-number">6.4.</span> <span class="toc-text">uwTick与硬件定时器外设区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#uwTick-1"><span class="toc-number">6.4.1.</span> <span class="toc-text">uwTick</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E5%A4%96%E8%AE%BE"><span class="toc-number">6.4.2.</span> <span class="toc-text">硬件定时器外设</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90"><span class="toc-number">6.4.3.</span> <span class="toc-text">使用场景分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-uwTick-%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">6.4.3.1.</span> <span class="toc-text">使用 uwTick 的场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%A1%AC%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E5%A4%96%E8%AE%BE%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">6.4.3.2.</span> <span class="toc-text">使用硬件定时器外设的场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E5%AF%B9%E6%AF%94%E8%A1%A8"><span class="toc-number">6.4.4.</span> <span class="toc-text">总结对比表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RCC%E4%B8%8ESysTick"><span class="toc-number">7.</span> <span class="toc-text">RCC与SysTick</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Timebase-Souce"><span class="toc-number">8.</span> <span class="toc-text">Timebase Souce</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E5%9F%BA%E4%BB%8B%E7%BB%8D"><span class="toc-number">8.1.</span> <span class="toc-text">时基介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">8.2.</span> <span class="toc-text">常用配置</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="toc-number">9.</span> <span class="toc-text">中断和异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">9.1.</span> <span class="toc-text">中断优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E5%88%86%E7%BB%84"><span class="toc-number">9.2.</span> <span class="toc-text">优先级分组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NVIC"><span class="toc-number">9.3.</span> <span class="toc-text">NVIC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXTI"><span class="toc-number">9.4.</span> <span class="toc-text">EXTI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C"><span class="toc-number">9.5.</span> <span class="toc-text">实验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E6%8C%89%E9%94%AE%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6LED%E4%BA%AE%E7%81%AD"><span class="toc-number">9.5.1.</span> <span class="toc-text">外部按键中断控制LED亮灭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E9%94%AE%E6%B6%88%E6%8A%96"><span class="toc-number">9.5.2.</span> <span class="toc-text">按键消抖:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AE%E8%AF%A2%E6%8C%89%E9%94%AE%E6%8E%A7%E5%88%B6LED%E4%BA%AE%E7%81%AD-%E5%BB%B6%E6%97%B6%E6%B6%88%E6%8A%96"><span class="toc-number">9.5.2.1.</span> <span class="toc-text">轮询按键控制LED亮灭(延时消抖)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD-%E5%AE%9A%E6%97%B6%E5%99%A8%E6%B6%88%E6%8A%96-%E6%8E%A8%E8%8D%90"><span class="toc-number">9.5.2.2.</span> <span class="toc-text">外部中断+定时器消抖(推荐)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E9%94%AE%E7%8A%B6%E6%80%81%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8%E6%B6%88%E6%8A%96"><span class="toc-number">9.5.2.3.</span> <span class="toc-text">按键状态机+定时器消抖</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">9.5.3.</span> <span class="toc-text">使用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9B%B8%E5%85%B3%E7%9A%84-volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">10.</span> <span class="toc-text">中断相关的-volatile关键字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E8%AE%AF%E6%A6%82%E5%BF%B5"><span class="toc-number">11.</span> <span class="toc-text">通讯概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F"><span class="toc-number">11.1.</span> <span class="toc-text">通讯方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%AE%AF%E9%80%9F%E7%8E%87"><span class="toc-number">11.2.</span> <span class="toc-text">通讯速率</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#USART"><span class="toc-number">12.</span> <span class="toc-text">USART</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">12.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD"><span class="toc-number">12.2.</span> <span class="toc-text">功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E6%8E%A5%E5%8F%97%E4%B8%8E%E5%8F%91%E9%80%81"><span class="toc-number">12.3.</span> <span class="toc-text">串口接受与发送</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#USART%E4%B8%AD%E6%96%AD"><span class="toc-number">12.4.</span> <span class="toc-text">USART中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-1"><span class="toc-number">12.5.</span> <span class="toc-text">实验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#USART1%E6%99%AE%E9%80%9A%E4%B8%AD%E6%96%AD%E5%9B%9E%E6%98%BE%E5%AE%9E%E9%AA%8C"><span class="toc-number">12.5.1.</span> <span class="toc-text">USART1普通中断回显实验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#USART2%E6%8E%A7%E5%88%B6LED%E7%81%AF"><span class="toc-number">12.5.2.</span> <span class="toc-text">USART2控制LED灯</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E6%8E%A5%E6%94%B6%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%95%B0%E6%8D%AE"><span class="toc-number">12.6.</span> <span class="toc-text">串口接收不定长数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-2"><span class="toc-number">12.7.</span> <span class="toc-text">实验</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HAL%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">13.</span> <span class="toc-text">HAL库函数的一些调用流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TIM-%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">14.</span> <span class="toc-text">TIM(定时器)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-number">14.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84LED%E9%97%AA%E7%83%81"><span class="toc-number">14.2.</span> <span class="toc-text">基于定时器的LED闪烁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CubeMX%E9%85%8D%E7%BD%AE"><span class="toc-number">14.2.1.</span> <span class="toc-text">CubeMX配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%92%8C%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81"><span class="toc-number">14.2.2.</span> <span class="toc-text">函数和业务代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RTC"><span class="toc-number">14.3.</span> <span class="toc-text">RTC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RTC%E6%97%B6%E9%92%9F%E9%80%89%E6%8B%A9"><span class="toc-number">14.3.1.</span> <span class="toc-text">RTC时钟选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RTC%E4%B8%AD%E6%96%AD"><span class="toc-number">14.3.2.</span> <span class="toc-text">RTC中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CubeMX%E9%85%8D%E7%BD%AE-1"><span class="toc-number">14.3.3.</span> <span class="toc-text">CubeMX配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-number">14.3.4.</span> <span class="toc-text">库函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E5%AE%9E%E6%97%B6%E6%97%B6%E9%97%B4OLED%E6%98%BE%E7%A4%BA"><span class="toc-number">14.3.5.</span> <span class="toc-text">实验-实时时间OLED显示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RTC%E6%8E%89%E7%94%B5%E9%87%8D%E7%BD%AE"><span class="toc-number">14.3.6.</span> <span class="toc-text">RTC掉电重置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BKP%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">14.3.6.1.</span> <span class="toc-text">BKP寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%8E%89%E7%94%B5%E9%87%8D%E7%BD%AE%E4%BB%A3%E7%A0%81"><span class="toc-number">14.3.6.2.</span> <span class="toc-text">解决掉电重置代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E5%A4%96%E9%83%A8%E6%97%B6%E9%92%9F%E4%B8%8E%E5%BE%AA%E8%BF%B9%E6%A8%A1%E5%9D%97"><span class="toc-number">14.4.</span> <span class="toc-text">定时器外部时钟与循迹模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E8%BF%B9%E6%A8%A1%E5%9D%97"><span class="toc-number">14.4.1.</span> <span class="toc-text">循迹模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%96%E5%8A%A8%E8%84%89%E5%86%B2"><span class="toc-number">14.4.2.</span> <span class="toc-text">抖动脉冲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%BB%A4%E6%B3%A2%E5%99%A8"><span class="toc-number">14.4.3.</span> <span class="toc-text">输入滤波器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PWM"><span class="toc-number">14.5.</span> <span class="toc-text">PWM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-2"><span class="toc-number">14.5.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">14.5.2.</span> <span class="toc-text">相关函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-PWM%E6%8E%A7%E5%88%B6LED%E4%BA%AE%E5%BA%A6%E5%AE%9E%E7%8E%B0%E5%91%BC%E5%90%B8%E7%81%AF"><span class="toc-number">14.5.3.</span> <span class="toc-text">实验-PWM控制LED亮度实现呼吸灯</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CubeMX%E9%85%8D%E7%BD%AE-2"><span class="toc-number">14.5.3.1.</span> <span class="toc-text">CubeMX配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81-%E8%BD%AE%E8%AF%A2%E4%BF%AE%E6%94%B9%E5%8D%A0%E7%A9%BA%E6%AF%94"><span class="toc-number">14.5.3.2.</span> <span class="toc-text">业务代码(轮询修改占空比)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81-%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BF%AE%E6%94%B9%E5%8D%A0%E7%A9%BA%E6%AF%94"><span class="toc-number">14.5.3.3.</span> <span class="toc-text">业务代码(定时器修改占空比)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-PWM%E6%8E%A7%E5%88%B6%E6%97%A0%E6%BA%90%E8%9C%82%E9%B8%A3%E5%99%A8"><span class="toc-number">14.5.4.</span> <span class="toc-text">实验-PWM控制无源蜂鸣器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">14.5.4.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CubeMX%E9%85%8D%E7%BD%AE-3"><span class="toc-number">14.5.4.2.</span> <span class="toc-text">CubeMX配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81"><span class="toc-number">14.5.4.3.</span> <span class="toc-text">业务代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-PWM%E6%8E%A7%E5%88%B6%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA"><span class="toc-number">14.5.5.</span> <span class="toc-text">实验-PWM控制直流电机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DRV8833%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97"><span class="toc-number">14.5.5.1.</span> <span class="toc-text">DRV8833电机驱动模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">14.5.5.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CubeMX%E9%85%8D%E7%BD%AE-4"><span class="toc-number">14.5.5.3.</span> <span class="toc-text">CubeMX配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81-1"><span class="toc-number">14.5.5.4.</span> <span class="toc-text">业务代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E5%BA%93"><span class="toc-number">14.5.5.5.</span> <span class="toc-text">驱动库</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7"><span class="toc-number">14.6.</span> <span class="toc-text">输入捕获</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-3"><span class="toc-number">14.6.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">14.6.2.</span> <span class="toc-text">捕获寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-1"><span class="toc-number">14.6.3.</span> <span class="toc-text">相关函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E5%8D%95%E9%80%9A%E9%81%93%E6%B5%8B%E9%A2%91%E7%8E%87"><span class="toc-number">14.6.4.</span> <span class="toc-text">输入捕获单通道测频率</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81-2"><span class="toc-number">14.6.4.1.</span> <span class="toc-text">业务代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%B5%8B%E8%B7%9D%E4%BB%8B%E7%BB%8D"><span class="toc-number">14.6.5.</span> <span class="toc-text">超声波测距介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81-3"><span class="toc-number">14.6.5.1.</span> <span class="toc-text">业务代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC%E7%BC%96%E7%A0%81%E5%99%A8"><span class="toc-number">14.7.</span> <span class="toc-text">旋转编码器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E5%9E%8B%E6%97%8B%E8%BD%AC%E7%BC%96%E7%A0%81%E5%99%A8"><span class="toc-number">14.7.1.</span> <span class="toc-text">增量型旋转编码器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-2"><span class="toc-number">14.7.1.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-number">14.7.1.2.</span> <span class="toc-text">实现思路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E4%BD%BF%E7%94%A8%E5%A2%9E%E9%87%8F%E5%9E%8B%E6%97%8B%E8%BD%AC%E7%BC%96%E7%A0%81%E5%99%A8%E6%8E%A7%E5%88%B6%E5%B0%8F%E7%81%AF%E4%BA%AE%E5%BA%A6"><span class="toc-number">14.7.2.</span> <span class="toc-text">实验-使用增量型旋转编码器控制小灯亮度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CubeMX%E9%85%8D%E7%BD%AE-5"><span class="toc-number">14.7.2.1.</span> <span class="toc-text">CubeMX配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">14.7.2.2.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81-4"><span class="toc-number">14.7.2.3.</span> <span class="toc-text">业务代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%88%B5%E6%9C%BA-SERVO"><span class="toc-number">14.8.</span> <span class="toc-text">舵机(SERVO)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-PWM"><span class="toc-number">14.8.1.</span> <span class="toc-text">原理(PWM)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E4%BD%BF%E7%94%A8%E6%97%8B%E8%BD%AC%E7%BC%96%E7%A0%81%E5%99%A8%E6%8E%A7%E5%88%B6%E8%88%B5%E6%9C%BA-SG90-%E6%97%8B%E8%BD%AC"><span class="toc-number">14.8.2.</span> <span class="toc-text">实验-使用旋转编码器控制舵机(SG90)旋转</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CubeMX%E9%85%8D%E7%BD%AE-6"><span class="toc-number">14.8.2.1.</span> <span class="toc-text">CubeMX配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81-5"><span class="toc-number">14.8.2.2.</span> <span class="toc-text">业务代码</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9C%8B%E9%97%A8%E7%8B%97"><span class="toc-number">15.</span> <span class="toc-text">看门狗</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">15.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E7%9C%8B%E9%97%A8%E7%8B%97"><span class="toc-number">15.2.</span> <span class="toc-text">独立看门狗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CubeMX%E9%85%8D%E7%BD%AE-7"><span class="toc-number">15.2.1.</span> <span class="toc-text">CubeMX配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-2"><span class="toc-number">15.2.2.</span> <span class="toc-text">相关函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E7%9C%8B%E9%97%A8%E7%8B%97"><span class="toc-number">15.3.</span> <span class="toc-text">窗口看门狗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-number">15.3.1.</span> <span class="toc-text">中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE"><span class="toc-number">15.3.2.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-3"><span class="toc-number">15.3.3.</span> <span class="toc-text">相关函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-3"><span class="toc-number">15.3.4.</span> <span class="toc-text">实验</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A8%A1%E5%9D%97"><span class="toc-number">16.</span> <span class="toc-text">传感器模块</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ADC"><span class="toc-number">17.</span> <span class="toc-text">ADC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">17.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE"><span class="toc-number">17.2.</span> <span class="toc-text">参数配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-4"><span class="toc-number">17.3.</span> <span class="toc-text">相关函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E8%BD%AE%E8%AF%A2%E8%AF%BB%E5%8F%96ADC%E7%9A%84%E5%80%BC"><span class="toc-number">17.4.</span> <span class="toc-text">实验-轮询读取ADC的值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CubeMX%E9%85%8D%E7%BD%AE-8"><span class="toc-number">17.4.1.</span> <span class="toc-text">CubeMX配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81-6"><span class="toc-number">17.4.2.</span> <span class="toc-text">业务代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E4%BD%BF%E7%94%A8ADC%E8%AF%BB%E5%8F%96%E7%94%B5%E4%BD%8D%E5%99%A8%E7%94%B5%E5%8E%8B-%E5%8D%95%E9%80%9A%E9%81%93"><span class="toc-number">17.5.</span> <span class="toc-text">实验-使用ADC读取电位器电压(单通道)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B5%E4%BD%8D%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="toc-number">17.5.1.</span> <span class="toc-text">电位器介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CubeMX%E9%85%8D%E7%BD%AE-9"><span class="toc-number">17.5.2.</span> <span class="toc-text">CubeMX配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81-7"><span class="toc-number">17.5.3.</span> <span class="toc-text">业务代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E4%BD%BF%E7%94%A8NTC%E7%83%AD%E6%95%8F%E4%BC%A0%E6%84%9F%E5%99%A8%E6%B5%8B%E9%87%8F%E6%B8%A9%E5%BA%A6-%E5%8D%95%E9%80%9A%E9%81%93"><span class="toc-number">17.6.</span> <span class="toc-text">实验-使用NTC热敏传感器测量温度(单通道)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NTC-%E7%83%AD%E6%95%8F%E7%94%B5%E9%98%BB%E4%BB%8B%E7%BB%8D"><span class="toc-number">17.6.1.</span> <span class="toc-text">NTC-热敏电阻介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-3"><span class="toc-number">17.6.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CubeMX%E9%85%8D%E7%BD%AE-10"><span class="toc-number">17.6.3.</span> <span class="toc-text">CubeMX配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81-8"><span class="toc-number">17.6.4.</span> <span class="toc-text">业务代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DMA"><span class="toc-number">18.</span> <span class="toc-text">DMA</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-4"><span class="toc-number">18.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DMA%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F"><span class="toc-number">18.2.</span> <span class="toc-text">DMA传输方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3DMA%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%94%B6%E5%8F%91%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%95%B0%E6%8D%AE"><span class="toc-number">18.3.</span> <span class="toc-text">串口DMA模式与收发不定长数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DMA%E6%A8%A1%E5%BC%8F"><span class="toc-number">18.3.1.</span> <span class="toc-text">DMA模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B6%E5%8F%91%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%95%B0%E6%8D%AE-Idle"><span class="toc-number">18.3.2.</span> <span class="toc-text">收发不定长数据-Idle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DMA%E4%BC%A0%E8%BE%93%E8%BF%87%E5%8D%8A%E4%B8%AD%E6%96%AD"><span class="toc-number">18.3.3.</span> <span class="toc-text">DMA传输过半中断</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%93%9D%E7%89%99%E6%A8%A1%E5%9D%97%E4%B8%8E%E7%AE%80%E6%98%93%E6%95%B0%E6%8D%AE%E5%8C%85%E8%A7%A3%E6%9E%90"><span class="toc-number">19.</span> <span class="toc-text">蓝牙模块与简易数据包解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%93%9D%E7%89%99%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D"><span class="toc-number">19.1.</span> <span class="toc-text">蓝牙模块介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE"><span class="toc-number">19.2.</span> <span class="toc-text">协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E8%93%9D%E7%89%99%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6LED-UART"><span class="toc-number">19.3.</span> <span class="toc-text">实验(蓝牙发送数据控制LED-UART)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E6%98%93%E6%95%B0%E6%8D%AE%E5%8C%85%E8%A7%A3%E6%9E%90"><span class="toc-number">19.3.1.</span> <span class="toc-text">简易数据包解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%93%9D%E7%89%99%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6LED%E5%BC%80%E5%85%B3"><span class="toc-number">19.3.2.</span> <span class="toc-text">蓝牙发送数据控制LED开关</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IIC"><span class="toc-number">20.</span> <span class="toc-text">IIC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">20.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">20.2.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">20.3.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%B1%82%E4%B8%8E%E5%8D%8F%E8%AE%AE%E5%B1%82"><span class="toc-number">20.4.</span> <span class="toc-text">物理层与协议层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E"><span class="toc-number">20.5.</span> <span class="toc-text">主从</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IIC%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">20.6.</span> <span class="toc-text">IIC相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IIC%E8%AF%BB%E5%86%99"><span class="toc-number">20.6.1.</span> <span class="toc-text">IIC读写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IIC%E4%B8%AD%E6%96%AD"><span class="toc-number">20.6.2.</span> <span class="toc-text">IIC中断</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E8%AF%BB%E5%86%99EEPROM-AT24C02"><span class="toc-number">20.7.</span> <span class="toc-text">实验-读写EEPROM(AT24C02)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#EEPROM%E4%BB%8B%E7%BB%8D"><span class="toc-number">20.7.1.</span> <span class="toc-text">EEPROM介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%9C%B0%E5%9D%80"><span class="toc-number">20.7.2.</span> <span class="toc-text">设备地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E8%AF%BB%E6%95%B0%E6%8D%AE"><span class="toc-number">20.7.3.</span> <span class="toc-text">写读数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CubeMX%E9%85%8D%E7%BD%AE-11"><span class="toc-number">20.7.4.</span> <span class="toc-text">CubeMX配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">20.7.5.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E4%BD%BF%E7%94%A8AHT20%E6%B8%A9%E6%B9%BF%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8-%E8%BD%AE%E8%AF%A2"><span class="toc-number">20.8.</span> <span class="toc-text">实验-使用AHT20温湿度传感器(轮询)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CubeMX%E9%85%8D%E7%BD%AE%EF%BC%9A"><span class="toc-number">20.8.1.</span> <span class="toc-text">CubeMX配置：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E6%84%9F%E5%99%A8%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B"><span class="toc-number">20.8.2.</span> <span class="toc-text">传感器读取流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="toc-number">20.8.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IIC%E4%B8%AD%E6%96%AD%E4%B8%8EDMA%E4%BB%A5%E5%8F%8A%E7%8A%B6%E6%80%81%E6%9C%BA%E7%BC%96%E7%A8%8B"><span class="toc-number">20.9.</span> <span class="toc-text">IIC中断与DMA以及状态机编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-5"><span class="toc-number">20.9.1.</span> <span class="toc-text">相关函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA%E7%BC%96%E7%A8%8B"><span class="toc-number">20.9.2.</span> <span class="toc-text">状态机编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E4%BD%BF%E7%94%A8AHT20%E6%B8%A9%E6%B9%BF%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8-%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">20.9.3.</span> <span class="toc-text">实验-使用AHT20温湿度传感器(状态机)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SPI"><span class="toc-number">21.</span> <span class="toc-text">SPI</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-3"><span class="toc-number">21.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F"><span class="toc-number">21.2.</span> <span class="toc-text">主从模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E7%BA%BF"><span class="toc-number">21.3.</span> <span class="toc-text">信号线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6"><span class="toc-number">21.4.</span> <span class="toc-text">数据发送和接收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">21.5.</span> <span class="toc-text">工作模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#W25Q128-FLASH%E8%8A%AF%E7%89%87"><span class="toc-number">21.6.</span> <span class="toc-text">W25Q128 FLASH芯片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%AF%BB%E5%86%99FLASH-W25Q128"><span class="toc-number">21.7.</span> <span class="toc-text">实验读写FLASH(W25Q128)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CubeMX%E9%85%8D%E7%BD%AE-12"><span class="toc-number">21.7.1.</span> <span class="toc-text">CubeMX配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="toc-number">21.7.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-1"><span class="toc-number">21.8.</span> <span class="toc-text">函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#OLED"><span class="toc-number">22.</span> <span class="toc-text">OLED</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-4"><span class="toc-number">22.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-4"><span class="toc-number">22.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E5%87%BD%E6%95%B0"><span class="toc-number">22.3.</span> <span class="toc-text">驱动函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%96%E6%A8%A1-%E5%9B%BE%E6%A8%A1-%E5%AD%97%E6%A8%A1"><span class="toc-number">22.4.</span> <span class="toc-text">取模(图模+字模)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CubeMX%E9%85%8D%E7%BD%AE-13"><span class="toc-number">22.5.</span> <span class="toc-text">CubeMX配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E6%A4%8D"><span class="toc-number">22.6.</span> <span class="toc-text">移植</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/11/08/%E9%98%9F%E5%88%97/" title="队列"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/26.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="队列"/></a><div class="content"><a class="title" href="/2025/11/08/%E9%98%9F%E5%88%97/" title="队列">队列</a><time datetime="2025-11-08T15:32:44.000Z" title="发表于 2025-11-08 23:32:44">2025-11-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/08/%E6%A0%88/" title="栈"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/213.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="栈"/></a><div class="content"><a class="title" href="/2025/11/08/%E6%A0%88/" title="栈">栈</a><time datetime="2025-11-08T15:32:40.000Z" title="发表于 2025-11-08 23:32:40">2025-11-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/08/%E9%93%BE%E8%A1%A8/" title="链表"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/25.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="链表"/></a><div class="content"><a class="title" href="/2025/11/08/%E9%93%BE%E8%A1%A8/" title="链表">链表</a><time datetime="2025-11-08T15:25:17.000Z" title="发表于 2025-11-08 23:25:17">2025-11-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/30/MQTT%E8%BF%9E%E6%8E%A5AWS-IoT/" title="MQTT连接AWS IoT"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/22.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MQTT连接AWS IoT"/></a><div class="content"><a class="title" href="/2025/08/30/MQTT%E8%BF%9E%E6%8E%A5AWS-IoT/" title="MQTT连接AWS IoT">MQTT连接AWS IoT</a><time datetime="2025-08-29T16:33:21.000Z" title="发表于 2025-08-30 00:33:21">2025-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/30/TLS%E4%BC%A0%E8%BE%93%E5%B1%82%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/" title="TLS传输层安全协议"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/98.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TLS传输层安全协议"/></a><div class="content"><a class="title" href="/2025/08/30/TLS%E4%BC%A0%E8%BE%93%E5%B1%82%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/" title="TLS传输层安全协议">TLS传输层安全协议</a><time datetime="2025-08-29T16:31:07.000Z" title="发表于 2025-08-30 00:31:07">2025-08-30</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="workboard"><img class="workSituationImg boardsign" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-上班摸鱼中.svg" alt="距离月入25k也就还差一个大佬带我~" title="距离月入25k也就还差一个大佬带我~"/><div id="runtimeTextTip"></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://blog.anheyu.com/" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"/></a><a class="github-badge" target="_blank" href="https://www.dogecloud.com/" style="margin-inline:5px" data-title="本站使用多吉云为静态资源提供CDN加速" title="本站使用多吉云为静态资源提供CDN加速"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/CDN-多吉云-3693F3.svg" alt="本站使用多吉云为静态资源提供CDN加速"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"/></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2022 - 2025 By <a class="footer-bar-link" href="/" title="THEDI" target="_blank">THEDI</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">66</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">8</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="安知鱼的博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="安知鱼的博客"/><span class="back-menu-item-text">安知鱼的博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/keqiudi/keqiudi.github.io" title="我的博客仓库"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="我的博客仓库"/><span class="back-menu-item-text">我的博客仓库</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/sites/"><span> 网站导航</span></a></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AWS/" style="font-size: 0.88rem;">AWS<sup>2</sup></a><a href="/tags/C/" style="font-size: 0.88rem;">C++<sup>2</sup></a><a href="/tags/CLion/" style="font-size: 0.88rem;">CLion<sup>2</sup></a><a href="/tags/CMake/" style="font-size: 0.88rem;">CMake<sup>1</sup></a><a href="/tags/ESP32/" style="font-size: 0.88rem;">ESP32<sup>1</sup></a><a href="/tags/FreeRTOS/" style="font-size: 0.88rem;">FreeRTOS<sup>5</sup></a><a href="/tags/Git/" style="font-size: 0.88rem;">Git<sup>1</sup></a><a href="/tags/LCD/" style="font-size: 0.88rem;">LCD<sup>2</sup></a><a href="/tags/LVGL/" style="font-size: 0.88rem;">LVGL<sup>7</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem;">Linux<sup>8</sup></a><a href="/tags/MySQL/" style="font-size: 0.88rem;">MySQL<sup>2</sup></a><a href="/tags/PCB/" style="font-size: 0.88rem;">PCB<sup>2</sup></a><a href="/tags/QT/" style="font-size: 0.88rem;">QT<sup>1</sup></a><a href="/tags/STM32/" style="font-size: 0.88rem;">STM32<sup>2</sup></a><a href="/tags/keil/" style="font-size: 0.88rem;">keil<sup>1</sup></a><a href="/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1/" style="font-size: 0.88rem;">云服务<sup>3</sup></a><a href="/tags/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" style="font-size: 0.88rem;">启动流程<sup>2</sup></a><a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%89%E5%85%A8/" style="font-size: 0.88rem;">嵌入式安全<sup>3</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 0.88rem;">数据结构<sup>3</sup></a><a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 0.88rem;">架构<sup>2</sup></a><a href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" style="font-size: 0.88rem;">环境配置<sup>4</sup></a><a href="/tags/%E7%A1%AC%E4%BB%B6/" style="font-size: 0.88rem;">硬件<sup>5</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>3</sup></a><a href="/tags/%E8%B0%83%E8%AF%95/" style="font-size: 0.88rem;">调试<sup>5</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.cbd.int/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("12/01/2022 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2022 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 THEDI 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("12/01/2022 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-下班啦.svg";
        img.title = "下班了就该开开心心的玩耍，嘿嘿~";
        img.alt = "下班了就该开开心心的玩耍，嘿嘿~";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><script src="https://cdn.cbd.int/algoliasearch@4.18.0/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.cbd.int/instantsearch.js@4.60.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script async src="//at.alicdn.com/t/c/font_4169545_k8d3mxnig4s.js"></script><script src="/js/sites.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>