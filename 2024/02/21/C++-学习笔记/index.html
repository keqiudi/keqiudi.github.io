<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>C++学习笔记 | THEDI的仓库</title><meta name="keywords" content="C++"><meta name="author" content="THEDI"><meta name="copyright" content="THEDI"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="C++学习笔记"><meta name="application-name" content="C++学习笔记"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="C++学习笔记"><meta property="og:url" content="https://www.thekqd.top/2024/02/21/C++-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><meta property="og:site_name" content="THEDI的仓库"><meta property="og:description" content="学习C++时的一点笔记"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://www.thekqd.top/assets/43.webp"><meta property="article:author" content="THEDI"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.thekqd.top/assets/43.webp"><meta name="description" content="学习C++时的一点笔记"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://www.thekqd.top/2024/02/21/C++-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="manifest" href="/manifest.json"/><meta name="msapplication-TileColor" content="var(--anzhiyu-main)"/><link rel="mask-icon" href="/img/siteicon/apple-icon-180.png" color="#5bbad5"/><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/apple-icon-180.png"/><link rel="apple-touch-icon-precomposed" sizes="180x180" href="/img/siteicon/apple-icon-180.png"/><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/16.png"/><link rel="bookmark" href="/img/siteicon/apple-icon-180.png"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2048-2732.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2732-2048.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1668-2388.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2388-1668.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1536-2048.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2048-1536.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1668-2224.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2224-1668.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1620-2160.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2160-1620.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1290-2796.jpg" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2796-1290.jpg" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1179-2556.jpg" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2556-1179.jpg" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1284-2778.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2778-1284.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1170-2532.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2532-1170.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1125-2436.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2436-1125.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1242-2688.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2688-1242.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-828-1792.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1792-828.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1242-2208.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2208-1242.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-750-1334.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1334-750.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-640-1136.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"/><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1136-640.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"/><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css#fontawesome_animation 如果有就会加载，示例值：https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: {"enable":true,"title":"与大家一起进步","addFriendPlaceholder":"昵称（请勿包含博客等字样）：\n网站地址（要求博客地址，请勿提交个人主页）：\n头像图片url（请提供尽可能清晰的图片，我会上传到我自己的图床）：\n描述：\n站点截图（可选）：\n"},
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"该回来学习啦！","backTitle":"w(ﾟДﾟ)w快认真学习！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🏠 智能家居小能手"]},
  algolia: {"appId":"PW49GHYJ6T","apiKey":"42b04be58e36cfebeb6ac1989c6e8009","indexName":"hexo","hits":{"per_page":6},"languages":{"input_placeholder":"输入关键词后按下回车查找","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: THEDI","link":"链接: ","source":"来源: THEDI的仓库","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'THEDI的仓库',
  title: 'C++学习笔记',
  postAI: '',
  pageFillDescription: 'C++学习笔记：, 名称空间std, 控制符endl, cin和cout, 每次读取一行字符串(string)输入, 总结, 补, string类(头文件string), 补：获取字符串长度, 数组的替代品, 模板类vector, 1.3 vector对象的常用内置函数使用（举例说明）, size(), empty(), swap()         swap(交换), insert()      insert(插入), NULL和nullptr, 对类的定义：, 类对象（变量）的创建, new和delete, 1.New, 2.Delete, C++中文件的输入输出, 写入到文本文件中, 从文本文件中读取数据, 检查文件, 文件读取结尾, 文件的打开和关闭, 构造函数和析构函数, 构造函数, 运算符重载, 运算符重载的概念和原理, 运算符重载限制, 类的继承, 继承的定义, 继承：is-a 关系, 继承的格式, 继承的总结：, 多态公有继承, 虚方法, 虚析构函数, 静态联编和动态联编, 初始化列表, 概念, 什么时候必须使用, 建议使用的地方, 优点和缺点, 使用using 重新定义访问权限, 多重继承, 定义, 构造函数, 二义性, 模板, 类模板, 函数模板, 类模板与函数模板区别, 类模板成员函数实现, 成员模板, 类模板对象做函数参数, 将模板做模板类参数, 类模板与继承, 模板类和友元, 类模板成员函数创建时机, 类模板分文件编写(重要), 模板别名(C++11), 友元, 友元函数, 友元类, 友元成员函数, 友元的优缺点, 嵌套类, 概念, 作用, 访问控制, 异常, 异常概念, 异常的抛出和匹配规则, 异常的抛出, 匹配规则, 异常的重新抛出, 异常安全问题, 异常规范说明, 自定义异常体系, C++标准库的异常体系, 异常优缺点, RTTI, dynamic_cast, typeid和type_info, 智能指针模板类, auto_ptr模板类, shared_ptr模板类, unique_ptr模板类, unique_ptr为何优于auto_ptr, 标准模板库STL, 模板类vector, 基于范围的for循环, 泛型编程, 迭代器, 容器, 函数对象, 应用, 算法, STL总结, 其他库, vector、valarray、array, 模板initializer_list, 输入、输出和文件, 流和缓冲区, 流（Stream）, 缓冲区（Buffer）, iostream文件, cerr和clog, 使用cout进行输出, 重载的ltlt运算符, 其他osteam方法, 刷新输出缓冲区, 用cout进行格式化, 头文件iomanip, 使用cin进行输入, cin如何检查输入, 流状态, 使用cin错误处理, 其他istream类方法, 文件输入输出, 文件输入输出, 检查文件, 判断文件结尾, 文件打开关闭, 打开多个文件, 文件打开模式, c++新标准, 统一的初始化, 右值引用, 左值和右值：, 左值引用和右值引用：, Lambda函数学习笔记名称空间新式为新式为如果使用而不是即当头文件中没有扩展名时中定义的用于输出的变量实际是而实际上是因此可以省略编译指令用下述方式进行编码但如果使用编译指令便可以直接使用和而不必加上前缀控制符中的旧版换行采用的是和输出可以拼接每次读取一行字符串输入总结虽然可以使用和来输入字符串当读取数据时一旦它接触到第一个非空格字符即开始阅读当它读取到下一个空白字符时它将停止读取可以输入或但不能输入停止读取因为不能输入包含嵌入空格的字符串无参数时读入一个字符包括换行符常用来处理输入缓冲区中的换行符有参数时从缓冲区读取数据到达行尾或个字符剩下的空间储存在结尾添加的空字符后结束读取超过规定字符数不会出现错误会直接截断不会对换行符进行处理将其留在缓冲区从缓冲区读取数据到达行尾或剩下的空间储存在结尾添加的空字符个字符结束读取超过规定的字符数会出现错误中断会读取换行符将其替换为空字符并且丢弃例如从缓冲区中读取数据遇到换行符时将其替换为空字符并且丢弃补所需的头文件为这里的参数是输入的字符串变量是输入字符串的字符个数第个补是输入终止条件即遇到所代表的字符就终止输入正常使用时可以省略语言默认为例或所需的头文件为是标准输入流函数是用来存字符的变量名是结束标志作用与里的相同例注是流的函数只能用于类型不能用于输入类型的输入操作是流的函数只能用于类型的输入操作不能用于类型输入为数组当你定义了一个类型变量只能用输入在使用读入一整行时若是前面是使用这类读入了一个字母但是不会读入后续换行符号或者空格的输入时再接就容易出现问题这是因为输入数字之后敲回车产生的换行符仍然滞留在输入流了接着就被给读进去了此时的所以实际上只是读入了一个换行符而若是前面使用再又用进行读入此时不会发生问题中读入结束的回车后结束符不放入缓存区会将读入的直接去除下一个输入前缓冲区为空并不会因为回车留下而的结束后以及此类的读入结束后按下回车或者使用空格读入下一个此时按下的回车或空格会还在缓存区继续用就会出现前面所提到的情况那么如何解决前面用了后的输入呢可以直接在和后使用一个吃掉接下来的换行类头文件数组和类的不同点在数组中不能将一个数组赋给另一个数组但可以将一个对象赋给另一个对象可以使用让两个对象合并起来还可以使用将字符串附加到对象的末尾同时可以对字符串实现运算符可以直接比较用将输入读取到对象补获取字符串长度函数直接获取字符串长度包括空格在内表示方法即可表示字符串的长度函数需要添加头文件而且参数只能是数组不能是类而且结尾必须是即字符数组不能满因为满了结尾就不是会接着向下检索到为止啊哦这样是错误的嗷直接没法进行编译编译器直接帮我们解决问题表示方法数组名需要添加头文件用法类似于表示的是这个容器中的元素个数还可以获取类型的长度如果使用过之类的容器的话可以把看做是一个这里只是举例并不能等价就是这个容器的元素类型那么表示的就是这个容器中的个数表示方法即可表示字符串的长度不包含数组的替代品具体见模板类是向量类型可以容纳许多类型的数据因此也被称为容器可以理解为动态数组是封装好了的类进行操作前应添加头文件初始化方式定义具有个整型元素的向量尖括号为元素类型名它可以是任何合法的数据类型不具有初值其值不确定方式定义具有个整型元素的向量且给出的每个元素初值为方式用向量给向量赋值的值完全等价于的值方式将向量中从共三个的元素赋值给的类型为型方式从数组中获得初值对象的常用内置函数使用举例说明为向量将的个元素赋值给向量含有个值为的元素返回的最后一个元素返回的第一个元素返回的第元素当且仅当存在清空中的元素判断是否为空空则返回非空则返回删除向量的最后一个元素删除中第一个从第个算起到第二个元素也就是说删除的元素从算起包括它一直到不包括它结束在的最后一个向量后插入一个元素其值为在的第一个元素从第个算起位置插入数值在的第一个元素从第个算起位置插入个数其值都为为数组在的第一个元素从第个元素算起的位置插入的第三个元素到第个元素不包括返回中元素的个数返回在内存中总共可以容纳的元素个数将的现有元素个数调整至个多则删少则补其值随机将的现有元素个数调整至个多则删少则补其值为将的容量扩充至为向量将中的元素和中的元素整体交换为向量向量的比较操作还有中在获取字符串长度时函数与函数作用相同函数以及函数都用于计算字符串长度不能用作为参数除此之外函数还可以获取类型的长度函数返回值为类型为正数注意让其作为返回值赋给变量时变量类型要为或型补是一些标准在中定义的类型表示中任何对象所能达到的最大长度它是无符号整数位上的定义等价于位上的定义等价于中作为判断容器是否为空的函数用法为对象名例如果对象为空就返回不为空返回字符串为空字符串不为空交换具体见标准库的中的函数是一个在两个相同类型的给定变量之间直接交换值的函数元素个数不相等也可以进行交换用法插入对象几种用法下标索引都是默认从第个位置开始第个位置第个位置在第位置插入个字符插入前的字符串插入后的字符串在第位置插入一个常量字符串插入前的字符串插入后的字符串第位置插入常量字符串中的个字符插入前的字符串插入后的字符串第位置插入常量插入前的字符串插入后的字符串第位置插入常量的从开始的个字符插入前的字符串插入后的字符串位置插入常量从开始以后的字符串插入前的字符串插入后的字符串和中用表示空指针但在中用表示空指针把当作来使用具体的见对类的定义首先用标记名对类进行定义部分部分中的数据为隐藏数据通常是变量只能通过中的成员函数对其进行访问外部没有访问权力中通常是成员函数可以在成员函数中访问该类的中的数据通常只在里面声明函数原型在其他地方定义此处用的链表链表的下一个结点注访问成员函数要作用域解析符格式为类标记名函数名尤其是在定义时例定义一个全新的函数不是成员函数对成员函数进行定义此处用了友元类具体见笔记类对象变量的创建标记名对象名例创建一个类的对象错误写法正确写法重点注意在调用成员函数之前必须创建对象不能直接像定义成员函数那样调用成员函数如上方调用成员函数的方式是通过点关系符类访问成员函数时用访问并且如果没有参数访问的时候必须带上后面的括号否则认为访问的是变量格式为对象名函数名例如下为类对象变量在学生管理程序中使用和该处以链表类为例用分配内存时需要头文件但是不需要引用新的头文件为一个数据对象可以是结构也可以是基本类型获得并指定分配的内存通用格式如下申请了一个初值为的整型数据括号中为初始化的值申请了能存放个整型数据元素的数组其首地址为注意此时解引用的值将会是一个随机值未初始化此时括号里为空解引用的值将自动初始化为此处文件中是一个指针是类标记类型名返回的值是一个地址从被称为堆或自由储存区的内存区域分配内存除了主动释放外不会被回收而局部变量通常储存在栈的内存区域中用来释放分配的内存通常指针名即可注意不一定使用用于的指针而是用于的地址注意要删除数组时需要加以表示为数组使用和应该遵守以下规则不要使用来释放不是分配的内存不要使用来释放同一个内存块两次如果使用为数组分配内存则应该使用来释放如果使用为一个实体分配内存则应该使用没有方括号来释放对空指针使用是安全的中文件的输入输出写入到文本文件中要求包含头文件包含头文件头文件中定义了一个处理输出的类头文件定义了一个用于处理输出的类声明一个或多个的变量对象并且命名遵守常用的命名的规则通常取名为必须指明名称空间为引用必须使用编译指令或者前缀的将对象与文件关联起来为此方法之一是使用方法使用完文件后应使用将其关闭可结合对象和运算符来输出各种类型的数据总结文件的输出主要步骤如下包含头文件创建一个对象通常取名为将该对象同一个文件关联起来向那样使用对象通常重点在屏幕上输出而是在文件中输出写入例子见下方从文本文件中读取数据要求包含头文件包含头文件头文件中定义了一个处理输出的类头文件定义了一个用于处理输入的类声明一个或多个的变量对象并且命名遵守常用的命名的规则通常取名为必须指明名称空间为引用必须使用编译指令或者前缀的将对象与文件关联起来为此方法之一是使用方法使用完文件后应使用将其关闭可结合对象和运算符来输出各种类型的数据检查文件格式为对象名例如果文件成功被打开返回如果文件没有被打开因此表达式将为通常使用下方代码判断是否打开成功文件打开失败程序正常结束程序异常结束使用需要用到头文件文件读取结尾在遇到文件结束标志时返回否则返回通常和循环一起用作文件读取结束在文件结束前为真结束为假退出循环具体格式为文件的打开和关闭对象名文件名一个参数例如果文件不存在将会自动创建一个相同名字的文件如果文件存在将会打开该文件首先截断该文件将其长度截短到丢弃原有的内容然后将新的输入加入到该文件中对象名文件名打开方式两个参数例如只读模式见下方格式对象名例注意方法不需要使用文件名作为参数因为已经同特定的文件关联起来如果忘记关闭文件程序正常终止的时候将自动关闭它下面时学生管理程序中的例子读取数据到文件中输出数据到文件从该文件中读取数据从文件中输入数据到外从文件中读取数据时也需要用到分配新的内存与函数在输入数据时相同对应的中的从文件中读取数据对应的时中的写入数据到文件构造函数和析构函数构造函数按参数种类分无参构造函数有参构造函数有默认参构造函数按类型分为普通构造函数拷贝构造函数赋值构造函数构造函数的各种用法全面解析初学面向对象编程构造函数博客运算符重载运算符重载的概念和原理如果不做特殊处理的等运算符只能用于对基本类型的常量或变量进行运算不能用于对象之间的运算有时希望对象之间也能用这些运算符进行运算以达到使程序更简洁易懂的目的例如复数是可以进行四则运算的两个复数对象相加如果能直接用运算符完成不是很直观和简洁吗利用提供的运算符重载机制赋予运算符新的功能就能解决用将两个复数对象相加这样的问题运算符重载就是对已有的运算符赋予多重含义使同一运算符作用于不同类型的数据时产生不同的行为运算符重载的目的是使得中的运算符也能够用来操作对象运算符重载的实质是编写以运算符作为名称的函数不妨把这样的函数称为运算符函数运算符函数的格式如下返回值类型运算符形参表运算符可以是等必须是有效的运算符返回值可以是一个引用也可以是一个对象但一定注意不要返回一个指向局部变量或临时对象的引用因为函数执行完毕后局部变量和临时对象将消失引用将指向一个不存在的数据一个简单的重载运算符这是允许的得出的结果相同注意重载后的号允许大于两个对象相加如该函数有两种调用方式通过对象调用方法来调用如上边的直接通过重载的符号调用如上方运算符重载限制运算符重载规则即允许重载的运算符不允许重载的运算符见运算符重载意义限制方法规则特殊运算符重载应用场景博客注在中类型的名字包括类的名字本身也是一种运算符即类型强制转换运算符类型强制转换运算符是单目运算符也可以被重载但只能重载为成员函数不能重载为全局函数类的继承继承的定义定义继承机制是面向对象程序设计中使代码可以复用的最重要的手段它允许程序员在保持原有类特性的基础上进行扩展增加功能这样产生的新类称派生类或子类被继承的类称基类或父类继承呈现了面向对象程序设计的层次结构体现了由简单到复杂的认知过程之前接触的复用都是函数复用继承是类设计层次的复用继承关系因为派生类可以在基类上添加新特性所以这种关系成为是一种关系更加准确通常术语是关系例如香蕉是一种水果同时在指针指向的对象上面也有讲究可以将基类指针指向派生类对象多态性体现不能将派生类指针指向基类对象不允许这样做正确正确满足香蕉一种水果水果包含香蕉的关系使用基类指针引用派生类对象的能力允许多态性在这种情况下你可以通过基类指针调用基类的函数或访问基类的成员而在运行时将调用正确的派生类方法错误水果不是一种香蕉香蕉不包含水果不允许这样做正确继承的格式新类的名字继承方式继承类的名字一个简单的例子使用成员初始化列表语法会先调用基类的构造函数上面的构造函数等价于这两种方法都可以在继承的时候可以使用类名加上作用域解析符来调用基类的方法通常在私有继承中使用第二种便是使用指针调用继承过来的基类的方法更多详细内容学习继承超详解继承的总结基类成员无论以什么方式继承到派生类中都是不可见的这里的不可见是指基类的私有成员还是被继承到了派生类对象中但是语法上限制派生类对象不管在类里面还是类外面都不能去访问它基类成员在派生类中不能被访问如果基类成员不想在派生类外直接被访问但需要在派生类中访问就定义为可以看出保护成员限定符是因继承才出现的基类的私有成员在子类都是不可见基类的其他成员在子类的访问方式就是访问限定符和继承方式中权限更小的那个权限排序使用关键字时默认的继承方式是使用时默认的继承方式是但最好显式地写出继承方式多态公有继承简单来说就是一个方法的行文随上下文而异有两种重要机制可用于实现多态的公有继承在派生类中重新定义基类的方法使用虚方法虚方法关键词在基类中将派生类会重新定义的方法声明为虚方法使用了程序将根据引用或指针指向的对象的类型来选择方法而未使用时程序将仅仅根据引用或指针的类型来选择方法与多态性紧密相关关键词只用于类声明的方法原型中而不用于类方法实现中派生类中覆盖的方法后要加上标注客户姓名账号当前结余创建账户存款取款显示账户信息显示透支上限透支贷款利率当前的透支总额覆盖基类实现函数重载覆盖基类实现函数重载透支上限透支贷款利率当前透支总额设计的基类指针既可以指向对象也可以指向对象因此可以使用一个数组来表示多种类型的对象这就是多态性下面在一个数组中可以很清楚的看清的作用类型的指针指向类型对象指向类型对象多态性说明假如是使用关键字声明如果数组成员指针指向的是对象则调用的是如果数组成员指针指向的是对象则调用的是假如不是虚方法则在任何情况下都将调用虚析构函数基类要声明一个虚析构函数为了确保释放派生类对象时按正确的顺序调用析构函数客户姓名账号当前结余这是虚析构函数为何使用虚析构函数如果析构函数不是虚方法则将只调用对应于指针类型的析构函数对于指针将只调用基类的析构函数即使指针指向的是对象如果析构函数是虚方法将调用相应的指向对象类型的析构函数即如果指针指向的是对象将调用对象的析构函数如果指针指向的是对象将调用的析构函数然后自动调用基类的析构函数因此使用虚析构函数可以确保正确的析构函数序列被调用如果包含一个执行某些操作的析构函数则必须有一个虚析构函数即使的析构函数不执行任何操作静态联编和动态联编静态联编静态联编是指联编工作在编译阶段完成的联编过程是在程序运行之前完成要实现静态联编在编译阶段就必须确定程序中的操作调用如函数调用与执行该操作代码间的关系静态联编对函数的选择是基于指向对象的指针或者引用的类型其优点是效率高但灵活性差也因此作为默认联编选择动态联编动态联编是指联编在程序运行时动态地进行根据当时的情况来确定调用哪个同名函数实际上是在运行时是虚函数的实现动态联编对成员函数的选择是基于对象的类型针对不同的对象类型将做出不同的编译结果中一般情况下的联编是静态联编但是当涉及到多态性和虚函数时应该使用动态联编动态联编的优点是灵活性强但效率低动态联编规定只能通过指向基类的指针或基类对象的引用来调用虚函数其格式为指向基类的指针变量名虚函数名实参表或基类对象的引用名虚函数名实参表编译器对非虚方法使用静态联编编译器对虚方法使用动态联编实现动态联编需要同时满足以下三个条件必须把动态联编的行为定义为类的虚函数类之间应满足子类型关系通常表现为一个类从另一个类公有派生而来必须先使用基类指针指向子类型的对象然后直接或者间接使用基类指针调用虚函数总结大多数情况下动态联编很好因为他让程序能够选择特定类型设计的方法虚函数是实现多态的基础是实现动态联编的必要条件之一动态联编要靠虚函数来实现虚函数要靠动态联编的支持两者相辅相成缺一不可初始化列表概念当在中定义类的构造函数时可以使用初始化列表来初始化类的成员变量初始化列表是在构造函数的参数列表后面使用冒号分隔开来的一组初始化语句多个参数初始化使用逗号隔开用于初始化类的成员变量初始化列表写法这里的冒号及冒号右边的部分就是构造函数的初始化列表逗号隔开函数体内写法注意对于继承的对象构造函数在成员初始化列表中使用基类名来调用特定的基类构造函数对于成员对象构造函数则使用成员名什么时候必须使用在成员变量为引用类型时正确会报错引用类型不允许这样做只能使用初始化列表上面的方式初始化在成员变量为时会报错类型不允许这样做只能使用初始化列表上面的方式初始化建议使用的地方初始化基类部分在派生类构造函数中使用初始化列表法初始基类的变量可以避免在函数体中进行额外的赋值操作提高效率同时提高可读性对于成员对象使用成员名初始化列表这里的冒号及冒号右边的部分就是构造函数的初始化列表逗号隔开对于继承的对象使用基类名初始化列表调用基类构造函数初始化基类部分正常的在函数体内初始化派生类部分更清晰表明继承关系这个地方也可以在上面使用初始化列表方式为赋值总结建议尽可能使用初始化列表法来初始化构造函数中的成员变量但并非所有情况都必须使用初始化列表一般来说以下情况建议使用初始化列表法初始化成员变量如果构造函数需要初始化类的成员变量但此时类的结构和逻辑不是很复杂时使用初始化列表是最清晰和高效的方式初始化基类部分在派生类的构造函数中调用基类的构造函数时应该使用初始化列表来确保基类部分被正确地初始化初始化和引用类型成员变量和引用类型的成员变量只能在初始化列表中进行初始化无法在构造函数体内进行赋值初始化具有复杂初始化逻辑的成员变量如果某个成员变量的初始化逻辑比较复杂使用初始化列表可以将初始化逻辑集中在一起提高代码的可读性但也有一些情况可以在构造函数体内进行初始化例如运行时条件决定的初始化如果某些成员变量的初始化取决于运行时条件可能需要在构造函数体内进行初始化需要在构造函数体内执行额外逻辑如果构造函数需要执行一些额外的逻辑操作可以在构造函数体内进行初始化优点和缺点优点涉及含有类成员时效率高使用初始化列表可以直接对成员变量进行初始化而不需要先调用默认构造函数再进行赋值操作从而提高了代码的执行效率基本类型时效率与在函数体中差不多确保成员变量的初始化使用初始化列表可以确保所有成员变量在对象构造时立即得到正确的初始化避免了可能出现的未初始化的情况处理和引用类型成员变量对于成员变量和引用类型成员变量只能在初始化列表中进行初始化因为它们不能在构造函数体内被赋值清晰明了初始化列表将所有初始化操作集中在一起使代码更加清晰易读便于理解和维护缺点可读性差对于复杂的类结构和初始化逻辑初始化列表可能会使代码变得复杂和难以理解降低了可读性限制较多有些情况下无法在初始化列表中初始化所有的成员变量例如需要在构造函数体内进行逻辑判断后再进行初始化的情况容易遗忘在添加新成员变量时容易忘记在初始化列表中添加相应的初始化操作导致未初始化的错误使用重新定义访问权限使用保护派生或私有派生时基类的公有成员将成为保护成员或私有成员假设要让基类的方法在派生类外面可用可以在派生类的成员中使用声明指出派生类可以使用特定的基类成员就像指定的成员或函数是派生类的公有方法一样即使采用的是私有派生一个简单的例子私有派生使用定义重新定义访问权限使用定义重新定义访问权限正确使用了可以在派生类外调用正确使用了可以在派生类外调用报错未使用继承后为派生类成员不可以直接访问多重继承定义派生类都只有一个基类称为单继承除此之外也支持多继承即一个派生类可以有两个或多个基类多继承的语法也很简单将多个基类用逗号隔开如已声明了类类和类那么可以这样来声明派生类类新增加的成员构造函数与单继承形式基本相同只是在派生类的构造函数中调用多个基类的构造函数以上面的类为例类构造函数的写法为形参列表实参列表实参列表实参列表使用初始化列表写法调用基类构造函数二义性当两个或多个基类有同名成员时如果直接访问该成员就会产生命名冲突编译器不知道使用哪个基类的成员这个时候需要在名字前面加上类名和域解析符以显示地指明到底使用哪个类的成员消除二义性使用指明基类的使用指明基类的使用指明调用基类的方法使用指明调用基类的方法模板类模板在中模板类是一种用于创建通用数据结构或算法的强大工具模板类允许您编写一次代码然后在不同数据类型上重复使用它例如有两个或多个类其功能是相同的仅仅是数据类型不同时使用以提高代码的可重用性和灵活性模板类允许您定义一种通用的类模板其中某些成员或函数可以根据不同进行参数化它们使用关键字定义类模板名类的定义表明其后面的符号是一种数据类型可以用代替是通用的数据类型名称可以替换通常为大写字母函数模板建议用描述通用数据类型类模板建议用示例类模板函数模板函数模板不是一个实在的函数编译器不能为其生成可执行代码定义函数模板后只是一个对函数功能框架的描述当它具体执行时将根据传递的实际参数决定其功能提高了程序的可重用性语言支持模板有了模板例如可以只写一个模板编译器会根据模板自动生成多个函数用以交换不同类型变量的值写法类型参数类型参数返回值类型模板名形参表函数体可以使用替换一个简单的示例函数模板编译器自动生成函数编译器自动生成函数编译器自动生成函数类模板与函数模板区别应用对象函数模板主要用于生成通用函数可以用于不同类型的参数它通过在函数定义中使用模板来实现允许编写一次通用的函数代码用于多种数据类型类模板主要用于生成通用类可以包含不同类型的成员变量或成员函数它通过在类定义中使用模板来实现允许创建一种通用的类形式适用于多种数据类型自动类型推导的使用方式函数模板在调用时支持自动类型推导允许省略模板参数由编译器根据实参类型自动推导出模板参数的类型类模板在实例化时需要显式指定模板参数没有像函数模板那样的自动类型推导每次实例化都需要明确指定模板参数默认参数函数模板和类模板都支持默认参数在模板参数列表中可以为某些模板参数设置默认值使得在使用时可以不必每次都指定这些参数类模板与函数模板的区别指定默认参数孙悟空错误的类模板无法用自动类型推导正确只能用显式指定类型推导类模板在参数列表中有默认参数类模板成员函数实现在类内部定义成员函数可以更简洁因为不需要再次指定模板参数类内部的成员函数定义可以直接使用类模板的模板参数而在外部定义时需要重新指定一次总体来说选择在类内部还是类外部定义成员函数取决于项目的需求和组织代码的风格一般而言对于简单短小的成员函数可以选择在类内部定义而对于复杂或长的成员函数以及避免头文件的多次包含导致的重定义错误通常建议在类外部定义类模板成员类外实现内部定义内部定义姓名年龄构造函数的类外实现每个函数都要重新指定模板参数要点每个函数前加上要点类名指出模板参数再进行解析成员函数的类外实现每个函数都要重新指定模板参数姓名年龄成员模板模板可用作结构类或模板类的成员要完全实现标准模板库必须使用这个特性示例模板成员模板类中的模板对象传入的模板参数为即外部模板类想通过的模板参数模板对象模板函数做成员被设置为被设置为即第二个被设置为被设置为被设置为类模板对象做函数参数一共有三种传入方式指定传入的类型直接显示对象的数据类型此时模板对象必须含有模板类的参数参数模板化将对象中的参数变为模板进行传递整个类模板化将这个对象类型模板化进行传递示例类模板对象做函数参数指定传入类型孙悟空参数模板化的类型为的类型为猪八戒整个类模板化的类型为唐僧将模板做模板类参数模板可以包含类型参数如和非类型参数如模板还可以本身就是模板的参数这种参数是模板类新增的特性用于实现示例模板参数是其中是类型是参数假设有那么必须是一个模板类其声明与模板参数的声明匹配即假设有如下声明成员函数就被替换为替换为总之模板参数将被替换为声明对象时被用作模板参数的模板类型类模板与继承当类模板碰到继承时需要注意以下几点当子类继承的父类是一个类模板时子类在声明的时候要指定出父类中的类型如果不指定编译器无法给子类分配内存如果想灵活指定出父类中的类型子类也需为类模板示例类模板与继承错误必须要知道父类中的类型才能继承给子类如果想灵活指定父类中的类型子类也需要变成类模板的类型为的类型为模板类和友元模板类声明也可以有友元模板的友元分为类非模板友元约束模板友元即友元的类型取决于类被实例化时的类型非约束模板友元即友元的所有具体化都是类的每一个具体化的友元非模板友元在模板类中将一个常规函数声明为友元上述声明使函数成为模板所有实例化的友元例如是和的友元函数也是只不过接受一个模板类参数约束模板友元修改前一个示例使友元函数本身成为模板即使类的每一个具体化都获得与友元匹配的具体化一共包含步第一步在类定义前面声明每个模板函数第二步在类中将模板声明为友元这些语句根据类模板参数的类型声明具体化或使用声明中的指出这是模板具体化可以为空因为可以从函数参数推断出模板类型参数但没有参数因此必须使用模板参数语法来指明其具体化为类的类模板参数类型第三步为友元函数提供定义非约束模板友元每个函数具体化都是每个类具体化的友元友元模板类型参数与模板类类型参数不同类模板成员函数创建时机类模板中成员函数和普通类中成员函数创建时机是有区别的对于类模板的成员函数在使用时进行实例化当你使用特定类型实例化类模板对象时编译器会生成该类型的成员函数实现对于普通类所有的成员函数都在编译时就被实例化了故可以做到以下的操作类模板中成员函数的创建时机类模板中的成员函数在调用的时候才创建所以不会报错此时模板参数传递为故无法调用类模板分文件编写重要如果工程中需要利用多个类模板那么将这些类模板都写在同一个文件中将会导致代码可读性变差所以有必要对类模板进行分文件编写但是类模板的分文件编写面临着一些问题以下是类模板分文件编写面临的问题及解决方法问题模板的特性导致了编译器对模板的实例化是在链接阶段进行的而编译器需要在链接时找到模板的定义当模板类的定义放在文件模板类实现放在文件会出现链接失败情况找不到定义解决方法直接包含源文件不常用因为风格不好一般用文件将声明和实现写到同一个文件中并更改后缀名为文件通常用来包含的头文件其中包含类声明函数原型模板定义等这种文件扩展名的选择是一种约定用于表示这个头文件中包含一些声明与实现在一起比如模板类一般来说文件和文件在功能上是相似的都用于包含头文件但文件更常见于项目中尤其是涉及到类和模板的情况编写的文件模板类的定义和实现放在一个文件中构造函数的类外实现成员函数的类外实现姓名年龄文件内容模板别名如果能为类型指定别名将很方便在模板设计中尤其如此可以使用为模板具体化指定别名新增了一项功能使用为模板提供一系列别名如下所示使用将定义为一个模板别名表示类型等价于与上面相同允许将语法用于非模板用于非模板时语法与常规等价与上方等价好处使用模板别名可以提高代码的可读性特别是在涉及复杂模板或需要引入特定模板类型时模板别名还可以使代码更易于维护因为你只需要在一个地方修改模板类型或表达式而无需修改多处使用的地方友元在中友元类和友元函数是用来在类之间建立友好关系的机制允许一个类的成员访问另一个类的私有成员这样可以增加程序的灵活性和封装性虽然友元提供了灵活性但过度使用友元可能会破坏封装性因此应该谨慎使用友元应该只在确实需要访问私有成员的情况下使用以保持代码的清晰性和可维护性友元函数作用允许一个非成员函数访问类的私有成员用法可以在类的声明中使用关键字声明友元函数然后在类外定义这个函数示例友元函数声明友元函数类外定义友元函数可以访问私有数据友元类作用允许一个类的所有成员函数访问另一个类的私有成员用法在类的声明中使用关键字声明友元类示例指定为友元类友元类的成员函数直接访问另一个类的私有成员友元成员函数作用允许一个类的某一个成员函数访问另一个类的私有成员用法在类的声明中使用关键字声明友元示例前向声明以便在中声明友元关系声明的成员函数友元函数的声明在中声明使的作为类的友元的成员函数因为是的友元所以定义必须在类外用于访问的私有成员友元的优缺点优点灵活性友元机制允许在类之间建立友好关系使得某个函数或类可以访问其他类的私有成员提高了灵活性特定需求的访问权限有时候为了实现特定的功能需要某些函数或类能够直接访问其他类的私有成员友元机制提供了一种选择效率有时候使用友元可以避免通过公有接口的方式比如方法等等进行多次函数调用提高代码执行效率缺点破坏封装性友元可以直接访问类的私有成员这可能破坏类的封装性增加了代码的耦合性增加了维护的难度复杂性增加过度使用友元可能导致代码更加复杂使得程序难以理解和维护设计问题有时候需要重新考虑设计以避免对友元的过度依赖可能存在更好的设计模式或方法不需要使用友元嵌套类概念在中嵌套类是一个类被定义在另一个类的内部的情况被嵌套的类称为内部类或嵌套类而包含这个内部类的类称为外部类嵌套类可以具有私有受保护或公有的访问权限这取决于它在外部类中的声明方式包含类的成员函数可以创建和使用被嵌套类的对象而仅当声明位于公有部分时才能在包含类的外面使用嵌套类而且必须使用作用域解析运算符旧版本的不允许嵌套类或无法完全实现这种概念一个示例内部类表示二维平面上的点内部类的成员函数类包含类的对象类的构造函数类的成员函数调用内部类的成员函数创建类对象调用类的成员函数作用嵌套类的主要作用之一是组织和封装代码使代码更为模块化清晰和可读以下是嵌套类的一些主要作用封装实现细节嵌套类允许将一个类的一部分实现细节封装在另一个类中从而隐藏一些具体的实现细节提高封装性外部类可以更专注于公共接口而具体的实现则留给内部类组织相关的类当两个类有密切关联时将它们组织在一起可以形成更清晰的结构嵌套类可以在逻辑上将这些关联的类放在同一个地方方便代码的组织和维护限制访问权限内部类可以访问外部类的私有成员但外部类不能直接访问内部类的私有成员这种特性可以用于在设计中划分不同层次的访问权限使得代码更安全实现接口与实现分离将接口和实现分离可以通过内部类隐藏一些实现细节外部类可以专注于公共接口而具体的实现细节则留给内部类增加代码的模块化将相关的类组织在一起可以使代码更模块化每个嵌套类可以有自己的职责这样代码更易于理解和维护访问控制公有嵌套类如果内部类声明为则外部类的任何成员函数友元或其他类都可以访问内部类这使得内部类对外可见允许外部代码直接访问它私有嵌套类如果内部类声明为则只有外部类的成员函数和友元可以访问内部类外部类的客户端无法直接访问或创建内部类的对象保护嵌套类如果内部类声明为则外部类的成员函数友元以及继承了外部类的派生类都可以访问内部类异常异常概念语言异常处理机制是终止程序缺陷用户难以接受如发生内存错误除错误时就会终止返回错误码缺陷需要程序员自己去查对应的错误在中异常是一种在程序执行过程中发生的错误或者意外状况异常提供了一种机制允许程序员在代码中识别和处理错误以及在出现错误时进行适当的响应异常处理是中一个重要的编程概念它使得程序更健壮更容易维护中异常处理有三个关键字当问题出现程序抛出一个异常抛异常使用关键字完成用于捕捉异常可以捕获任意类型的异常主要时用来捕获没有显示捕获类型的异常相当于条件判断中的中包含会出现异常的代码或者函数后面通常会跟一个或者多个块注意可以抛出任意类型的对象抛出的异常必须捕获要和匹配使用里的内容抛出异常时才执行没有异常不执行示例请输入被除数和除数除错误抛出异常这里抛出的是字符串类型异常也可以是对象会出现异常的代码捕获字符串类型的异常即除错误捕获任意类型的异常通常未知异常异常的抛出和匹配规则异常的抛出异常时通过抛出对象而引发的该对象的类型决定了应该激活哪个的处理代码被选中的处理代码的调用链是找到于该类型匹配且离抛出异常位置最近的那一个抛出异常对象后会生成一个异常对象的拷贝因为抛出的异常对象可能是一个临时对象所以会生成一个拷贝对象可以捕获任意类型的对象主要是用来捕获没有显示捕获类型的异常因为如果没有匹配的会终止程序相当于条件判断中的问题是不知道异常错误是什么实际中抛出和捕获的类型不一定类型完全匹配可以抛出派生类对象使用基类来捕获这个在实际生活中很实用主要原因是派生类可以赋值给基类匹配规则首先检查本身是否在块内部如果是再在当前函数栈中查找匹配的语句如果有匹配的直接跳到的地方执行如果没有匹配的块则退出当前函数栈在调用函数的栈中查找匹配的如果到达函数的栈都没有匹配的就会终止程序上述沿着调用链查找匹配的块的过程叫栈展开所以实际要最后要加一个来捕获任意类型的异常防止程序终止找到匹配的会直接跳到语句执行执行完后会继续沿着语句后面执行异常的重新抛出有可能单个的不能完全处理一个异常在进行一些矫正处理后需要交给更外层的调用链函数来处理可以做完矫正操作再将异常重新抛出交给更上层的函数进行处理异常安全问题由于抛异常只要找到匹配的就直接跳到块执行没有找到对应的函数就不会继续执行这样导致函数的执行流回很乱可能会导致一些问题构造函数完成对象的构造和初始化最好不要再构造函数中抛出异常否则可能导致对象不完整或者没有完全初始化析构函数主要完成资源的清理最好不要在析构函数中抛异常否则可能导致内存泄漏异常经常会导致资源泄漏问题比如在和中抛出异常导致出来的资源没有释放导致内存泄漏在和中抛出异常导致锁没有释放导致死锁有两种解决办法将异常捕获释放资源后将锁重新抛出使用的思想解决定义一个类封装管理资源当要使用时实例化一个类对象将资源传入当退出函数调用对象析构函数释放资源异常规范说明表示函数不抛出异常函数体表示如果求值结果为则函数不抛出异常函数体早期的异常规范在早期的标准中可以使用表示函数不抛出异常或者使用来指定函数可能抛出的异常类型函数不抛出异常函数可能抛出或现代中的推荐使用关键字来表示函数是否抛出异常函数不抛出异常函数在为时不抛出异常异常规范的问题早期的异常规范在实践中并没有提供太多的好处而且容易导致问题因此自开始异常规范已经被弃用而关键字更灵活且更安全自定义异常体系在实际中并不是我们想抛什么异常就抛什么异常这样会导致捕捉的时候不好捕捉而是会建立一个继承体系建立一个异常类派生类继承这个类来定义出不同的异常到时候抛出异常只需要用基类进行捕捉即可基类可以相当于是一个框架派生类是具体的异常然后去具体实现异常的内容然后抛异常只需要抛派生类捕捉异常只需要捕捉基类即可下列使用一个简单实现基类异常派生类中输出的指定异常信息错误信息错误码派生类数据库异常网络异常缓存异常当网络连接失败抛出这个异常即可当缓存错误抛出这个异常当数据库错误抛出派生类异常对象捕获基类异常输出错误信息标准库的异常体系在库中也建立了一个异常体系也给我们提供了一些异常类我们可以在程序中使用这些标准异常它们也是以父子类层次结构组织起来的基类派生类等异常优缺点优点异常对象定义好了相比较于错误码可以清晰准确的展示出错误的各种信息甚至包含堆栈调用信息可以帮我们很好的定位程序的在函数调用链中深层函数返回错误我们得层层返回需要不断的判断是什么错误再返回给最外层异常直接会找到对应的执行不需要判断是什么错误部分函数更好处理比如没有返回值的函数或者返回值为自身的不好返回错误码并且越界了内存错误等不需要终止程序更好的进行测试代码缺点异常导致执行流乱跳运行混乱导致我们调试和分析程序时比较困难没有垃圾回收机制可能会导致异常安全问题开辟的资源和打开的流由于执行流乱跳导致没有释放和关闭等导致内存泄漏打开的锁为关闭导致死锁标准库的异常体系定义不好导致我们需要各自定义各自的体系非常混乱随意抛异常外层不好捕获所以尽量按找异常规范使用在中是运行阶段类型识别的简称它允许在程序运行时获取对象的类型信息是新添加到中的特性之一很多老式实现不支持主要用途包括识别对象类型允许在程序运行时确定对象的类型这对于处理多态性和动态多态性非常有用例如在一个基类的指针或引用指向派生类对象时你可以使用来确定实际派生类的类型安全的类型转换在某些情况下你可能需要将基类指针或引用安全地转换为派生类指针或引用的运算符可用于执行这种安全的转换它会在转换之前检查类型信息如果转换不安全它会返回空指针或引发异常而不是导致未定义行为类型检查允许你在运行时检查对象的类型信息从而采取相应的措施这对于实现一些通用的算法或框架需要根据对象的类型来执行不同的操作非常有用异常处理在一些情况下可用于处理异常当在基类指针或引用上使用时如果转换失败会返回空指针或引发异常可以在异常处理中捕获中有三个支持的元素运算符将使用一个指向基类的指针来生成一个指向派生类的指针否则该运算符返回空指针运算符返回一个指出对象的类型的值结构储存了有关特定类型的信息操作符用于在运行时执行安全的类型转换主要用于处理继承关系它可以将指向基类的指针或引用转换为派生类的指针或引用同时执行类型检查成功转换转换失败在一些情况下可用于处理异常当在基类指针或引用上使用时如果转换失败会返回空指针或引发异常可以在异常处理中捕获和运算符用途运算符用于在运行时获取对象的类型信息它返回一个对象该对象包含有关实际类型的信息其中是在头文件以前是中定义的一个类语法其中是一个表达式通常是一个对象或一个类型类用途是一个类表示类型信息它包含有关类型的信息例如类型的名称成员函数返回一个指向包含类型名称的字符串的指针请注意这个名称的格式是实现定义的可能在不同编译器和平台上有所不同其他成员函数可能会有其他一些实现特定的成员函数但标准并没有规定运算符使得能够确定两个对象是否为同种类型类重载了和运算符可以使用这些运算符来对类型比较例如表示指向的对象相同返回值返回值返回值返回值对象不同返回值智能指针模板类当谈到中的智能指针时通常会涉及到和这两个模板类还有一个已经被摒弃但在以前使用了多年如果编译器不支持其他两种则是唯一选择这些智能指针类旨在管理动态分配的内存并在对象不再需要时自动释放该内存从而避免内存泄漏和悬挂指针的问题要创建智能指针对象必须包含头文件该文件模板定义然后使用通常的模板语法来实例化所需类型的指针模板类是标准中引入的智能指针用于管理动态分配的内存然而它在标准中已被弃用并且在标准中已经被移除主要原因是存在一些问题特别是在资源所有权转移方面存在潜在的危险一个简单的例子现在拥有的内存所有权输出这里不再拥有资源会导致运行时错误使用时可能会出现未定义的行为输出具有独占所有权的特性但其所有权转移的方式可能导致一些问题因为它采用了移动语义而非拷贝语义这意味着当一个所有权转移给另一个时原始的将不再拥有对资源的所有权模板类是一种共享所有权的智能指针多个实例可以共享对同一块内存的所有权它使用引用计数来追踪有多少个共享相同的资源创建一个并分配内存等价于但是更加安全因为它有性能优势和异常安全性共享所有权使用和当最后一个离开作用域时内存会被自动释放模板类是一种独占所有权的智能指针一个实例独立拥有对其指向的资源的所有权不能共享创建一个并分配内存输出等价于但是更加安全因为它有性能优势和异常安全性不能直接赋值给另一个会发生所有权转移错误编译失败可以通过进行所有权转移输出使用当离开作用域时内存会被自动释放为何优于更安全的所有权转移使用移动语义进行所有权转移而使用复制语义由于的复制语义可能导致不明确的行为因此在引入时被标记为已弃用使用更容易理解和更安全支持数组和自定义删除器可以用于管理数组而不支持这种用法此外还支持通过自定义删除器来管理非默认方式分配的资源更灵活的模板参数具有更灵活的模板参数可以轻松地与自定义删除器和分配器一起使用这提供了更多的灵活性以适应各种资源管理需求更严格的所有权管理严格实现了独占所有权的概念一个实例独立拥有对其指向的资源的所有权这使得代码更加明确减少了潜在的错误警告只有使用分配内存时才能使用和使用分配内存时不能使用它们只能使用不使用或分配内存时也不能使用标准模板库模板类又名动态数组容器详解容器博客基于范围的循环基于范围的循环是为用于而设计的在这种循环中括号中的代码声明一个类型通常用与容器储存的内容相同的变量然后指出了容器的名称接下来循环体使用指定的变量依次访问容器的每个元素若使用引用参数则可修改容器内容一个简单的例子未使用引用参数不能修改容器内容使用引用可以修改容器内容泛型编程是一种泛型编程面向对象编程关注的是编程的数据方面而泛型编程关注的则是算法他们之间的共同点是抽象和创建可重用代码但他们的理念绝然不同泛型编程旨在编写独立于数据类型的代码在中完成通用程序的工具是模板模板使得能够按泛型定义函数或类而通过通用算法更近了一步为了解模板和设计是如何协同工作的我们需要先了解一下迭代器迭代器在中模板使得算法独立于储存的数据类型而迭代器使算法独立于使用的容器类型迭代器是一种用于遍历容器如数组向量链表等中元素的对象迭代器提供了一种统一的方式来访问容器中的元素而不必关心容器的具体类型或实现细节标准库提供了多种类型的迭代器主要分为五种输入迭代器只允许从容器中读取元素但不能修改元素支持逐个递增只能用于单向遍历输出迭代器只允许往容器中写入元素但不能读取元素支持逐个递增也只能用于单向遍历前向迭代器具有和的功能支持读写操作支持逐个递增可用于单向遍历双向迭代器具有的功能同时支持逐个递减支持双向遍历即可以前进也可以后退随机访问迭代器具有的功能同时支持随机访问元素支持通过指针算术运算如直接跳跃访问容器中的元素在标准库中不同的容器提供不同类型的迭代器例如和提供了双向迭代器而和提供了随机访问迭代器在使用迭代器时要注意选择适当的类型以满足操作的需求示例定义一个迭代器一个简单的示例定义的一个遍历容器的迭代器定义的一个遍历容器的迭代器迭代器支持前缀和后缀遍历容器实际上作为一种编程风格最好避免直接使用迭代器而应尽可能使用函数来处理细节也可以使用新增的基于范围的循环容器具有容器概念和容器类型概念是具有名称容器序列容器关联容器的通用类别容器类型是可用于创建具体容器对象的模板主要的容器分类包括序列容器顺序存储元素元素的顺序与它们被插入的顺序相同包括动态数组支持快速随机访问双向链表支持在任意位置快速插入和删除元素双端队列支持在两端快速插入和删除元素固定大小的数组支持快速随机访问关联容器基于键值对的存储方式通过键值来快速查找元素包括有序集合不允许重复元素有序映射存储键值对不允许重复的键有序集合允许重复元素有序映射允许重复的键无序容器使用哈希表实现元素的存储顺序不固定包括无序集合不允许重复元素无序映射存储键值对不允许重复的键无序集合允许重复元素无序映射允许重复的键容器适配器提供特定接口的封装简化了底层容器的使用包括栈后进先出队列先进先出优先队列按照优先级排序用法见常用容器博客函数对象在中函数对象也称为函数符或仿函数函数符是可以以函数方式与结合使用的任意对象这包括函数名的指针和重载了运算符对象的类即定义了函数的类是一种可调用对象可以像函数一样被调用函数对象通常是类对象但不像普通函数它们可以携带状态信息并可以通过成员函数实现自定义行为函数对象可用于算法容器等各种场景中函数对象类函数符类重载函数调用运算符使用方式结果为应用函数对象作为算法的参数函数对象可以作为算法的参数提供一种灵活的方式来定制算法的行为使用函数对象对容器中的每个元素进行平方操作现在为函数对象与函数对象在标准模板库中广泛应用例如在排序查找等算法中可以通过函数对象来指定比较的规则使用函数对象进行降序排序现在为算法的算法作用范围的算法是独立于容器的通用算法它们被设计为能够在不同类型的容器上进行操作而不依赖于具体容器的实现这种独立性使得同一个算法可以用于不同的数据结构例如可以使用在不同类型的容器上进行排序参数类型的算法通常接受迭代器作为参数因此可以用于各种容器如数组向量链表等它们不直接与容器关联而是通过迭代器与容器交互功能丰富的算法涵盖了广泛的应用场景包括排序查找数学运算变换等这些算法是为了提供通用且高效的数据处理工具以下是一些常用的算法及其简要介绍排序算法对容器进行排序默认是升序排序可以传递自定义的比较函数或表达式来实现不同的排序规则稳定排序保持相等元素的相对顺序部分排序将容器中的一部分元素排序其余元素不变查找算法在容器中查找指定值的第一个出现位置在已排序的容器中进行二分查找统计容器中指定值的出现次数变换算法将一个范围的元素转换为另一个范围可以结合函数对象或表达式进行元素的变换操作将一个范围的元素复制到另一个范围替换容器中指定值的所有出现删除和修改算法在容器中移除指定值的所有元素不改变容器大小返回一个新的结束迭代器根据谓词条件移除满足条件的元素移除容器中相邻的重复元素仅保留一个数值算法对范围内的元素进行累积操作可以用于计算总和平均值等计算两个范围的内积用给定的值填充一个范围其他算法找到范围内的最小值和最大值将容器中的元素进行反转将容器中的元素进行旋转标准库中还有很多其他有用的算法使用算法可以编写更简洁可读性更好的代码并且由于这些算法经过优化通常具有较好的性能总结是标准库的一部分提供了一套通用的模板类和函数用于处理常见的数据结构和算法的设计目标是提供高效灵活可复用的代码以便开发者能够更加专注于解决问题而不必重复实现基础数据结构和算法主要包括以下三个组件容器序列容器关联容器等等算法提供了一系列通用的算法如排序查找变换合并等这些算法可以用于不同类型的容器通过迭代器进行操作实现了数据结构和算法的分离增强了代码的可复用性和通用性算法通过函数对象或函数指针支持用户自定义的操作和比较规则迭代器迭代器是中用于遍历容器元素的通用接口为算法和容器提供了统一的访问机制不同类型的容器支持不同类型的迭代器包括输入迭代器输出迭代器正向迭代器双向迭代器和随机访问迭代器提供了不同程度的功能和效率其他库标准库提供了多个数组模板每个模板都有其特定的用途和优势这样设计的目的是为了满足不同的编程需求提供更丰富更灵活的选择以下是这三个数组模板的主要区别和适用场景动态大小是一个动态数组其大小可以在运行时动态调整这使得它非常适用于需要动态增减大小的场景例如在运行时读取不确定数量的数据内存管理会自动处理内存的分配和释放使得在动态数组的使用上更加方便数值运算设计用于面向数值计算提供了一些成员函数和操作符用于逐元素进行数学运算它的目标是提高数值计算的效率元素级别的操作更适用于执行逐元素的数学运算如数组的逐元素加法乘法等固定大小是一个静态数组其大小在编译时就确定了不能动态改变这使得它适用于固定大小的场景例如需要在编译时确定数组大小的情况栈上分配通常在栈上分配内存因此相较于动态数组它的内存访问更加高效模板在中是一个标准库中的类模板用于方便地初始化容器或其他类的对象它允许在对象的构造函数中传递一个初始化列表类似于数组的初始化方式的定义位于头文件中用于容器的构造函数使得容器类如等能够通过初始化列表进行构造类构造函数中参数使用了容器和类的构造函数重载类可以同时提供接受和其他参数的构造函数以便支持不同的初始化方式使传递一个初始化列表输入输出和文件流和缓冲区在中流和缓冲区是与输入和输出相关的概念用于处理数据的流动和存储流提供了一个抽象层使得输入和输出可以以统一的方式进行处理而缓冲区则用于临时存储数据以提高性能和效率流流是一个抽象的概念表示数据在程序和外部设备如文件屏幕键盘等之间的传输在中标准库提供了一些流类如等用于实现输入和输出的操作流可以分为输入流和输出流分别用于读取和写入数据常见的流类包括提供了标准输入流和标准输出流用于从键盘读取输入和向屏幕输出数据用于文件输入和输出包括文件输入流和文件输出流用于在内存中操作字符串可以将字符串作为输入或输出流处理缓冲区缓冲区是用于暂时存储数据的区域它可以提高输入输出的效率标准库中的流都具有与之关联的缓冲区用于暂时存储数据然后一次性地进行读取或写入而不是每次都直接与外部设备进行通信流的缓冲区可以分为两种输入缓冲区存储从外部设备如键盘或文件读取的数据以便程序可以逐一处理输出缓冲区存储要写入外部设备的数据以提高写入效率在一些情况下你可能需要手动刷新缓冲区以确保数据被及时处理使用函数可以强制将输出缓冲区的内容写入外部设备文件是标准库中的头文件之一它包含了对输入和输出流的支持具体而言是由两个基本的头文件合并而成分别是用于输入流提供了从输入设备如键盘读取数据的功能主要的类包括和用于输出流提供了向输出设备如屏幕或文件写入数据的功能主要的类包括和通过合并这两个头文件得到了其中包括了等标准流对象以及相关的功能和操作符重载使得输入输出操作变得简便和灵活的库管理了很多细节例如在程序中包换文件将自动创建个流对象个用于窄字符流个用于宽字符流常见的个流对象及其用途包括标准输入流用于从用户输入中读取数据对象于此类似但处理的是宽字符类型类型标准输出流用于将数据输出到控制台对象于此类似但处理的是宽字符类型类型标准错误流没有被缓冲用于输出错误信息到控制台对象于此类似但处理的是宽字符类型类型标准日志流用于输出程序运行时的一般信息对象于此类似但处理的是宽字符类型类型和在中和都是标准错误流用于输出错误信息到控制台它们是类的实例提供了与相似的输出功能但通常用于不同的目的标准错误流是一个标准错误流对象用于输出程序的错误信息与不同的输出默认不被缓冲意味着错误消息会立即显示在控制台上而不受缓冲机制的影响通常用于输出紧急的错误信息以便及时发现问题示例标准日志流也是一个标准错误流对象用于输出程序运行时的一般信息类似于日志与不同的输出默认是被缓冲的可以通过强制刷新输出或者等到缓冲区满时才刷新通常用于输出程序的运行时信息方便调试和了解程序执行的进展示例总体而言和都是用于输出程序的诊断信息的标准错误流它们与一起构成了中的标准流选择使用哪一个取决于你的需求如果你需要及时看到错误信息可以使用如果你希望输出日志信息并允许一定程度的缓冲可以使用使用进行输出重载的运算符在中运算符的默认含义是按位左移运算符但类重新定义了运算符将其重载为输出在这种情况下能识别中的所有的基本类型对于上述每种类型类提供了函数的定义运算符的所有化身返回类型都是格式如下意味着该运算符将返回一个指向对象的引用该引用指向用于调用该运算符的对象例如运算符返回的是对象这种特性使得能串联输出其他方法还提供了方法和方法用于显示字符用于显示字符串原型将一个字符插入到输出流中示例可进行拼接输出输出自动将值转换为值输出模板原型将指定数量的字符从指定位置的字符串插入到输出流中第一个参数为指定字符串第二个参数为指定长度示例将写入输出流刷新输出缓冲区在中刷新输出缓冲区是指将缓冲区中的数据强制写入输出设备默认情况下输出流如等会将数据存储在内部缓冲区中而不是每次写入一个字符就立即刷新到输出设备刷新输出缓冲区的操作可以通过方法或操纵符来实现第一种刷新输出缓冲区第二种操纵符会输出一个换行符并刷新输出缓冲区第三种用进行格式化控制输出的进制在下一次将格式状态修改为其他进制时才会输出其他进制否则一直按照设置进制之后进行输出十六进制输出或者使用八进制输出都是控制符调整字段宽度和对齐方式方法只影响接下来显示的一个项目然后字段宽度将恢复为默认值使用进行设置字段宽度左对齐右对齐控制输出宽度和对齐方式填充字符在默认情况下用空格填充字段中未被使用的部分可以使用成员函数来改变填充字符在下次修改之前将一直使用之前修改的字符填充控制输出宽度和对齐方式宽度为前位用填充设置浮点数的显示精度浮点数精度的含义取决于输出模式在默认情况下指的是显示的总位数在定点模式和科学模式下精度指的是小数点后面的位数默认精度位位末尾的不显示成员函数使得能选择其他值精度设置为打印末尾的和小数点对于有些输出比如价格栏中的数字保留末尾的将更为美观上面的等都是标准控制符能够调用并且自动提供正确的参数工作方式都相似头文件使用工具来设置一些格式值有时不太方便为简化工作在头文件中提供了一些控制符作用类似表示更方便常用的有三个和表示设置精度填充字符字段宽度接受一个指定精度的整数参数接受一个指定字段宽度的整数参数接受一个指定填充字符的参数因为他们都是控制符故可以使用将语句连接起来示例使用进行输入如何检查输入不同版本的抽取运算符查看输入流的方法是相同的他们跳过空白空格换行符制表符直到遇到非空白字符即使对于单字符模式也是如此在其他模式下运算符将读取一个指定类型的数据将从非空白字符开始到与目标类型不匹配的第一个字符的全部内容假设输入输出剩下的留在输入缓冲区流状态在中对象的流状态会受到输入的影响是标准库中的标准输入流对象用于从标准输入设备通常是键盘获取用户输入流状态的不同值反映了输入的有效性和状态以下是一些关于流状态的详细介绍流状态位有一系列的流状态位主要的有当输入的数据类型不匹配或输入格式错误时会被设置例如用户输入了非整数字符而期望输入整数当输入流发生严重错误时如错误或设备故障会被设置当遇到文件末尾时会被设置表示没有错误发生流状态查询可以通过对象的成员函数和来查询流的状态返回表示或被设置返回表示被设置返回表示被设置返回表示没有任何错误位被设置即被设置流状态的影响在使用进行输入时输入的有效性和格式与流状态密切相关如果输入不符合预期流状态位将被设置进而影响程序的行为例如使用错误处理在使用进行输入时最好进行错误处理以确保用户输入的数据是有效的例如如果用户输入了非整数的字符将进入错误状态可以通过检查来检测错误并通过来清除错误状态输入有效返回无效返回清除错误状态忽略缓冲区中的无效字符的作用是清除对象的错误状态以便能够继续尝试接收输入如果不清除错误状态会一直保持在错误状态导致后续的输入操作无法正常进行的作用是清除输入缓冲区中的无效字符直到遇到换行符为止这通常用于处理用户输入错误时清除缓冲区中的残留字符以便下一次输入操作不受之前错误的影响是流的一个成员函数用于检查最近一次的输入操作是否成功它返回一个布尔值如果最近的输入操作失败则返回否则返回其他类方法单字符输入在使用参数或没有参数的情况下方法读取下一个字符即使该字符是空格制表符或换行符版本将输入字符赋给其参数而版本将输入字符转换为整型并将其返回返回值为整型可以进行拼接代表先赋值给返回调用对象再赋值给返回最后把下一个非空白字符赋值给如果这里替换位下面将不会退出循环假设输入最终输出会跳过空格输出字符串输入和放置输入字符串的内存单元的地址比读取的最大字符大额外的一个字符用于存储结果为空字符指定用作分界符的字符只有两个参数时将使用换行符用作分界符无参数时读入一个字符包括换行符常用来处理输入缓冲区中的换行符有参数时从缓冲区读取数据到达行尾或个字符剩下的空间储存在结尾添加的空字符后结束读取超过规定字符数不会出现错误会直接截断不会对换行符进行处理将其留在输入流放置输入字符串的内存单元的地址比读取的最大字符大额外的一个字符用于存储结果为空字符指定用作分界符的字符只有两个参数时将使用换行符用作分界符从缓冲区读取数据到达行尾或剩下的空间储存在结尾添加的空字符个字符结束读取超过规定的字符数会出现错误中断会读取并丢弃输入流中的换行符可拼接原型为两个参数提供的默认值为和导致读取指定数目的字符或读取到文件结尾是中用于忽略输入流中一定数量字符或特定字符的函数这个函数通常用于清除输入缓冲区中的不需要的字符以便在后续的输入操作中不受其影响文件输入输出文件输入输出头文件中定义了一个处理输出的类头文件定义了一个用于处理输出的类文件的输出主要步骤如下包含头文件创建一个对象通常取名为将该对象同一个文件关联起来使用方法向那样使用对象通常重点在屏幕上输出而是在文件中输出写入关闭文件流步骤步骤步骤以写入的方式打开文件判断文件是否打开成功打开成功返回文件打开失败步骤输入文件中步骤关闭文件流文件的输入包括以下步骤包含头文件包含头文件声明一个或多个的变量对象并且命名遵守常用的命名的规则通常取名为将对象与文件关联起来为此方法之一是使用方法可结合对象和运算符来输入各种类型的数据使用关闭文件流步骤步骤文件打开失败判断是否读取到文件结尾步骤步骤检查文件格式为对象名例如果文件成功被打开返回如果文件没有被打开因此表达式将为通常使用下方代码判断是否打开成功文件打开失败程序正常结束程序异常结束使用需要用到头文件判断文件结尾格式为对象名例在遇到文件结束标志时返回否则返回通常和循环一起用作文件读取结束在文件结束前为真结束为假退出循环具体格式为判断是否读取到文件结尾步骤文件打开关闭文件打开对象名文件名一个参数例如果文件不存在将会自动创建一个相同名字的文件如果文件存在将会打开该文件首先截断该文件将其长度截短到丢弃原有的内容然后将新的输入加入到该文件中对象名文件名打开方式两个参数例如只读模式以只读模式打开文件关闭格式对象名例注意方法不需要使用文件名作为参数因为已经同特定的文件关联起来如果忘记关闭文件程序正常终止的时候将自动关闭它打开多个文件打开多个文件时可以同时打开多个文件流文件打开失败文件打开模式打开文件含打开模式一览表函数博客新标准更多内容见章统一的初始化扩大了大括号扩起的列表即初始化列表的使用范围使其可用于所有内置类型和用户定义的类对象使用初始化列表时可添加等号也可不添加另外初始化列表可用于表达式中右值引用左值和右值左值左值是可以标识内存位置的表达式通常左值是具有名称的变量对象或表达式的结果它们可以出现在等号的左边可以被取地址例如是左值是左值因为它是地址右值右值是不能标识内存位置的表达式右值通常是临时的无法取地址的值出现在等号的右边例如是右值是右值不是右值可以取地址左值引用和右值引用左值引用左值引用是用于引用左值的引用类型它使用符号声明左值引用主要用于在函数中传递参数或作为函数的返回类型以及在赋值操作中例如是对的左值引用右值引用右值引用是用于引用右值的引用类型它使用符号声明右值引用通常与移动语义一起使用允许有效地将资源从一个对象移动到另一个对象而不进行深层复制例如是对右值的引用无法对取地址右值引用通常与移动语义结合例如在移动构造函数和移动赋值运算符中使用提高了对动态分配资源的效率左值引用用于传递可修改的参数而右值引用用于支持移动操作函数在中表达式是一种方便的方式允许你在函数内部定义匿名函数它的语法形式为是捕获列表用于指定在表达式中可以访问的外部变量是函数的参数列表是返回类型包含实际的函数体示例表达式接受两个参数返回它们的和使用表达式计算并输出结果表达式也可以访问外部变量使用表达式计算并输出结果',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-08-29 20:04:36',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://i.postimg.cc/fbN6bFqP/20220206101541-14a48.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="安知鱼的博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="安知鱼的博客"/><span class="back-menu-item-text">安知鱼的博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/keqiudi/keqiudi.github.io" title="我的博客仓库"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="我的博客仓库"/><span class="back-menu-item-text">我的博客仓库</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">THEDI的仓库</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/null"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/null"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AWS/" style="font-size: 1.05rem;">AWS<sup>2</sup></a><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>2</sup></a><a href="/tags/CLion/" style="font-size: 1.05rem;">CLion<sup>2</sup></a><a href="/tags/CMake/" style="font-size: 1.05rem;">CMake<sup>1</sup></a><a href="/tags/ESP32/" style="font-size: 1.05rem;">ESP32<sup>1</sup></a><a href="/tags/FreeRTOS/" style="font-size: 1.05rem;">FreeRTOS<sup>5</sup></a><a href="/tags/Git/" style="font-size: 1.05rem;">Git<sup>1</sup></a><a href="/tags/LCD/" style="font-size: 1.05rem;">LCD<sup>2</sup></a><a href="/tags/LVGL/" style="font-size: 1.05rem;">LVGL<sup>7</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem;">Linux<sup>8</sup></a><a href="/tags/MySQL/" style="font-size: 1.05rem;">MySQL<sup>2</sup></a><a href="/tags/PCB/" style="font-size: 1.05rem;">PCB<sup>2</sup></a><a href="/tags/QT/" style="font-size: 1.05rem;">QT<sup>1</sup></a><a href="/tags/STM32/" style="font-size: 1.05rem;">STM32<sup>2</sup></a><a href="/tags/keil/" style="font-size: 1.05rem;">keil<sup>1</sup></a><a href="/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1/" style="font-size: 1.05rem;">云服务<sup>3</sup></a><a href="/tags/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" style="font-size: 1.05rem;">启动流程<sup>2</sup></a><a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%89%E5%85%A8/" style="font-size: 1.05rem;">嵌入式安全<sup>3</sup></a><a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 1.05rem;">架构<sup>2</sup></a><a href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" style="font-size: 1.05rem;">环境配置<sup>4</sup></a><a href="/tags/%E7%A1%AC%E4%BB%B6/" style="font-size: 1.05rem;">硬件<sup>5</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>3</sup></a><a href="/tags/%E8%B0%83%E8%AF%95/" style="font-size: 1.05rem;">调试<sup>5</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/08/"><span class="card-archive-list-date">八月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">35</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/06/"><span class="card-archive-list-date">六月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/05/"><span class="card-archive-list-date">五月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/01/"><span class="card-archive-list-date">一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/02/"><span class="card-archive-list-date">二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">九月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"><a class="article-meta__tags" href="/tags/C/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>C++</span></a></span></div></div><h1 class="post-title" itemprop="name headline">C++学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-02-21T10:16:23.000Z" title="发表于 2024-02-21 18:16:23">2024-02-21</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-08-29T12:04:36.101Z" title="更新于 2025-08-29 20:04:36">2025-08-29</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">30.8k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>111分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="C++学习笔记"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为成都"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>成都</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="/assets/43.webp"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://www.thekqd.top/2024/02/21/C++-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><header><a href="/tags/C/" tabindex="-1" itemprop="url">C++</a><h1 id="CrawlerTitle" itemprop="name headline">C++学习笔记</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">THEDI</span><time itemprop="dateCreated datePublished" datetime="2024-02-21T10:16:23.000Z" title="发表于 2024-02-21 18:16:23">2024-02-21</time><time itemprop="dateCreated datePublished" datetime="2025-08-29T12:04:36.101Z" title="更新于 2025-08-29 20:04:36">2025-08-29</time></header><h1 id="C-学习笔记："><a href="#C-学习笔记：" class="headerlink" title="C++学习笔记："></a>C++学习笔记：</h1><h2 id="名称空间std"><a href="#名称空间std" class="headerlink" title="名称空间std"></a>名称空间std</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="E:！！！！Markdown\C++.assets\image-20221113132517924.png" alt="image-20221113132517924"></p>
<p>&lt;math.h&gt;新式为<cmath></p>
<p>&lt;string.h&gt;新式为<cstring></p>
<p>如果使用iostream，而不是iostream.h，即当头文件中没有扩展名h时，iostream中定义的用于输出的cout变量实际是<strong>std::cout</strong>,而endl实际上是<strong>std::endl</strong>.因此，可以省略编译指令using，用下述方式进行编码:</p>
<p>std::cout&lt;&lt;” xxxxxx”;</p>
<p>std::cout&lt;&lt;std::endl;</p>
<p>但如果使用using编译指令:<strong>using namespace std;</strong></p>
<p><strong>便可以直接使用cin和cout…，而不必加上std::前缀</strong></p>
<h2 id="控制符endl"><a href="#控制符endl" class="headerlink" title="控制符endl"></a>控制符endl</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="E:！！！！Markdown\C++.assets\image-20221113133422849.png" alt="image-20221113133422849"></p>
<p><strong>C++中的旧版换行采用的是”\n</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="E:！！！！Markdown\C++.assets\image-20221113133633328.png" alt="image-20221113133633328"></p>
<h2 id="cin和cout"><a href="#cin和cout" class="headerlink" title="cin和cout"></a>cin和cout</h2><p><strong>（1）.</strong><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="E:！！！！Markdown\C++.assets\image-20221113135231199.png" alt="image-20221113135231199"></p>
<p><strong>（2）.</strong></p>
<p><strong>输出可以拼接:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="E:！！！！Markdown\C++.assets\image-20221113140118344.png" alt="image-20221113140118344">**</p>
<h2 id="每次读取一行字符串-string-输入"><a href="#每次读取一行字符串-string-输入" class="headerlink" title="每次读取一行字符串(string)输入"></a>每次读取一行字符串(string)输入</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="E:！！！！Markdown\C++.assets\image-20221113193250853.png" alt="image-20221113193250853"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="E:！！！！Markdown\C++.assets\image-20221113194203451.png" alt="image-20221113194203451"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="E:！！！！Markdown\C++.assets\image-20221113194311275.png" alt="image-20221113194311275"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p><strong>1.cin(&gt;&gt;)</strong></p>
<p>虽然可以使用 cin 和 &gt;&gt; 来输入字符串，当 cin 读取数据时，<strong>一旦它接触到第一个非空格字符即开始阅读，当它读取到下一个空白字符时，它将停止读取。</strong></p>
<p>可以输入 “Mark” 或 “Twain”，但不能输入 “Mark (停止读取)  Twain”，<br><strong>因为 cin 不能输入包含嵌入空格的字符串。</strong></p>
<p><strong>2.cin.get(char ch)&#x2F;(array_name,size)</strong></p>
<p>无参数时，读入一个字符，包括换行符，常用来处理输入缓冲区中的换行符。</p>
<p>有参数时，从缓冲区读取数据，到达行尾或size-1个字符**(剩下的空间储存在结尾添加的空字符)**后结束读取(超过规定字符数不会出现错误,会直接截断)，不会对换行符进行处理，将其留在缓冲区</p>
<p><strong>3.cin.getline(array_name,size)</strong>      </p>
<p>从缓冲区读取数据,到达行尾或size-1**(剩下的空间储存在结尾添加的空字符)**个字符结束读取(超过规定的字符数会出现错误,中断)，会读取换行符将其替换为空字符，并且丢弃。</p>
<p>**4.getline(cin,array_name） **&#x2F;  <strong>std::getline(std::cin,array_name)</strong></p>
<p>例如：getline(cin,str); </p>
<p>从缓冲区中读取数据，遇到换行符时将其替换为空字符，并且丢弃。</p>
<h2 id="补"><a href="#补" class="headerlink" title="补:"></a>补:</h2><p><strong>(1)cin.getline(char*s,streamsize n,char delim)</strong></p>
<p>所需的头文件为<iostream>(这里的参数char s是输入的字符串变量， n是输入字符串的字符个数（第n个补’\0’）， delim是输入终止条件，即遇到delim所代表的字符就终止输入,正常使用时 char delim可以省略，c++语言默认为’\0’)   例 :   cin.getline(name,20,’C’)或cin.getline(name,20)</p>
<p><strong>(2)getline(istream&amp; is, string&amp; str, char delim)</strong></p>
<p>所需的头文件为<string>(s是标准输入流函数， str是用来存字符的变量名， delim是结束标志,作用与cin.getline()里的相同）例: getline(cin,str,’A’)</p>
<p>&#x3D;&#x3D;<strong>注:</strong> <strong>getline()是string流的函数，只能用于string类型(不能用于输入char*类型)的输入操作.</strong>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;<strong>cin.getline()是std流的函数，只能用于char*类型的输入操作（不能用于string类型输入）</strong>。&#x3D;&#x3D;       <strong>char*为数组</strong></p>
<p>   <strong>当你定义了一个char*类型变量，只能用cin&#x2F;cin.getline()输入。！！！！！</strong></p>
<p>**(3).**在使用getline读入一整行时，<br>若是前面是使用getchar()、cin这类读入了一个字母，<br>但是不会读入后续换行\n符号或者空格的输入时，再接getline()就容易出现问题。</p>
<p>这是因为输入数字之后，敲回车，产生的换行符仍然滞留在输入流了，<br>接着就被getline(cin,s)给读进去了，<br>此时的s&#x3D;“\n”,所以实际上s只是读入了一个换行符\n。</p>
<p>而若是前面使用getline()，再又用getline()进行读入，此时不会发生问题。<br><strong>getline()中读入结束的回车后，结束符不放入缓存区，会将读入的\n直接去除，</strong><br><strong>下一个输入前，缓冲区为空，并不会因为回车留下\n。</strong></p>
<p>而cin的结束后，以及getchar()此类的读入结束后,按下回车或者使用空格读入下一个，<br>此时按下的回车或空格会还在缓存区,继续用getline()就会出现前面所提到的情况。<br>那么如何解决前面用了cin、getchar()后的输入呢？<br><strong>可以直接在cin和getchar()后使用一个getchar()吃掉接下来的换行.</strong></p>
<h1 id="string类-头文件”string”"><a href="#string类-头文件”string”" class="headerlink" title="string类(头文件”string”)"></a>string类(头文件”string”)</h1><p><strong>1.</strong><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="E:！！！！Markdown\C++.assets\image-20221113202153066.png" alt="image-20221113202153066"></p>
<p><strong>2.</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="E:！！！！Markdown\C++.assets\image-20221113202108337.png" alt="image-20221113202108337"></p>
<p><strong>3.数组和string类的不同点:</strong></p>
<p>**(1)**在数组中，不能将一个数组赋给另一个数组，但可以将一个string对象赋给另一个string对象。</p>
<p>**(2)**可以使用+让两个string对象合并起来，还可以使用+&#x3D;将字符串附加到string对象的末尾。</p>
<p>同时可以对字符串实现运算符（&#x3D;&#x3D;，&#x3D;），可以直接比较</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="E:！！！！Markdown\C++.assets\image-20221113202543882.png" alt="image-20221113202543882"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="E:！！！！Markdown\C++.assets\image-20221113202618980.png"></p>
<p><strong>4.用getline将输入读取到string对象</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="E:！！！！Markdown\C++.assets\image-20221113202709793.png" alt="image-20221113202709793"></p>
<h2 id="补：获取字符串长度"><a href="#补：获取字符串长度" class="headerlink" title="补：获取字符串长度"></a>补：获取字符串长度</h2><p><strong>1.length()函数</strong><br>直接获取字符串长度，包括空格在内</p>
<p>表示方法:    **str.length()**即可表示str字符串的长度</p>
<p><strong>2.strlen()函数</strong><br>需要添加头文件&lt;string.h&gt;,而且<strong>参数只能是char数组</strong>（不能是string类）<br>而且结尾必须是\0(即字符数组不能满，因为满了结尾就不是\0，会接着向下检索到\0为止)<br>啊哦char c[6]{“kunkun”}; 这样是错误的嗷 直接没法进行编译，编译器直接帮我们解决问题2。</p>
<p>表示方法：  <strong>strlen(数组名)</strong></p>
<p><strong>3.size()</strong></p>
<p>需要添加&lt;string.h&gt;头文件，用法类似于length()。<br>size()表示的是string这个容器中的元素个数。（还可以获取vector类型的长度）<br>如果使用过std::vector之类的容器的话，可以把string看做是一个vector(这里只是举例，并不能等价)， char就是这个容器的元素类型。那么size()表示的就是这个vector(容器)中char的个数。<br>表示方法:</p>
<p>**str.size()**即可表示str字符串的长度（不包含’\0’）</p>
<h1 id="数组的替代品"><a href="#数组的替代品" class="headerlink" title="数组的替代品"></a>数组的替代品</h1><p><strong>具体见CSDN</strong></p>
<h2 id="模板类vector"><a href="#模板类vector" class="headerlink" title="模板类vector"></a>模板类vector</h2><ul>
<li><p>vector是向量类型，可以容纳许多类型的数据，因此也被称为容器</p>
</li>
<li><p>(可以理解为<strong>动态数组</strong>，是封装好了的类）</p>
</li>
<li><p>进行<code>vector</code>操作前应添加头文件<code>#include &lt;vector&gt;</code></p>
</li>
<li><p>.2 vector初始化：<br>方式1.</p>
<p>定义具有10个整型元素的向量（尖括号为元素类型名，它可以是任何合法的数据类型），不具有初值，其值不确定</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>方式2.</p>
<p>定义具有10个整型元素的向量，且给出的每个元素初值为1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(<span class="number">10</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>方式3.</p>
<p>用向量b给向量a赋值，a的值完全等价于b的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(b);</span><br></pre></td></tr></table></figure>

<p>方式4.</p>
<p>将向量b中从0-2（共三个）的元素赋值给a，a的类型为int型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(b.<span class="built_in">begin</span>(),b.begin<span class="number">+3</span>);</span><br></pre></td></tr></table></figure>

<p>方式5.</p>
<p>&#x2F;&#x2F;从数组中获得初值<br>int b[7]&#x3D;{1,2,3,4,5,6,7};</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(b,b<span class="number">+7</span>）;</span></span></span><br></pre></td></tr></table></figure>





<h4 id="1-3-vector对象的常用内置函数使用（举例说明）"><a href="#1-3-vector对象的常用内置函数使用（举例说明）" class="headerlink" title="1.3 vector对象的常用内置函数使用（举例说明）"></a>1.3 vector对象的常用内置函数使用（举例说明）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a,b;</span><br><span class="line"><span class="comment">//b为向量，将b的0-2个元素赋值给向量a</span></span><br><span class="line">a.<span class="built_in">assign</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">begin</span>()<span class="number">+3</span>);</span><br><span class="line"><span class="comment">//a含有4个值为2的元素</span></span><br><span class="line">a.<span class="built_in">assign</span>(<span class="number">4</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//返回a的最后一个元素</span></span><br><span class="line">a.<span class="built_in">back</span>();</span><br><span class="line"><span class="comment">//返回a的第一个元素</span></span><br><span class="line">a.<span class="built_in">front</span>();</span><br><span class="line"><span class="comment">//返回a的第i元素,当且仅当a存在</span></span><br><span class="line">a[i];</span><br><span class="line"><span class="comment">//清空a中的元素</span></span><br><span class="line">a.<span class="built_in">clear</span>();</span><br><span class="line"><span class="comment">//判断a是否为空，空则返回true，非空则返回false</span></span><br><span class="line">a.<span class="built_in">empty</span>();</span><br><span class="line"><span class="comment">//删除a向量的最后一个元素</span></span><br><span class="line">a.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="comment">//删除a中第一个（从第0个算起）到第二个元素，也就是说删除的元素从a.begin()+1算起（包括它）一直到a.begin()+3（不包括它）结束</span></span><br><span class="line">a.<span class="built_in">erase</span>(a.<span class="built_in">begin</span>()<span class="number">+1</span>,a.<span class="built_in">begin</span>()<span class="number">+3</span>);</span><br><span class="line"><span class="comment">//在a的最后一个向量后插入一个元素，其值为5</span></span><br><span class="line">a.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//在a的第一个元素（从第0个算起）位置插入数值5,</span></span><br><span class="line">a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()<span class="number">+1</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//在a的第一个元素（从第0个算起）位置插入3个数，其值都为5</span></span><br><span class="line">a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()<span class="number">+1</span>,<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//b为数组，在a的第一个元素（从第0个元素算起）的位置插入b的第三个元素到第5个元素（不包括b+6）</span></span><br><span class="line">a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()<span class="number">+1</span>,b<span class="number">+3</span>,b<span class="number">+6</span>);</span><br><span class="line"><span class="comment">//返回a中元素的个数</span></span><br><span class="line">a.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//返回a在内存中总共可以容纳的元素个数</span></span><br><span class="line">a.<span class="built_in">capacity</span>();</span><br><span class="line"><span class="comment">//将a的现有元素个数调整至10个，多则删，少则补，其值随机</span></span><br><span class="line">a.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//将a的现有元素个数调整至10个，多则删，少则补，其值为2</span></span><br><span class="line">a.<span class="built_in">resize</span>(<span class="number">10</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//将a的容量扩充至100，</span></span><br><span class="line">a.<span class="built_in">reserve</span>(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//b为向量，将a中的元素和b中的元素整体交换</span></span><br><span class="line">a.<span class="built_in">swap</span>(b);</span><br><span class="line"><span class="comment">//b为向量，向量的比较操作还有 != &gt;= &gt; &lt;= &lt;</span></span><br><span class="line">a==b;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h2><p>C++中，在获取<strong>字符串长度</strong>时，size()函数与length()函数作用相同。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line">cin&gt;&gt;str;</span><br><span class="line">cout&lt;&lt;str.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;str.<span class="built_in">length</span>()&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p><strong>size()函数以及length()函数</strong>都用于计算字符串（string）长度，不能用char*作为参数。除此之外，size()函数还可以获取vector类型的长度。</p>
<p>size()函数返回值为unsigned int 类型为正数</p>
<p>注意 让其作为返回值赋给变量时，变量类型要为<br>unsigned int 或 size_t型</p>
<p>补:<strong>size_t</strong></p>
<p><strong>size_t</strong> 是一些C&#x2F;C++标准在stddef.h中定义的，size_t 类型表示C中任何对象所能达到的最大长度，它是无符号整数。</p>
<p>32位上的定义:  等价于 unsigned int</p>
<p>64位上的定义:  等价于 unsigned long</p>
<h2 id="empty"><a href="#empty" class="headerlink" title="empty()"></a>empty()</h2><p>C++中empty()作为判断容器是否为空的函数</p>
<p>用法为 <strong>对象名.empty()</strong>    例: <strong>s.empty()</strong></p>
<p><strong>如果对象为空就返回1(ture)，</strong></p>
<p><strong>不为空返回0(false)</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string s = <span class="string">&quot;&quot;</span>；</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; “字符串为空”;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;字符串不为空&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="swap-swap-交换"><a href="#swap-swap-交换" class="headerlink" title="swap()         swap(交换)"></a>swap()         swap(交换)</h2><p><strong>具体见CSDN</strong></p>
<p>标准库的<strong>C ++中</strong>的<code>swap()</code>函数是一个在两个<strong>相同类型</strong>的给定变量之间直接交换值的函数。<strong>元素个数不相等也可以进行交换</strong></p>
<p>用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">swap</span>(a,b);</span><br></pre></td></tr></table></figure>

<h2 id="insert-insert-插入"><a href="#insert-insert-插入" class="headerlink" title="insert()      insert(插入)"></a>insert()      insert(插入)</h2><p><strong>对象.insert()</strong></p>
<p><strong>几种用法:</strong>         <strong>下标（索引）都是默认从第0个位置开始（第0个位置，第1个位置）</strong></p>
<p><strong>1、在第index位置插入count个字符c—-&gt;str.insert(index,count,c);</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;012356789&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入前的字符串----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;<span class="number">0123567</span>89</span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">4</span>,<span class="number">1</span>,<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入后的字符串----&gt;&quot;</span>  &lt;&lt; str &lt;&lt; endl;  <span class="number">01234567</span>89</span><br></pre></td></tr></table></figure>

<p><strong>2、在第index位置插入一个常量字符串—-&gt;str.insert(index,str);</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;0156789&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入前的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;  <span class="number">01567</span>89</span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">2</span>,<span class="string">&quot;234&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入后的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;   <span class="number">01234567</span>89</span><br></pre></td></tr></table></figure>

<p><strong>3、第index位置插入常量字符串str中的count个字符—-&gt;str.insert(index,str,count);</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;01236789&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入前的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">4</span>,<span class="string">&quot;456789&quot;</span>,<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入后的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl; <span class="number">01234567</span>89</span><br></pre></td></tr></table></figure>

<p>4、<strong>第index位置插入常量str—-&gt;str.insert(index,str);</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;01236789&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入前的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">4</span>,<span class="string">&quot;45&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入后的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl; <span class="number">01234567</span>89</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>5、第index位置插入常量str的从index_str开始的count个字符—-&gt;str.insert(index,str,index_str,count);</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;01236789&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入前的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">4</span>,<span class="string">&quot;2345678&quot;</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入后的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;   <span class="number">01234567</span>89</span><br></pre></td></tr></table></figure>

<p><strong>6、index位置插入常量str从index_str开始以后的字符串—-&gt;str.insert(index,str,index_str,string::npos);</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;01236789&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入前的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">4</span>,<span class="string">&quot;012345&quot;</span>,<span class="number">4</span>,string::npos);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入后的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;  <span class="number">01234567</span>89</span><br></pre></td></tr></table></figure>





<h1 id="NULL和nullptr"><a href="#NULL和nullptr" class="headerlink" title="NULL和nullptr"></a>NULL和nullptr</h1><p>c中用NULL表示空指针</p>
<p>但在c++中用nullptr表示空指针，把NULL当作0来使用</p>
<p><strong>具体的见CSDN</strong></p>
<h2 id="对类的定义："><a href="#对类的定义：" class="headerlink" title="对类的定义："></a>对类的定义：</h2><p><strong>首先用class+标记名对类进行定义</strong>：<strong>1.private部分，2.public部分</strong></p>
<p><strong>(1)private</strong>中的数据为隐藏数据（通常是变量），只能通过public中的成员函数对其进行访问，外部没有访问权力。</p>
<p><strong>(2)public</strong>中通常是成员函数，可以在成员函数中访问该类的private中的数据，<strong>通常只在里面声明函数原型,在其他地方定义</strong>（此处用的链表，链表的下一个结点）</p>
<p>**注：**访问成员函数要作用域解析符 <strong>: :</strong>  ，格式为 : <strong>类标记名+ : : + 函数名</strong>   <strong>尤其是在定义时</strong> 例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Input</span><span class="params">()</span></span>&#123;<span class="comment">//定义一个全新的函数Input,不是成员函数</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Classroom::Input</span><span class="params">()</span></span>&#123;<span class="comment">//对成员函数进行定义</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处用了友元类，具体见笔记</p>
<h2 id="类对象（变量）的创建"><a href="#类对象（变量）的创建" class="headerlink" title="类对象（变量）的创建"></a>类对象（变量）的创建</h2><p><strong>标记名 + 对象名</strong> 例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Classroom</span>&#123;</span></span><br><span class="line">    private：</span><br><span class="line">        </span><br><span class="line">    public：</span><br><span class="line">        <span class="type">void</span> <span class="title function_">Input</span><span class="params">()</span>; </span><br><span class="line">&#125;</span><br><span class="line">Classroom a<span class="comment">//创建一个Classroom类的对象a</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Classroom::Input();<span class="comment">//错误写法</span></span><br><span class="line">    a.Input()<span class="comment">//正确写法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>重点！！   注意：在调用成员函数之前，必须创建对象,不能直接像定义成员函数那样调用成员函数.   如上方</strong></p>
<p><strong>调用成员函数的方式是通过 点关系符 ”  .  “</strong></p>
<p>！！！！ <strong>类访问&#x3D;&#x3D;成员函数&#x3D;&#x3D;时用”.”访问,并且如果没有参数访问的时候必须带上后面的括号，否则认为访问的是变量；</strong></p>
<p>格式为：   <strong>对象名 . 函数名()</strong></p>
<p>  <strong>例如:       a.Input();</strong></p>
<p><strong>下为类对象（变量）在学生管理程序中使用：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="E:！！！！Markdown\C++.assets\image-20221120220212245.png" alt="image-20221120220212245"></p>
<h2 id="new和delete"><a href="#new和delete" class="headerlink" title="new和delete"></a>new和delete</h2><p><strong>该处以链表+类为例：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="E:！！！！Markdown\C++.assets\image-20221120200903909.png![image-20221120202508583](E:！！！！Markdown\C++.assets\image-20221120202508583.png![image-20221120202614633](E:！！！！Markdown\C++.assets\image-20221120202614633.png" alt="image-20221120200903909"></p>
<h3 id="1-New"><a href="#1-New" class="headerlink" title="1.New"></a>1.New</h3><p>（1）用malloc分配内存时需要头文件cstdlib,但是new 不需要引用新的头文件。</p>
<p> （2）new为一个数据对象（可以是结构，也可以是基本类型）获得并指定分配的内存</p>
<p>通用格式如下：<strong>typename * pointer_name &#x3D; new typeName</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);<span class="comment">//申请了一个初值为10的整型数据,括号中为初始化的值</span></span><br><span class="line"><span class="type">int</span> *arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];<span class="comment">//申请了能存放10个整型数据元素的数组，其首地址为arr</span></span><br></pre></td></tr></table></figure>

<p>注意: </p>
<p>*<em>int <em>p&#x3D;new int 此时解引用p的值将会是一个随机值，未初始化。</em></em></p>
<p>*<em>int <em>p&#x3D;new int() 此时括号里为空，解引用p的值将自动初始化为0</em></em></p>
<p>此处文件中<strong>current</strong> 是一个指针 ，<strong>Student</strong>是类标记，<strong>new + 类型名 返回的值是一个地址</strong></p>
<p>（3）new 从被称为<strong>堆</strong>或<strong>自由储存区</strong>的内存区域分配内存，除了主动释放外不会被回收。而局部变量通常储存在<strong>栈</strong>的内存区域中</p>
<h3 id="2-Delete"><a href="#2-Delete" class="headerlink" title="2.Delete"></a>2.Delete</h3><p><strong>delete 用来释放new分配的内存</strong></p>
<p>通常    delete + 指针名    即可（注意:delete不一定使用用于new的指针，而是用于new的地址）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p；</span><br><span class="line"><span class="keyword">delete</span>[] arr;<span class="comment">//注意要删除数组时，需要加[]，以表示arr为数组。</span></span><br></pre></td></tr></table></figure>

<p><strong>使用new 和 delete 应该遵守以下规则：</strong></p>
<p>1.不要使用delete来释放不是new分配的内存。</p>
<p>2.不要使用delete来释放同一个内存块两次。</p>
<p>3.如果使用new [ ]为数组分配内存，则应该使用delete [ ]来释放</p>
<p>4.如果使用new为一个实体分配内存，则应该使用delete（没有方括号）来释放。</p>
<p>5.对空指针使用delete是安全的。</p>
<h2 id="C-中文件的输入输出"><a href="#C-中文件的输入输出" class="headerlink" title="C++中文件的输入输出"></a>C++中文件的输入输出</h2><h3 id="写入到文本文件中"><a href="#写入到文本文件中" class="headerlink" title="写入到文本文件中"></a>写入到文本文件中</h3><p>&#x3D;&#x3D;要求&#x3D;&#x3D;：</p>
<p><strong>1.包含头文件iostream，</strong></p>
<p><strong>包含头文件fstream</strong></p>
<p><strong>iostream: 头文件中定义了一个处理输出的ostream类</strong></p>
<p><strong>fstream：头文件定义了一个用于处理输出的ofstream类</strong></p>
<p><strong>2.<strong>声明一个或多个</strong>ofstream</strong>（<strong>output fstream</strong>）的变量（对象），并且命名，遵守常用的命名的规则，<strong>通常取名为outFile</strong></p>
<p>**3.**必须指明名称空间std，为引用ofstream，必须使用编译指令using或者前缀的std：：</p>
<p>**4.**将ofstream对象与文件关联起来。为此，方法之一是使用open()方法</p>
<p>**5.**使用完文件后，应使用close()将其关闭</p>
<p>**6.**可结合ofstream对象 和运算符&lt;&lt;来输出各种类型的数据。</p>
<p>**总结：**文件的输出主要步骤如下:</p>
<p>1.包含头文件fstream</p>
<p>2.创建一个ofstream（output fstream）对象（<strong>通常取名为outFile</strong>）</p>
<p>3.将该ofstream 对象同一个文件关联起来。</p>
<p>**4.向cout那样使用ofstream对象（通常outFile）**重点：<strong>cout在屏幕上输出，而outFile是在文件中输出（写入）</strong></p>
<p><strong>例子见下方</strong></p>
<h3 id="从文本文件中读取数据"><a href="#从文本文件中读取数据" class="headerlink" title="从文本文件中读取数据"></a>从文本文件中读取数据</h3><p>&#x3D;&#x3D;要求&#x3D;&#x3D;：</p>
<p><strong>1.包含头文件iostream，包含头文件fstream</strong></p>
<p><strong>iostream: 头文件中定义了一个处理输出的istream类</strong></p>
<p><strong>fstream：头文件定义了一个用于处理输入的ifstream类</strong></p>
<p><strong>2.<strong>声明一个或多个</strong>ifstream</strong>（<strong>input fstream</strong>）的变量（对象），并且命名，遵守常用的命名的规则，<strong>通常取名为inFile</strong></p>
<p>**3.**必须指明名称空间std，为引用ifstream，必须使用编译指令using或者前缀的std：：</p>
<p>**4.**将ifstream对象与文件关联起来。为此，方法之一是使用open()方法</p>
<p>**5.**使用完文件后，应使用close()将其关闭</p>
<p>**6.**可结合ifstream对象 和运算符&lt;&lt;来输出各种类型的数据。</p>
<h4 id="检查文件"><a href="#检查文件" class="headerlink" title="检查文件"></a>检查文件</h4><p>格式为: 对象名.isopen()  例:    <strong>inFile.is_open()</strong></p>
<p>如果文件成功被打开，返回<strong>true</strong>；如果文件没有被打开，<strong>因此表达式   !inFile.is_open()  将为true</strong></p>
<p>通常使用下方代码判断是否打开成功</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!inFile.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;文件打开失败&quot;</span>;</span><br><span class="line">   	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>exit(0)程序正常结束</strong></p>
<p><strong>exit(1)程序异常结束</strong></p>
<p><strong>exit()使用需要用到头文件&#x3D;&#x3D;cstdlib&#x3D;&#x3D;</strong>  </p>
<h4 id="文件读取结尾"><a href="#文件读取结尾" class="headerlink" title="文件读取结尾"></a>文件读取结尾</h4><p><strong>eof在遇到EOF（文件结束标志）时返回ture ，否则返回false</strong></p>
<p>通常和while循环一起用作文件读取结束，<strong>!inFile.eof</strong>在文件结束前为真，结束为假（退出循环）</p>
<p>具体格式为：   <strong>while(  !inFile.eof（）)</strong> </p>
<h4 id="文件的打开和关闭"><a href="#文件的打开和关闭" class="headerlink" title="文件的打开和关闭"></a>文件的打开和关闭</h4><p>**1.对象名.open(“文件名”) **（一个参数）例：<strong>outFile.open(“student.txt”)</strong> 如果文件不存在，将会自动创建一个相同名字的文件,如果文件存在，将会打开该文件，首先截断该文件，将其长度截短到0，丢弃原有的内容，然后将新的输入加入到该文件中</p>
<p><strong>2.对象名.open(“文件名”，打开方式)</strong> （两个参数）例如 : **outFile.open(“student.txt”,std::ios::in)**只读模式  见下方</p>
<p>格式：对象名.close()  例: <strong>outFile.close()</strong></p>
<p>注意方法close()，不需要使用文件名作为参数，因为outFile已经同特定的文件关联起来，如果忘记关闭文件，程序正常终止的时候将自动关闭它。</p>
<p><strong>下面时学生管理程序中的例子:</strong></p>
<p><strong>读取数据到文件中（output输出数据到文件）：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="E:！！！！Markdown\C++.assets\image-20221120212115308.png" alt="image-20221120212115308"></p>
<p><strong>从该文件中读取数据（input从文件中输入数据到外）：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="E:！！！！Markdown\C++.assets\image-20221120212136110.png" alt="image-20221120212136110"></p>
<p><strong>从文件中读取数据时，也需要用到new分配新的内存，与Input（）函数在输入数据时相同</strong></p>
<p><strong>inFile 对应的c中的fscanf（从文件中读取数据）</strong></p>
<p><strong>outFile对应的时c中的fprintf（写入数据到文件）</strong></p>
<h1 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul>
<li>按参数种类分：无参构造函数、有参构造函数、有默认参构造函数</li>
<li>按类型分为：普通构造函数、拷贝构造函数(赋值构造函数)</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Viewinfinitely/article/details/115017678?ops_request_misc=%7B%22request_id%22:%22170626893616800185850269%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170626893616800185850269&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-115017678-null-null.142%5Ev99%5Epc_search_result_base4&utm_term=C++%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&spm=1018.2226.3001.4187">C++构造函数的各种用法全面解析（C++初学面向对象编程）_c++ 构造函数-CSDN博客</a></p>
<h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><h2 id="运算符重载的概念和原理"><a href="#运算符重载的概念和原理" class="headerlink" title="运算符重载的概念和原理"></a>运算符重载的概念和原理</h2><p>如果不做特殊处理，C++ 的 +、-、*、&#x2F; 等运算符只能用于对基本类型的常量或变量进行运算，不能用于对象之间的运算。</p>
<p>有时希望对象之间也能用这些运算符进行运算，以达到使程序更简洁、易懂的目的。例如，复数是可以进行四则运算的，两个复数对象相加如果能直接用+运算符完成，不是很直观和简洁吗？</p>
<p>利用 C++ 提供的“运算符重载”机制，赋予运算符新的功能，就能解决用+将两个复数对象相加这样的问题。</p>
<p>运算符重载，就是对已有的运算符赋予多重含义，使同一运算符作用于不同类型的数据时产生不同的行为。运算符重载的目的是使得 C++ 中的运算符也能够用来操作对象。</p>
<p>运算符重载的实质是编写以运算符作为名称的函数。不妨把这样的函数称为运算符函数。运算符函数的格式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">返回值类型  <span class="keyword">operator</span>  运算符(形参表)</span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符可以是+、-、*、/等，必须是有效的C++运算符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值可以是一个引用，也可以是一个对象，但一定注意！！！，不要返回一个指向局部变量或临时对象的引用，因为函数执行完毕后，局部变量和临时对象将消失，引用将指向一个不存在的数据</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*一个简单的重载+运算符*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">       <span class="type">int</span> testData;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getData</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> testData;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">setData</span><span class="params">(<span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>-&gt;testData = data;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Test <span class="keyword">operator</span>+(<span class="type">const</span> Test&amp; t)</span><br><span class="line">     &#123;</span><br><span class="line">         Test test;</span><br><span class="line">         test.testData = testData+t.testData;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> test;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Test t1,t2;</span><br><span class="line">    Test t3,t4;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">setData</span>(<span class="number">5</span>);</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">setData</span>(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    t3 = t1+t2;</span><br><span class="line"></span><br><span class="line">    t4 = t<span class="number">1.</span><span class="keyword">operator</span>+(t3);</span><br><span class="line">    <span class="comment">//t4 = t1+t2+t3 这是允许的，得出的结果相同</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;t1:&quot;</span> &lt;&lt; t<span class="number">1.</span><span class="built_in">getData</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;t2:&quot;</span> &lt;&lt; t<span class="number">2.</span><span class="built_in">getData</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;t3:&quot;</span> &lt;&lt; t<span class="number">3.</span><span class="built_in">getData</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;t4:&quot;</span> &lt;&lt; t<span class="number">4.</span><span class="built_in">getData</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：重载后的+号允许大于两个对象相加，如t4 = t1+ t2 + t3</span></span><br></pre></td></tr></table></figure>



<div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>该函数有两种调用方式</strong>：</p>
<ul>
<li>通过对象调用方法来调用，如上边的t4</li>
<li>直接通过重载的符号调用，如上方t1+t2</li>
</ul>
</div>

<h2 id="运算符重载限制"><a href="#运算符重载限制" class="headerlink" title="运算符重载限制:"></a>运算符重载限制:</h2><p>运算符重载规则，即允许重载的运算符，不允许重载的运算符见：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_72157449/article/details/128664136?ops_request_misc=&request_id=&biz_id=102&utm_term=c++%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E9%99%90%E5%88%B6&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-128664136.142%5Ev96%5Epc_search_result_base1&spm=1018.2226.3001.4187">【⑤C++ | 运算符重载】意义 | 限制 | 方法 | 规则 | 特殊运算符重载 | 应用场景-CSDN博客</a></p>
<p>注：在 <strong>C++ 中，类型的名字（包括类的名字）本身也是一种运算符</strong>，即类型强制转换运算符。 类型强制转换运算符是单目运算符，也可以被重载，但只能重载为成员函数，不能重载为全局函数。</p>
<h1 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h1><h2 id="继承的定义"><a href="#继承的定义" class="headerlink" title="继承的定义"></a>继承的定义</h2><p>定义：</p>
<p>继承(inheritance)机制是面向对象程序设计中使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加功能。这样产生的新类，称派生类（或子类），被继承的类称基类（或父类）。</p>
<p>继承呈现了面向对象程序设计的层次结构，体现了由简单到复杂的认知过程。之前接触的复用都是函数复用，继承是类设计层次的复用。</p>
<h2 id="继承：is-a-关系"><a href="#继承：is-a-关系" class="headerlink" title="继承：is-a 关系"></a>继承：is-a 关系</h2><p>因为派生类可以在基类上添加新特性，所以这种关系成为is-a-kind-of(是一种)关系更加准确，通常术语是is-a关系。例如：香蕉是一种水果</p>
<p>同时在指针指向的对象上面也有讲究：</p>
<ul>
<li>可以将基类指针指向派生类对象(多态性体现)</li>
<li>不能将派生类指针指向基类对象(不允许这样做)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Banana</span>:<span class="keyword">public</span> Fruit</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Fruit *pFruit1 = <span class="keyword">new</span> <span class="built_in">Fruit</span>();<span class="comment">//正确</span></span><br><span class="line">    Fruit *pBanana = <span class="keyword">new</span> <span class="built_in">Banana</span>();<span class="comment">//正确，满足香蕉一种水果，水果包含香蕉的关系</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用基类指针引用派生类对象的能力允许多态性。在这种情况下，你可以通过基类指针调用基类的函数或访问基类的成员，而在运行时，将调用正确的派生类方法。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    Banana* pFruit2 = <span class="keyword">new</span> <span class="built_in">Fruit</span>();<span class="comment">//错误，水果不是一种香蕉，香蕉不包含水果，不允许这样做</span></span><br><span class="line">    Banana* pBanana1 =<span class="keyword">new</span> <span class="built_in">Banana</span>();<span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="继承的格式"><a href="#继承的格式" class="headerlink" title="继承的格式"></a>继承的格式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 新类的名字: 继承方式 继承类的名字</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*一个简单的例子*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">people</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">people</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">people</span>(string name,<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>:<span class="keyword">public</span> people</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> schoolnum;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">student</span>(string name,<span class="type">int</span> age,<span class="type">int</span> schoolNum):<span class="built_in">people</span>(name,age)<span class="comment">//使用成员初始化列表语法,会先调用基类的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;schoolnum = schoolNum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*上面的构造函数等价于</span></span><br><span class="line"><span class="comment">    student(string name,int age,int schoolnum)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        this-&gt;name = name;</span></span><br><span class="line"><span class="comment">        this-&gt;age = age;</span></span><br><span class="line"><span class="comment">        this-&gt;schoolnum = schoolnum;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    这两种方法都可以</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; name &lt;&lt; endl &lt;&lt; age &lt;&lt; endl &lt;&lt; schoolnum &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">student <span class="title">s</span><span class="params">(<span class="string">&quot;keqiudi&quot;</span>,<span class="number">18</span>,<span class="number">2022124018</span>)</span></span>;</span><br><span class="line">    s.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>在继承的时候可以使用类名加上作用域解析符(:)来调用基类的方法，通常在私有继承中使用，第二种便是使用this指针调用继承过来的基类的方法</strong></p>
</div>





<p>更多详细内容学习：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_62718027/article/details/125922249?ops_request_misc=%7B%22request_id%22:%22170126212316800222846414%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170126212316800222846414&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-125922249-null-null.142%5Ev96%5Epc_search_result_base1&utm_term=C++%E7%B1%BB%E7%BB%A7%E6%89%BF&spm=1018.2226.3001.4187">c++：继承（超详解）</a></p>
<h2 id="继承的总结："><a href="#继承的总结：" class="headerlink" title="继承的总结："></a>继承的总结：</h2><ol>
<li>基类private成员无论以什么方式继承到派生类中都是不可见的。这里的不可见是指基类的私有成员还是被继承到了派生类对象中，但是语法上限制派生类对象不管在类里面还是类外面都不能去访问它。</li>
<li>基类private成员在派生类中不能被访问，如果基类成员不想在派生类外直接被访问，但需要在派生类中访问，就定义为protected。可以看出保护成员限定符是因继承才出现的。</li>
<li>基类的私有成员在子类都是不可见；基类的其他成员在子类的访问方式就是访问限定符和继承方式中权限更小的那个（权限排序：public&gt;protected&gt;private）。</li>
<li>使用关键字class时<strong>默认的继承方式是private</strong>，使用struct时默认的继承方式是public，但最好显式地写出继承方式。</li>
</ol>
<h2 id="多态公有继承"><a href="#多态公有继承" class="headerlink" title="多态公有继承"></a>多态公有继承</h2><p>简单来说就是一个方法的行文随上下文而异，有两种重要机制可用于实现多态的公有继承</p>
<ol>
<li>在派生类中重新定义基类的方法</li>
<li>使用虚方法</li>
</ol>
<h3 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a>虚方法</h3><ul>
<li>关键词：virtual</li>
<li>在基类中将<strong>派生类会重新定义的方法</strong>声明为虚方法。使用了virtual，程序将根据<strong>引用或指针指向的对象</strong>的类型来选择方法，而未使用时程序将仅仅根据<strong>引用或指针的类型</strong>来选择方法，与<strong>多态性</strong>紧密相关。</li>
<li>virtual关键词只用于类声明的方法原型中，而不用于类方法实现中</li>
<li>派生类中覆盖的方法后要加上override标注</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//brass.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BRASS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BRASS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Brass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string fullName; <span class="comment">//客户姓名</span></span><br><span class="line">	<span class="type">long</span> acctNum; <span class="comment">//账号</span></span><br><span class="line">	<span class="type">double</span> balance; <span class="comment">//当前结余</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Brass</span>(<span class="type">const</span> string &amp;s = <span class="string">&quot;Nullbody&quot;</span>, <span class="type">long</span> an = <span class="number">-1</span>, <span class="type">double</span> bal = <span class="number">0.0</span>); <span class="comment">//创建账户</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Deposit</span><span class="params">(<span class="type">double</span> amt)</span></span>; <span class="comment">//存款</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Withdraw</span><span class="params">(<span class="type">double</span> amt)</span></span>; <span class="comment">//取款</span></span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">Balance</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//显示账户信息</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ViewAcct</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//显示</span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Brass</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BrassPlus</span> : <span class="keyword">public</span> Brass</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">double</span> maxLoan; <span class="comment">//透支上限</span></span><br><span class="line">	<span class="type">double</span> rate; <span class="comment">//透支贷款利率</span></span><br><span class="line">	<span class="type">double</span> owesBank; <span class="comment">//当前的透支总额</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">BrassPlus</span>(<span class="type">const</span> string &amp;s = <span class="string">&quot;Nullbody&quot;</span>, <span class="type">long</span> an = <span class="number">-1</span>, <span class="type">double</span> bal = <span class="number">0.0</span>, <span class="type">double</span> m1 = <span class="number">500</span>, <span class="type">double</span> r = <span class="number">0.11125</span>);</span><br><span class="line">	<span class="built_in">BrassPlus</span>(<span class="type">const</span> Brass &amp;ba, <span class="type">double</span> m1 = <span class="number">500</span>, <span class="type">double</span> r = <span class="number">0.11125</span>);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ViewAcct</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">//覆盖基类实现，函数重载</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Withdraw</span><span class="params">(<span class="type">double</span> amt)</span> <span class="keyword">override</span></span>; <span class="comment">//覆盖基类实现，函数重载</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ResetMax</span><span class="params">(<span class="type">double</span> m)</span> </span>&#123; maxLoan = m; &#125; <span class="comment">//透支上限</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ResetRate</span><span class="params">(<span class="type">double</span> r)</span> </span>&#123; rate = r; &#125; <span class="comment">//透支贷款利率</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ResetOwes</span><span class="params">()</span> </span>&#123; owesBank = <span class="number">0</span>; &#125; <span class="comment">//当前透支总额</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>







<p>设计的Brass基类指针既可以指向Brass对象，也可以指向BrassPlus对象，因此可以使用一个数组来表示多种类型的对象，这就是多态性。下面在一个数组中可以很清楚的看清virtual的作用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> CLIENTS = <span class="number">2</span>;</span><br><span class="line">Brass *clients[CLIENTS];<span class="comment">//Brass类型的指针</span></span><br><span class="line">clients[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">Brass</span>(<span class="string">&quot;Test0&quot;</span>, <span class="number">1234</span>, <span class="number">1234.56</span>);<span class="comment">//指向Brass类型对象</span></span><br><span class="line">clients[<span class="number">1</span>] = <span class="keyword">new</span> <span class="built_in">BrassPlus</span>(<span class="string">&quot;Test1&quot;</span>, <span class="number">5678</span>, <span class="number">5678.91</span>);<span class="comment">//指向BrassPlus类型对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; CLIENTS;++i)</span><br><span class="line">&#123;</span><br><span class="line">    clients[i]-&gt;<span class="built_in">ViewAcct</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>多态性说明</strong>：</p>
<ul>
<li>假如ViewAcct()是使用关键字virtual声明</li>
</ul>
<p>如果数组成员(指针)指向的是Brass对象，则调用的是Brass::ViewAcct()。<br>如果数组成员(指针)指向的是BrassPlus对象，则调用的是BrassPlus::ViewAcct()。</p>
<ul>
<li>假如ViewAcct()不是虚方法</li>
</ul>
<p>则在任何情况下都将调用Brass::ViewAcct()。</p>
<h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>基类要声明一个虚析构函数，为了确保释放派生类对象时，按正确的顺序调用析构函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Brass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string fullName; <span class="comment">//客户姓名</span></span><br><span class="line">	<span class="type">long</span> acctNum; <span class="comment">//账号</span></span><br><span class="line">	<span class="type">double</span> balance; <span class="comment">//当前结余</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Brass</span>() &#123;&#125; <span class="comment">//这是虚析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>为何使用虚析构函数</strong>：</p>
<ul>
<li>如果析构函数不是虚方法，则将只调用对应于指针类型的析构函数。对于Brass * 指针将只调用Brass基类的析构函数，即使Brass * 指针指向的是BrassPlus对象。</li>
<li>如果析构函数是虚方法，将调用相应的指向对象类型的析构函数。即如果指针指向的是Brass对象，将调用Brass对象的析构函数，如果指针指向的是BrassPlus对象，将调用BrassPlus的析构函数，然后自动调用基类的析构函数。因此，使用虚析构函数可以确保正确的析构函数序列被调用。</li>
<li>如果BrassPlus包含一个执行某些操作的析构函数，则Brass必须有一个虚析构函数，即使Brass的析构函数不执行任何操作。</li>
</ul>
</div>

<h2 id="静态联编和动态联编"><a href="#静态联编和动态联编" class="headerlink" title="静态联编和动态联编"></a>静态联编和动态联编</h2><p><strong>静态联编</strong>：静态联编是指联编工作在<strong>编译阶段完成的</strong>，联编过程是在程序运行之前完成。要实现静态联编，在编译阶段就必须确定程序中的操作调用（如函数调用）与执行该操作代码间的关系，静态联编对函数的选择是<strong>基于指向对象的指针或者引用的类型</strong>。其优点是<strong>效率高，但灵活性差</strong>，也因此作为C++默认联编选择。</p>
<p><strong>动态联编</strong>：动态联编是指联编在<strong>程序运行时动态地进行</strong>，根据当时的情况来确定调用哪个同名函数，实际上是在运行时是<strong>虚函数的实现</strong>。动态联编对成员函数的选择是基于<strong>对象的类型</strong>，针对不同的对象类型将做出不同的编译结果。C++中一般情况下的联编是静态联编，但是当涉及到<strong>多态性和虚函数时应该使用动态联编</strong>。动态联编的优点是<strong>灵活性强，但效率低</strong>。</p>
<p>动态联编规定：只能通过指向基类的指针或基类对象的引用来调用虚函数，其格式为：指向基类的指针变量名-&gt;虚函数名（实参表）或基类对象的引用名.虚函数名（实参表）</p>
<ul>
<li>编译器对<strong>非虚方法</strong>使用<strong>静态联编</strong></li>
<li>编译器对<strong>虚方法</strong>使用<strong>动态联编</strong></li>
</ul>
<hr>
<p><strong>实现动态联编需要同时满足以下三个条件：</strong></p>
<p>①  必须把动态联编的行为定义为类的虚函数。</p>
<p>②  类之间应满足子类型关系，通常表现为一个类从另一个类公有派生而来。</p>
<p>③  必须先使用基类指针指向子类型的对象，然后直接或者间接使用基类指针调用虚函数</p>
<p><strong>总结</strong>：</p>
<p>大多数情况下，动态联编很好，因为他让程序能够选择特定类型设计的方法。<strong>虚函数是实现多态的基础，是实现动态联编的必要条件之一</strong>。动态联编要靠虚函数来实现，虚函数要靠动态联编的支持。两者相辅相成，缺一不可。</p>
<h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>当在C++中定义类的构造函数时，可以使用初始化列表来初始化类的成员变量。初始化列表是在构造函数的参数列表后面使用冒号(:)分隔开来的一组初始化语句,多个参数初始化使用逗号隔开，用于初始化类的成员变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*初始化列表写法*/</span></span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> value,<span class="type">double</span> values):<span class="built_in">data</span>(value),<span class="built_in">datas</span>(values)<span class="comment">//这里的冒号及冒号右边的部分就是构造函数的初始化列表,逗号隔开</span></span><br><span class="line">	&#123;</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/*函数体内写法*/</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> value,<span class="type">double</span> values)</span><br><span class="line">    &#123;</span><br><span class="line">        data = value;</span><br><span class="line">        <span class="type">double</span> = datas;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">    <span class="type">double</span> datas;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>注意</strong>：</p>
<ul>
<li>对于<strong>继承的对象</strong>，构造函数在成员初始化列表中使用基类名来调用特定的基类构造函数。</li>
<li>对于<strong>成员对象</strong>，构造函数则使用成员名。</li>
</ul>
</div>



<h3 id="什么时候必须使用"><a href="#什么时候必须使用" class="headerlink" title="什么时候必须使用"></a>什么时候必须使用</h3><ol>
<li><strong>在成员变量为引用类型时</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> &amp;data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> value):<span class="built_in">data</span>(value)<span class="comment">//正确</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        data = value;<span class="comment">//会报错引用类型不允许这样做,只能使用初始化列表(上面的方式初始化)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>在成员变量为const时</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> value):<span class="built_in">data</span>(value)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="built_in">A</span>(<span class="type">int</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        data = value;<span class="comment">//会报错const类型不允许这样做,只能使用初始化列表(上面的方式初始化)</span></span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="建议使用的地方"><a href="#建议使用的地方" class="headerlink" title="建议使用的地方"></a>建议使用的地方</h3><ul>
<li>初始化基类部分</li>
</ul>
<p>在派生类构造函数中使用初始化列表法初始基类的变量，可以避免在函数体中进行额外的赋值操作提高效率，同时提高可读性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*对于成员对象使用成员名初始化列表*/</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="type">int</span> value)</span>:data(value)//这里的冒号及冒号右边的部分就是构造函数的初始化列表,逗号隔开</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> datas;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*对于继承的对象，使用基类名初始化列表，调用基类构造函数初始化基类部分*/</span></span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> value,<span class="type">double</span> values):<span class="built_in">A</span>(value)</span><br><span class="line">    &#123;</span><br><span class="line">        datas = values; <span class="comment">//正常的在函数体内初始化派生类部分,更清晰表明继承关系，这个地方也可以在上面使用初始化列表方式为datas赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>总结</strong>：</p>
<p>建议尽可能使用初始化列表法来初始化构造函数中的成员变量，但并非所有情况都必须使用初始化列表。</p>
<p>一般来说，以下情况建议使用初始化列表法：</p>
<ol>
<li><strong>初始化成员变量</strong>：如果构造函数需要初始化类的成员变量,但此时类的结构和逻辑不是很复杂时，使用初始化列表是最清晰和高效的方式。</li>
<li><strong>初始化基类部分</strong>：在派生类的构造函数中调用基类的构造函数时，应该使用初始化列表来确保基类部分被正确地初始化。</li>
<li><strong>初始化const和引用类型成员变量</strong>：const和引用类型的成员变量只能在初始化列表中进行初始化，无法在构造函数体内进行赋值。</li>
<li><strong>初始化具有复杂初始化逻辑的成员变量</strong>：如果某个成员变量的初始化逻辑比较复杂，使用初始化列表可以将初始化逻辑集中在一起，提高代码的可读性。</li>
</ol>
<p>但也有一些情况可以在构造函数体内进行初始化，例如：</p>
<ol>
<li><strong>运行时条件决定的初始化</strong>：如果某些成员变量的初始化取决于运行时条件，可能需要在构造函数体内进行初始化。</li>
<li><strong>需要在构造函数体内执行额外逻辑</strong>：如果构造函数需要执行一些额外的逻辑操作，可以在构造函数体内进行初始化。</li>
</ol>
<h3 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h3><p><strong>优点</strong>:</p>
<ol>
<li>(涉及含有类成员时)<strong>效率高</strong>: 使用初始化列表可以直接对成员变量进行初始化，而不需要先调用默认构造函数再进行赋值操作，从而提高了代码的执行效率。基本类型时效率与在函数体中差不多</li>
<li><strong>确保成员变量的初始化</strong>: 使用初始化列表可以确保所有成员变量在对象构造时立即得到正确的初始化，避免了可能出现的未初始化的情况。</li>
<li><strong>处理const和引用类型成员变量</strong>: 对于const成员变量和引用类型成员变量，只能在初始化列表中进行初始化，因为它们不能在构造函数体内被赋值。</li>
<li><strong>清晰明了</strong>: 初始化列表将所有初始化操作集中在一起，使代码更加清晰易读，便于理解和维护</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li><strong>可读性差</strong>: 对于复杂的类结构和初始化逻辑，初始化列表可能会使代码变得复杂和难以理解，降低了可读性。</li>
<li><strong>限制较多</strong>: 有些情况下，无法在初始化列表中初始化所有的成员变量，例如需要在构造函数体内进行逻辑判断后再进行初始化的情况。</li>
<li><strong>容易遗忘</strong>: 在添加新成员变量时，容易忘记在初始化列表中添加相应的初始化操作，导致未初始化的错误。</li>
</ol>
<h2 id="使用using-重新定义访问权限"><a href="#使用using-重新定义访问权限" class="headerlink" title="使用using 重新定义访问权限"></a>使用using 重新定义访问权限</h2><p>使用<strong>保护派生或私有派生</strong>时，基类的公有成员将成为保护成员或私有成员。假设要让基类的方法在派生类外面可用，可以在派生类的public成员中使用using声明指出派生类可以使用特定的基类成员，就像using指定的成员或函数是派生类的公有方法一样，即使采用的是私有派生。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*一个简单的例子*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">people</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">people</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">people</span>(string name,<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>: <span class="keyword">private</span> people<span class="comment">//私有派生</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> schoolnum;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> people::showName;<span class="comment">//使用using定义重新定义访问权限</span></span><br><span class="line">    <span class="keyword">using</span> people::name;<span class="comment">//使用using定义重新定义访问权限</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">student</span>(string name,<span class="type">int</span> age,<span class="type">int</span> schoolNum):<span class="built_in">people</span>(name,age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;schoolnum = schoolNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">student <span class="title">s</span><span class="params">(<span class="string">&quot;keqiudi&quot;</span>,<span class="number">18</span>,<span class="number">2022124018</span>)</span></span>;</span><br><span class="line">    s.<span class="built_in">showName</span>();<span class="comment">//正确，使用了using可以在派生类外调用</span></span><br><span class="line">    cout &lt;&lt; s.name &lt;&lt; endl;<span class="comment">//正确，使用了using可以在派生类外调用</span></span><br><span class="line">    cout &lt;&lt; s.age &lt;&lt; endl;<span class="comment">//报错，未使用using，继承后为派生类private成员不可以直接访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>派生类都只有一个基类，称为单继承。除此之外，C++也支持多继承，即一个派生类可以有两个或多个基类。<br>多继承的语法也很简单，将多个基类用逗号隔开。</p>
<p>如已声明了类A、类B和类C，那么可以这样来声明派生类D：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> A, <span class="keyword">private</span> B, <span class="keyword">protected</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//类D新增加的成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><p>与单继承形式基本相同，只是在派生类的构造函数中调用多个基类的构造函数。<br>以上面的 A、B、C、D 类为例，D 类构造函数的写法为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">D</span>(形参列表): <span class="built_in">A</span>(实参列表), <span class="built_in">B</span>(实参列表), <span class="built_in">C</span>(实参列表)<span class="comment">//使用初始化列表写法调用基类构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="二义性"><a href="#二义性" class="headerlink" title="二义性"></a>二义性</h3><p>当两个或多个基类有同名成员时，如果直接访问该成员，就会产生命名冲突，编译器不知道使用哪个基类的成员。这个时候需要在<strong>名字前面加上类名和域解析符::</strong>，以显示地指明到底使用哪个类的成员，消除二义性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BaseA</span>()=<span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">BaseA</span>()=<span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BaseA</span>(<span class="type">int</span> value):_value(value)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;BaseA::_value: &quot;</span> &lt;&lt; _value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> _value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseB</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BaseB</span>()=<span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">BaseB</span>()=<span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BaseB</span>(<span class="type">int</span> value):_value(value)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;BaseB::_value: &quot;</span> &lt;&lt; _value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> _value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> BaseA, <span class="keyword">public</span> BaseB</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>()=<span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Derived</span>()=<span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> valueA, <span class="type">int</span> valueB):<span class="built_in">BaseA</span>(valueA), <span class="built_in">BaseB</span>(valueB)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;BaseA::_value: &quot;</span> &lt;&lt; BaseA::_value &lt;&lt; endl;<span class="comment">//使用::指明基类BaseA的value</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;BaseB::_value: &quot;</span> &lt;&lt; BaseB::_value &lt;&lt; endl;<span class="comment">//使用::指明基类BaseB的value</span></span><br><span class="line">        BaseA::<span class="built_in">showValue</span>();<span class="comment">//使用::指明调用基类BaseA的方法</span></span><br><span class="line">        BaseB::<span class="built_in">showValue</span>();<span class="comment">//使用::指明调用基类BaseB的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">d</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    d.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p>在C++中，<strong>模板类</strong>是一种用于创建通用数据结构或算法的强大工具。模板类允许您编写一次代码，然后在不同数据类型上重复使用它，例如有两个或多个类，其功能是相同的，仅仅是数据类型不同时使用，<strong>以提高代码的可重用性和灵活性</strong>。</p>
<p>模板类允许您定义一种通用的类模板，其中某些成员或函数可以根据不同进行参数化。它们使用template关键字定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,....&gt;</span><br><span class="line"><span class="keyword">class</span> 类模板名</span><br><span class="line">&#123;</span><br><span class="line">类的定义;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>typename</code>表明其后面的符号是一种数据类型，可以用<code>class</code>代替</li>
<li><code>T</code>是通用的数据类型，名称可以替换，通常为大写字母</li>
<li>函数模板建议用 <code>typename</code> 描述通用数据类型，类模板建议用 <code>class</code></li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">nameType</span>,<span class="keyword">class</span> <span class="title class_">ageType</span>&gt;<span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    nameType name;</span><br><span class="line">    ageType age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(nameType name,ageType age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person&lt;string,<span class="type">int</span>&gt; <span class="title">student</span><span class="params">(<span class="string">&quot;Tom&quot;</span>,<span class="number">18</span>)</span></span>;</span><br><span class="line">    student.<span class="built_in">showPerson</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>函数模板不是一个实在的函数，编译器不能为其生成可执行代码。定义函数模板后只是一个对函数功能框架的描述，当它具体执行时，将根据传递的实际参数决定其功能，提高了程序的可重用性。</p>
<p>C++ 语言支持模板。有了模板，例如可以只写一个 Swap 模板，编译器会根据 Swap 模板自动生成多个 Sawp 函数，用以交换不同类型变量的值。</p>
<p><strong>写法</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> 类型参数<span class="number">1</span>,<span class="keyword">typename</span> 类型参数<span class="number">2</span>, ...&gt;</span><br><span class="line">返回值类型  模板名(形参表)</span><br><span class="line">&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*typename可以使用class替换*/</span></span><br></pre></td></tr></table></figure>

<p><strong>一个简单的示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T &amp; x, T &amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T tmp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">1</span>, m = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">Swap</span>(n, m);  <span class="comment">//编译器自动生成 void Swap (int &amp;, int &amp;)函数</span></span><br><span class="line">    <span class="type">double</span> f = <span class="number">1.2</span>, g = <span class="number">2.3</span>;</span><br><span class="line">    <span class="built_in">Swap</span>(f, g);  <span class="comment">//编译器自动生成 void Swap (double &amp;, double &amp;)函数</span></span><br><span class="line">    string s1 = <span class="string">&quot;hello&quot;</span>, s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="built_in">Swap</span>(s1, s2);  <span class="comment">//编译器自动生成 void Swap (string &amp;, string &amp;)函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="类模板与函数模板区别"><a href="#类模板与函数模板区别" class="headerlink" title="类模板与函数模板区别"></a>类模板与函数模板区别</h2><ol>
<li><strong>应用对象</strong>：<ul>
<li><strong>函数模板</strong>主要用于生成通用函数，可以用于不同类型的参数。它通过在函数定义中使用模板来实现，允许编写一次通用的函数代码，用于多种数据类型。</li>
<li><strong>类模板</strong>主要用于生成通用类，可以包含不同类型的成员变量或成员函数。它通过在类定义中使用模板来实现，允许创建一种通用的类形式，适用于多种数据类型。</li>
</ul>
</li>
<li><strong>自动类型推导的使用方式</strong>：<ul>
<li><strong>函数模板</strong>在调用时支持自动类型推导，允许省略模板参数，由编译器根据实参类型自动推导出模板参数的类型。</li>
<li><strong>类模板</strong>在实例化时需要显式指定模板参数，没有像函数模板那样的自动类型推导。每次实例化都需要<strong>明确指定模板参数</strong>。</li>
</ul>
</li>
<li><strong>默认参数</strong>：<ul>
<li><strong>函数模板</strong>和<strong>类模板</strong>都支持默认参数。在模板参数列表中可以为某些模板参数设置默认值，使得在使用时可以不必每次都指定这些参数。</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类模板与函数模板的区别</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt; <span class="comment">//指定默认参数</span></span><br><span class="line"><span class="keyword">class</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	NameType m_Name;</span><br><span class="line">	AgeType m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Person p(&quot;孙悟空&quot;, 1000);错误的，类模板无法用自动类型推导</span></span><br><span class="line">	Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;keqiudi&quot;</span>, <span class="number">19</span>);<span class="comment">//正确，只能用显式指定类型推导</span></span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person&lt;string&gt;<span class="built_in">p</span>(<span class="string">&quot;keqiudi&quot;</span>, <span class="number">19</span>); <span class="comment">//类模板在参数列表中有默认参数</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="类模板成员函数实现"><a href="#类模板成员函数实现" class="headerlink" title="类模板成员函数实现"></a>类模板成员函数实现</h2><p>在类<strong>内部定义成员函数</strong>可以更简洁，因为不需<strong>要再次指定模板参数</strong>。类内部的成员函数定义可以直接使用类模板的模板参数，而在<strong>外部定义时需要重新指定一次</strong>。</p>
<p>总体来说，选择在类内部还是类外部定义成员函数取决于项目的需求和组织代码的风格。一般而言，对于简单、短小的成员函数，可以选择在类内部定义；而对于复杂或长的成员函数，以及避免头文件的多次包含导致的重定义错误，通常建议在类外部定义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类模板成员类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line">	<span class="comment">/*内部定义&#123;</span></span><br><span class="line"><span class="comment">		this-&gt;m_Name = name;</span></span><br><span class="line"><span class="comment">		this-&gt;m_Age = age;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">/*内部定义&#123;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line"></span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*构造函数的类外实现，每个函数都要重新指定模板参数*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;<span class="comment">//要点1：每个函数前加上template&lt;&gt;</span></span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age)<span class="comment">//要点2:类名指出模板参数再进行解析(::)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*成员函数的类外实现，每个函数都要重新指定模板参数*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">30</span>);</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h2><p>模板可用作结构、类或模板类的成员。要完全实现STL(标准模板库)，必须使用这个特性</p>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">beta</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">V</span>&gt;<span class="comment">//模板成员</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">hold</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">         	V val;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">         	<span class="built_in">hold</span>(V v=<span class="number">0</span>):<span class="built_in">val</span>(v)&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span>&#123;cout &lt;&lt; val &lt;&lt; endl;&#125;</span><br><span class="line">        </span><br><span class="line">        	<span class="function">V <span class="title">Value</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> val;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    hold&lt;T&gt; q; <span class="comment">//模板类中的模板对象,传入的模板参数为T，即外部模板类想通过的模板参数</span></span><br><span class="line">    hold&lt;<span class="type">int</span>&gt; n;<span class="comment">//模板对象</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">beta</span>(T t,<span class="type">int</span> i):<span class="built_in">q</span>(t),<span class="built_in">n</span>(i)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;<span class="comment">//模板函数做成员</span></span><br><span class="line">    <span class="function">U <span class="title">blab</span><span class="params">(U u,T t)</span></span>&#123;<span class="keyword">return</span> (n.<span class="built_in">Value</span>()+q.<span class="built_in">Value</span>()*u/t);&#125; </span><br><span class="line">                    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> <span class="type">const</span></span>&#123; q.<span class="built_in">show</span>(); n.<span class="built_in">show</span>();&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">beta&lt;<span class="type">double</span>&gt; <span class="title">guy</span><span class="params">(<span class="number">3.5</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T被设置为double\n&quot;</span>;</span><br><span class="line">    guy.<span class="built_in">Show</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;V被设置为T,即double，第二个V被设置为int\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; guy.<span class="built_in">blab</span>(<span class="number">10</span>,<span class="number">2.3</span>) &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;U被设置为int\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; guy.<span class="built_in">blab</span>(<span class="number">10.0</span>,<span class="number">2.3</span>) &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;U被设置为double\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Done\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="类模板对象做函数参数"><a href="#类模板对象做函数参数" class="headerlink" title="类模板对象做函数参数"></a>类模板对象做函数参数</h2><p>一共有三种传入方式：</p>
<ol>
<li>指定传入的类型：直接显示对象的数据类型，此时模板对象必须含有模板类的参数</li>
<li>参数模板化：将对象中的参数变为模板进行传递</li>
<li>整个类模板化：将这个对象类型模板化进行传递</li>
</ol>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类模板对象做函数参数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(T1 name,T2 age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; age:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、指定传入类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson1</span><span class="params">(Person&lt;string, <span class="type">int</span>&gt;&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">199</span>);</span><br><span class="line">	<span class="built_in">printPerson1</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="comment">// 2、参数模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1,<span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1,T2&gt;&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T1的类型为:&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T2的类型为:&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">90</span>);</span><br><span class="line">	<span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、整个类模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson3</span><span class="params">(T &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T的类型为:&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;唐僧&quot;</span>, <span class="number">60</span>);</span><br><span class="line">	<span class="built_in">printPerson3</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="将模板做模板类参数"><a href="#将模板做模板类参数" class="headerlink" title="将模板做模板类参数"></a>将模板做模板类参数</h2><p>模板可以包含类型参数(如typename T)和非类型参数(如 int n)。模板还可以本身就是模板的参数，这种参数是模板类新增的特性，用于实现STL。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">Thing</span>&gt;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *模板参数是template &lt;typename T&gt; class Thing，其中template &lt;typename T&gt; class 是类型，Thing是参数。</span></span><br><span class="line"><span class="comment"> 假设有Crab&lt;King&gt; legs;</span></span><br><span class="line"><span class="comment"> 那么King必须是一个模板类，其声明与模板参数Thing的声明匹配；</span></span><br><span class="line"><span class="comment"> 即：</span></span><br><span class="line"><span class="comment"> template&lt;class T&gt;</span></span><br><span class="line"><span class="comment"> class King&#123;...&#125;</span></span><br><span class="line"><span class="comment"> */</span>    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Crab</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Thing&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">    Thing&lt;<span class="type">double</span>&gt; s2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ....</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设有如下声明</span></span><br><span class="line">Crab&lt;Stack&gt;stack;</span><br><span class="line"><span class="comment">//成员函数Thing&lt;int&gt;就被替换为Stack&lt;int&gt;,Thing&lt;double&gt;替换为Stack&lt;int&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *总之模板参数Thing将被替换为声明Crab对象时被用作模板参数的模板类型</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>





<h2 id="类模板与继承"><a href="#类模板与继承" class="headerlink" title="类模板与继承"></a>类模板与继承</h2><p>当类模板碰到继承时，需要注意以下几点：</p>
<ul>
<li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中<code>T</code>的类型</li>
<li>如果不指定，编译器无法给子类分配内存</li>
<li>如果想灵活指定出父类中<code>T</code>的类型，子类也需为类模板</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类模板与继承</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">	T m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class Son: public Base //错误，必须要知道父类中的T类型，才能继承给子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base&lt;<span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son s1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果想灵活指定父类中T的类型，子类也需要变成类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> : <span class="keyword">public</span> Base&lt;T2&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son2</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;T1的类型为:&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;T2的类型为:&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	T1 obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son2&lt;<span class="type">int</span>,<span class="type">char</span>&gt; s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="模板类和友元"><a href="#模板类和友元" class="headerlink" title="模板类和友元"></a>模板类和友元</h2><p>模板类声明也可以有友元。模板的友元分为3类：</p>
<ol>
<li><p>非模板友元</p>
</li>
<li><p>约束(bound)模板友元，即友元的类型取决于类被实例化时的类型；</p>
</li>
<li><p>非约束(unbound)模板友元，即友元的所有具体化都是类的每一个具体化的友元</p>
</li>
</ol>
<ul>
<li><p>非模板友元</p>
<p>在模板类中将一个常规函数声明为友元</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HasFriend</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">counts</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">report</span><span class="params">(HasFriend&lt;<span class="type">int</span>&gt;&amp; hf)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">report</span><span class="params">(HasFriend&lt;<span class="type">double</span>&gt;&amp; hf)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *上述声明使counts()函数成为模板所有实例化的友元,例如是HasFriend&lt;int&gt;和HasFriend&lt;string&gt;的友元</span></span><br><span class="line"><span class="comment"> *report()函数也是，只不过接受一个模板类参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">counts</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">report</span><span class="params">(HasFriend&lt;<span class="type">int</span>&gt;&amp; hf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">report</span><span class="params">(HasFriend&lt;<span class="type">double</span>&gt;&amp; hf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>约束模板友元</li>
</ul>
<p>​		修改前一个示例，使友元函数本身成为模板，即使类的每一个具体化都获得与友元匹配的具体化，一共包含3步。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*第一步，在类定义前面声明每个模板函数*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">counts</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">report</span><span class="params">(T&amp; t)</span>；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/*第二步，在类中将模板声明为友元，这些语句根据类模板参数的类型声明具体化*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span> &lt;<span class="keyword">class</span> TT&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">class</span> HasFriendT</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">friend</span> <span class="type">void</span> <span class="built_in">counts</span>&lt;TT&gt;();</span><br><span class="line">    	<span class="keyword">friend</span> <span class="type">void</span> report&lt;&gt;(HasFriendT&lt;TT&gt; &amp; tt);</span><br><span class="line">        <span class="comment">//或使用friend void report&lt;HasFriendT&lt;TT&gt;&gt;(HasFriendT&lt;TT&gt; &amp; tt);</span></span><br><span class="line">    	<span class="comment">//声明中的&lt;&gt;指出这是模板具体化，&lt;&gt;可以为空，因为可以从函数参数推断出模板类型参数</span></span><br><span class="line">    	<span class="comment">//但counts()没有参数，因此必须使用模板参数语法(&lt;TT&gt;)来指明其具体化,TT为HasFriendT类的类模板参数类型</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*第三步，为友元函数提供定义*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">counts</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">report</span><span class="params">(T &amp; hf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>非约束模板友元</li>
</ul>
<p>每个函数<strong>具体化</strong>都是每个类<strong>具体化</strong>的友元，<strong>友元模板类型参数与模板类类型参数不同</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ManyFriend</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T item</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">ManyFriend</span>(<span class="type">const</span> T&amp; i):<span class="built_in">item</span>(i)&#123;&#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> C,<span class="keyword">typename</span> D&gt;</span><br><span class="line">      <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">show2</span><span class="params">(C&amp; c,D&amp; d)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C,<span class="keyword">typename</span> D&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show2</span><span class="params">(C&amp; c,D&amp; d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; c.item &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; d.item &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="类模板成员函数创建时机"><a href="#类模板成员函数创建时机" class="headerlink" title="类模板成员函数创建时机"></a>类模板成员函数创建时机</h2><p>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p>
<ul>
<li>对于类模板的成员函数在使用时进行实例化。当你使用特定类型实例化类模板对象时，编译器会生成该类型的成员函数实现。</li>
<li>对于普通类，所有的成员函数都在编译时就被实例化了。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*故可以做到以下的操作*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板中成员函数的创建时机</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person1 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person2 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T obj;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//类模板中的成员函数在调用的时候才创建，所以不会报错</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		obj.<span class="built_in">showPerson1</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		obj.<span class="built_in">showPerson2</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Myclass&lt;Person1&gt;m;</span><br><span class="line">	m.<span class="built_in">func1</span>();</span><br><span class="line">	<span class="comment">//m.func2(); 此时模板参数传递为Person1故无法调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="类模板分文件编写-重要"><a href="#类模板分文件编写-重要" class="headerlink" title="类模板分文件编写(重要)"></a>类模板分文件编写(重要)</h2><p>如果工程中需要利用多个类模板，那么将这些类模板都写在同一个文件中将会导致代码可读性变差，所以有必要对类模板进行分文件编写，但是类模板的分文件编写面临着一些问题，以下是类模板分文件编写面临的问题及解决方法。</p>
<p><strong>问题</strong>：模板的特性导致了编译器对模板的实例化是在链接阶段进行的，而编译器需要在链接时找到模板的定义，当模板类的定义放在.h文件模板类实现放在.cpp文件，会出现链接失败情况，找不到定义。</p>
<p><strong>解决方法</strong>：</p>
<ul>
<li>直接包含<code>.cpp</code>源文件（不常用因为.cpp风格不好一般用.hpp文件）</li>
<li>将声明和实现写到同一个文件中，并更改后缀名为<code>.hpp</code></li>
</ul>
<div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>.hpp</code> 文件通常用来包含 C++ 的头文件，其中包含类声明、函数原型、模板定义等。这种文件扩展名的选择<strong>是一种约定</strong>，用于表示这个头文件中包含一些声明与实现在一起，比如模板类</p>
<p>一般来说，<code>.hpp</code> 文件和 <code>.h</code> 文件在功能上是相似的，都用于包含头文件，但 <code>.hpp</code> 文件更常见于 C++ 项目中，尤其是涉及到类和模板的情况。</p>
</div>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*编写的templatePerson.hpp文件，模板类的定义和实现放在一个文件中*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数的类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数的类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.cpp文件内容*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;templatePerson.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    p<span class="number">1.</span><span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="模板别名-C-11"><a href="#模板别名-C-11" class="headerlink" title="模板别名(C++11)"></a>模板别名(C++11)</h2><p>如果能为类型指定别名，将很方便，在模板设计中尤其如此，可以使用typedef为模板具体化指定别名：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::array&lt;<span class="type">double</span>,12&gt;arrd;</span><br><span class="line"><span class="keyword">typedef</span> std::array&lt;<span class="type">int</span>,12&gt;arri;</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>



<p>C++11新增了一项功能——使用(using)为模板提供一系列别名，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> arrtype = std::array&lt;T,<span class="number">12</span>&gt;;</span><br><span class="line"><span class="comment">//使用using将arrtype定义为一个模板别名，arrtype&lt;T&gt;表示类型std::array&lt;T,12&gt;。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arrtype&lt;<span class="type">double</span>&gt; gallons;<span class="comment">//等价于 std::array&lt;double,12&gt;</span></span><br><span class="line">arrtype&lt;<span class="type">int</span>&gt; days;<span class="comment">//与上面相同</span></span><br><span class="line">arrtype&lt;std::string&gt; months</span><br></pre></td></tr></table></figure>



<p>C++11 允许将语法using &#x3D; 用于非模板。用于非模板时语法与常规typedef等价：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">char</span>* pc1;</span><br><span class="line"><span class="keyword">using</span> pc2 = <span class="type">const</span> <span class="type">char</span>*;<span class="comment">//与上方等价</span></span><br></pre></td></tr></table></figure>



<p><strong>好处</strong>：</p>
<ul>
<li>使用模板别名可以提高代码的可读性，特别是在涉及复杂模板或需要引入特定模板类型时。</li>
<li>模板别名还可以使代码更易于维护，因为你只需要在一个地方修改模板类型或表达式，而无需修改多处使用的地方。</li>
</ul>
<h1 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h1><p>在C++中，友元类和友元函数是用来在类之间建立友好关系的机制，允许一个类的成员访问另一个类的私有成员。这样可以增加程序的灵活性和封装性。</p>
<p>虽然友元提供了灵活性，但过度使用友元可能会破坏封装性，因此应该谨慎使用。友元应该只在确实需要访问私有成员的情况下使用，以保持代码的清晰性和可维护性。</p>
<h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><ul>
<li><strong>作用</strong>： <strong>允许一个非成员函数访问类的私有成员。</strong></li>
<li><strong>用法</strong>： 可以在类的声明中使用<code>friend</code>关键字声明友元函数，然后在类外定义这个函数。</li>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> myData;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Myclass</span><span class="params">(<span class="type">int</span> data)</span>:myData(data)&#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">Myclass</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Myclass</span>()=<span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">showMyData</span><span class="params">(<span class="type">const</span> Myclass&amp; myclass)</span></span>;<span class="comment">//友元函数声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//友元函数类外定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showMyData</span><span class="params">(<span class="type">const</span> Myclass&amp; myclass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myData = &quot;</span> &lt;&lt; myclass.myData &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//友元函数可以访问私有数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Myclass <span class="title">myclass</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">showMyData</span>(myclass);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h2><ul>
<li><strong>作用</strong>： <strong>允许一个类的所有成员函数访问另一个类的私有成员</strong>。</li>
<li><strong>用法</strong>：在类的声明中使用<code>friend</code>关键字声明<strong>友元类</strong>。</li>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FriendClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> friendData;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">FriendClass</span><span class="params">(<span class="type">int</span> data)</span>:friendData(data)&#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">FriendClass</span>()=<span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Myclass</span>;<span class="comment">//指定Myclass为友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> myData;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Myclass</span><span class="params">(<span class="type">int</span> data)</span>:myData(data)&#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">Myclass</span>()=<span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showFriendData</span><span class="params">(<span class="type">const</span> FriendClass&amp; friendclass)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;FriendClass data is: &quot;</span> &lt;&lt; friendclass.friendData &lt;&lt; endl;<span class="comment">//友元类的成员函数直接访问另一个类的私有成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">FriendClass <span class="title">friendclass</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">   <span class="function">Myclass <span class="title">myclass</span><span class="params">(<span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">   myclass.<span class="built_in">showFriendData</span>(friendclass);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="友元成员函数"><a href="#友元成员函数" class="headerlink" title="友元成员函数"></a>友元成员函数</h2><ul>
<li><strong>作用</strong>： <strong>允许一个类的某一个成员函数访问另一个类的私有成员</strong>。</li>
<li><strong>用法</strong>：在类的声明中使用<code>friend</code>关键字声明<strong>友元</strong>。</li>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前向声明FriendClass，以便在Myclass中声明友元关系</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FriendClass</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> myData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Myclass</span><span class="params">(<span class="type">int</span> data)</span> : myData(data) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">Myclass</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明Myclass的成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showFriendData</span><span class="params">(<span class="type">const</span> FriendClass&amp; friendclass)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FriendClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> friendData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">FriendClass</span><span class="params">(<span class="type">int</span> data)</span> : friendData(data) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">FriendClass</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 友元函数的声明，在FriendClass中声明，使Myclass的showFriendData作为FriendClass类的友元</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Myclass::showFriendData</span><span class="params">(<span class="type">const</span> FriendClass&amp; friendclass)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Myclass的成员函数因为是FriendClass的友元，所以定义必须在类外，用于访问FriendClass的私有成员，</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Myclass::showFriendData</span><span class="params">(<span class="type">const</span> FriendClass&amp; friendclass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;FriendClass data is: &quot;</span> &lt;&lt; friendclass.friendData &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Myclass data is: &quot;</span> &lt;&lt; myData &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">FriendClass <span class="title">friendclass</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">Myclass <span class="title">myclass</span><span class="params">(<span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    myclass.<span class="built_in">showFriendData</span>(friendclass);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="友元的优缺点"><a href="#友元的优缺点" class="headerlink" title="友元的优缺点"></a>友元的优缺点</h2><p><strong>优点：</strong></p>
<ol>
<li><strong>灵活性：</strong> 友元机制允许在类之间建立友好关系，使得某个函数或类可以访问其他类的私有成员，提高了灵活性。</li>
<li><strong>特定需求的访问权限：</strong> 有时候，为了实现特定的功能，需要某些函数或类能够直接访问其他类的私有成员，友元机制提供了一种选择。</li>
<li><strong>效率：</strong> 有时候使用友元可以避免通过公有接口的方式(比如get方法等等)进行多次函数调用，提高代码执行效率。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li><strong>破坏封装性：</strong> 友元可以直接访问类的私有成员，这可能破坏类的封装性，增加了代码的耦合性，增加了维护的难度。</li>
<li><strong>复杂性增加：</strong> 过度使用友元可能导致代码更加复杂，使得程序难以理解和维护。</li>
<li><strong>设计问题：</strong> 有时候需要重新考虑设计，以避免对友元的过度依赖。可能存在更好的设计模式或方法，不需要使用友元。</li>
</ol>
<h1 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>在C++中，嵌套类是一个类被定义在另一个类的内部的情况。被嵌套的类称为内部类或嵌套类，而包含这个内部类的类称为外部类。嵌套类可以具有私有、受保护或公有的访问权限，这取决于它在外部类中的声明方式。包含类的成员函数可以创建和使用被嵌套类的对象；而仅当声明位于公有部分时，才能在包含类的外面使用嵌套类，而且必须使用作用域解析运算符(旧版本的C++不允许嵌套类或无法完全实现这种概念)</p>
<p><strong>一个示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 内部类 Point 表示二维平面上的点</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Point</span>(<span class="type">int</span> xCoord, <span class="type">int</span> yCoord) : <span class="built_in">x</span>(xCoord), <span class="built_in">y</span>(yCoord) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内部类的成员函数</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Point: (&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Point center; <span class="comment">// Shape 类包含 Point 类的对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Shape 类的构造函数</span></span><br><span class="line">    <span class="built_in">Shape</span>(<span class="type">int</span> centerX, <span class="type">int</span> centerY) : <span class="built_in">center</span>(centerX, centerY) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shape 类的成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayShape</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Shape with center at &quot;</span>;</span><br><span class="line">        center.<span class="built_in">display</span>(); <span class="comment">// 调用内部类的成员函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 Shape 类对象</span></span><br><span class="line">    <span class="function">Shape <span class="title">myShape</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 Shape 类的成员函数</span></span><br><span class="line">    myShape.<span class="built_in">displayShape</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>嵌套类的主要作用之一是组织和封装代码，使代码更为模块化、清晰和可读。以下是嵌套类的一些主要作用：</p>
<ol>
<li><strong>封装实现细节：</strong> 嵌套类允许将一个类的一部分实现细节封装在另一个类中，从而隐藏一些具体的实现细节，提高封装性。外部类可以更专注于公共接口，而具体的实现则留给内部类。</li>
<li><strong>组织相关的类：</strong> 当两个类有密切关联时，将它们组织在一起可以形成更清晰的结构。嵌套类可以在逻辑上将这些关联的类放在同一个地方，方便代码的组织和维护。</li>
<li><strong>限制访问权限：</strong> 内部类可以访问外部类的私有成员，但外部类不能直接访问内部类的私有成员。这种特性可以用于在设计中划分不同层次的访问权限，使得代码更安全。</li>
<li><strong>实现接口与实现分离：</strong> 将接口和实现分离，可以通过内部类隐藏一些实现细节。外部类可以专注于公共接口，而具体的实现细节则留给内部类。</li>
<li><strong>增加代码的模块化：</strong> 将相关的类组织在一起可以使代码更模块化。每个嵌套类可以有自己的职责，这样代码更易于理解和维护。</li>
</ol>
<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><ol>
<li><p><strong>公有嵌套类</strong>： 如果内部类声明为<code>public</code>，则外部类的任何成员函数、友元或其他类都可以访问内部类。这使得内部类对外可见，允许外部代码直接访问它。</p>
</li>
<li><p><strong>私有嵌套类</strong>：如果内部类声明为<code>private</code>，则只有外部类的成员函数和友元可以访问内部类。外部类的客户端无法直接访问或创建内部类的对象。</p>
</li>
<li><p><strong>保护嵌套类</strong>： 如果内部类声明为<code>protected</code>，则外部类的成员函数、友元以及继承了外部类的派生类都可以访问内部类</p>
</li>
</ol>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="异常概念"><a href="#异常概念" class="headerlink" title="异常概念"></a>异常概念</h2><p>C语言异常处理机制是：</p>
<ol>
<li>终止程序。缺陷：用户难以接受。如发生内存错误，除0错误时就会终止</li>
<li>返回错误码。缺陷：需要程序员自己去查对应的错误</li>
</ol>
<p>在C++中，异常是一种在程序执行过程中发生的错误或者意外状况。异常提供了一种机制，允许程序员在代码中识别和处理错误，以及在出现错误时进行适当的响应。异常处理是C++中一个重要的编程概念，它使得程序更健壮，更容易维护。</p>
<p>C++中异常处理有三个关键字：<strong>throw、catch、try</strong></p>
<ul>
<li>throw：当问题出现，程序抛出一个异常。抛异常使用throw关键字完成。</li>
<li>catch：用于捕捉异常。**catch(…)**可以捕获任意类型的异常，主要时用来捕获没有显示捕获类型的异常。相当于条件判断中的else。</li>
<li>try：try中包含会出现异常的代码或者函数。后面通常会跟一个或者多个catch块。</li>
</ul>
<p><strong>注意：可以抛出任意类型的对象。抛出的异常必须捕获。try要和catch匹配使用，catch里的内容抛出异常时才执行，没有异常，不执行。</strong></p>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入被除数和除数:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;除0错误&quot;</span>;<span class="comment">//抛出异常,这里抛出的是字符串类型异常，也可以是对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">test</span>() &lt;&lt; endl;<span class="comment">//会出现异常的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//捕获字符串类型的异常，a即 &quot;除0错误&quot;。</span></span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* a)&#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    	<span class="comment">//捕获任意类型的异常，通常未知异常</span></span><br><span class="line">    <span class="built_in">catch</span> (...)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;unknow exception&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="异常的抛出和匹配规则"><a href="#异常的抛出和匹配规则" class="headerlink" title="异常的抛出和匹配规则"></a>异常的抛出和匹配规则</h2><h3 id="异常的抛出"><a href="#异常的抛出" class="headerlink" title="异常的抛出"></a>异常的抛出</h3><ol>
<li><p>异常时通过抛出对象而引发的，该对象的类型决定了应该激活哪个catch的处理代码。</p>
</li>
<li><p>被选中的处理代码的调用链是，找到于该类型匹配且离抛出异常位置最近的那一个catch。</p>
</li>
<li><p>抛出异常对象后，会生成一个异常对象的拷贝，因为抛出的异常对象可能是一个临时对象，所以会生成一个拷贝对象。</p>
</li>
<li><p>catch(…)可以捕获任意类型的对象，主要是用来捕获没有显示捕获类型的异常，因为如果没有匹配的catch会终止程序。相当于条件判断中的else。问题是不知道异常错误是什么。</p>
</li>
<li><p>实际中抛出和捕获的类型不一定类型完全匹配，可以抛出派生类对象，使用基类来捕获，这个在实际生活中很实用。主要原因是：派生类可以赋值给基类。</p>
</li>
</ol>
<h3 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h3><ul>
<li>首先检查throw本身是否在try块内部，如果是，再在当前函数栈中查找匹配的catch语句。如果有匹配的直接跳到catch的地方执行。</li>
<li>如果没有匹配的catch块，则退出当前函数栈，在调用函数的栈中查找匹配的catch。</li>
<li>如果到达main函数的栈，都没有匹配的catch，就会终止程序。</li>
<li>上述沿着调用链查找匹配的catch块的过程叫栈展开。所以实际要最后要加一个catch(…)来捕获任意类型的异常，防止程序终止。</li>
<li>找到匹配的catch会直接跳到catch语句执行，执行完后，会继续沿着catch语句后面执行。</li>
</ul>
<h2 id="异常的重新抛出"><a href="#异常的重新抛出" class="headerlink" title="异常的重新抛出"></a>异常的重新抛出</h2><p> 有可能单个的catch不能完全处理一个异常，**在进行一些矫正处理后，需要交给更外层的调用链函数来处理。**catch可以做完矫正操作，再将异常重新抛出，交给更上层的函数进行处理。</p>
<h2 id="异常安全问题"><a href="#异常安全问题" class="headerlink" title="异常安全问题"></a>异常安全问题</h2><p> 由于抛异常只要找到匹配的catch就直接跳到catch块执行，没有找到对应catch的函数就不会继续执行。这样导致函数的执行流回很乱。可能会导致一些问题。</p>
<ul>
<li><p>构造函数完成对象的构造和初始化，最好不要再构造函数中抛出异常，否则可能导致对象不完整或者没有完全初始化</p>
</li>
<li><p>析构函数主要完成资源的清理，最好不要在析构函数中抛异常，否则可能导致内存泄漏。</p>
</li>
<li><p>C++异常经常会导致资源泄漏问题。比如：在new和delete中抛出异常，导致new出来的资源没有释放，导致内存泄漏。在lock和unlock中抛出异常，导致锁没有释放，导致死锁。</p>
</li>
</ul>
<p>有两种解决办法：</p>
<ul>
<li>将异常捕获，释放资源后，将锁重新抛出。</li>
<li>使用RAII的思想解决。定义一个类封装，管理资源。当要使用时实例化一个类对象，将资源传入，当退出函数，调用对象析构函数，释放资源。</li>
</ul>
<h2 id="异常规范说明"><a href="#异常规范说明" class="headerlink" title="异常规范说明"></a>异常规范说明</h2><ul>
<li><strong>noexcept</strong>：表示函数不抛出异常。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>noexcept(expression)</strong>： 表示如果 <code>expression</code> 求值结果为 <code>true</code>，则函数不抛出异常。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(someExpression())</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>早期的异常规范：</strong> 在早期的C++标准中，可以使用 <code>throw()</code> 表示函数不抛出异常，或者使用 <code>throw(type1, type2, ...)</code> 来指定函数可能抛出的异常类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>; <span class="comment">// 函数不抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">anotherFunction</span><span class="params">()</span> <span class="title">throw</span><span class="params">(std::exception, MyException)</span></span>; <span class="comment">// 函数可能抛出 std::exception 或 MyException</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>现代C++中的 noexcept</strong>： 推荐使用 <code>noexcept</code> 关键字来表示函数是否抛出异常。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> <span class="keyword">noexcept</span></span>; <span class="comment">// 函数不抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">anotherFunction</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(someExpression())</span></span>; <span class="comment">// 函数在 someExpression() 为 true 时不抛出异常</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>异常规范的问题：</strong> 早期的异常规范在实践中并没有提供太多的好处，而且容易导致问题。因此，自C++11开始，异常规范已经被弃用，而 <code>noexcept</code> 关键字更灵活且更安全。</p>
<h2 id="自定义异常体系"><a href="#自定义异常体系" class="headerlink" title="自定义异常体系"></a>自定义异常体系</h2><p> 在实际中，并不是我们想抛什么异常就抛什么异常，这样会导致捕捉的时候不好捕捉。而是，会建立一个继承体系，<strong>建立一个异常类，派生类继承这个类，来定义出不同的异常。</strong></p>
<ul>
<li>到时候抛出异常**，只需要用基类进行捕捉即可**</li>
<li>基类可以相当于是一个框架，派生类是具体的异常。然后去具体实现异常的内容，然后<strong>抛异常只需要抛派生类，捕捉异常只需要捕捉基类即可。</strong> ‘</li>
</ul>
<p>下列使用一个简单实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="comment">//异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Exception</span>(<span class="type">const</span> <span class="type">char</span>* str = <span class="literal">nullptr</span>, <span class="type">int</span> id = <span class="number">0</span>):_errmsg(str), _id(id)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">what</span><span class="params">()</span><span class="type">const</span> </span>= <span class="number">0</span>;<span class="comment">//派生类中输出的指定异常信息</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string _errmsg;<span class="comment">//错误信息</span></span><br><span class="line">    <span class="type">int</span> _id;<span class="comment">//错误码</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="comment">//数据库异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlException</span> :<span class="keyword">public</span> Exception&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SqlException</span>(<span class="type">const</span> <span class="type">char</span> *str = <span class="literal">nullptr</span>, <span class="type">int</span> id = <span class="number">1</span>)</span><br><span class="line">            :<span class="built_in">Exception</span>(str, id)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">what</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error msg:&quot;</span> &lt;&lt; _errmsg &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error id:&quot;</span> &lt;&lt; _id &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//网络异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpException</span> :<span class="keyword">public</span> Exception&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HttpException</span>(<span class="type">const</span> <span class="type">char</span> *str = <span class="literal">nullptr</span>, <span class="type">int</span> id = <span class="number">2</span>)</span><br><span class="line">            :<span class="built_in">Exception</span>(str, id)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">what</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error msg:&quot;</span> &lt;&lt; _errmsg &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error id:&quot;</span> &lt;&lt; _id &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//缓存异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CacheException</span> :<span class="keyword">public</span> Exception&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CacheException</span>(<span class="type">const</span> <span class="type">char</span> *str = <span class="literal">nullptr</span>, <span class="type">int</span> id = <span class="number">3</span>)</span><br><span class="line">            :<span class="built_in">Exception</span>(str, id)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">what</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error msg:&quot;</span> &lt;&lt; _errmsg &lt;&lt; endl;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;error id:&quot;</span> &lt;&lt; _id &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//当网络连接失败，抛出这个异常即可</span></span><br><span class="line">    <span class="comment">//throw HttpException(&quot;Http fail&quot;, 2);</span></span><br><span class="line">    <span class="comment">//当缓存错误,抛出这个异常</span></span><br><span class="line">    <span class="comment">//throw CacheException(&quot;Cache error&quot;, 3);</span></span><br><span class="line">    <span class="comment">//当数据库错误</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">SqlException</span>(<span class="string">&quot;Sql error&quot;</span>, <span class="number">4</span>);<span class="comment">//抛出派生类异常对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">test</span>();</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//捕获基类异常，</span></span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> Exception&amp; a)&#123;</span><br><span class="line">        a.<span class="built_in">what</span>();<span class="comment">//输出错误信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;unknow exception&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="C-标准库的异常体系"><a href="#C-标准库的异常体系" class="headerlink" title="C++标准库的异常体系"></a>C++标准库的异常体系</h2><p> 在C++库中也建立了一个异常体系。也给我们提供了一些异常类。我们可以在程序中使用这些标准异常，它们也是以父子类层次结构组织起来的。</p>
<ul>
<li>基类：std::exception</li>
<li>派生类：std::runtime_error等</li>
</ul>
<h2 id="异常优缺点"><a href="#异常优缺点" class="headerlink" title="异常优缺点"></a>异常优缺点</h2><p><strong>优点</strong>：</p>
<ul>
<li>异常对象定义好了，相比较于错误码，可以清晰准确的展示出错误的各种信息，甚至包含堆栈调用信息，可以帮我们很好的定位程序的bug。</li>
<li>在函数调用链中，深层函数返回错误，我们得层层返回，需要不断的判断是什么错误，再返回给最外层。异常直接会找到对应的catch执行，不需要判断是什么错误。</li>
<li>部分函数更好处理，比如没有返回值的函数或者返回值为自身的T&amp; operator，不好返回错误码。并且pos越界了，内存错误等不需要终止程序。</li>
<li>更好的进行测试代码</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>异常导致执行流乱跳，运行混乱。导致我们调试和分析程序时，比较困难。</li>
<li>C++没有垃圾回收机制，可能会导致异常安全问题。开辟的资源和打开的流，由于执行流乱跳，导致没有释放和关闭等。导致内存泄漏。打开的锁为关闭，导致死锁。</li>
<li>C++标准库的异常体系定义不好，导致我们需要各自定义各自的体系，非常混乱。</li>
<li>随意抛异常，外层不好捕获，所以尽量按找异常规范使用。</li>
</ul>
<h2 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h2><p>在C++中，RTTI是<strong>运行阶段类型识别</strong>的简称（Runtime Type Identification）。它允许在程序运行时获取对象的类型信息。是新添加到C++中的特性之一，很多老式实现不支持。主要用途包括：</p>
<ol>
<li><strong>识别对象类型：</strong> RTTI允许在程序运行时确定对象的类型。这对于处理多态性和动态多态性（dynamic polymorphism）非常有用。例如，在一个基类的指针或引用指向派生类对象时，你可以使用RTTI来确定实际派生类的类型。</li>
<li><strong>安全的类型转换：</strong> 在某些情况下，你可能需要将基类指针或引用安全地转换为派生类指针或引用。RTTI的<code>dynamic_cast</code>运算符可用于执行这种安全的转换，它会在转换之前检查类型信息，如果转换不安全，<strong>它会返回空指针或引发异常</strong>，而不是导致未定义行为。</li>
<li><strong>类型检查：</strong> RTTI允许你在运行时检查对象的类型信息，从而采取相应的措施。这对于实现一些通用的算法或框架，需要根据对象的类型来执行不同的操作，非常有用。</li>
<li><strong>异常处理：</strong> 在一些情况下，RTTI可用于处理异常。当在基类指针或引用上使用<code>dynamic_cast</code>时，如果转换失败，会返回空指针或引发<code>std::bad_cast</code>异常，可以在异常处理中捕获。</li>
</ol>
<p>C++中有三个支持RTTI的元素</p>
<ul>
<li>dynamic_cast运算符将使用一个指向基类的指针来生成一个指向派生类的指针，否则，该运算符返回空指针-0</li>
<li>typeid运算符返回一个指出对象的类型的值</li>
<li>type_info结构储存了有关特定类型的信息</li>
</ul>
<h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><p><strong>dynamic_cast 操作符</strong>：<code>dynamic_cast</code> 用于在运行时执行安全的类型转换，主要用于处理继承关系。它可以将指向基类的指针或引用转换为派生类的指针或引用，同时执行类型检查。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dummy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"></span><br><span class="line">   Derived* derivedPtr = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (derivedPtr != <span class="literal">nullptr</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Successfully casted to Derived.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">   &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Failed to cast to Derived.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">delete</span> basePtr;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Derived&amp; derivedRef = <span class="built_in">dynamic_cast</span>&lt;Derived&amp;&gt;(*basePtr);</span><br><span class="line">    <span class="comment">// 成功转换</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_cast&amp; e) &#123;</span><br><span class="line">    <span class="comment">// 转换失败</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*在一些情况下，RTTI可用于处理异常。当在基类指针或引用上使用dynamic_cast时，如果转换失败，会返回空指针或引发std::bad_cast异常，可以在异常处理中捕获。*/</span></span><br></pre></td></tr></table></figure>





<h3 id="typeid和type-info"><a href="#typeid和type-info" class="headerlink" title="typeid和type_info"></a>typeid和type_info</h3><p><strong>typeid运算符</strong>：</p>
<ul>
<li><strong>用途：</strong> <code>typeid</code>运算符用于在运行时获取对象的类型信息。它返回一个<code>const std::type_info&amp;</code> 对象，该对象包含有关实际类型的信息，其中type_info是在头文件typeinfo(以前是typeInfo.h)中定义的一个类。。</li>
<li><strong>语法：</strong> <code>typeid(expression)</code>，其中<code>expression</code>是一个表达式，通常是<strong>一个对象或一个类型</strong>。</li>
</ul>
<p><strong>type_info类</strong>：</p>
<ul>
<li><strong>用途：</strong> <code>type_info</code>是一个类，表示类型信息。它包含有关类型的信息，例如类型的名称。</li>
<li><strong>成员函数：</strong><ul>
<li><strong><code>name()</code>：</strong> 返回一个指向包含类型名称的C字符串的指针。请注意，这个名称的格式是实现定义的，可能在不同编译器和平台上有所不同。</li>
<li><strong>其他成员函数：</strong> 可能会有其他一些实现特定的成员函数，但标准并没有规定。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="type">const</span> std::type_info&amp; typeInfo = <span class="built_in">typeid</span>(*basePtr);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Object type: &quot;</span> &lt;&lt; typeInfo.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> basePtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>typeid运算符使得能够确定两个对象是否为同种类型。type_info类重载了&#x3D;&#x3D;和!运算符，可以使用这些运算符来对类型比较。</strong></p>
<p><strong>例如</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dummy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> Base;</span><br><span class="line">    Derived* derivedPtr = <span class="keyword">new</span> Derived;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; (<span class="built_in">typeid</span>(Base) == <span class="built_in">typeid</span>(*basePtr)) &lt;&lt; std::endl;<span class="comment">//(*basePtr表示指向的对象)相同,返回值1</span></span><br><span class="line">    std::cout &lt;&lt; (<span class="built_in">typeid</span>(Base) == <span class="built_in">typeid</span>(*derivedPtr)) &lt;&lt; std::endl;<span class="comment">//返回值0</span></span><br><span class="line">    std::cout &lt;&lt; (<span class="built_in">typeid</span>(Derived) == <span class="built_in">typeid</span>(*basePtr)) &lt;&lt; std::endl;<span class="comment">//返回值0</span></span><br><span class="line">    std::cout &lt;&lt; (<span class="built_in">typeid</span>(Derived) == <span class="built_in">typeid</span>(*derivedPtr)) &lt;&lt; std::endl;<span class="comment">//返回值1</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; (<span class="built_in">typeid</span>(*basePtr) == <span class="built_in">typeid</span>(*derivedPtr)) &lt;&lt; std::endl;<span class="comment">//,对象不同返回值0</span></span><br><span class="line">    <span class="keyword">delete</span> basePtr;</span><br><span class="line">    <span class="keyword">delete</span> derivedPtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="智能指针模板类"><a href="#智能指针模板类" class="headerlink" title="智能指针模板类"></a>智能指针模板类</h1><p>当谈到C++中的智能指针时，通常会涉及到 <code>std::shared_ptr</code> 和 <code>std::unique_ptr</code> 这两个模板类。还有一个<code>std::auto_ptr</code>已经被摒弃，但在C++11以前使用了多年，如果编译器不支持其他两种，则auto_ptr是唯一选择。<strong>这些智能指针类旨在管理动态分配的内存，并在对象不再需要时自动释放该内存，从而避免内存泄漏和悬挂指针的问题。</strong></p>
<p>要创建智能指针对象，必须包含头文件<strong>memory</strong>，该文件模板定义。然后使用通常的模板语法来实例化所需类型的指针。</p>
<h2 id="auto-ptr模板类"><a href="#auto-ptr模板类" class="headerlink" title="auto_ptr模板类"></a>auto_ptr模板类</h2><p><code>std::auto_ptr</code> 是 C++98 标准中引入的智能指针，用于管理动态分配的内存。然而，它在 C++11 标准中已被弃用，并且在 C++17 标准中已经被移除。主要原因是 <code>std::auto_ptr</code> 存在一些问题，特别是在资源所有权转移方面存在潜在的危险。</p>
<p>一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">autoPtr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line">    *autoPtr1 = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// autoPtr2 现在拥有 autoPtr1 的内存所有权</span></span><br><span class="line">    std::auto_ptr&lt;<span class="type">int</span>&gt; autoPtr2 = autoPtr1;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; *autoPtr1 &lt;&lt; std::endl;<span class="comment">//输出1</span></span><br><span class="line">    <span class="comment">// 这里autoPtr1不再拥有资源，会导致运行时错误</span></span><br><span class="line">    <span class="comment">// 使用 autoPtr1 时可能会出现未定义的行为</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	<span class="function">std::auto_ptr&lt;<span class="type">double</span>&gt; <span class="title">autoPtr3</span><span class="params">(<span class="keyword">new</span> <span class="type">double</span>)</span></span>;</span><br><span class="line">    *autoPtr3 = <span class="number">3.14</span>;</span><br><span class="line">    std::cout &lt;&lt; *autoPtr3 &lt;&lt; std::endl;<span class="comment">//输出3.14</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">std::auto_ptr&lt;string&gt; <span class="title">autoPtr4</span><span class="params">(<span class="keyword">new</span> string)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>std::auto_ptr</strong>具有独占所有权的特性，但其所有权转移的方式可能导致一些问题，因为它采用了移动语义而非拷贝语义。这意味着当一个 <strong>std::auto_ptr</strong>所有权转移给另一个时，原始的 <strong>std::auto_ptr</strong> 将不再拥有对资源的所有权。</p>
</div>

<h2 id="shared-ptr模板类"><a href="#shared-ptr模板类" class="headerlink" title="shared_ptr模板类"></a>shared_ptr模板类</h2><p><code>std::shared_ptr</code> 是一种共享所有权的智能指针，多个 <code>shared_ptr</code> 实例可以共享对同一块内存的所有权。它使用引用计数来追踪有多少个 <code>shared_ptr</code> 共享相同的资源。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">// 创建一个shared_ptr并分配内存</span></span><br><span class="line">        std::shared_ptr&lt;<span class="type">int</span>&gt; sharedPtr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *  等价于std::shared_ptr&lt;int&gt; sharedPtr(new int(42));</span></span><br><span class="line"><span class="comment">         *  但是std::make_shared&lt;int&gt;(42)更加安全，因为它有性能优势和异常安全性</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 共享所有权</span></span><br><span class="line">        std::shared_ptr&lt;<span class="type">int</span>&gt; anotherSharedPtr = sharedPtr;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;sharedPtr: &quot;</span> &lt;&lt; *sharedPtr &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;anotherSharedPtr: &quot;</span> &lt;&lt; *anotherSharedPtr &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 使用sharedPtr和anotherSharedPtr</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当最后一个shared_ptr离开作用域时，内存会被自动释放</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="unique-ptr模板类"><a href="#unique-ptr模板类" class="headerlink" title="unique_ptr模板类"></a>unique_ptr模板类</h2><p><code>std::unique_ptr</code> 是一种独占所有权的智能指针，一个 <code>unique_ptr</code> 实例独立拥有对其指向的资源的所有权，不能共享。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 创建一个unique_ptr并分配内存</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; uniquePtr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    std::cout &lt;&lt; *uniquePtr &lt;&lt; std::endl;<span class="comment">//输出42</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *  等价于std::unique_ptr&lt;int&gt; sharedPtr(new int(42));</span></span><br><span class="line"><span class="comment">         *  但是std::make_unique&lt;int&gt;(42)更加安全，因为它有性能优势和异常安全性</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// unique_ptr不能直接赋值给另一个unique_ptr（会发生所有权转移）</span></span><br><span class="line">    <span class="comment">// std::unique_ptr&lt;int&gt; anotherUniquePtr = uniquePtr;  // 错误，编译失败</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以通过std::move进行所有权转移</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; anotherUniquePtr = std::<span class="built_in">move</span>(uniquePtr);</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt; *anotherUniquePtr &lt;&lt; std::endl;<span class="comment">//输出42</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用anotherUniquePtr</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当anotherUniquePtr离开作用域时，内存会被自动释放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="unique-ptr为何优于auto-ptr"><a href="#unique-ptr为何优于auto-ptr" class="headerlink" title="unique_ptr为何优于auto_ptr"></a>unique_ptr为何优于auto_ptr</h2><ol>
<li><p><strong>更安全的所有权转移：</strong> <code>std::unique_ptr</code> 使用移动语义进行所有权转移，而 <code>std::auto_ptr</code> 使用复制语义。由于 <code>std::auto_ptr</code> 的复制语义可能导致不明确的行为，因此在 C++11 引入 <code>std::unique_ptr</code> 时，<code>std::auto_ptr</code> 被标记为已弃用。使用 <code>std::unique_ptr</code> 更容易理解和更安全。</p>
</li>
<li><p><strong>支持数组和自定义删除器：</strong> <code>std::unique_ptr</code> 可以用于管理数组（<code>std::unique_ptr&lt;T[]&gt;</code>），而 <code>std::auto_ptr</code> 不支持这种用法。此外，<code>std::unique_ptr</code> 还支持通过自定义删除器来管理非默认方式分配的资源。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">arrayPtr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>])</span></span>;</span><br><span class="line"></span><br><span class="line">arrayPtr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">arrayPtr[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">arrayPtr[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>更灵活的模板参数：</strong> <code>std::unique_ptr</code> 具有更灵活的模板参数，可以轻松地与自定义删除器和分配器一起使用。这提供了更多的灵活性，以适应各种资源管理需求。</p>
</li>
<li><p><strong>更严格的所有权管理：</strong> <code>std::unique_ptr</code> 严格实现了独占所有权的概念，一个 <code>std::unique_ptr</code> 实例独立拥有对其指向的资源的所有权。这使得代码更加明确，减少了潜在的错误。</p>
</li>
</ol>
<p><strong>警告</strong>：</p>
<p><strong>只有使用new分配内存时</strong>，才能使用auto_ptr和shared_ptr，<strong>使用new[] 分配内存时</strong>，不能使用它们，只能使用unique_ptr。<strong>不使用new或new[]分配内存时</strong>，也不能使用unique_ptr。</p>
<h1 id="标准模板库STL"><a href="#标准模板库STL" class="headerlink" title="标准模板库STL"></a>标准模板库STL</h1><h2 id="模板类vector-1"><a href="#模板类vector-1" class="headerlink" title="模板类vector"></a>模板类vector</h2><p><strong>vector又名动态数组</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_52324409/article/details/121000029?ops_request_misc=%7B%22request_id%22:%22170903352516800180642186%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170903352516800180642186&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-121000029-null-null.142%5Ev99%5Epc_search_result_base1&utm_term=vector%E5%AE%B9%E5%99%A8&spm=1018.2226.3001.4187">C++ vector容器详解_c++容器vector-CSDN博客</a></p>
<h2 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h2><p>基于范围的for循环是为用于STL而设计的。在这种for循环中，括号中的代码<strong>声明一个类型(通常用auto)与容器储存的内容相同的变量</strong>，然后指出了容器的名称。接下来，循环体使用指定的变量依次访问容器的每个元素。若<strong>使用引用参数，则可修改容器内容</strong>。</p>
<p>一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> price[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; price2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*未使用引用参数，不能修改容器内容*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x: price) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*使用引用可以修改容器内容*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x: price2) &#123;</span><br><span class="line">        x=<span class="number">10</span>;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h2 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h2><p>STL是一种泛型编程。面向对象编程关注的是编程的数据方面，而泛型编程关注的则是算法。他们之间的共同点是抽象和创建可重用代码，但他们的理念绝然不同。</p>
<p>泛型编程旨在编写独立于数据类型的代码。在C++中，完成通用程序的工具是模板。模板使得能够按泛型定义函数或类，而STL通过通用算法更近了一步。为了解模板和设计是如何协同工作的，我们需要先了解一下迭代器。</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>在C++中，模板使得<strong>算法独立于储存的数据类型</strong>，而迭代器使<strong>算法独立于使用的容器类型</strong>，迭代器（Iterator）是一种用于遍历容器（如数组、向量、链表等）中元素的对象。迭代器提供了一种统一的方式来访问容器中的元素，而不必关心容器的具体类型或实现细节。C++标准库提供了多种类型的迭代器，<strong>主要分为五种</strong>：</p>
<ol>
<li><strong>Input Iterator（输入迭代器）</strong>：<ul>
<li>只允许从容器中读取元素，但不能修改元素。</li>
<li>支持逐个递增，只能用于单向遍历。</li>
</ul>
</li>
<li><strong>Output Iterator（输出迭代器）</strong>：<ul>
<li>只允许往容器中写入元素，但不能读取元素。</li>
<li>支持逐个递增，也只能用于单向遍历。</li>
</ul>
</li>
<li><strong>Forward Iterator（前向迭代器）</strong>：<ul>
<li>具有Input Iterator和Output Iterator的功能，支持读写操作。</li>
<li>支持逐个递增，可用于单向遍历。</li>
</ul>
</li>
<li><strong>Bidirectional Iterator（双向迭代器）</strong>：<ul>
<li>具有Forward Iterator的功能，同时支持逐个递减。</li>
<li>支持双向遍历，即可以前进也可以后退。</li>
</ul>
</li>
<li><strong>Random Access Iterator（随机访问迭代器）</strong>：<ul>
<li>具有Bidirectional Iterator的功能，同时支持随机访问元素。</li>
<li>支持通过指针算术运算（如 +、-）直接跳跃访问容器中的元素。</li>
</ul>
</li>
</ol>
<p>在C++标准库中，不同的容器提供不同类型的迭代器，例如，<code>std::vector</code>和<code>std::list</code>提供了双向迭代器，而<code>std::array</code>和<code>std::deque</code>提供了随机访问迭代器。在使用迭代器时，要注意选择适当的类型以满足操作的需求。。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*定义一个迭代器...*/</span></span><br><span class="line">vector&lt;type&gt;::iterator it;</span><br><span class="line">list&lt;type&gt;::iterator it2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*一个简单的示例*/</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; price= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">list&lt;<span class="type">double</span>&gt;::iterator it2;<span class="comment">//定义的一个遍历list容器的迭代器</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = price<span class="number">2.</span><span class="built_in">begin</span>();<span class="comment">//定义的一个遍历vector容器的迭代器</span></span><br><span class="line"><span class="keyword">for</span>(; it != price<span class="number">2.</span><span class="built_in">end</span>(); it++)<span class="comment">//迭代器支持前缀++和后缀++，遍历容器</span></span><br><span class="line">&#123;</span><br><span class="line">   std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>实际上作为一种编程风格，最好避免直接使用迭代器，而应尽可能使用STL函数(for_each())来处理细节。也可以使用C++11新增的基于范围的for循环。</p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>STL具有容器概念和容器类型。概念是具有名称(容器、序列容器、关联容器)的通用类别，容器类型是可用于创建具体容器对象的模板。</p>
<p>主要的容器分类包括：</p>
<ol>
<li><strong>序列容器（Sequence Containers）</strong>：<ul>
<li>顺序存储元素，元素的顺序与它们被插入的顺序相同。</li>
<li>包括：<ul>
<li><strong>std::vector：</strong> 动态数组，支持快速随机访问。</li>
<li><strong>std::list：</strong> 双向链表，支持在任意位置快速插入和删除元素。</li>
<li><strong>std::deque：</strong> 双端队列，支持在两端快速插入和删除元素。</li>
<li><strong>std::array：</strong> 固定大小的数组，支持快速随机访问。</li>
</ul>
</li>
</ul>
</li>
<li><strong>关联容器（Associative Containers）</strong>：<ul>
<li>基于键值对（Key-Value）的存储方式，通过键值来快速查找元素。</li>
<li>包括：<ul>
<li><strong>std::set：</strong> 有序集合，不允许重复元素。</li>
<li><strong>std::map：</strong> 有序映射，存储键值对，不允许重复的键。</li>
<li><strong>std::multiset：</strong> 有序集合，允许重复元素。</li>
<li><strong>std::multimap：</strong> 有序映射，允许重复的键。</li>
</ul>
</li>
</ul>
</li>
<li><strong>无序容器（Unordered Containers）</strong>：<ul>
<li>使用哈希表实现，元素的存储顺序不固定。</li>
<li>包括：<ul>
<li><strong>std::unordered_set：</strong> 无序集合，不允许重复元素。</li>
<li><strong>std::unordered_map：</strong> 无序映射，存储键值对，不允许重复的键。</li>
<li><strong>std::unordered_multiset：</strong> 无序集合，允许重复元素。</li>
<li><strong>std::unordered_multimap：</strong> 无序映射，允许重复的键。</li>
</ul>
</li>
</ul>
</li>
<li><strong>容器适配器（Container Adapters）</strong>：<ul>
<li>提供特定接口的封装，简化了底层容器的使用。</li>
<li>包括：<ul>
<li><strong>std::stack：</strong> 栈，后进先出（LIFO）。</li>
<li><strong>std::queue：</strong> 队列，先进先出（FIFO）。</li>
<li><strong>std::priority_queue：</strong> 优先队列，按照优先级排序。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>用法见</strong>：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45524532/article/details/115386824?ops_request_misc=&request_id=&biz_id=102&utm_term=C++%E5%AE%B9%E5%99%A8&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-115386824.142%5Ev99%5Epc_search_result_base9&spm=1018.2226.3001.4187">C++常用容器-CSDN博客</a></p>
<h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><p>在C++中，函数对象（Function Objects），也称为函数符或仿函数（Functor），函数符是可以以函数方式与()结合使用的任意对象。这包括函数名的指针和重载了()运算符对象的类(即定义了函数operator()()的类)。是一种可调用对象，可以像函数一样被调用。函数对象通常是类对象，但不像普通函数，它们可以携带状态信息，并可以通过成员函数实现自定义行为。函数对象可用于算法、STL容器等各种场景中。</p>
<p><strong>函数对象类</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数符类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddFunctor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 重载函数调用运算符</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>使用方式</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AddFunctor addFunctor;</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">addFunctor</span>(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 结果为7</span></span><br></pre></td></tr></table></figure>



<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol>
<li><strong>函数对象作为算法的参数</strong>：</li>
</ol>
<p>函数对象可以作为算法的参数，提供一种灵活的方式来定制算法的行为。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SquareFunctor</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    SquareFunctor squareFunctor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用函数对象对容器中的每个元素进行平方操作</span></span><br><span class="line">    std::<span class="built_in">transform</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), numbers.<span class="built_in">begin</span>(), squareFunctor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在numbers为 &#123;1, 4, 9, 16, 25&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ol start="2">
<li><strong>函数对象与STL</strong>：</li>
</ol>
<p>函数对象在STL（标准模板库）中广泛应用，例如在排序、查找等算法中可以通过函数对象来指定比较的规则。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DescendingOrder</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    DescendingOrder descendingOrder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用函数对象进行降序排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), descendingOrder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在numbers为 &#123;8, 5, 3, 2, 1&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p><strong>STL的算法</strong>：</p>
<ul>
<li><strong>作用范围</strong>：STL的算法是独立于容器的通用算法。它们被设计为能够在不同类型的容器上进行操作，而不依赖于具体容器的实现。这种独立性使得同一个算法可以用于不同的数据结构，例如，可以使用<code>std::sort</code>在不同类型的容器上进行排序。</li>
<li><strong>参数类型</strong>：STL的算法通常接受迭代器（iterator）作为参数，因此可以用于各种容器，如数组、向量、链表等。它们不直接与容器关联，而是通过迭代器与容器交互。</li>
<li><strong>功能丰富</strong>：STL的算法涵盖了广泛的应用场景，包括排序、查找、数学运算、变换等。这些算法是为了提供通用且高效的数据处理工具。</li>
</ul>
<p>以下是一些常用的STL算法及其简要介绍：</p>
<ol>
<li><strong>排序算法</strong>：<ul>
<li><code>std::sort</code>：对容器进行排序，默认是升序排序。可以传递自定义的比较函数或Lambda表达式来实现不同的排序规则。</li>
<li><code>std::stable_sort</code>：稳定排序，保持相等元素的相对顺序。</li>
<li><code>std::partial_sort</code>：部分排序，将容器中的一部分元素排序，其余元素不变。</li>
</ul>
</li>
<li><strong>查找算法</strong>：<ul>
<li><code>std::find</code>：在容器中查找指定值的第一个出现位置。</li>
<li><code>std::binary_search</code>：在已排序的容器中进行二分查找。</li>
<li><code>std::count</code>：统计容器中指定值的出现次数。</li>
</ul>
</li>
<li><strong>变换算法</strong>：<ul>
<li><code>std::transform</code>：将一个范围的元素转换为另一个范围，可以结合函数对象或Lambda表达式进行元素的变换操作。</li>
<li><code>std::copy</code>：将一个范围的元素复制到另一个范围。</li>
<li><code>std::replace</code>：替换容器中指定值的所有出现。</li>
</ul>
</li>
<li><strong>删除和修改算法</strong>：<ul>
<li><code>std::remove</code>：在容器中移除指定值的所有元素，不改变容器大小，返回一个新的结束迭代器。</li>
<li><code>std::remove_if</code>：根据谓词条件移除满足条件的元素。</li>
<li><code>std::unique</code>：移除容器中相邻的重复元素，仅保留一个。</li>
</ul>
</li>
<li><strong>数值算法</strong>：<ul>
<li><code>std::accumulate</code>：对范围内的元素进行累积操作，可以用于计算总和、平均值等。</li>
<li><code>std::inner_product</code>：计算两个范围的内积。</li>
<li><code>std::iota</code>：用给定的值填充一个范围。</li>
</ul>
</li>
<li><strong>其他算法</strong>：<ul>
<li><code>std::min</code>、<code>std::max</code>：找到范围内的最小值和最大值。</li>
<li><code>std::reverse</code>：将容器中的元素进行反转。</li>
<li><code>std::rotate</code>：将容器中的元素进行旋转。</li>
</ul>
</li>
</ol>
<p>C++标准库中还有很多其他有用的算法。使用STL算法，可以编写更简洁、可读性更好的代码，并且由于这些算法经过优化，通常具有较好的性能</p>
<h2 id="STL总结"><a href="#STL总结" class="headerlink" title="STL总结"></a>STL总结</h2><p>STL（Standard Template Library）是C++标准库的一部分，提供了一套通用的模板类和函数，用于处理常见的数据结构和算法。STL的设计目标是提供高效、灵活、可复用的代码，以便开发者能够更加专注于解决问题而不必重复实现基础数据结构和算法。<strong>STL主要包括以下三个组件</strong>：</p>
<ol>
<li>容器：序列容器、关联容器等等</li>
<li>算法：提供了一系列通用的算法，如排序、查找、变换、合并等。这些算法可以用于不同类型的容器，通过迭代器进行操作，实现了数据结构和算法的分离，增强了代码的可复用性和通用性。算法通过函数对象或函数指针支持用户自定义的操作和比较规则。</li>
<li>迭代器：迭代器是STL中用于遍历容器元素的通用接口，为算法和容器提供了统一的访问机制。不同类型的容器支持不同类型的迭代器，包括输入迭代器、输出迭代器、正向迭代器、双向迭代器和随机访问迭代器，提供了不同程度的功能和效率。</li>
</ol>
<h2 id="其他库"><a href="#其他库" class="headerlink" title="其他库"></a>其他库</h2><h3 id="vector、valarray、array"><a href="#vector、valarray、array" class="headerlink" title="vector、valarray、array"></a>vector、valarray、array</h3><p>C++标准库提供了多个数组模板（<code>std::vector</code>、<code>std::valarray</code>、<code>std::array</code>），每个模板都有其特定的用途和优势。这样设计的目的是为了满足不同的编程需求，提供更丰富、更灵活的选择。以下是这三个数组模板的主要区别和适用场景：</p>
<ol>
<li><strong><code>std::vector</code></strong>：</li>
</ol>
<ul>
<li><strong>动态大小</strong>：<code>std::vector</code>是一个动态数组，其大小可以在运行时动态调整。这使得它非常适用于需要动态增减大小的场景，例如在运行时读取不确定数量的数据。</li>
<li><strong>内存管理</strong>：<code>std::vector</code>会自动处理内存的分配和释放，使得在动态数组的使用上更加方便。</li>
</ul>
<ol start="2">
<li><strong><code>std::valarray</code></strong>：</li>
</ol>
<ul>
<li><strong>数值运算</strong>：<code>std::valarray</code>设计用于面向数值计算，提供了一些成员函数和操作符用于逐元素进行数学运算。它的目标是提高数值计算的效率。</li>
<li><strong>元素级别的操作</strong>：<code>std::valarray</code>更适用于执行逐元素的数学运算，如数组的逐元素加法、乘法等。</li>
</ul>
<ol start="3">
<li><strong><code>std::array</code></strong>：</li>
</ol>
<ul>
<li><strong>固定大小</strong>：<code>std::array</code>是一个静态数组，其大小在编译时就确定了，不能动态改变。这使得它适用于固定大小的场景，例如需要在编译时确定数组大小的情况。</li>
<li><strong>栈上分配</strong>：<code>std::array</code>通常在栈上分配内存，因此相较于动态数组，它的内存访问更加高效。</li>
</ul>
<h3 id="模板initializer-list"><a href="#模板initializer-list" class="headerlink" title="模板initializer_list"></a>模板initializer_list</h3><p>在C++中，<code>initializer_list</code> 是一个标准库中的类模板，用于方便地<strong>初始化容器或其他类的对象</strong>。它允许在对象的构造函数中传递一个初始化列表，类似于数组的初始化方式。<code>initializer_list</code> 的定义位于头文件 <code>&lt;initializer_list&gt;</code> 中。</p>
<ul>
<li><strong>用于容器的构造函数</strong>：使得容器类如 <code>std::vector</code>、<code>std::initializer_list</code> 等能够通过初始化列表进行构造。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//vector类构造函数中参数使用了initializer_list</span></span><br></pre></td></tr></table></figure>



<ul>
<li><strong>容器和类的构造函数重载</strong>：类可以同时提供接受 <code>initializer_list</code> 和其他参数的构造函数，以便支持不同的初始化方式。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> a, <span class="type">double</span> b) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(std::initializer_list&lt;<span class="type">int</span>&gt; values) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">10</span>, <span class="number">3.14</span>)</span></span>;</span><br><span class="line">    MyClass obj2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;<span class="comment">//使传递一个初始化列表</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="输入、输出和文件"><a href="#输入、输出和文件" class="headerlink" title="输入、输出和文件"></a>输入、输出和文件</h1><h2 id="流和缓冲区"><a href="#流和缓冲区" class="headerlink" title="流和缓冲区"></a>流和缓冲区</h2><p>在C++中，流（stream）和缓冲区（buffer）是与输入和输出相关的概念，用于处理数据的流动和存储。流提供了一个抽象层，使得输入和输出可以以统一的方式进行处理，而缓冲区则用于临时存储数据，以提高性能和效率。</p>
<h3 id="流（Stream）"><a href="#流（Stream）" class="headerlink" title="流（Stream）"></a>流（Stream）</h3><p>流是一个抽象的概念，表示数据在程序和外部设备（如文件、屏幕、键盘等）之间的传输。在C++中，标准库提供了一些流类（如iostream、fstream、stringstream等），用于实现输入和输出的操作。流可以分为输入流和输出流，分别用于读取和写入数据。</p>
<p>常见的流类包括：</p>
<ol>
<li><p><strong><code>iostream</code>：</strong> 提供了<code>cin</code>（标准输入流）和<code>cout</code>（标准输出流），用于从键盘读取输入和向屏幕输出数据。</p>
</li>
<li><p><strong><code>fstream</code>：</strong> 用于文件输入和输出，包括<code>ifstream</code>（文件输入流）和<code>ofstream</code>（文件输出流）。</p>
</li>
<li><p><strong><code>stringstream</code>：</strong> 用于在内存中操作字符串，可以将字符串作为输入或输出流处理。</p>
</li>
</ol>
<h3 id="缓冲区（Buffer）"><a href="#缓冲区（Buffer）" class="headerlink" title="缓冲区（Buffer）"></a>缓冲区（Buffer）</h3><p>缓冲区是用于暂时存储数据的区域，它可以提高输入输出的效率。标准库中的流都具有与之关联的缓冲区，用于暂时存储数据，然后一次性地进行读取或写入，而不是每次都直接与外部设备进行通信。</p>
<p>流的缓冲区可以分为两种：</p>
<ol>
<li><strong>输入缓冲区：</strong> 存储从外部设备（如键盘或文件）读取的数据，以便程序可以逐一处理。</li>
<li><strong>输出缓冲区：</strong> 存储要写入外部设备的数据，以提高写入效率。</li>
</ol>
<p>在一些情况下，你可能需要手动刷新缓冲区，以确保数据被及时处理。使用<code>flush()</code>函数可以强制将输出缓冲区的内容写入外部设备。</p>
<h2 id="iostream文件"><a href="#iostream文件" class="headerlink" title="iostream文件"></a>iostream文件</h2><p><code>iostream</code>是C++标准库中的头文件之一，它包含了对输入和输出流的支持。具体而言，<code>iostream</code>是由两个基本的头文件合并而成，分别是：</p>
<ul>
<li><strong><code>istream</code>（Input Stream）：</strong> 用于输入流，提供了从输入设备（如键盘）读取数据的功能。主要的类包括<code>istream</code>和<code>ifstream</code>。</li>
<li><strong><code>ostream</code>（Output Stream）：</strong> 用于输出流，提供了向输出设备（如屏幕或文件）写入数据的功能。主要的类包括<code>ostream</code>和<code>ofstream</code>。</li>
</ul>
<p>通过合并这两个头文件，得到了<code>iostream</code>，其中包括了<code>cin</code>、<code>cout</code>、<code>cerr</code>、<code>clog</code>等标准流对象，以及相关的功能和操作符重载，使得输入输出操作变得简便和灵活。</p>
<p>C++的iostream库管理了很多细节。例如在程序中包换iostream文件将自动创建8个流对象(4个用于窄字符流，4个用于宽字符流)</p>
<p>常见的8个流对象及其用途包括：</p>
<ul>
<li><strong><code>cin</code>：</strong> 标准输入流，用于从用户输入中读取数据，wcin对象于此类似但处理的是wchar_t(宽字符类型)类型。</li>
<li><strong><code>cout</code>：</strong> 标准输出流，用于将数据输出到控制台。wcout对象于此类似但处理的是wchar_t(宽字符类型)类型。</li>
<li><strong><code>cerr</code>：</strong> 标准错误流，没有被缓冲，用于输出错误信息到控制台。wcerr对象于此类似但处理的是wchar_t(宽字符类型)类型。</li>
<li><strong><code>clog</code>：</strong> 标准日志流，用于输出程序运行时的一般信息。wclog对象于此类似但处理的是wchar_t(宽字符类型)类型。</li>
</ul>
<h3 id="cerr和clog"><a href="#cerr和clog" class="headerlink" title="cerr和clog"></a>cerr和clog</h3><p>在C++中，<code>cerr</code>和<code>clog</code>都是标准错误流，用于输出错误信息到控制台。它们是<code>ostream</code>类的实例，提供了与<code>cout</code>相似的输出功能，但通常用于不同的目的。</p>
<ol>
<li><p><strong><code>cerr</code>（标准错误流）：</strong></p>
<ul>
<li><code>cerr</code>是一个标准错误流对象，用于输出程序的错误信息。</li>
<li>与<code>cout</code>不同，<code>cerr</code>的<strong>输出默认不被缓冲</strong>，意味着错误消息会立即显示在控制台上，而<strong>不受缓冲机制的影响</strong>。</li>
<li>通常用于输出紧急的错误信息，以便及时发现问题。</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;This is an error message.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>clog</code>（标准日志流）：</strong></p>
<ul>
<li><code>clog</code>也是一个标准错误流对象，用于输出程序运行时的一般信息，类似于日志。</li>
<li>与<code>cerr</code>不同，<code>clog</code>的输出默认是被缓冲的，可以通过<code>std::flush</code>强制刷新输出，或者等到缓冲区满时才刷新。</li>
<li><strong>通常用于输出程序的运行时信息，方便调试和了解程序执行的进展</strong>。</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::clog &lt;&lt; <span class="string">&quot;This is a log message.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>总体而言，<code>cerr</code>和<code>clog</code>都是用于输出程序的诊断信息的标准错误流，它们与<code>cout</code>一起构成了C++中的标准流。选择使用哪一个取决于你的需求，如果你需要及时看到错误信息，可以使用<code>cerr</code>，如果你希望输出日志信息，并允许一定程度的缓冲，可以使用<code>clog</code>。</p>
<h2 id="使用cout进行输出"><a href="#使用cout进行输出" class="headerlink" title="使用cout进行输出"></a>使用cout进行输出</h2><h3 id="重载的"><a href="#重载的" class="headerlink" title="重载的&lt;&lt;运算符"></a>重载的&lt;&lt;运算符</h3><p>在C++中，&lt;&lt;运算符的默认含义是按位左移运算符，但ostream类重新定义了&lt;&lt;运算符，将其重载为输出。在这种情况下&lt;&lt;能识别C++中的所有的基本类型(int、double、string…)</p>
<p>对于上述每种类型，ostream类提供了operator&lt;&lt;()函数的定义。</p>
<p>&lt;&lt;运算符的所有化身返回类型都是ostream&amp;，格式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(type);</span><br></pre></td></tr></table></figure>

<p>意味着该运算符将返回一个指向ostream对象的引用，该引用指向用于调用该运算符的对象。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="comment">// &lt;&lt;运算符返回的是cout对象</span></span><br></pre></td></tr></table></figure>

<p>这种特性使得cout能串联输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;oh&quot;</span>;</span><br></pre></td></tr></table></figure>



<h3 id="其他osteam方法"><a href="#其他osteam方法" class="headerlink" title="其他osteam方法"></a>其他osteam方法</h3><p>ostream还提供了put()方法和write()方法</p>
<p>put：用于显示字符</p>
<p>write：用于显示字符串</p>
<ul>
<li>put原型：将一个字符插入到输出流中。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream&amp; <span class="title">put</span><span class="params">(<span class="type">char</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cout.<span class="built_in">put</span>(<span class="string">&#x27;W&#x27;</span>);</span><br><span class="line">cout.<span class="built_in">put</span>(<span class="string">&#x27;I&#x27;</span>).<span class="built_in">put</span>(<span class="string">&#x27;t&#x27;</span>);<span class="comment">//可进行拼接输出</span></span><br><span class="line">cout.<span class="built_in">put</span>(<span class="number">65</span>) <span class="comment">//输出A</span></span><br><span class="line">cout.<span class="built_in">put</span>(<span class="number">66.3</span>) <span class="comment">//自动将double值66.3转换为char值66，输出B</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p>write模板原型： 将指定数量的字符从指定位置的字符串插入到输出流中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">basic_ostream&lt;<span class="type">char</span>, Traits&gt;&amp; <span class="title">write</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, streamsize n)</span></span>;</span><br><span class="line"></span><br><span class="line">-第一个参数为指定字符串</span><br><span class="line">-第二个参数为指定长度</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* message = <span class="string">&quot;Hello, C++!&quot;</span>;</span><br><span class="line">    cout.<span class="built_in">write</span>(message, <span class="number">6</span>); <span class="comment">// 将 &quot;Hello&quot; 写入输出流</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="刷新输出缓冲区"><a href="#刷新输出缓冲区" class="headerlink" title="刷新输出缓冲区"></a>刷新输出缓冲区</h3><ul>
<li><p>在C++中，刷新输出缓冲区是指将缓冲区中的数据强制写入输出设备。默认情况下，输出流（如<code>cout</code>、<code>cerr</code>等）会将数据存储在内部缓冲区中，而不是每次写入一个字符就立即刷新到输出设备。刷新输出缓冲区的操作可以通过 <code>flush</code> 方法或 <code>flush</code> 操纵符来实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*第一种*/</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;This is some text.&quot;</span> &lt;&lt; flush; <span class="comment">// 刷新输出缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*第二种*/</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;This is some text.&quot;</span> &lt;&lt; endl;   <span class="comment">// endl 操纵符会输出一个换行符并刷新输出缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*第三种*/</span></span><br><span class="line"><span class="built_in">flush</span>(cout);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="用cout进行格式化"><a href="#用cout进行格式化" class="headerlink" title="用cout进行格式化"></a>用cout进行格式化</h3><ol>
<li><strong>控制输出的进制</strong>：在下一次将格式状态修改为其他进制时才会输出其他进制，否则一直按照设置进制之后进行输出</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 十六进制输出</span></span><br><span class="line">    cout &lt;&lt; hex &lt;&lt; <span class="string">&quot;Hexadecimal: &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    <span class="comment">/*或者使用hex(cout)、oct(cout)*/</span></span><br><span class="line">    <span class="comment">// 八进制输出</span></span><br><span class="line">    cout &lt;&lt; oct &lt;&lt; <span class="string">&quot;Octal: &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hex,oct都是控制符</span></span><br></pre></td></tr></table></figure>



<ol start="2">
<li><strong>调整字段宽度和对齐方式</strong>：width()方法只影响接下来显示的一个项目，然后字段宽度将恢复为默认值</li>
</ol>
<p>使用width()进行设置字段宽度，left左对齐，right右对齐</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">123</span>;</span><br><span class="line">    <span class="type">double</span> num2 = <span class="number">45.6789</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制输出宽度和对齐方式</span></span><br><span class="line">    cout.<span class="built_in">width</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; left &lt;&lt; num1;</span><br><span class="line">    </span><br><span class="line">    cout.<span class="built_in">width</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; right &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li><strong>填充字符</strong>：</li>
</ol>
<p>在默认情况下，cout用空格填充字段中未被使用的部分，可以使用fill()成员函数来改变填充字符。<strong>在下次修改之前将一直使用之前修改的字符填充</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout.<span class="built_in">fill</span>(<span class="string">&#x27;*&#x27;</span>);</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">123</span>;</span><br><span class="line">    <span class="type">double</span> num2 = <span class="number">45.6789</span>;</span><br><span class="line">    cout.<span class="built_in">fill</span>(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    <span class="comment">// 控制输出宽度和对齐方式</span></span><br><span class="line">    cout.<span class="built_in">width</span>(<span class="number">10</span>);<span class="comment">//宽度为10，前7位用*填充</span></span><br><span class="line">    cout &lt;&lt; right &lt;&lt; num1;</span><br><span class="line">    cout.<span class="built_in">width</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; right &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="4">
<li><strong>设置浮点数的显示精度</strong>：</li>
</ol>
<p>浮点数精度的含义取决于输出模式。在<strong>默认情况</strong>下，指的是显示的总位数，在<strong>定点模式和科学模式</strong>下，精度指的是小数点后面的位数。c++默认精度位6位(末尾的0不显示)。precision()成员函数使得能选择其他值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cout精度设置为2</span></span><br><span class="line">cout.<span class="built_in">precision</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>



<ol start="5">
<li><strong>打印末尾的0和小数点</strong>：</li>
</ol>
<p>对于有些输出(比如价格栏中的数字)，保留末尾的0将更为美观。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout.setf(ios_base::showpoint);</span><br></pre></td></tr></table></figure>



<p><strong>上面的dec、hex、oct、left、right等都是标准控制符能够调用setf()，并且自动提供正确的参数，工作方式都相似。</strong></p>
<h3 id="头文件iomanip"><a href="#头文件iomanip" class="headerlink" title="头文件iomanip"></a>头文件iomanip</h3><p>使用iostream工具来设置一些格式值有时不太方便。为简化工作，C++在头文件iomanip中提供了一些控制符，作用类似，表示更方便。常用的有三个：setprecision()、setfill()和setw()，表示设置精度、填充字符、字段宽度。</p>
<p>setprecision()：接受一个指定精度的整数参数</p>
<p>setfill()：接受一个指定字段宽度的整数参数</p>
<p>setw()：接受一个指定填充字符的char参数</p>
<p>因为他们都是控制符，故可以使用cout将语句连接起来。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> root = <span class="number">3.1415926</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">10</span>;n&lt;=<span class="number">100</span>; n+=<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;.&#x27;</span>) &lt;&lt; n &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">12</span>) &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">3</span>) &lt;&lt; root &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="使用cin进行输入"><a href="#使用cin进行输入" class="headerlink" title="使用cin进行输入"></a>使用cin进行输入</h2><h3 id="cin如何检查输入"><a href="#cin如何检查输入" class="headerlink" title="cin如何检查输入"></a>cin如何检查输入</h3><p>不同版本的抽取运算符查看输入流的方法是相同的。<strong>他们跳过空白（空格、换行符、制表符），直到遇到非空白字符</strong>。即使对于单字符模式（char、unsigned char）也是如此。在其他模式下，&gt;&gt;运算符将读取一个指定类型的数据。<strong>将从非空白字符开始，到与目标类型不匹配的第一个字符的全部内容</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num;</span><br><span class="line">cin &gt;&gt; num;</span><br><span class="line"><span class="comment">//假设输入12348z</span></span><br><span class="line">cout &lt;&lt; num;<span class="comment">//输出12348，剩下的留在输入缓冲区</span></span><br></pre></td></tr></table></figure>



<h3 id="流状态"><a href="#流状态" class="headerlink" title="流状态"></a>流状态</h3><p>在C++中，<code>cin</code> 对象的流状态会受到输入的影响。<code>cin</code> 是C++标准库中的标准输入流对象，用于从标准输入设备（通常是键盘）获取用户输入。流状态的不同值反映了输入的有效性和状态。以下是一些关于 <code>cin</code> 流状态的详细介绍：</p>
<ol>
<li><strong>流状态位</strong>：</li>
</ol>
<p><code>cin</code> 有一系列的流状态位，主要的有：</p>
<ul>
<li><strong><code>failbit</code>：</strong> 当输入的数据类型不匹配或输入格式错误时，<code>failbit</code> 会被设置。例如，用户输入了非整数字符而 <code>cin</code> 期望输入整数。</li>
<li><strong><code>badbit</code>：</strong> 当输入流发生严重错误时，如IO错误或设备故障，<code>badbit</code> 会被设置。</li>
<li><strong><code>eofbit</code>：</strong> 当遇到文件末尾时，<code>eofbit</code> 会被设置。</li>
<li><strong><code>goodbit</code>：</strong> 表示没有错误发生。</li>
</ul>
<ol start="2">
<li><strong>流状态查询</strong>：</li>
</ol>
<p>可以通过 <code>cin</code> 对象的成员函数 <code>fail()</code>、<code>bad()</code>、<code>eof()</code> 和 <code>good()</code> 来查询流的状态。</p>
<ul>
<li><strong><code>fail()</code>：</strong> 返回 <code>true</code> 表示 <code>failbit</code> 或 <code>badbit</code> 被设置。</li>
<li><strong><code>bad()</code>：</strong> 返回 <code>true</code> 表示 <code>badbit</code> 被设置。</li>
<li><strong><code>eof()</code>：</strong> 返回 <code>true</code> 表示 <code>eofbit</code> 被设置。</li>
<li><strong><code>good()</code>：</strong> 返回 <code>true</code> 表示没有任何错误位被设置，即 <code>goodbit</code> 被设置。</li>
</ul>
<ol start="3">
<li><strong>流状态的影响</strong>：</li>
</ol>
<p>在使用 <code>cin</code> 进行输入时，输入的有效性和格式与流状态密切相关。如果输入不符合预期，流状态位将被设置，进而影响程序的行为。例如：</p>
<h3 id="使用cin错误处理"><a href="#使用cin错误处理" class="headerlink" title="使用cin错误处理"></a>使用cin错误处理</h3><p>在使用 <code>cin</code> 进行输入时，最好进行错误处理，以确保用户输入的数据是有效的。例如，如果用户输入了非整数的字符，<code>cin</code> 将进入错误状态。可以通过检查 <code>cin.fail()</code> 来检测错误，并通过 <code>cin.clear()</code> 来清除错误状态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter an integer: &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!(cin &gt;&gt; num)) &#123;</span><br><span class="line">        <span class="comment">/*输入有效返回true，无效返回false*/</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Invalid input. Please enter an integer: &quot;</span>;</span><br><span class="line">        cin.<span class="built_in">clear</span>(); <span class="comment">// 清除错误状态</span></span><br><span class="line">      cin.<span class="built_in">ignore</span>(numeric_limits&lt;streamsize&gt;::<span class="built_in">max</span>(), <span class="string">&#x27;\n&#x27;</span>); <span class="comment">// 忽略缓冲区中的无效字符</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;You entered: &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- cin.clear() 的作用是清除 cin 对象的错误状态，以便能够继续尝试接收输入。如果不清除错误状态，cin 会一直保持在错误状态，导致后续的输入操作无法正常进行。</span><br><span class="line"></span><br><span class="line">- cin.ignore(numeric_limits&lt;streamsize&gt;<span class="punctuation">:</span><span class="punctuation">:</span>max()<span class="punctuation">,</span> &#x27;\n&#x27;) 的作用是清除输入缓冲区中的无效字符，直到遇到换行符为止。这通常用于处理用户输入错误时，清除缓冲区中的残留字符，以便下一次输入操作不受之前错误的影响。</span><br><span class="line"></span><br><span class="line">- cin.fail() 是 cin 流的一个成员函数，用于检查最近一次的输入操作是否成功。它返回一个布尔值，如果最近的输入操作失败，则返回 <span class="literal"><span class="keyword">true</span></span>，否则返回 <span class="literal"><span class="keyword">false</span></span>。</span><br></pre></td></tr></table></figure>



<h3 id="其他istream类方法"><a href="#其他istream类方法" class="headerlink" title="其他istream类方法"></a>其他istream类方法</h3><ol>
<li><strong>单字符输入</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">get</span>(<span class="type">char</span>&amp; )</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在使用char参数或没有参数的情况下，get()方法读取下一个字符，即使该字符是空格、制表符或换行符。get(char&amp; ch)版本将输入字符赋给其参数，而get(void)版本将输入字符转换为整型并将其返回</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">cin.<span class="built_in">get</span>(c1);</span><br><span class="line"></span><br><span class="line">c1 = cin.<span class="built_in">get</span>();<span class="comment">//返回值为整型</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">cin.<span class="built_in">get</span>(c1).<span class="built_in">get</span>(c2) &gt;&gt; c3;</span><br><span class="line"><span class="comment">//可以进行拼接get，代表先赋值给c1返回调用对象cin，再赋值给c2，返回cin，最后把下一个非空白字符赋值给c3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ct=<span class="number">0</span></span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line">cin.<span class="built_in">get</span>(ch);<span class="comment">//如果这里替换位&gt;&gt;下面将不会退出循环</span></span><br><span class="line"><span class="keyword">while</span>(ch!=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; ch;</span><br><span class="line">    ct++;</span><br><span class="line">    cin.<span class="built_in">get</span>(ch);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ct &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设输入 I C++ clearly.&lt;Enter&gt;</span></span><br><span class="line"><span class="comment">//最终输出会跳过空格，输出IC++clearly.</span></span><br></pre></td></tr></table></figure>



<p>2.<strong>字符串输入</strong>：get()、getline()和ignore()</p>
<ul>
<li><strong>cin.get()</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream &amp; <span class="title">get</span><span class="params">(<span class="type">char</span>*,<span class="type">int</span>,<span class="type">char</span>)</span></span>;</span><br><span class="line"><span class="function">istream &amp; <span class="title">get</span><span class="params">(<span class="type">char</span>*,<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">- <span class="type">char</span>*:放置输入字符串的内存单元的地址</span><br><span class="line">- <span class="type">int</span>:比读取的最大字符大<span class="number">1</span>，额外的一个字符用于存储结果为空字符</span><br><span class="line">- <span class="type">char</span>:指定用作分界符的字符，只有两个参数时将使用换行符用作分界符</span><br><span class="line">    </span><br><span class="line">cin.<span class="built_in">get</span>(array,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>无参数时，读入一个字符，包括换行符，常用来处理输入缓冲区中的换行符。</p>
<p>有参数时，从缓冲区读取数据，到达行尾或size-1个字符**(剩下的空间储存在结尾添加的空字符)<strong>后结束读取(超过规定字符数不会出现错误,会直接截断)，不会对换行符进行处理，将</strong>其留在输入流**。</p>
<ul>
<li><strong>cin.getline()</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream &amp; <span class="title">getline</span><span class="params">(<span class="type">char</span>*,<span class="type">int</span>,<span class="type">char</span>)</span></span>;</span><br><span class="line"><span class="function">istream &amp; <span class="title">getline</span><span class="params">(<span class="type">char</span>*,<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">- <span class="type">char</span>*:放置输入字符串的内存单元的地址</span><br><span class="line">- <span class="type">int</span>:比读取的最大字符大<span class="number">1</span>，额外的一个字符用于存储结果为空字符</span><br><span class="line">- <span class="type">char</span>:指定用作分界符的字符，只有两个参数时将使用换行符用作分界符</span><br><span class="line">    </span><br><span class="line">cin.<span class="built_in">getline</span>(array,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>从缓冲区读取数据,到达行尾或size-1**(剩下的空间储存在结尾添加的空字符)**个字符结束读取(超过规定的字符数会出现错误,中断)，会读取并丢弃输入流中的换行符。</p>
<ul>
<li><strong>ignore()</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">ignore</span><span class="params">(<span class="type">int</span> =<span class="number">1</span>,<span class="type">int</span>= EOF)</span></span>;</span><br><span class="line"></span><br><span class="line">cin.<span class="built_in">ignore</span>(<span class="number">255</span>,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">cin.<span class="built_in">ignore</span>(<span class="number">255</span>,<span class="string">&#x27;\n&#x27;</span>).<span class="built_in">ignore</span>(<span class="number">255</span>,<span class="string">&#x27;\n&#x27;</span>);<span class="comment">//可拼接</span></span><br></pre></td></tr></table></figure>

<p>原型为两个参数提供的默认值为1和EOF，EOF导致读取指定数目的字符或读取到文件结尾</p>
<p><code>cin.ignore</code> 是 C++ 中用于忽略输入流中一定数量字符或特定字符的函数。这个函数通常用于清除输入缓冲区中的不需要的字符，以便在后续的输入操作中不受其影响。</p>
<h2 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h2><h3 id="文件输入输出-1"><a href="#文件输入输出-1" class="headerlink" title="文件输入输出"></a>文件输入输出</h3><p><strong>iostream: 头文件中定义了一个处理输出的ostream类</strong></p>
<p><strong>fstream：头文件定义了一个用于处理输出的ofstream类</strong></p>
<p><strong>文件的输出主要步骤如下</strong>:</p>
<ol>
<li><p>包含头文件fstream，iostream</p>
</li>
<li><p>创建一个ofstream（output fstream）对象（<strong>通常取名为outFile</strong>）</p>
</li>
<li><p>将该ofstream 对象同一个文件关联起来(使用open方法)。</p>
</li>
<li><p>向cout那样使用ofstream对象（通常outFile）</p>
<p><strong>重点</strong>：cout在屏幕上输出，而outFile是在文件中输出（写入）</p>
</li>
<li><p>outFile.close()关闭文件流</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span><span class="comment">//步骤1</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">	ofstream outFile;<span class="comment">//步骤2</span></span><br><span class="line">	outFile.<span class="built_in">open</span>(<span class="string">&quot;data.txt&quot;</span>,std::ios::out);<span class="comment">//步骤3以写入的方式打开文件</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!outFile.<span class="built_in">is_open</span>()) </span><br><span class="line">	&#123;<span class="comment">//判断文件是否打开成功，打开成功返回true</span></span><br><span class="line">     	cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span>;</span><br><span class="line">     	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>()</span><br><span class="line">	&#123;</span><br><span class="line">    	outFile &lt;&lt; data &lt;&lt; endl;<span class="comment">//步骤4，输入文件中</span></span><br><span class="line">	&#125;</span><br><span class="line">      </span><br><span class="line">    outFile.<span class="built_in">close</span>();<span class="comment">//步骤5，关闭文件流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>文件的输入包括以下步骤</strong>：</p>
<ol>
<li><p>包含头文件iostream，包含头文件fstream</p>
</li>
<li><p>声明一个或多个<strong>ifstream</strong>（<strong>input fstream</strong>）的变量（对象），并且命名，遵守常用的命名的规则，<strong>通常取名为inFile</strong></p>
</li>
<li><p>将ifstream对象与文件关联起来。为此，方法之一是使用open()方法</p>
</li>
<li><p>可结合ifstream对象 和运算符&gt;&gt;来输入各种类型的数据。</p>
</li>
<li><p>使用inFile.close()关闭文件流</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">255</span>];</span><br><span class="line">    ifstream inFile;<span class="comment">//步骤2</span></span><br><span class="line">    inFile.<span class="built_in">open</span>(<span class="string">&quot;student.txt&quot;</span>,std::ios::in);<span class="comment">//步骤3</span></span><br><span class="line">    <span class="keyword">if</span> (!inFile.<span class="built_in">is_open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!inFile.<span class="built_in">eof</span>())<span class="comment">//判断是否读取到文件结尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        inFile &gt;&gt; data;<span class="comment">//步骤4</span></span><br><span class="line">        inFile.<span class="built_in">getline</span>(str,<span class="number">255</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inFile.<span class="built_in">close</span>();<span class="comment">//步骤5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="检查文件-1"><a href="#检查文件-1" class="headerlink" title="检查文件"></a>检查文件</h3><p>格式为: 对象名.isopen()  例：   <strong>inFile.is_open()</strong></p>
<p>如果文件成功被打开，返回<strong>true</strong>；如果文件没有被打开，<strong>因此表达式   !inFile.is_open()  将为true</strong></p>
<p><strong>通常使用下方代码判断是否打开成功</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!inFile.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;文件打开失败&quot;</span>;</span><br><span class="line">   	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//exit(0)程序正常结束</span></span><br><span class="line"><span class="comment">//exit(1)程序异常结束</span></span><br><span class="line"><span class="comment">//exit()使用需要用到头文件cstdlib</span></span><br></pre></td></tr></table></figure>



<h3 id="判断文件结尾"><a href="#判断文件结尾" class="headerlink" title="判断文件结尾"></a>判断文件结尾</h3><p>格式为：对象名.eof()  例:   <strong>inFile.eof()</strong></p>
<p><strong>eof在遇到EOF（文件结束标志）时返回ture ，否则返回false</strong></p>
<p>通常和while循环一起用作文件读取结束，<strong>!inFile.eof</strong>在文件结束前为真，结束为假（退出循环）</p>
<p>具体格式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!inFile.<span class="built_in">eof</span>())<span class="comment">//判断是否读取到文件结尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        inFile &gt;&gt; data;<span class="comment">//步骤4</span></span><br><span class="line">        inFile.<span class="built_in">getline</span>(str,<span class="number">255</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="文件打开关闭"><a href="#文件打开关闭" class="headerlink" title="文件打开关闭"></a>文件打开关闭</h3><ul>
<li><strong>文件打开</strong>：</li>
</ul>
<p>**1.对象名.open(“文件名”) **（一个参数）例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outFile.<span class="built_in">open</span>(<span class="string">&quot;student.txt&quot;</span>)</span><br></pre></td></tr></table></figure>



<p>如果文件不存在，将会自动创建一个相同名字的文件,如果文件存在，将会打开该文件，首先截断该文件，将其长度截短到0，丢弃原有的内容，然后将新的输入加入到该文件中</p>
<p><strong>2.对象名.open(“文件名”，打开方式)</strong> （两个参数）例如 : </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outFile.<span class="built_in">open</span>(<span class="string">&quot;student.txt&quot;</span>,std::ios::in)</span><br></pre></td></tr></table></figure>

<p>只读模式以只读模式打开 </p>
<ul>
<li><strong>文件关闭</strong>：</li>
</ul>
<p>格式：对象名.close()  例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outFile.<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure>



<p>注意方法close()，不需要使用文件名作为参数，因为outFile已经同特定的文件关联起来，如果忘记关闭文件，程序正常终止的时候将自动关闭它。</p>
<h3 id="打开多个文件"><a href="#打开多个文件" class="headerlink" title="打开多个文件"></a>打开多个文件</h3><p>打开多个文件时可以同时打开多个文件流：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">std::ifstream userInFile,managerInFile;</span><br><span class="line">    userInFile.<span class="built_in">open</span>(<span class="string">&quot;user_data.txt&quot;</span>, std::ios::in);</span><br><span class="line">    managerInFile.<span class="built_in">open</span>(<span class="string">&quot;manager_data.txt&quot;</span>, std::ios::in);</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">if</span>(!userInFile.<span class="built_in">is_open</span>()||!managerInFile.<span class="built_in">is_open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">while</span>(!userInFile.<span class="built_in">eof</span>())</span><br><span class="line">    &#123;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line"> 	<span class="keyword">while</span>(!managerInFile.<span class="built_in">eof</span>())</span><br><span class="line"> 	&#123;</span><br><span class="line"> 	&#125;</span><br><span class="line">    </span><br><span class="line">    userInFile.<span class="built_in">close</span>();</span><br><span class="line">    managerInFile.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="文件打开模式"><a href="#文件打开模式" class="headerlink" title="文件打开模式"></a>文件打开模式</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/digitalkee/article/details/105799054?ops_request_misc=&request_id=&biz_id=102&utm_term=c++%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E6%A8%A1%E5%BC%8F&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-105799054.142%5Ev99%5Epc_search_result_base1&spm=1018.2226.3001.4187">C++ open 打开文件（含打开模式一览表）_c++ open函数-CSDN博客</a></p>
<h1 id="c-新标准"><a href="#c-新标准" class="headerlink" title="c++新标准"></a>c++新标准</h1><p><strong>更多内容见C++ primer plus 18章</strong></p>
<h2 id="统一的初始化"><a href="#统一的初始化" class="headerlink" title="统一的初始化"></a>统一的初始化</h2><p>C++11扩大了大括号扩起的列表，即初始化列表的使用范围，使其可用于所有内置类型和用户定义的类对象。使用初始化列表时，可添加等号，也可不添加。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=&#123;<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">double</span> y&#123;<span class="number">2.75</span>&#125;;</span><br><span class="line"><span class="type">short</span> quar[<span class="number">5</span>] = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">76</span>,<span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure>



<p>另外初始化列表可用于new表达式中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ar = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">4</span>] &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>&#125;<span class="comment">//c++11</span></span><br></pre></td></tr></table></figure>





<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><h3 id="左值和右值："><a href="#左值和右值：" class="headerlink" title="左值和右值："></a>左值和右值：</h3><ul>
<li><p><strong>左值（lvalue）：</strong> <strong>左值是可以标识内存位置的表达式</strong>。通常，左值是具有名称的变量、对象或表达式的结果，它们可以出现在等号的左边，可以被取地址。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">42</span>;  <span class="comment">// x 是左值</span></span><br><span class="line"><span class="type">int</span>* ptr = &amp;x;  <span class="comment">// &amp;x 是左值，因为它是地址</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>右值（rvalue）：</strong> <strong>右值是不能标识内存位置的表达式</strong>。右值通常是临时的、<strong>无法取地址的值</strong>，出现在等号的右边。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> y = <span class="number">10</span> + <span class="number">5</span>;  <span class="comment">// 10 + 5 是右值</span></span><br><span class="line"><span class="type">int</span> z = x + y;   <span class="comment">// x + y 是右值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> z = x;<span class="comment">//x不是右值，可以取地址</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="左值引用和右值引用："><a href="#左值引用和右值引用：" class="headerlink" title="左值引用和右值引用："></a>左值引用和右值引用：</h3><ul>
<li><p><strong>左值引用（lvalue reference）：</strong> 左值引用是用于引用左值的引用类型。它使用 <code>&amp;</code> 符号声明。<strong>左值引用主要用于在函数中传递参数或作为函数的返回类型，以及在赋值操作中</strong>。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = x;  <span class="comment">// ref 是对 x 的左值引用</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>右值引用（rvalue reference）：</strong> <strong>右值引用是用于引用右值的引用类型</strong>。它使用 <code>&amp;&amp;</code> 符号声明。<strong>右值引用通常与移动语义一起使用，允许有效地将资源从一个对象移动到另一个对象，而不进行深层复制</strong>。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; rref = <span class="number">10</span> + <span class="number">5</span>;  <span class="comment">// rref 是对右值的引用</span></span><br><span class="line"><span class="comment">//无法对rref取地址</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>右值引用通常与移动语义结合，例如在移动构造函数和移动赋值运算符中使用，提高了对动态分配资源的效率。左值引用用于传递可修改的参数，而右值引用用于支持移动操作。</strong></p>
<h2 id="Lambda函数"><a href="#Lambda函数" class="headerlink" title="Lambda函数"></a>Lambda函数</h2><p>在C++中，lambda 表达式是一种方便的方式，允许你在函数内部定义匿名函数。它的语法形式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters) -&gt; return_type &#123;</span><br><span class="line">    <span class="comment">// lambda body</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>capture</code> 是捕获列表，用于指定在 lambda 表达式中可以访问的外部变量。</li>
<li><code>parameters</code> 是 lambda 函数的参数列表。</li>
<li><code>return_type</code> 是返回类型。</li>
<li><code>lambda body</code> 包含实际的函数体。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operateWithLambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lambda 表达式，接受两个参数，返回它们的和</span></span><br><span class="line">    <span class="keyword">auto</span> add1 = [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Lambda 表达式计算并输出结果</span></span><br><span class="line">    <span class="type">int</span> result1 = <span class="built_in">add1</span>(x, y);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The sum1 is: &quot;</span> &lt;&lt; result1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lambda 表达式也可以访问外部变量</span></span><br><span class="line">    <span class="keyword">auto</span> add2 = [x,y]() -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> result2 = <span class="built_in">add2</span>(x, y);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The sum2 is: &quot;</span> &lt;&lt; result2 &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> addWithExternal = [x](<span class="type">int</span> b) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + b;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Lambda 表达式计算并输出结果</span></span><br><span class="line">    <span class="type">int</span> resultWithExternal = <span class="built_in">addWithExternal</span>(y);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The sum with external variable is: &quot;</span> &lt;&lt; resultWithExternal &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">operateWithLambda</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://i.postimg.cc/fbN6bFqP/20220206101541-14a48.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://i.postimg.cc/fbN6bFqP/20220206101541-14a48.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">THEDI</div><div class="post-copyright__author_desc">我想睡到12点!</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://www.thekqd.top/2024/02/21/C++-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://www.thekqd.top/2024/02/21/C++-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/')">C++学习笔记</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/null" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/null" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://www.thekqd.top/2024/02/21/C++-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=C++学习笔记&amp;url=https://www.thekqd.top/2024/02/21/C++-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/&amp;pic=/assets/43.webp" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.thekqd.top" target="_blank">THEDI的仓库</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/C/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>C++<span class="tagsPageCount">2</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="/assets/25.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/02/08/C++-%E5%85%B3%E9%94%AE%E5%AD%97%E7%94%A8%E6%B3%95/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/6.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++关键字用法</div></div></a></div><div class="next-post pull-right"><a href="/2025/01/13/STM32%E6%A0%87%E5%87%86%E5%BA%93/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/33.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">STM32(标准库)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2024/02/08/C++-%E5%85%B3%E9%94%AE%E5%AD%97%E7%94%A8%E6%B3%95/" title="C++关键字用法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/6.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-02-08</div><div class="title">C++关键字用法</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://i.postimg.cc/fbN6bFqP/20220206101541-14a48.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">THEDI</h1><div class="author-info__desc">我想睡到12点!</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="/assets/QRCode.jpg" target="_blank" title="微信"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-weixin"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/" target="_blank" title="B站"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg></a><a class="social-icon faa-parent animated-hover" href="mailto:1244381125@qq.com" target="_blank" title="QQ邮箱"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxiang"></use></svg></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">不要偷看我的博客!</div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(null) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">C++学习笔记：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4std"><span class="toc-number">1.1.</span> <span class="toc-text">名称空间std</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E7%AC%A6endl"><span class="toc-number">1.2.</span> <span class="toc-text">控制符endl</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cin%E5%92%8Ccout"><span class="toc-number">1.3.</span> <span class="toc-text">cin和cout</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%8F%E6%AC%A1%E8%AF%BB%E5%8F%96%E4%B8%80%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2-string-%E8%BE%93%E5%85%A5"><span class="toc-number">1.4.</span> <span class="toc-text">每次读取一行字符串(string)输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.</span> <span class="toc-text">总结:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5"><span class="toc-number">1.6.</span> <span class="toc-text">补:</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#string%E7%B1%BB-%E5%A4%B4%E6%96%87%E4%BB%B6%E2%80%9Dstring%E2%80%9D"><span class="toc-number">2.</span> <span class="toc-text">string类(头文件”string”)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%EF%BC%9A%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6"><span class="toc-number">2.1.</span> <span class="toc-text">补：获取字符串长度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E6%9B%BF%E4%BB%A3%E5%93%81"><span class="toc-number">3.</span> <span class="toc-text">数组的替代品</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%B1%BBvector"><span class="toc-number">3.1.</span> <span class="toc-text">模板类vector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-vector%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%EF%BC%89"><span class="toc-number">3.1.0.1.</span> <span class="toc-text">1.3 vector对象的常用内置函数使用（举例说明）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#size"><span class="toc-number">3.2.</span> <span class="toc-text">size()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#empty"><span class="toc-number">3.3.</span> <span class="toc-text">empty()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#swap-swap-%E4%BA%A4%E6%8D%A2"><span class="toc-number">3.4.</span> <span class="toc-text">swap()         swap(交换)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#insert-insert-%E6%8F%92%E5%85%A5"><span class="toc-number">3.5.</span> <span class="toc-text">insert()      insert(插入)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#NULL%E5%92%8Cnullptr"><span class="toc-number">4.</span> <span class="toc-text">NULL和nullptr</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">4.1.</span> <span class="toc-text">对类的定义：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%8F%98%E9%87%8F%EF%BC%89%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">4.2.</span> <span class="toc-text">类对象（变量）的创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new%E5%92%8Cdelete"><span class="toc-number">4.3.</span> <span class="toc-text">new和delete</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-New"><span class="toc-number">4.3.1.</span> <span class="toc-text">1.New</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Delete"><span class="toc-number">4.3.2.</span> <span class="toc-text">2.Delete</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%AD%E6%96%87%E4%BB%B6%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">4.4.</span> <span class="toc-text">C++中文件的输入输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E5%88%B0%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E4%B8%AD"><span class="toc-number">4.4.1.</span> <span class="toc-text">写入到文本文件中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">4.4.2.</span> <span class="toc-text">从文本文件中读取数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E6%96%87%E4%BB%B6"><span class="toc-number">4.4.2.1.</span> <span class="toc-text">检查文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E7%BB%93%E5%B0%BE"><span class="toc-number">4.4.2.2.</span> <span class="toc-text">文件读取结尾</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%93%E5%BC%80%E5%92%8C%E5%85%B3%E9%97%AD"><span class="toc-number">4.4.2.3.</span> <span class="toc-text">文件的打开和关闭</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">构造函数和析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.</span> <span class="toc-text">构造函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">6.</span> <span class="toc-text">运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-number">6.1.</span> <span class="toc-text">运算符重载的概念和原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E9%99%90%E5%88%B6"><span class="toc-number">6.2.</span> <span class="toc-text">运算符重载限制:</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">7.</span> <span class="toc-text">类的继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">7.1.</span> <span class="toc-text">继承的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%EF%BC%9Ais-a-%E5%85%B3%E7%B3%BB"><span class="toc-number">7.2.</span> <span class="toc-text">继承：is-a 关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">7.3.</span> <span class="toc-text">继承的格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">7.4.</span> <span class="toc-text">继承的总结：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%85%AC%E6%9C%89%E7%BB%A7%E6%89%BF"><span class="toc-number">7.5.</span> <span class="toc-text">多态公有继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%96%B9%E6%B3%95"><span class="toc-number">7.5.1.</span> <span class="toc-text">虚方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">7.5.2.</span> <span class="toc-text">虚析构函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%81%94%E7%BC%96%E5%92%8C%E5%8A%A8%E6%80%81%E8%81%94%E7%BC%96"><span class="toc-number">7.6.</span> <span class="toc-text">静态联编和动态联编</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">7.7.</span> <span class="toc-text">初始化列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">7.7.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8"><span class="toc-number">7.7.2.</span> <span class="toc-text">什么时候必须使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="toc-number">7.7.3.</span> <span class="toc-text">建议使用的地方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="toc-number">7.7.4.</span> <span class="toc-text">优点和缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8using-%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">7.8.</span> <span class="toc-text">使用using 重新定义访问权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">7.9.</span> <span class="toc-text">多重继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">7.9.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-1"><span class="toc-number">7.9.2.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E4%B9%89%E6%80%A7"><span class="toc-number">7.9.3.</span> <span class="toc-text">二义性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">8.</span> <span class="toc-text">模板</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">8.1.</span> <span class="toc-text">类模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">8.2.</span> <span class="toc-text">函数模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%8C%BA%E5%88%AB"><span class="toc-number">8.3.</span> <span class="toc-text">类模板与函数模板区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.4.</span> <span class="toc-text">类模板成员函数实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF"><span class="toc-number">8.5.</span> <span class="toc-text">成员模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%AF%B9%E8%B1%A1%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">8.6.</span> <span class="toc-text">类模板对象做函数参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E6%A8%A1%E6%9D%BF%E5%81%9A%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%8F%82%E6%95%B0"><span class="toc-number">8.7.</span> <span class="toc-text">将模板做模板类参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-number">8.8.</span> <span class="toc-text">类模板与继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%92%8C%E5%8F%8B%E5%85%83"><span class="toc-number">8.9.</span> <span class="toc-text">模板类和友元</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E6%97%B6%E6%9C%BA"><span class="toc-number">8.10.</span> <span class="toc-text">类模板成员函数创建时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%88%86%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99-%E9%87%8D%E8%A6%81"><span class="toc-number">8.11.</span> <span class="toc-text">类模板分文件编写(重要)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%88%AB%E5%90%8D-C-11"><span class="toc-number">8.12.</span> <span class="toc-text">模板别名(C++11)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8B%E5%85%83"><span class="toc-number">9.</span> <span class="toc-text">友元</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-number">9.1.</span> <span class="toc-text">友元函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="toc-number">9.2.</span> <span class="toc-text">友元类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">9.3.</span> <span class="toc-text">友元成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">9.4.</span> <span class="toc-text">友元的优缺点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E7%B1%BB"><span class="toc-number">10.</span> <span class="toc-text">嵌套类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-number">10.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">10.2.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-number">10.3.</span> <span class="toc-text">访问控制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">11.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%A6%82%E5%BF%B5"><span class="toc-number">11.1.</span> <span class="toc-text">异常概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8A%9B%E5%87%BA%E5%92%8C%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99"><span class="toc-number">11.2.</span> <span class="toc-text">异常的抛出和匹配规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8A%9B%E5%87%BA"><span class="toc-number">11.2.1.</span> <span class="toc-text">异常的抛出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99"><span class="toc-number">11.2.2.</span> <span class="toc-text">匹配规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E9%87%8D%E6%96%B0%E6%8A%9B%E5%87%BA"><span class="toc-number">11.3.</span> <span class="toc-text">异常的重新抛出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">11.4.</span> <span class="toc-text">异常安全问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E8%A7%84%E8%8C%83%E8%AF%B4%E6%98%8E"><span class="toc-number">11.5.</span> <span class="toc-text">异常规范说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB"><span class="toc-number">11.6.</span> <span class="toc-text">自定义异常体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB"><span class="toc-number">11.7.</span> <span class="toc-text">C++标准库的异常体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">11.8.</span> <span class="toc-text">异常优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RTTI"><span class="toc-number">11.9.</span> <span class="toc-text">RTTI</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dynamic-cast"><span class="toc-number">11.9.1.</span> <span class="toc-text">dynamic_cast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#typeid%E5%92%8Ctype-info"><span class="toc-number">11.9.2.</span> <span class="toc-text">typeid和type_info</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="toc-number">12.</span> <span class="toc-text">智能指针模板类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#auto-ptr%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="toc-number">12.1.</span> <span class="toc-text">auto_ptr模板类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shared-ptr%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="toc-number">12.2.</span> <span class="toc-text">shared_ptr模板类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unique-ptr%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="toc-number">12.3.</span> <span class="toc-text">unique_ptr模板类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unique-ptr%E4%B8%BA%E4%BD%95%E4%BC%98%E4%BA%8Eauto-ptr"><span class="toc-number">12.4.</span> <span class="toc-text">unique_ptr为何优于auto_ptr</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93STL"><span class="toc-number">13.</span> <span class="toc-text">标准模板库STL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%B1%BBvector-1"><span class="toc-number">13.1.</span> <span class="toc-text">模板类vector</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E5%BE%AA%E7%8E%AF"><span class="toc-number">13.2.</span> <span class="toc-text">基于范围的for循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="toc-number">13.3.</span> <span class="toc-text">泛型编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">13.3.1.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8"><span class="toc-number">13.3.2.</span> <span class="toc-text">容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">13.4.</span> <span class="toc-text">函数对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">13.4.1.</span> <span class="toc-text">应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">13.5.</span> <span class="toc-text">算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL%E6%80%BB%E7%BB%93"><span class="toc-number">13.6.</span> <span class="toc-text">STL总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%BA%93"><span class="toc-number">13.7.</span> <span class="toc-text">其他库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E3%80%81valarray%E3%80%81array"><span class="toc-number">13.7.1.</span> <span class="toc-text">vector、valarray、array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BFinitializer-list"><span class="toc-number">13.7.2.</span> <span class="toc-text">模板initializer_list</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E3%80%81%E8%BE%93%E5%87%BA%E5%92%8C%E6%96%87%E4%BB%B6"><span class="toc-number">14.</span> <span class="toc-text">输入、输出和文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E5%92%8C%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">14.1.</span> <span class="toc-text">流和缓冲区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%EF%BC%88Stream%EF%BC%89"><span class="toc-number">14.1.1.</span> <span class="toc-text">流（Stream）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%88Buffer%EF%BC%89"><span class="toc-number">14.1.2.</span> <span class="toc-text">缓冲区（Buffer）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iostream%E6%96%87%E4%BB%B6"><span class="toc-number">14.2.</span> <span class="toc-text">iostream文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cerr%E5%92%8Cclog"><span class="toc-number">14.2.1.</span> <span class="toc-text">cerr和clog</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8cout%E8%BF%9B%E8%A1%8C%E8%BE%93%E5%87%BA"><span class="toc-number">14.3.</span> <span class="toc-text">使用cout进行输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E7%9A%84"><span class="toc-number">14.3.1.</span> <span class="toc-text">重载的&lt;&lt;运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96osteam%E6%96%B9%E6%B3%95"><span class="toc-number">14.3.2.</span> <span class="toc-text">其他osteam方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B7%E6%96%B0%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">14.3.3.</span> <span class="toc-text">刷新输出缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8cout%E8%BF%9B%E8%A1%8C%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">14.3.4.</span> <span class="toc-text">用cout进行格式化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6iomanip"><span class="toc-number">14.3.5.</span> <span class="toc-text">头文件iomanip</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8cin%E8%BF%9B%E8%A1%8C%E8%BE%93%E5%85%A5"><span class="toc-number">14.4.</span> <span class="toc-text">使用cin进行输入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cin%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5%E8%BE%93%E5%85%A5"><span class="toc-number">14.4.1.</span> <span class="toc-text">cin如何检查输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%8A%B6%E6%80%81"><span class="toc-number">14.4.2.</span> <span class="toc-text">流状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8cin%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">14.4.3.</span> <span class="toc-text">使用cin错误处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96istream%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">14.4.4.</span> <span class="toc-text">其他istream类方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">14.5.</span> <span class="toc-text">文件输入输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA-1"><span class="toc-number">14.5.1.</span> <span class="toc-text">文件输入输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E6%96%87%E4%BB%B6-1"><span class="toc-number">14.5.2.</span> <span class="toc-text">检查文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E7%BB%93%E5%B0%BE"><span class="toc-number">14.5.3.</span> <span class="toc-text">判断文件结尾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E5%85%B3%E9%97%AD"><span class="toc-number">14.5.4.</span> <span class="toc-text">文件打开关闭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6"><span class="toc-number">14.5.5.</span> <span class="toc-text">打开多个文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E6%A8%A1%E5%BC%8F"><span class="toc-number">14.5.6.</span> <span class="toc-text">文件打开模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c-%E6%96%B0%E6%A0%87%E5%87%86"><span class="toc-number">15.</span> <span class="toc-text">c++新标准</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">15.1.</span> <span class="toc-text">统一的初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">15.2.</span> <span class="toc-text">右值引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC%EF%BC%9A"><span class="toc-number">15.2.1.</span> <span class="toc-text">左值和右值：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%EF%BC%9A"><span class="toc-number">15.2.2.</span> <span class="toc-text">左值引用和右值引用：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda%E5%87%BD%E6%95%B0"><span class="toc-number">15.3.</span> <span class="toc-text">Lambda函数</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/08/30/MQTT%E8%BF%9E%E6%8E%A5AWS-IoT/" title="MQTT连接AWS IoT"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/25.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MQTT连接AWS IoT"/></a><div class="content"><a class="title" href="/2025/08/30/MQTT%E8%BF%9E%E6%8E%A5AWS-IoT/" title="MQTT连接AWS IoT">MQTT连接AWS IoT</a><time datetime="2025-08-29T16:33:21.000Z" title="发表于 2025-08-30 00:33:21">2025-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/30/TLS%E4%BC%A0%E8%BE%93%E5%B1%82%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/" title="TLS传输层安全协议"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/11.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TLS传输层安全协议"/></a><div class="content"><a class="title" href="/2025/08/30/TLS%E4%BC%A0%E8%BE%93%E5%B1%82%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/" title="TLS传输层安全协议">TLS传输层安全协议</a><time datetime="2025-08-29T16:31:07.000Z" title="发表于 2025-08-30 00:31:07">2025-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/30/AWS%E4%BB%8B%E7%BB%8D/" title="AWS介绍"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/3.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AWS介绍"/></a><div class="content"><a class="title" href="/2025/08/30/AWS%E4%BB%8B%E7%BB%8D/" title="AWS介绍">AWS介绍</a><time datetime="2025-08-29T16:28:11.000Z" title="发表于 2025-08-30 00:28:11">2025-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/30/PCB%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E4%BA%8E%E7%AB%8B%E5%88%9BEDA/" title="PCB设计(基于立创EDA)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/16.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="PCB设计(基于立创EDA)"/></a><div class="content"><a class="title" href="/2025/08/30/PCB%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E4%BA%8E%E7%AB%8B%E5%88%9BEDA/" title="PCB设计(基于立创EDA)">PCB设计(基于立创EDA)</a><time datetime="2025-08-29T16:20:05.000Z" title="发表于 2025-08-30 00:20:05">2025-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/30/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/" title="加密算法"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/11.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="加密算法"/></a><div class="content"><a class="title" href="/2025/08/30/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/" title="加密算法">加密算法</a><time datetime="2025-08-29T16:12:06.000Z" title="发表于 2025-08-30 00:12:06">2025-08-30</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="workboard"><img class="workSituationImg boardsign" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-上班摸鱼中.svg" alt="距离月入25k也就还差一个大佬带我~" title="距离月入25k也就还差一个大佬带我~"/><div id="runtimeTextTip"></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://blog.anheyu.com/" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"/></a><a class="github-badge" target="_blank" href="https://www.dogecloud.com/" style="margin-inline:5px" data-title="本站使用多吉云为静态资源提供CDN加速" title="本站使用多吉云为静态资源提供CDN加速"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/CDN-多吉云-3693F3.svg" alt="本站使用多吉云为静态资源提供CDN加速"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"/></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2022 - 2025 By <a class="footer-bar-link" href="/" title="THEDI" target="_blank">THEDI</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">63</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">8</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="安知鱼的博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="安知鱼的博客"/><span class="back-menu-item-text">安知鱼的博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/keqiudi/keqiudi.github.io" title="我的博客仓库"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="我的博客仓库"/><span class="back-menu-item-text">我的博客仓库</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AWS/" style="font-size: 0.88rem;">AWS<sup>2</sup></a><a href="/tags/C/" style="font-size: 0.88rem;">C++<sup>2</sup></a><a href="/tags/CLion/" style="font-size: 0.88rem;">CLion<sup>2</sup></a><a href="/tags/CMake/" style="font-size: 0.88rem;">CMake<sup>1</sup></a><a href="/tags/ESP32/" style="font-size: 0.88rem;">ESP32<sup>1</sup></a><a href="/tags/FreeRTOS/" style="font-size: 0.88rem;">FreeRTOS<sup>5</sup></a><a href="/tags/Git/" style="font-size: 0.88rem;">Git<sup>1</sup></a><a href="/tags/LCD/" style="font-size: 0.88rem;">LCD<sup>2</sup></a><a href="/tags/LVGL/" style="font-size: 0.88rem;">LVGL<sup>7</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem;">Linux<sup>8</sup></a><a href="/tags/MySQL/" style="font-size: 0.88rem;">MySQL<sup>2</sup></a><a href="/tags/PCB/" style="font-size: 0.88rem;">PCB<sup>2</sup></a><a href="/tags/QT/" style="font-size: 0.88rem;">QT<sup>1</sup></a><a href="/tags/STM32/" style="font-size: 0.88rem;">STM32<sup>2</sup></a><a href="/tags/keil/" style="font-size: 0.88rem;">keil<sup>1</sup></a><a href="/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1/" style="font-size: 0.88rem;">云服务<sup>3</sup></a><a href="/tags/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" style="font-size: 0.88rem;">启动流程<sup>2</sup></a><a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%89%E5%85%A8/" style="font-size: 0.88rem;">嵌入式安全<sup>3</sup></a><a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 0.88rem;">架构<sup>2</sup></a><a href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" style="font-size: 0.88rem;">环境配置<sup>4</sup></a><a href="/tags/%E7%A1%AC%E4%BB%B6/" style="font-size: 0.88rem;">硬件<sup>5</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>3</sup></a><a href="/tags/%E8%B0%83%E8%AF%95/" style="font-size: 0.88rem;">调试<sup>5</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.cbd.int/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("12/01/2022 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2022 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 THEDI 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("12/01/2022 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-下班啦.svg";
        img.title = "下班了就该开开心心的玩耍，嘿嘿~";
        img.alt = "下班了就该开开心心的玩耍，嘿嘿~";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><script src="https://cdn.cbd.int/algoliasearch@4.18.0/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.cbd.int/instantsearch.js@4.60.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script async src="//at.alicdn.com/t/c/font_4169545_k8d3mxnig4s.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>